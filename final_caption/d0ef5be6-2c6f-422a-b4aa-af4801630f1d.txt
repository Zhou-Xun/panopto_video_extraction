1
00:00:12,390 --> 00:00:17,340
Okay. Yes. Go ahead and get started.

2
00:00:18,690 --> 00:00:23,320
Okay. Yes, yes.

3
00:00:24,270 --> 00:00:34,200
Yes. Is just the topics then. So this is the calendar start up.

4
00:00:36,630 --> 00:00:38,640
We finished off last time, I guess.

5
00:00:39,330 --> 00:00:51,420
Just example with strings and you know, mention a few things about operations with numbers, mostly straightforward, just a few features too.

6
00:00:52,260 --> 00:01:00,790
You have to keep in mind that your own integer division automatically, automatically produces an integer.

7
00:01:00,790 --> 00:01:08,969
It doesn't it doesn't return any kind of any fractional value, any kind of boolean expressions.

8
00:01:08,970 --> 00:01:16,110
And if all statements kind of how to do that is plus plus it's a related statement which

9
00:01:16,110 --> 00:01:24,540
some people use is a switch statement since it's not as commonly used in our guide.

10
00:01:26,400 --> 00:01:27,450
So we'll talk about that.

11
00:01:28,350 --> 00:01:39,120
And then the operator, you know, just kind of extra details, I guess, which should kind of come plus plus the increment operator.

12
00:01:41,580 --> 00:01:49,380
Increasing the value of a number and then just seen is kind of like how to get input from the keyboard.

13
00:01:51,360 --> 00:02:01,080
Not that much to say about that. It's kind of like the input version of See Out See, which is useful to know.

14
00:02:02,070 --> 00:02:10,140
We did this last time mentioned and could see where we were.

15
00:02:11,460 --> 00:02:25,350
The special string type. If you want to declare it, you have to use string to match the initial that initial language kind of inside double quotes,

16
00:02:26,910 --> 00:02:38,190
dot length that will try to increase the number of characters in your string to kind of access individual characters

17
00:02:38,190 --> 00:02:45,570
of your string to use bracket type of notation like bracket zero gives you the first letter in the string.

18
00:02:48,100 --> 00:02:52,810
Yeah, basically indexing starts with zero, not one.

19
00:02:52,830 --> 00:02:57,479
So it's true for strings, but it's kind of true for everything else in C++.

20
00:02:57,480 --> 00:03:09,600
Like talk about res indexing starts from zero and then this is basically I guess you only need to do this if you're using like a print, print app.

21
00:03:09,990 --> 00:03:14,850
Okay. I was just kind of watching that last time.

22
00:03:15,180 --> 00:03:23,190
For example, you have an example over declaring a string s and giving it an initial value.

23
00:03:23,190 --> 00:03:27,719
Hello. Or turning it out or not the length.

24
00:03:27,720 --> 00:03:33,120
And then yes, if we do s one, that's like the second letter.

25
00:03:33,120 --> 00:03:41,210
So that should use that kind of prints out. E I think we did that some last time.

26
00:03:41,310 --> 00:03:45,780
I mentioned this right at the end. This is just something to know.

27
00:03:45,780 --> 00:03:55,140
If you don't want to keep typing out S.T.D. every time you use it,

28
00:03:55,860 --> 00:04:02,490
so steady is really just means that you're kind of using something from the standard template library.

29
00:04:07,270 --> 00:04:15,790
So if you have a head like this, head using namespace, steady at the top, you don't have to write down STD, colon,

30
00:04:15,790 --> 00:04:21,639
colon kind of every time you use something from the standard template library so you

31
00:04:21,640 --> 00:04:28,720
don't have to use STV Colon colon before string or you don't have to use it for Seattle.

32
00:04:29,600 --> 00:04:33,249
You can see that, you know, if you don't have using namespace here,

33
00:04:33,250 --> 00:04:47,470
you would have to have a string double colon here because out before string is type, this sets the top so you can avoid having to type that through.

34
00:04:48,990 --> 00:04:55,390
Really the only reason for for including that just makes it a little bit easier to type out your code a little bit,

35
00:04:55,870 --> 00:05:04,240
makes your code a little bit easier to read as well, but it's not like required or anything.

36
00:05:05,560 --> 00:05:07,690
So yeah, I think this is just what we had before.

37
00:05:07,690 --> 00:05:18,099
This was just, we're just putting the, using namespace at the top, whereas the previous example we didn't have using namespace.

38
00:05:18,100 --> 00:05:22,499
Okay. Okay.

39
00:05:22,500 --> 00:05:24,270
So I think that's where we stopped last time.

40
00:05:24,270 --> 00:05:31,260
Maybe this was just a little bit of a review question just to make sure we know all of this, like this syntax,

41
00:05:31,290 --> 00:05:42,900
it's just kind of do you think that knows what this prints out and kind of like some of the main syntax that we discussed.

42
00:05:43,680 --> 00:05:50,040
So let's say if we run this label and print out, so here we have an integer x first.

43
00:05:50,040 --> 00:06:04,799
Then we declared a string and had a string is w o an empty space r l d So this string has six elements.

44
00:06:04,800 --> 00:06:10,890
This has lengths like six, so that the white space is counted as a character.

45
00:06:12,330 --> 00:06:17,790
So six elements and then we see how s of X plus one.

46
00:06:19,380 --> 00:06:34,650
And so this is going to print out the index three of of S so index index zero is W

47
00:06:35,280 --> 00:06:46,140
index one is oh index two is the empty space white space and then index three is the R.

48
00:06:47,790 --> 00:07:00,299
So if you run this, this should print out basically the letter R, just kind of a review of the syntax before we move forward.

49
00:07:00,300 --> 00:07:15,270
So, so I think mostly where we stopped last time, so I think just had a few, a few slides about doing operations with numbers.

50
00:07:15,720 --> 00:07:23,940
So I think you're right, the addition and subtraction, multiplication division with numbers is pretty straightforward.

51
00:07:27,150 --> 00:07:34,230
So but there's there's one or two things to keep in mind when you're doing kind of math with C++.

52
00:07:34,980 --> 00:07:44,370
So the first, I would say important thing that to keep in mind is that your division between two integers also returns

53
00:07:44,370 --> 00:07:52,140
a different an integer so that for that reason you cannot have like a fractional part of a number.

54
00:07:52,650 --> 00:08:03,360
So like if you do, if you divide seven by two and these are the variables that you're using are both integers that will return the integer three.

55
00:08:03,360 --> 00:08:09,480
So it kind of returns that low I guess round down.

56
00:08:12,390 --> 00:08:22,379
Okay. So it returns kind of the floor of of seven divided by two since like the always rounds it all around brownstones.

57
00:08:22,380 --> 00:08:25,410
So that's just something that to be careful about.

58
00:08:25,410 --> 00:08:34,620
I mean sometimes forget about it and you're doing kind of such math with variables that you declared with an idea as it might,

59
00:08:35,130 --> 00:08:42,570
it might give you the wrong value or the value that you did that you didn't have a value that you didn't want it to compute.

60
00:08:42,960 --> 00:08:52,620
Since it's returning an integer and you kind of had in mind that the computation should have like the true value of seven by two.

61
00:08:52,620 --> 00:08:56,730
So that's just, yeah, it's just an important thing to keep in mind.

62
00:08:57,240 --> 00:09:01,080
And sometimes it leads to mistakes if you forget about it.

63
00:09:02,730 --> 00:09:04,620
Oh, so this only works.

64
00:09:05,370 --> 00:09:14,459
So this remainder or modulus operator this is only valid for integers or it only returns something value to give it to integers.

65
00:09:14,460 --> 00:09:20,220
So this is just the remainder if we do seven divided by two, so there's one left over.

66
00:09:22,200 --> 00:09:33,829
And the other thing to keep in mind is that C++ doesn't have like an exponential operator, at least like the, like the base C C++.

67
00:09:33,830 --> 00:09:44,040
So if you want to do this, if you want to compute like for the third power, like do that directly and C++, I mean,

68
00:09:45,000 --> 00:09:53,160
you could write it out four times, four times four, but it's not like something that automatically does it raising a number to a certain power.

69
00:09:54,840 --> 00:09:58,200
Probably the only key things I'd point out.

70
00:09:58,200 --> 00:10:09,629
I mean, you can you can you could certainly do exponential version, but you just have to load in this element library.

71
00:10:09,630 --> 00:10:17,490
So C as well as exponential. And I mean else I think there's a number of other kind of useful mathematical functions.

72
00:10:18,120 --> 00:10:27,230
So if you want to. I saw. If you want to use a function that does exponential, you have to import the C math library.

73
00:10:27,810 --> 00:10:34,650
So the function you would probably want to use is POW! P.O.W. So it's like raising something to certain powers.

74
00:10:35,460 --> 00:10:41,570
If you do this here, if you include this header, you see math, that is good.

75
00:10:41,580 --> 00:10:51,420
An example, this will print out x x squared, kind of the first argument and the power function is kind of like the face.

76
00:10:52,020 --> 00:11:02,790
And then the entity to the second argument is like the basically like the exponent term, the thing that is the problem.

77
00:11:04,380 --> 00:11:14,910
So this is x squared, this is actually going to do exponential and I think I would just use that the P.O.W. function from the C math library.

78
00:11:18,030 --> 00:11:28,530
There's nothing really extra here. This is just a screenshot showing that it works if you use the P.O.W. function from the C math library.

79
00:11:31,240 --> 00:11:44,160
Yeah, I think we touched on this in the other modules as well as just a reminder, you know, that there are precedents, operator precedence rules.

80
00:11:44,160 --> 00:11:51,570
I guess when you're doing math, it's basically like the same the same rules that are in regular math kind of everything.

81
00:11:52,410 --> 00:11:56,280
All of the math done inside of parentheses is done first.

82
00:11:56,280 --> 00:12:03,450
And then if you're looking at things outside of parentheses, kind of multiplication division,

83
00:12:03,450 --> 00:12:08,010
have have higher precedence, then then addition and subtraction.

84
00:12:08,190 --> 00:12:14,150
Okay. So I think this is the same rule as regular math,

85
00:12:14,160 --> 00:12:24,090
but it's something you should keep in mind that you should try to be clear when you're writing mathematical expressions.

86
00:12:25,200 --> 00:12:28,820
I just think it helps avoid errors. Okay.

87
00:12:30,810 --> 00:12:38,640
So this was just an example of a couple of different mathematical operations.

88
00:12:39,120 --> 00:12:46,189
Just to. I guess to show what's going on.

89
00:12:46,190 --> 00:12:53,600
I guess mainly I guess I wanted to show the difference between like division between two doubles and a division between two integers.

90
00:12:54,560 --> 00:12:58,860
So I, I define two integers, a and b a is 72.

91
00:12:59,990 --> 00:13:07,040
I see as these are doubles, so C is 7.0 and D is 2.0.

92
00:13:08,750 --> 00:13:22,200
I guess one of the key things here is that so if we divide two doubles, so C divided by D, then only 3.5.

93
00:13:23,010 --> 00:13:30,020
And what it should be. However, if we divide by within division with two integers, that's going to be three.

94
00:13:31,070 --> 00:13:35,450
And also an example with the division of a double by an integer.

95
00:13:36,050 --> 00:13:39,110
So just to give you an example of each combination.

96
00:13:40,070 --> 00:13:46,160
So look here, in this example, it's A divided by B, so this is a division of two integers.

97
00:13:46,160 --> 00:13:50,430
This gives us an integer three divided by three.

98
00:13:53,570 --> 00:13:57,350
However, a double by an integer kind of works fine as well.

99
00:13:57,350 --> 00:14:02,899
That returns in a double. So what is C divided by?

100
00:14:02,900 --> 00:14:06,440
B, right? So this is a double divided by an integer.

101
00:14:06,440 --> 00:14:10,700
So that kind of gives the correct the correct value, I guess.

102
00:14:10,700 --> 00:14:13,880
And then that's the mathematical sense.

103
00:14:14,480 --> 00:14:19,180
So the C divided by B return to double. So that gives you the kind of the common here.

104
00:14:21,170 --> 00:14:29,030
And then this last one, I don't know what the point of this I guess that I guess maybe this is order of operations is what I had in mind.

105
00:14:29,030 --> 00:14:40,880
So if we do a kind of my the modulus and the division for adding everything up some 80 divided by three, right.

106
00:14:41,470 --> 00:14:59,200
Correct. Yeah. Eight divided by three is B B modulus A would be two actually because like no two, modulus seven can divide into eight.

107
00:14:59,210 --> 00:15:04,250
By itself it's seven. So it's like seven plus two.

108
00:15:05,510 --> 00:15:10,320
Plus three. So that would give you 12. So that's why the answers to both, Heidi.

109
00:15:12,150 --> 00:15:17,390
I think the point of this example that just like order of operations.

110
00:15:18,990 --> 00:15:29,510
Okay. Okay. So there's just a few things to point out about doing math, C++.

111
00:15:29,510 --> 00:15:36,320
I want to point out the integer division.

112
00:15:36,510 --> 00:15:38,240
That's just something to be careful about.

113
00:15:38,270 --> 00:15:50,419
And then I guess the modulus, this type of thing has to be between two integers and then just order of operations.

114
00:15:50,420 --> 00:15:55,010
I mean that that's true for basically every programing language, which is something to be.

115
00:15:55,820 --> 00:16:01,670
Just to keep in mind whenever you're writing down kind of mathematical expressions and C++ code.

116
00:16:02,540 --> 00:16:09,439
Okay. So the next, the next topic is basically conditional statements.

117
00:16:09,440 --> 00:16:18,740
So this is really just if l statements and else if L statements and then switch statements.

118
00:16:19,760 --> 00:16:27,499
Okay. So this is kind of something that we have the same type of slide for R in Python.

119
00:16:27,500 --> 00:16:37,159
This is just more of just an overview, I guess, of the next few topics.

120
00:16:37,160 --> 00:16:45,230
So these are they're often called like the title of control flows.

121
00:16:47,240 --> 00:17:02,570
So these are just, I guess, tools that, you know, determine kind of which statements are executed and how they're executed or or how many times.

122
00:17:03,410 --> 00:17:10,090
So these are kind of like the kind of important building blocks for for writing programs.

123
00:17:10,100 --> 00:17:15,559
I think we just cover these three topics first.

124
00:17:15,560 --> 00:17:24,080
So you're able to kind of. Right. Write programs that do things basically.

125
00:17:24,590 --> 00:17:32,300
So control flows kind of indicate how certain statements in your code are executed so that

126
00:17:32,840 --> 00:17:40,819
conditional statements are basically allow you to control whether or not they're executed.

127
00:17:40,820 --> 00:17:50,299
So in some cases, you want a search statement to be executed, in some cases you don't want them to be executed.

128
00:17:50,300 --> 00:17:55,310
So conditional statements allow you to control whether whether or not they're executed or not.

129
00:17:56,630 --> 00:18:10,120
These functions allow you to control like whether a certain chunk of code can be executed and in many different places in your program.

130
00:18:10,130 --> 00:18:18,860
So that allows you to write a chunk of code in one place and then kind of reuse it all over another program for examples.

131
00:18:19,400 --> 00:18:27,740
Then I guess loops allow you to control kind of how many times, as you know, maybe one statement or similar statements are executed.

132
00:18:27,740 --> 00:18:34,370
So that basically just allows you to repeat a certain type of computation many times.

133
00:18:34,780 --> 00:18:43,340
Okay. So kind of combining all of these things might do a lot of different to a lot of different types of things.

134
00:18:43,940 --> 00:18:48,829
So I guess for yeah, the first thing we're going to talk about are conditional statements.

135
00:18:48,830 --> 00:18:53,660
For conditional statements, you basically need to know how to write,

136
00:18:54,620 --> 00:19:07,070
write down Boolean expressions and C++ ability and expression is basically just something that evaluates to true or false.

137
00:19:07,670 --> 00:19:17,780
Okay. So the reason we need that is that conditional statements are basically kind of statements that are only executed.

138
00:19:18,740 --> 00:19:30,800
If a certain condition is true, certain condition is true, you might execute a if it's not true, you would need to execute kind of a B statement.

139
00:19:32,870 --> 00:19:42,020
And the Boolean expressions are just really just a formal way of representing kind of the conditions that you have in mind.

140
00:19:44,110 --> 00:19:53,420
And expressions form a way for expressing, you know, a logical condition that you have in mind.

141
00:19:53,750 --> 00:20:01,760
Okay. So these are just examples of Boolean expressions are usually something like this.

142
00:20:01,760 --> 00:20:09,620
So five is greater than three that. Evaluates to true three is lesser than or equal to five.

143
00:20:10,460 --> 00:20:14,920
That's also true. This is this is also true.

144
00:20:14,930 --> 00:20:19,480
This is like the and boolean operator.

145
00:20:19,490 --> 00:20:23,270
So it's just evaluating whether or not both of these statements are true.

146
00:20:28,580 --> 00:20:43,280
Okay. So if I have a kind of I guess I'll do the kind of general form of an F statement and then later slide, make sure we know that the syntax,

147
00:20:43,280 --> 00:20:53,179
at least for the main types of Boolean expressions, at least like Boolean and or Boolean or so for an if statement and C++.

148
00:20:53,180 --> 00:21:02,030
I mean, I think it's fairly similar to like most of other languages you have if and then you put a Boolean

149
00:21:02,030 --> 00:21:12,290
expression in parentheses and then you have like the body of the statement is enclosed in curly braces.

150
00:21:12,440 --> 00:21:17,899
Okay, so this is, this is called like the body of the statement.

151
00:21:17,900 --> 00:21:25,790
It's basically if this Boolean expression, true kind of everything inside of the curly braces is executed.

152
00:21:26,090 --> 00:21:33,050
Okay. So the way you separate out the body of this statement in C++ is with is with curly braces.

153
00:21:35,990 --> 00:21:43,130
So you don't if you have a single line for the body of your statement, you don't absolutely have to have curly braces if you don't want to.

154
00:21:43,160 --> 00:21:55,670
So you can either write it on the same line or if it's not on the same line, you could put it on the line immediately below it,

155
00:21:56,720 --> 00:22:02,840
and it would treat that as kind of a body of the statement if you have a single line,

156
00:22:03,590 --> 00:22:08,720
but if it's more than one line, you have to kind of put everything inside of the curly braces.

157
00:22:08,880 --> 00:22:16,940
Okay. Now I usually put everything kind of inside of currently braces, but even if it's a single line,

158
00:22:17,840 --> 00:22:25,909
but you don't have to like I like the way it looks kind of just separates out the body of the statement from everything else.

159
00:22:25,910 --> 00:22:30,680
But it's not it's not like required in C++.

160
00:22:31,310 --> 00:22:36,980
So here's just an example of an issue statement.

161
00:22:36,980 --> 00:22:42,860
So if you run this, this is only going to print out the first message.

162
00:22:43,010 --> 00:22:48,380
Three is less than five because that's the only statement that's true.

163
00:22:51,080 --> 00:22:55,010
So this Boolean expression three is greater than five that evaluates to false.

164
00:22:55,010 --> 00:23:12,920
And it doesn't even kind of run this statement inside of the inside of the body of the second is based on the first one is is run so you know,

165
00:23:12,950 --> 00:23:23,389
so here is just I think some more details at least about kind of the syntax for writing Boolean expressions and in C++.

166
00:23:23,390 --> 00:23:27,440
So if you if you want to write if statements or if false statements that mean you have

167
00:23:27,440 --> 00:23:33,380
to you have to be able to write at least some some types of basic these expressions.

168
00:23:34,040 --> 00:23:43,189
So really Boolean expressions are really just a matter of mixing these types of comparison

169
00:23:43,190 --> 00:23:49,570
operators are usually often called and then it's kind of logical operator and operator.

170
00:23:49,580 --> 00:23:55,909
So it's just kind of combining these types of types of things in various ways.

171
00:23:55,910 --> 00:24:03,380
So like, say if something is less than or less than or equal to, then this double equal is.

172
00:24:03,590 --> 00:24:08,090
You're testing whether or not two things are equal and then this last one is not equal.

173
00:24:08,960 --> 00:24:12,770
And then so those are kind of comparing two things.

174
00:24:13,520 --> 00:24:28,190
And these kinds of things are usually like looking at multiple expression so and is testing whether or not two things are both true or not or is

175
00:24:28,190 --> 00:24:39,620
testing whether or not the two are two things are at least one of them is true and then not is basically kind of just negating any logical statement.

176
00:24:39,620 --> 00:24:50,810
So it's not a it's basically convert to true to false and vice and false to true.

177
00:24:51,470 --> 00:24:59,660
So in C++, the and is a double ampersand and the other is this double double vertical bar.

178
00:25:02,720 --> 00:25:11,000
So that's kind of the syntax. Plus. And then the nod is just the exclamation point by itself.

179
00:25:12,680 --> 00:25:21,559
So this pretty much summarizes what I've been saying.

180
00:25:21,560 --> 00:25:26,350
These are the kinds of main comparison operators. Okay.

181
00:25:26,390 --> 00:25:29,840
So these are the the main boolean operators.

182
00:25:29,840 --> 00:25:34,220
So not just the exclamation points.

183
00:25:34,230 --> 00:25:38,090
If you just do not choose to false.

184
00:25:38,090 --> 00:25:42,319
Not false is actually true. Probably should have written these all in lowercase letters.

185
00:25:42,320 --> 00:25:53,030
So. Like if you actually want to declare a boolean variable itself without using a boolean expression,

186
00:25:53,030 --> 00:26:00,440
you should should write like the word true in all lowercase letters and false, and all will replace the letters.

187
00:26:03,290 --> 00:26:13,790
Anyway, this is like the logic trying to express the logic here the boolean and only a value is true if both of the individual

188
00:26:13,790 --> 00:26:22,970
components are true and then boolean or evaluates to true if at least one of the individual components is true.

189
00:26:24,610 --> 00:26:32,620
And okay, so here's something you should keep in mind a little bit.

190
00:26:32,620 --> 00:26:43,540
I think the key thing here is that when you have kind of if you have an entire expression where you're combining kind of math,

191
00:26:44,470 --> 00:26:52,570
mathematical operations, and in Boolean operations, the math the math is done first, basically.

192
00:26:52,570 --> 00:26:57,460
So the math has higher, higher precedence.

193
00:26:57,910 --> 00:27:05,290
Okay. So if you have an expression where you have these as an addition and subtraction,

194
00:27:05,290 --> 00:27:17,380
and then there's also some operators of these comparison operators in the operators of and in or kind of you should do the kind of the math first.

195
00:27:17,530 --> 00:27:22,600
It's really kind of many points, the math as higher precedence.

196
00:27:25,990 --> 00:27:31,690
Sometimes I you know, if if you think the expression is a little bit confusing, I mean,

197
00:27:33,100 --> 00:27:41,139
it's always good to put things in parentheses if you if you think something is kind of confusing because even if you're putting things in parentheses,

198
00:27:41,140 --> 00:27:47,380
that parentheses always has the highest precedence. So everything is inside of the parentheses is done first.

199
00:27:48,130 --> 00:27:53,410
Okay. So this is just an example of this. So this is well, maybe it's oh, yes.

200
00:27:54,340 --> 00:27:59,010
Oh, yeah. I guess the the modulus is like the math part of this.

201
00:27:59,770 --> 00:28:05,330
So like this math is going to be done first. Okay.

202
00:28:07,620 --> 00:28:09,180
So like it's going to do.

203
00:28:14,220 --> 00:28:24,959
It's going to X, it's going to evaluate X modulus to first and then it's going to do this kind of logical evaluation in evaluation.

204
00:28:24,960 --> 00:28:30,650
So it's going to say X Modulus two, it's going to compute that and then look at it.

205
00:28:30,670 --> 00:28:43,920
So your x modulus two is is zero sense since access to all right so it's basically testing first is zero

206
00:28:43,920 --> 00:28:51,540
equal to zero so that's that's zero I mean that's true if you if you test if zero is equal to zero or not.

207
00:28:53,340 --> 00:28:56,610
So that's true. And then this is also true. X is greater than zero.

208
00:28:58,930 --> 00:29:03,669
So both of these things are true. So it's going on.

209
00:29:03,670 --> 00:29:07,660
They should print out this turn out this message.

210
00:29:10,930 --> 00:29:17,229
And then if we look here. Well, this evaluates to.

211
00:29:17,230 --> 00:29:22,000
True. Okay. For the same reasons we said before, it's test.

212
00:29:22,000 --> 00:29:25,600
It is testing whether or not zero equals zero.

213
00:29:25,600 --> 00:29:30,670
It's not testing two is equal to zero. Right. Because it's kind of doing the math first.

214
00:29:32,770 --> 00:29:36,310
So this is true. This part is false.

215
00:29:37,930 --> 00:29:45,729
But it doesn't really matter for the entire statement. It doesn't matter since at least one of them is true.

216
00:29:45,730 --> 00:29:50,469
And where he went completely and or so it's still going to print out this and then

217
00:29:50,470 --> 00:29:54,700
prints this out because the body of this if statements only like a single line.

218
00:29:55,400 --> 00:29:59,110
Right. So in this case, we're actually using the curly braces.

219
00:29:59,710 --> 00:30:04,060
In this case, we actually don't you don't have to use a curly braces.

220
00:30:04,060 --> 00:30:06,070
So I didn't use it just as an example.

221
00:30:09,310 --> 00:30:15,640
So since it's a single line body of in a statement to just put it on the following line, that's that's a fine way to do it.

222
00:30:17,720 --> 00:30:24,129
Okay. I mean, I usually do like I said before, I usually put curly braces.

223
00:30:24,130 --> 00:30:28,330
But this was just an example showing that it's not required.

224
00:30:29,410 --> 00:30:38,240
Okay. So, yeah, here's just here. Just running the actual code that we had and and it prints out those statements, like we said before.

225
00:30:38,260 --> 00:30:41,830
So this should print out both of these these messages.

226
00:30:41,850 --> 00:30:45,310
Okay. So here it actually.

227
00:30:45,970 --> 00:30:50,170
Yeah, it's just running it and showing that and print it out.

228
00:30:52,120 --> 00:30:59,870
What happened here? Forgot he changed.

229
00:30:59,900 --> 00:31:05,680
Oh, I don't know why I said that example. Yeah, I guess I just changed this part, so.

230
00:31:05,690 --> 00:31:09,710
And X is less than zero. So in this case, the first.

231
00:31:10,550 --> 00:31:18,740
The first message didn't it didn't turn out since this kind of this Boolean expression is now false.

232
00:31:19,400 --> 00:31:22,550
Since I second I've switched this.

233
00:31:23,060 --> 00:31:32,570
I have this statement X is less than zero. Okay. So there's just as basically an extra example here.

234
00:31:38,490 --> 00:31:43,500
All right. So that's okay. So maybe let's pause for a second.

235
00:31:43,500 --> 00:31:52,590
This is just kind of a periodic reminder of that.

236
00:31:52,590 --> 00:31:57,060
You're kind of you're familiar with most of the syntax so far.

237
00:31:57,630 --> 00:32:01,110
So there's kind of yeah. I mean, there's a lot of different.

238
00:32:03,620 --> 00:32:13,550
Detail details about notes plus syntax that takes a while to get used to.

239
00:32:14,670 --> 00:32:28,280
So let's see what with this printout if we run. So this is we have first we are first defining this double variable X to 2.0.

240
00:32:28,280 --> 00:32:34,040
Then we define a integer variable Y. So now let's look at the boolean expression.

241
00:32:35,060 --> 00:32:40,460
Testing is the first part of this is x is greater than Y.

242
00:32:41,420 --> 00:32:47,990
Okay. So this entire Boolean expression is as an order statement.

243
00:32:49,340 --> 00:32:53,959
So let's look at each part of the order. So an X is greater than Y.

244
00:32:53,960 --> 00:32:57,020
So that's that's false, right?

245
00:32:58,220 --> 00:33:02,270
And then the second part we have X is equal to 2.0.

246
00:33:03,360 --> 00:33:07,970
So that's true. So we should execute the body of the if statement.

247
00:33:09,140 --> 00:33:14,719
So we're basically here, we're just updating the value of X, right?

248
00:33:14,720 --> 00:33:22,240
So we first define X and then you can certainly do it this type of updating of the value of X.

249
00:33:22,850 --> 00:33:29,440
So here we're assigning X a different a new value using.

250
00:33:30,590 --> 00:33:34,670
It's perfectly fine to use the existing value of X on the right hand side.

251
00:33:35,400 --> 00:33:46,700
This type of expression assigning excellent value, which is two times the the original value of x x should be now equal to 4.0.

252
00:33:48,470 --> 00:33:51,740
All right. And then the thing that we're printing out is this.

253
00:33:52,310 --> 00:33:57,290
So we're using kind of a C style for F statement here.

254
00:33:57,290 --> 00:34:02,570
If you remember that F like the percent F is used for double variables.

255
00:34:04,250 --> 00:34:08,870
And then here, if you remember, this is DOT three in this type of print,

256
00:34:08,870 --> 00:34:14,629
F is just to denote the digits of precision, which is kind of how many digits turn out.

257
00:34:14,630 --> 00:34:22,270
So it should print out see here since we have like three digits, I think you should print out, right?

258
00:34:26,100 --> 00:34:30,830
Of. They didn't take the strategic cooperation agreement.

259
00:34:31,370 --> 00:34:34,520
You should pronounce see 1.000.

260
00:34:38,400 --> 00:34:43,920
Okay. So that's Boolean expressions, at least a basic part of an ID statement.

261
00:34:43,920 --> 00:34:50,430
So I think we'll just show how to do if else statements and then if all else.

262
00:34:50,430 --> 00:34:53,070
But it's kind of pretty similar.

263
00:34:54,570 --> 00:35:09,030
So basically if false statements as if you want to not just execute one thing whether or not a certain condition is true or not.

264
00:35:09,840 --> 00:35:17,909
If you want to have like if one condition is true, you execute a if it's not true and you want to execute.

265
00:35:17,910 --> 00:35:23,219
B Okay. So that's the type of situation where you want to use it falsely.

266
00:35:23,220 --> 00:35:32,610
So the way the syntax for if L statements and C++ is this, it's kind of similar.

267
00:35:32,610 --> 00:35:43,680
You just have you just basically have the else keyword after the closing curly braces and then you just have another code chunk.

268
00:35:44,250 --> 00:35:48,600
You have kind of another body that's associated with else.

269
00:35:48,600 --> 00:35:52,950
And you have to you have to put that inside of curly braces as well.

270
00:35:55,620 --> 00:36:02,040
So basically, if this kind of Boolean expression here that I'm calling condition, so if that evaluates to true,

271
00:36:02,640 --> 00:36:10,080
you're going to execute this code chunk one and then after executing that,

272
00:36:10,080 --> 00:36:14,610
you're going to kind of move on to the code after the entire default statement.

273
00:36:15,570 --> 00:36:26,970
If this evaluates to false, you do not execute this and you only execute code, and then after that you execute everything after the entire NFL state.

274
00:36:27,270 --> 00:36:30,360
Okay. So that's kind of the logic of the NFL's statement.

275
00:36:31,020 --> 00:36:36,290
Basically, you're only executing one of these code chunks. You cannot not execute both of them.

276
00:36:37,320 --> 00:36:41,850
Okay. So what is this going to this example?

277
00:36:41,850 --> 00:36:51,810
What is this going to print out? So here we have an integer X that where there's a value to.

278
00:36:53,190 --> 00:37:00,660
So if we look at the first Boolean expression, so that's as false two is not less than two.

279
00:37:01,200 --> 00:37:13,620
So you're basically going to execute the body of the, I guess the chunk of code associated with the L statement, the out part of the whole state.

280
00:37:14,520 --> 00:37:23,550
So you going to execute this, this chunk of code so it's basically going to print out to is non negative.

281
00:37:25,440 --> 00:37:31,979
So let's remember the syntax for for print F usually percent B is if you have a integer variable.

282
00:37:31,980 --> 00:37:37,560
So your x is an integer variable. So is just pronounced to is non negative.

283
00:37:40,480 --> 00:37:43,590
Oh. Yes, I.

284
00:37:43,740 --> 00:37:50,410
You have. Oh.

285
00:37:50,450 --> 00:37:55,559
I didn't include this as a screenshot. Yeah. Anyway, it should turn out if you run it too.

286
00:37:55,560 --> 00:37:58,910
Is non-Natives. So this is an entirely different example.

287
00:37:59,660 --> 00:38:05,200
So here's another half statement. This is just like an absolute valley type of thing.

288
00:38:05,210 --> 00:38:09,680
So here I have a double rather than an integer.

289
00:38:10,200 --> 00:38:24,290
And so here, if you want to if you want to, like use a new variable that's based on the value of X, you actually have to declare this first.

290
00:38:25,580 --> 00:38:29,000
So just something to keep in mind like an R python.

291
00:38:29,000 --> 00:38:35,420
If you wanted to assign absolute underscore x, x or negative x, you don't really have to declare it first.

292
00:38:35,960 --> 00:38:41,030
But here in C++, you have to actually have to declare it before you assign it anything.

293
00:38:43,430 --> 00:38:48,440
Okay. So here, if we run this code, so X is -3.2.

294
00:38:48,450 --> 00:38:51,530
So this boolean expression is false.

295
00:38:51,660 --> 00:39:01,190
So it'll run this thing. So it'll assign the double variable, underscore x a negative of x.

296
00:39:01,190 --> 00:39:05,250
So it's going to assign aps x like 3.2.

297
00:39:06,500 --> 00:39:21,650
And so here, when we print this out, it'll print out the message, the absolute value of 3.2, so that the absolute value of -3.2 since that's X.

298
00:39:22,160 --> 00:39:30,170
So the first percent it prints out the value of X and then the second percent, if it turns out the value of APS understood x.

299
00:39:30,800 --> 00:39:38,990
So it should print out the absolute value of -3.2 is 3.2 on here.

300
00:39:39,020 --> 00:39:49,850
So if you don't give it any like if you don't specify the precision, I think it just uses kind of a default precision, which I think is like six.

301
00:39:51,500 --> 00:39:59,240
It's like six digits or something. So if you wanted to control the precision, you could have done 1.1 half.

302
00:40:04,230 --> 00:40:17,730
Okay. So it, fellas, is basically two conditions are basically two possible chunks of code that you can execute.

303
00:40:18,240 --> 00:40:27,900
I mean, you could certainly have more possibilities and two pens all the time and that kind of thing.

304
00:40:28,020 --> 00:40:31,350
You might want to use it and if else, if else, chain.

305
00:40:31,800 --> 00:40:35,520
So here is you just kind of you have more than one condition.

306
00:40:36,660 --> 00:40:39,810
So syntax is pretty similar.

307
00:40:40,230 --> 00:40:47,670
You're basically you take an AFL statement, you're just adding these extra else if chunks to it.

308
00:40:48,430 --> 00:40:54,270
Okay. So you have after the curly braces closes for the if part of the statement,

309
00:40:54,270 --> 00:41:05,940
you have to add else if it's the keyword you use and then you also have open and close braces for each else if you chunk.

310
00:41:13,140 --> 00:41:19,379
So here's the logic of it. If all else, Cheney kind of executes that first code chunk.

311
00:41:19,380 --> 00:41:34,860
That's true. Or the set executes the first part, because the first chunk of code for the first Boolean expression that evaluates to true among these.

312
00:41:35,640 --> 00:41:39,750
And then after executing that, it kind of moves on to something below.

313
00:41:41,670 --> 00:41:46,410
So. Yeah.

314
00:41:46,540 --> 00:41:54,659
Okay. So I can just do an example. So I guess this is this is the same thing.

315
00:41:54,660 --> 00:42:03,549
I mean, you can have an LCF on the same line as the closing parentheses or you can have it on the, on the next line and it doesn't matter.

316
00:42:03,550 --> 00:42:08,879
And it's what like whatever one you prefer is the same thing.

317
00:42:08,880 --> 00:42:16,440
So this is pronounced so each integer x is equal to two.

318
00:42:18,770 --> 00:42:22,710
And so it's basically going to do that at least part of it.

319
00:42:24,540 --> 00:42:28,200
Since this is false, x is less than zero is false.

320
00:42:28,950 --> 00:42:32,969
So it looks at that first. If that's false, it kind of checks this.

321
00:42:32,970 --> 00:42:36,190
This is also false. You know, both of these are false.

322
00:42:36,200 --> 00:42:45,960
Then it goes to kind of the else part. So this should turn out to is non negative, which print out if you run that code.

323
00:42:46,780 --> 00:42:58,149
Okay. So this is. The screen shot of running that you can also, if you have single lines,

324
00:42:58,150 --> 00:43:05,860
you can also put them on the same line or immediately the line immediately below.

325
00:43:07,820 --> 00:43:12,940
You know, sometimes it's ending on. How long the statement is.

326
00:43:12,940 --> 00:43:18,400
Sometimes I think that's a little bit confusing to read, but you can do that if you prefer.

327
00:43:19,000 --> 00:43:25,230
So this would actually do kind of the same thing as before, since we only have like a single line for each code block,

328
00:43:25,780 --> 00:43:30,930
we can kind of put them on the same lines rather than putting them inside of curly braces.

329
00:43:35,630 --> 00:43:43,860
Okay. So here's this. I think this is the last kind of example for if Alice or if Alison helps.

330
00:43:43,880 --> 00:43:51,560
Just a reminder, I mean, you could certainly put your false statements inside of their false statements.

331
00:43:52,220 --> 00:44:01,430
So here we've put like an f l statement inside of the the code chunk for the if part of this like larger if Alice if

332
00:44:01,430 --> 00:44:10,249
our statement so we kind of have this larger if l if l statement where we have x modulus two is equal to one else,

333
00:44:10,250 --> 00:44:12,620
if x is less than zero.

334
00:44:12,620 --> 00:44:23,840
And then Alice basically we have like another if Alice part inside of this, if part of this kind of larger, if all else statement.

335
00:44:24,650 --> 00:44:28,670
So Peter, what is this going to pronounce? So we have X is equal to three.

336
00:44:29,760 --> 00:44:33,380
So the first thing we check is, is this Boolean expression.

337
00:44:34,010 --> 00:44:38,090
And if part of this larger it fails if ls change.

338
00:44:38,100 --> 00:44:44,500
So this is this is actually true. So three modulus two is is one right?

339
00:44:46,100 --> 00:44:53,470
So it's only going to execute kind of this chunk inside of these curly braces that's going to execute this email statement.

340
00:44:53,480 --> 00:44:57,110
So this if there's statement. What's the first thing we're in check?

341
00:44:57,830 --> 00:45:00,980
If X is less than zero, well, that's false.

342
00:45:01,820 --> 00:45:06,020
So we're going to go to this basically, we're going to execute this chunk of code.

343
00:45:07,340 --> 00:45:11,660
It's going to print out this statement here corresponding to this else.

344
00:45:12,380 --> 00:45:19,310
So it should print out three is odd and non-negative is the message that should be printed out.

345
00:45:20,690 --> 00:45:26,150
Printing out this thing here three is odd and non-negative.

346
00:45:30,490 --> 00:45:34,330
Oh, good. Oh, yeah, I think you said that at the bottom.

347
00:45:35,020 --> 00:45:41,079
Just notice some pronoun message here or responding this else.

348
00:45:41,080 --> 00:45:44,110
Part three is odd and non-negative.

349
00:45:44,650 --> 00:45:52,870
So that's an example of just effects inside of a larger if else, if I was type of statement.

350
00:45:53,680 --> 00:46:03,520
Okay. So here's something else that I've mentioned, which is a switch statement.

351
00:46:04,660 --> 00:46:08,110
I think I know you absolutely have to use this.

352
00:46:08,110 --> 00:46:11,769
I mean, there's know four for switch statements.

353
00:46:11,770 --> 00:46:23,829
You I mean, you if you if you want to, you can basically rewrite a switch statement as an equivalent, if else if else changed.

354
00:46:23,830 --> 00:46:31,780
But I think in some cases, switch might be much more efficient, but maybe slightly more efficient.

355
00:46:31,780 --> 00:46:35,019
But I think some people like them.

356
00:46:35,020 --> 00:46:48,250
I think maybe it's a little bit easier to read the code for certain types of for certain types of programs.

357
00:46:48,310 --> 00:46:56,260
The easier to read the logic that you have expressed as a switch statement rather

358
00:46:56,260 --> 00:47:03,460
than this huge influx of knowledge chain kind of launching the switch statement.

359
00:47:04,270 --> 00:47:09,700
Okay. So this is kind of the way a switch statement works. Okay.

360
00:47:12,670 --> 00:47:19,840
So the way it works is the following. So I usually get switch at the top and usually I guess you have the name of a variable,

361
00:47:20,320 --> 00:47:23,440
or it could be an expression, I guess, that evaluates to something,

362
00:47:24,070 --> 00:47:34,630
or it could be a number itself if you want to actually type in a number, if that actually makes sense in the context of programing.

363
00:47:35,080 --> 00:47:38,770
But I think it's usually like a the name of a variable and it's usually it's it should be an

364
00:47:38,770 --> 00:47:49,000
integer variable and there's kind of a bunch of different possible values for that variable.

365
00:47:49,600 --> 00:48:01,240
And so and in the case that the variable takes kind of the first possible value, the way this works is that it executes well,

366
00:48:01,330 --> 00:48:07,120
not only statement one, I mean, it executes statement one, but also executes everything below it.

367
00:48:07,120 --> 00:48:10,750
So it executes like all statements and pattern switching.

368
00:48:12,160 --> 00:48:23,200
So that's that's true. If kind of this variable equals value one, if it equals value two, it would it won't execute statement one,

369
00:48:23,200 --> 00:48:29,559
but it'll execute statement two and kind of everything below statement to execute

370
00:48:29,560 --> 00:48:33,730
statement two and however many other statements you have until statement.

371
00:48:33,730 --> 00:48:39,220
If so, what happens with statement?

372
00:48:41,590 --> 00:48:49,209
So kind of if, if, if this variable doesn't take doesn't equal any of these values, it only executes statement.

373
00:48:49,210 --> 00:48:56,120
And here it's kind of the only the only case where you where you really only execute statement in this one.

374
00:48:57,340 --> 00:49:00,460
This doesn't equal any of those values. Okay.

375
00:49:03,200 --> 00:49:11,130
I saw the variable name, it should be an integer variable or I think you could even have an expression that then evaluates to an integer.

376
00:49:11,140 --> 00:49:20,710
Sometimes that makes more sense. Okay, so let's say you want to do with it.

377
00:49:21,010 --> 00:49:30,079
You want to write a program that does the following. So let's say let's assume we define an integer somewhere in a program called X.

378
00:49:30,080 --> 00:49:43,570
So let's say you want the program to say exit divisible by six, print out is divisible by six if it's even, but not divisible by six.

379
00:49:44,380 --> 00:49:48,190
So we wanted to print out even a number not divisible by six.

380
00:49:48,850 --> 00:49:53,440
And then if it's odd, we want to print out.

381
00:49:53,440 --> 00:49:58,270
It's an odd number. So we want to write a program that does this.

382
00:49:59,480 --> 00:50:05,810
Okay. So this is I think I thought this would be, I guess, a wrong way to do it.

383
00:50:08,260 --> 00:50:18,620
So let's say let's say. Yes.

384
00:50:20,080 --> 00:50:26,770
So. Well, first off, this is going to print out kind of multiple things.

385
00:50:27,730 --> 00:50:31,240
So in this case, this is going to print on average.

386
00:50:31,780 --> 00:50:35,169
Okay. Oh, yeah. I guess I didn't say.

387
00:50:35,170 --> 00:50:39,130
We assume that X is going to be an integer from like zero six.

388
00:50:39,790 --> 00:50:50,349
Okay, so this you could do it if if l statement.

389
00:50:50,350 --> 00:50:53,770
But I just wanted to give an example when we're using a switch statement.

390
00:50:56,350 --> 00:51:00,850
So this doesn't really print out. So in this case, X is equal to zero.

391
00:51:01,270 --> 00:51:05,360
It's going to print out everything's. I want it to print out.

392
00:51:05,380 --> 00:51:12,810
One message is X is in my work.

393
00:51:12,820 --> 00:51:17,320
If if X is odd, actually. So X is equal to one.

394
00:51:17,800 --> 00:51:21,310
It's only going to print out this message. So that part works, essentially.

395
00:51:21,820 --> 00:51:24,980
So if X is equal to one, three or five, it should only threat.

396
00:51:25,000 --> 00:51:28,569
This is X is equal to zero.

397
00:51:28,570 --> 00:51:34,690
It'll print out everything. If X is equal to two or four, you print out both options.

398
00:51:35,260 --> 00:51:39,490
Okay. Right.

399
00:51:43,030 --> 00:51:46,560
It's not exactly what we had in mind. So yeah, here's an example.

400
00:51:46,570 --> 00:51:50,620
I think I just did a screenshot and we run this so x is equal to zero.

401
00:51:51,520 --> 00:51:56,670
It kind of prints out all three messages. That's because your case is zero.

402
00:51:56,680 --> 00:52:05,500
So switch x x is equal to zero zero case and all of the other cases below zero.

403
00:52:05,830 --> 00:52:12,550
So that's kind of how a switch statement works. If we do exist, people are.

404
00:52:14,110 --> 00:52:23,049
It's like I said before, for now, the first one. But I'll do case to case to doesn't have anything associated with it.

405
00:52:23,050 --> 00:52:30,250
But it turns out everything below it, which is kind of to friend message from case four and the default print message

406
00:52:30,250 --> 00:52:36,850
that prints out both two is an even number and two is an odd number if we have.

407
00:52:37,600 --> 00:52:41,500
Okay, so the way in some cases.

408
00:52:44,950 --> 00:52:51,900
You actually want it to kind of do everything below a certain values so that that happens sometimes

409
00:52:51,910 --> 00:52:57,610
I would say it's actually it's maybe more common to you only want it to do kind of 100%,

410
00:52:58,270 --> 00:53:06,010
right. So you actually have you want it to do kind of a similar logic as kind of a big offensive chain.

411
00:53:06,520 --> 00:53:12,070
But a lot of times it's it's kind of more efficient to write it as just case in case two or something,

412
00:53:12,940 --> 00:53:23,290
rather than just especially if the condition is maybe a little complicated where you have to try to see if if type of thing,

413
00:53:23,590 --> 00:53:31,660
it's maybe it's a little bit more efficient to just write it isn't a switch statements so the way to do kind of a

414
00:53:32,080 --> 00:53:42,340
closer to it like an if else if else type of logic you would have to you just have to include these break statements.

415
00:53:42,790 --> 00:53:48,040
So when you include the break statements, it all executes this.

416
00:53:48,040 --> 00:53:51,100
But when it hits break, it kind of it leaves the switch statement.

417
00:53:52,210 --> 00:53:55,270
So if it was case zero, it would it would print this out.

418
00:53:55,270 --> 00:53:58,960
And since we have a break statement here, it just leaves the switch statement.

419
00:53:59,620 --> 00:54:08,229
So it only executes this statement. And here if if it was two or if it was two or four, it's only going to print this out.

420
00:54:08,230 --> 00:54:14,080
And then since we have a break, it will only turn out that signal print message.

421
00:54:18,600 --> 00:54:22,350
Okay. So here's an example.

422
00:54:22,860 --> 00:54:33,780
We just run it where we had this brake statement only prints out a message x is divisible, our value of x is divisible by six.

423
00:54:34,470 --> 00:54:38,220
That kind of works the way we wanted to.

424
00:54:38,850 --> 00:54:42,480
If we put x is equal to here, it should only print out this message.

425
00:54:44,640 --> 00:54:49,020
Okay. That's the only. Yes, I could have put in another example.

426
00:54:49,360 --> 00:54:57,329
That's the only example I had that that's how switch works is just the key thing to know about.

427
00:54:57,330 --> 00:55:03,510
Switch statement is that if you don't have any breaks, it'll basically do the first case.

428
00:55:04,300 --> 00:55:07,770
The first case that's kind of true and then kind of everything below it.

429
00:55:08,910 --> 00:55:17,219
But if you only want if you only wanted to execute a single thing for each case,

430
00:55:17,220 --> 00:55:22,440
the way the way that's usually done is just to add add breaks to your switch statement.

431
00:55:22,710 --> 00:55:33,840
Okay. So kind of break statement means whenever you break is X executed, you kind of immediately leave the switch thing.

432
00:55:40,110 --> 00:55:44,390
Please. It's reasonably clear.

433
00:55:46,690 --> 00:55:49,800
So that's it for the conditional statements.

434
00:55:49,940 --> 00:55:54,480
So that's like if else, if else, if else, and switch.

435
00:55:55,240 --> 00:56:03,660
Oh, so I think these are I don't know if this is really a big topic for are just a kind of extra detail that I mentioned,

436
00:56:03,660 --> 00:56:07,110
which is something you'll see often in C++ code.

437
00:56:07,620 --> 00:56:17,460
So this is kind of like the syntax for incrementing integers and you'll often see it in like the syntax used for loops.

438
00:56:18,100 --> 00:56:22,410
I think we should, I think we should mention it.

439
00:56:22,870 --> 00:56:29,180
So oh yeah, I've said this before.

440
00:56:29,190 --> 00:56:36,719
Like the equals sign is the assignment operator. That's how to sign a value to a certain variable.

441
00:56:36,720 --> 00:56:43,390
So here this is assigning the value one to X, assigning value Y to two.

442
00:56:43,950 --> 00:56:51,540
I mean, you could also, even after it's been declared, you can always assign it a new value.

443
00:56:52,890 --> 00:57:00,640
It's perfectly fine to use kind of the previous value of X in that assignment.

444
00:57:00,660 --> 00:57:05,309
So here we're using the previous value of X to assign X adding value.

445
00:57:05,310 --> 00:57:08,360
So here X is going to equal x plus one.

446
00:57:08,370 --> 00:57:11,670
So after running this, x should have the value two.

447
00:57:12,750 --> 00:57:27,000
And here I kind of did a similar thing with updating the value y should have value by, after, after, after running that line of code.

448
00:57:27,600 --> 00:57:38,729
So this kind of incrementing, updating the value of a variable by one is kind of used all the time in C++.

449
00:57:38,730 --> 00:57:45,690
So there's kind of a shorthand notation for that that was developed that's been developed.

450
00:57:46,170 --> 00:57:57,329
So doing this kind of X is equal to X plus one, or even during the multiplication that we did with Y,

451
00:57:57,330 --> 00:58:07,140
you can use this kind of compound assignment syntax and just say instead of writing out x is equal to x plus one, I could just do x plus equals one.

452
00:58:07,150 --> 00:58:13,229
So that does the same thing. And also y is equal to y two times y.

453
00:58:13,230 --> 00:58:17,130
Instead of writing that out, you can just do y times equals two.

454
00:58:20,200 --> 00:58:28,730
So it just kind of. An alternative way of doing the same thing.

455
00:58:29,840 --> 00:58:39,140
And I just thought I'd mention I think this is fairly common to see in C++ code, so it's good to be familiar with it.

456
00:58:40,100 --> 00:58:47,120
Okay. So you can basically do this with subtraction and and division as well.

457
00:58:47,310 --> 00:58:50,630
It doesn't have to be addition or multiplication.

458
00:58:52,010 --> 00:58:57,710
So this is just how you can even do it with the modulus operator as well.

459
00:58:58,310 --> 00:59:02,390
Time can be plus equals minus equals. Times equals.

460
00:59:02,540 --> 00:59:11,440
Division equals. Kind of similar interpretation.

461
00:59:13,670 --> 00:59:16,720
Oh, so that's compound assignment.

462
00:59:17,650 --> 00:59:27,969
Okay. So, all right, so here's something else you often see.

463
00:59:27,970 --> 00:59:34,210
So this is another way of doing incrementing.

464
00:59:36,190 --> 00:59:43,270
I don't think there's a double mine is showed up actually based on the slides trying

465
00:59:43,300 --> 00:59:50,040
to fix that this is supposed to be like x minus minus eight should have this.

466
00:59:50,150 --> 00:59:53,980
I want to fix that.

467
00:59:54,610 --> 01:00:02,950
But anyway, I think I'll mention the the other syntax that you can use for kind of incrementing a variable.

468
01:00:03,460 --> 01:00:09,400
So you'll often see this X plus plus that just does it increases the value of X by one.

469
01:00:09,550 --> 01:00:13,060
It's kind of the same thing as doing x equal x plus one.

470
01:00:16,720 --> 01:00:27,820
You can also write it as plus plus x. I think it kind of does the same thing in most as a standalone statement.

471
01:00:27,820 --> 01:00:31,600
It should do the same thing depending on how you're using it.

472
01:00:31,630 --> 01:00:39,140
It could potentially give different results. So it's slightly different, but this kind of does the each incrementing here,

473
01:00:39,760 --> 01:00:48,880
the variable first and then in the other evaluation in the overall statement that it's part of.

474
01:00:50,110 --> 01:01:05,370
And then this does the evaluation first guess that the overall statement that's saying it and then it kind of does the incrementing of x together.

475
01:01:05,500 --> 01:01:12,160
An example of the example of the difference.

476
01:01:17,130 --> 01:01:23,000
Yeah, at least. And after the next two or three slides, every example where it could,

477
01:01:23,210 --> 01:01:28,910
it could give you different value depending on whether or not plus plus X or x plus plus.

478
01:01:30,320 --> 01:01:35,430
I mean, I usually don't. I wouldn't worry about it too much.

479
01:01:35,440 --> 01:01:45,909
I mean, I think as long as you're kind of writing code clear where where the expressions are not that ambiguous,

480
01:01:45,910 --> 01:01:57,790
it shouldn't make a difference most of the time. But there are cases where you can give different results if you use X plus plus versus plus plus X.

481
01:01:58,600 --> 01:02:03,010
But anyway, here's just a basic example of just using X plus plus by itself.

482
01:02:03,040 --> 01:02:11,620
So here we have we first define this integer X and the first print out is value.

483
01:02:11,980 --> 01:02:16,780
And you can just run the statement X plus plus by itself on a single line.

484
01:02:16,780 --> 01:02:21,130
You don't have to have anything else next to it or whatever.

485
01:02:21,730 --> 01:02:29,290
You just run X plus a plus by itself on a single line that's just going to that's basically the same thing as writing X is equal to X plus one.

486
01:02:29,290 --> 01:02:37,540
So it's just going to change the value of X. So here, if we print this out, it should print out actually two.

487
01:02:38,140 --> 01:02:45,730
So here we have the value of x is one here is to say here, yeah, it's just a screenshot of what happens when you run it.

488
01:02:46,750 --> 01:02:55,120
So this example is just saying you can run X plus plus on a single line without anything else next to it.

489
01:02:56,290 --> 01:02:59,740
That's a perfectly valid. Okay.

490
01:03:00,560 --> 01:03:10,840
Okay. So here's an example of you could have a difference between plus plus X and X plus plus.

491
01:03:11,590 --> 01:03:19,360
I would say I don't usually do a plus plus in an assignment like when you're assigning the value a little confusing.

492
01:03:19,360 --> 01:03:24,669
But if you did do that, I guess you would want to be careful.

493
01:03:24,670 --> 01:03:28,059
If you have, I could use X plus plus or plus plus x.

494
01:03:28,060 --> 01:03:31,750
So let's look at what's going on here.

495
01:03:31,750 --> 01:03:48,760
So we have it first declare the variable x is equal to one and then I assign it declared a variable y and I sign into value plus plus x x.

496
01:03:49,120 --> 01:03:56,020
So what does that print out? When we print out x and y that turns out to to survive.

497
01:03:58,450 --> 01:04:14,710
So why is that? So it does the incrementing of X first and it kind of does the evaluation, right?

498
01:04:16,750 --> 01:04:19,899
So here it's incrementing the values x, right?

499
01:04:19,900 --> 01:04:27,910
So it converts X to two and then it kind of assigns the value to of two to y.

500
01:04:28,460 --> 01:04:31,750
Okay. So both. So both actions.

501
01:04:32,530 --> 01:04:36,640
So both X and Y have the value two. So they're the same.

502
01:04:37,270 --> 01:04:42,070
Okay. So now like after running this line, x says the value two.

503
01:04:43,120 --> 01:04:51,860
So what happens here? I assign the of declaring the variable Z and I'm assigning it the value like x plus plus.

504
01:04:51,880 --> 01:05:00,840
So what's happening here? So first, it's kind of evaluating everything in the expression first and then does the kind of increment.

505
01:05:00,850 --> 01:05:08,920
So it's assigning the Z the value to and then it does the kind of the increment of X.

506
01:05:09,820 --> 01:05:20,260
So it's signing the value to the Z and then then it then increments X to three.

507
01:05:20,290 --> 01:05:27,460
Okay. So that's why in the second case, we print out X and Z, X says the value three and Z has the value two.

508
01:05:27,910 --> 01:05:40,960
So in this case, Z, and like after running this line, Z and X will not have the same value in this case after kind of running this line,

509
01:05:41,590 --> 01:05:46,590
the first case where we have Y and X after running this line by an X have the same values.

510
01:05:47,670 --> 01:05:56,860
That's just an example where it could have differences using X plus, plus and plus plus x.

511
01:05:58,400 --> 01:06:03,870
You know, I don't know if it's that. If it's that important to worry about.

512
01:06:03,870 --> 01:06:08,209
But I guess it is. Yeah.

513
01:06:08,210 --> 01:06:16,130
I just thought I'd mention that there can be cases where x plus plus versus plus plus x gives you a little bit different results.

514
01:06:17,630 --> 01:06:21,020
Okay. Okay.

515
01:06:21,910 --> 01:06:31,250
Okay. So I think one or two final things to mention.

516
01:06:31,250 --> 01:06:38,420
One thing I wanted to mention is about getting user input just because I often want to use that.

517
01:06:38,420 --> 01:06:45,799
If you at least if you're writing kind of basic C++ programs like you want to have a function that allows the user to input something.

518
01:06:45,800 --> 01:06:57,560
So kind of the standard way to do this is with the C in function seen as kind of like the input version of C out in a sense.

519
01:06:58,490 --> 01:07:03,710
So we use this STV double colon C out to like basically just prints,

520
01:07:05,960 --> 01:07:13,970
prints information of the screen to get information from the user at least you know specifically the keyboard you usually want to use.

521
01:07:14,050 --> 01:07:18,470
STV Double Colon, see and look at that.

522
01:07:19,310 --> 01:07:24,200
That's used when you want to, you want to prompt the user to input something.

523
01:07:24,650 --> 01:07:31,250
Okay. So usually if you have a C in statement and then you run your C++ program,

524
01:07:31,250 --> 01:07:41,270
it'll usually like it'll be a pause and it'll allow the user to input something and then it runs using that input.

525
01:07:41,540 --> 01:07:47,870
Okay. So like an example of this is if you wanted the user to input like two numbers,

526
01:07:48,470 --> 01:07:57,170
the way you usually kind of write this in your program is you have a C out statement and say like enter height and weight, for example.

527
01:07:58,000 --> 01:08:03,680
Right. And then immediately following that,

528
01:08:03,680 --> 01:08:09,920
you would have a C in statement and that would be like a sign that this basically means we're kind of

529
01:08:10,190 --> 01:08:17,480
declaring variables and assigning these variables the things that were entered into the keyboard.

530
01:08:17,490 --> 01:08:22,100
So there should be like kind of two pauses when you run the program.

531
01:08:22,100 --> 01:08:28,879
So you would have like it would prompt you to enter height and weight, type A number,

532
01:08:28,880 --> 01:08:37,400
hit enter and then you would wait for you like you put another number and then hit enter.

533
01:08:37,730 --> 01:08:44,720
And so kind of the first number, that would be input, it would be assigned to the variable weight or is this just T?

534
01:08:45,200 --> 01:08:51,000
And then the second number that you would input to the keyboard is assigned to the the variable team.

535
01:08:51,200 --> 01:09:04,430
It's kind of the way that that works. So this is kind of just the standard way to get input from from numbers that you would input on a keyboard.

536
01:09:05,510 --> 01:09:09,050
Okay. So this is, is I didn't run it. I guess I.

537
01:09:12,380 --> 01:09:22,400
Try to run. This does eventually become a cause. But here's kind of a full program that prompts the user to input something.

538
01:09:22,940 --> 01:09:30,200
So here I'm using if you want to use scene or C++, you have to use the IO stream library.

539
01:09:30,680 --> 01:09:36,950
And I also put the using namespace hosted so you don't have to type in STD double colon every time.

540
01:09:37,940 --> 01:09:50,090
So here you do have to declare your variables before you use them, even as they're kind of input from the keyboard.

541
01:09:50,660 --> 01:09:59,690
So if I want to use WTNH team, if I want to get them as input from the keyboard, you do have to declare that type first.

542
01:10:01,190 --> 01:10:10,130
Okay. And so here I just have a C out statement just prompting the user to put the height link and then I have the C in statement.

543
01:10:12,740 --> 01:10:17,899
So that's basically like the first number that you enter that's going to be assigned to

544
01:10:17,900 --> 01:10:23,950
the variable w t second number that you enter is going to be assigned to the value,

545
01:10:24,290 --> 01:10:32,149
the variable h t. And then after we get that, I'll just have another C out statements,

546
01:10:32,150 --> 01:10:39,830
just kind of print out weight number that you entered and then height and then the number that you enter.

547
01:10:39,840 --> 01:10:48,950
This is basically the second number that you entered, right? So here you could see that if I if I run the whole thing to kind of be a pause here.

548
01:10:52,220 --> 01:10:56,540
Enter 3.2 and then another pause and 3.4 to enter.

549
01:10:57,200 --> 01:11:02,330
And this is the message that shows up. Come a screenshot of the whole thing.

550
01:11:03,050 --> 01:11:08,190
So this just prints out basically the. Print out the numbers that you've entered.

551
01:11:08,280 --> 01:11:11,309
Okay. So that tells C and works. Okay.

552
01:11:11,310 --> 01:11:21,180
So here's just another example, just to make sure we're a little bit more clear on how do you see.

553
01:11:21,180 --> 01:11:34,680
And so here again, using namespaces to be don't want to type that out.

554
01:11:34,950 --> 01:11:42,990
Every time I see double column, I also want to include the string library since in this case I want to use kind of the string variable type.

555
01:11:44,010 --> 01:11:49,469
So here I'm going to prompt the user to input like three different values.

556
01:11:49,470 --> 01:11:52,650
So I have a string variable that I want them to enter.

557
01:11:52,650 --> 01:11:58,799
I want an integer and then a double. So the first thing,

558
01:11:58,800 --> 01:12:04,230
I just prompt them to type a string here and type in a string that'll be assigned

559
01:12:04,230 --> 01:12:09,030
the value s and type in an integer that will be assigned to the variable.

560
01:12:10,290 --> 01:12:15,450
And then here we type in some numeric value which probably isn't done.

561
01:12:15,870 --> 01:12:19,460
And here I'm just printing everything out.

562
01:12:19,710 --> 01:12:27,450
In this case, I'm just using that. If you want to use the C style print F, I guess here is the reminder.

563
01:12:27,870 --> 01:12:41,190
If you want to print out a string using a print f, you have to use this dot to c underscore str.

564
01:12:42,150 --> 01:12:48,560
So whatever your name, the name of the variable is, you have to include that. That seems to be okay.

565
01:12:48,570 --> 01:12:53,460
So yeah, this is. Yeah.

566
01:12:53,850 --> 01:12:57,120
Basically an example of what happens when you run it. I just typed in the string.

567
01:12:57,120 --> 01:13:05,220
Hello? It's an integer with six or seven and then kind of double variable as 3.14.

568
01:13:07,160 --> 01:13:11,240
So it basically turns out everything.

569
01:13:11,660 --> 01:13:15,410
So like we said before, so this was this is another example that you see.

570
01:13:17,390 --> 01:13:24,130
And again, in this print F if you wanted it to do a different level of precision,

571
01:13:24,140 --> 01:13:33,640
you could have done to the point, if we did for point 2 hours, that would turn out 3.14 instead of 3.140000.

572
01:13:33,650 --> 01:13:40,250
Whatever. Okay. So we actually finished slightly early.

573
01:13:42,030 --> 01:13:50,690
Not much start to finish with a just a small review or.

574
01:13:50,730 --> 01:13:59,780
Right. I think it's helpful. It's helpful just to make sure you know how to do this.

575
01:13:59,780 --> 01:14:10,580
That's just more and more of just kind of a reminder of of all the ways to combine the different types of syntax that we went over.

576
01:14:10,970 --> 01:14:20,330
So let's say we just wanted to write a little short little program that's going to have a double variable temp.

577
01:14:21,770 --> 01:14:33,110
And then based on temp, we want to create a string variable called level, which equals string variable will have the value hot if are greater than 80,

578
01:14:33,610 --> 01:14:43,010
it's medium if temp is equal to 80 but for 40 and then cold if temp is lesser than or equal to four.

579
01:14:44,000 --> 01:14:47,330
And then we want our program to print this out. Okay.

580
01:14:47,910 --> 01:14:59,569
So this is just a reminder of kind of all the different syntax, just how to declare a variable, you know, to create strings and this type of thing.

581
01:14:59,570 --> 01:15:05,030
We probably didn't want to use it. It felt as if our statement was the right syntax for that.

582
01:15:05,030 --> 01:15:09,410
And then what's what's the correct syntax for printing out a for something?

583
01:15:10,010 --> 01:15:15,410
So you can either you c out or print out for kind of the main things that we discussed so far.

584
01:15:15,950 --> 01:15:23,329
So was probably one of those. So this is an example of this.

585
01:15:23,330 --> 01:15:32,290
So in this case that you see out, so we want to include the IO string library since we want to have a string somewhere,

586
01:15:32,300 --> 01:15:35,330
we want to probably include the string library.

587
01:15:36,170 --> 01:15:42,770
Okay. So the way we do that, we first create, first declare, you have to first declare your variable,

588
01:15:42,770 --> 01:15:50,120
double your I'm just assigning value 45.0 and then you have to declare the variables.

589
01:15:50,840 --> 01:15:55,130
You have to declare a string variable before you use it or before you assign it anything.

590
01:15:57,020 --> 01:16:07,970
Okay, so it's important to declare everything first. And here you like I said, we just just want to probably want an efficient value chain.

591
01:16:08,600 --> 01:16:14,840
So I'm saying if temp is greater than 80 the level of the sign the string hot

592
01:16:15,860 --> 01:16:23,240
else if of the other cases if it 40 level three assign the string medium.

593
01:16:23,810 --> 01:16:26,210
So this kind of automatically handles the case.

594
01:16:27,050 --> 01:16:34,520
I mean you actually could put the double ampersand 72 equals 80, but it's not actually necessary because.

595
01:16:37,730 --> 01:16:43,490
What happens if you have something greater than 80?

596
01:16:43,940 --> 01:16:54,130
It's not going to go here. If it's if it's graded in 80, 90, if it's 82, it'll go here in this and this code chunk it and it won't reach here.

597
01:16:54,140 --> 01:17:03,440
So you actually don't need to not need to worry about putting greater than 40 or greater than 40 and then double ampersand,

598
01:17:04,790 --> 01:17:06,100
lesser than or equal to 80.

599
01:17:06,110 --> 01:17:18,290
Just because the logic of the deficit, Alice Chain says that it only executes the body of kind of corresponding to the first expression.

600
01:17:18,290 --> 01:17:21,720
That's true. Okay.

601
01:17:22,310 --> 01:17:28,340
In the last case, like everything else, if it's if it's not greater than 80 and it's not greater than 40,

602
01:17:28,730 --> 01:17:34,700
everything else is lesser than or equal to 40. So the else part handles that part of the logic.

603
01:17:35,390 --> 01:17:40,400
It. So for everything less than equal to 40, the level should be called.

604
01:17:41,120 --> 01:17:48,320
So here in the last case, I'm just printing out the message with see how the temperature is, which is cold.

605
01:17:48,840 --> 01:17:53,209
So that's what it should print out if it's less than 40.

606
01:17:53,210 --> 01:18:07,370
I think in this case it should say medium. Oh, and then take a screenshot or not forget to run it.

607
01:18:07,370 --> 01:18:12,650
But yeah, in this case it will print out temperatures. I think that's safe to say.

608
01:18:14,810 --> 01:18:18,440
If you wanted it to be cold, you could just change this to 35 or something.

609
01:18:20,840 --> 01:18:27,200
So I think yeah I think that's it's a few minutes after today I think.

610
01:18:27,440 --> 01:18:33,919
Yeah. Covered quite a bit. I think next time we do the weeks and functions is probably the main thing.

611
01:18:33,920 --> 01:18:45,260
Next time, if not we'll just finish there unless to be questions or come.

612
01:18:50,420 --> 01:18:55,399
Question or comment, sir? No, it's not.

613
01:18:55,400 --> 01:19:04,890
Yeah, we'll just just wrap it up there. I will see you on CNN and then me.

