1
00:00:09,430 --> 00:00:21,610
Though it's too early to tell.

2
00:00:22,740 --> 00:00:31,270
You know, it's going to help, you know, how to get started. And it's the first thing I just mentioned.

3
00:00:31,650 --> 00:00:43,830
I did. I had the zoom link for the office hours of only in my office at the same time.

4
00:00:43,830 --> 00:00:52,290
So, you know, Congress order is here.

5
00:00:58,290 --> 00:01:05,290
It's up to you. So the thing I didn't know was trying to organize the notes receivable.

6
00:01:07,110 --> 00:01:27,780
Well, again, of course, you know some of your files for this in case you want to look ahead to future topics that would put you through meetings,

7
00:01:27,780 --> 00:01:30,960
we sort of had some extra exercises.

8
00:01:33,930 --> 00:01:44,040
But overall, I think the course notes are pretty it's very, very similar to what's in the election notes to the citizens and everything in one place.

9
00:01:44,190 --> 00:01:56,100
So, you know, hopefully it's useful to some is the only thing you can do.

10
00:01:56,780 --> 00:02:12,629
I mean, you know, a lot of these are online quizzes so that people are trying to do the 15th quiz one online.

11
00:02:12,630 --> 00:02:28,860
And then, you know, if they use the other questions about the homework right now or until when they don't have a scratch,

12
00:02:28,860 --> 00:02:35,100
you might find the answers or the content, basically.

13
00:02:35,260 --> 00:02:37,149
So both of these are functions.

14
00:02:37,150 --> 00:03:01,850
So basically the burden to function somewhere and then just show one output when you were kind of running in on let's see on Wednesday afternoon.

15
00:03:07,180 --> 00:03:13,950
All right. So yeah, I guess it's a dual lens thing, isn't it?

16
00:03:19,770 --> 00:03:28,540
Yeah. Wednesday is the 40. So to do on the end of one's dividing line.

17
00:03:30,700 --> 00:03:36,670
All right. So I guess to go back to what we were talking about, so this reminder about the due date,

18
00:03:36,690 --> 00:03:43,090
so it's Wednesday is the first one, mark, and then there is the first quiz.

19
00:03:44,020 --> 00:03:52,749
So I think we'll just finish up vectors and we'll talk about any values in our subject.

20
00:03:52,750 --> 00:03:58,930
We started with a lot of stuff about matters last time, so this would just finish out.

21
00:03:59,290 --> 00:04:07,390
The main topics was with vectors. So I think we just talk about doing I mean, that's really useful for Google Maps.

22
00:04:08,320 --> 00:04:24,160
So you can add vectors, I think in terms of the most basic and you would like to add activities is lectures at the same length,

23
00:04:24,850 --> 00:04:30,669
so and vectors in the same length. It basically does element by element.

24
00:04:30,670 --> 00:04:37,270
So for the sum, the first element of the sum is the, the,

25
00:04:38,220 --> 00:04:51,100
the sum of like the first element plus the first element of the first vector plus the first element of the x and Y here of factors of length three.

26
00:04:51,910 --> 00:05:02,020
The first element is the first element of X plus the first element of why speculation is we are at least when you're

27
00:05:02,020 --> 00:05:11,470
adding to the assembly plant thing with multiplication or division or extra initiation or anything like that,

28
00:05:12,430 --> 00:05:21,490
for if you do multiplication of X and Y, the first element of X times, why is the first X times the first?

29
00:05:21,550 --> 00:05:26,380
So that's probably pretty straightforward.

30
00:05:31,640 --> 00:05:40,000
The only other thing commonly used is just by multiplying a vector times a number, right?

31
00:05:40,670 --> 00:05:44,180
So if you multiply a vector times a single number,

32
00:05:44,180 --> 00:05:51,230
it just kind of multiplies every element of that vector by simply multiplying three times like that,

33
00:05:51,950 --> 00:05:58,099
three times x, it's just every element of three times x, right?

34
00:05:58,100 --> 00:06:01,610
So the first element of three times x is three times x.

35
00:06:01,610 --> 00:06:08,179
1/2 element of three times x is three times x two and so forth.

36
00:06:08,180 --> 00:06:13,370
Third element and three times x is x three times.

37
00:06:14,270 --> 00:06:19,159
Right. Right. Same thing with division or other things.

38
00:06:19,160 --> 00:06:27,410
Even adding or subtracting by a single number. And you have by single numbers and it's every element.

39
00:06:27,830 --> 00:06:40,670
Violence as we'll see, I guess on the next slide, if you think of adding by single numbers, actually example what's called a are a recycling rule.

40
00:06:46,690 --> 00:06:50,120
You know I don't know if you used this that much at not. Ah.

41
00:06:50,140 --> 00:06:57,580
But I think it's good to be aware of it just and in some cases you may run into

42
00:06:57,580 --> 00:07:03,430
one of the messages and which kind of it helps to know how to interpret that.

43
00:07:03,430 --> 00:07:16,690
So you. So recycling rules come in when you kind of do addition or subtraction of diff of different

44
00:07:16,690 --> 00:07:25,960
length vectors and ah so you actually can add or subtract vectors of different length.

45
00:07:26,350 --> 00:07:30,520
That's perfectly valid and ah it'll, it'll return a result.

46
00:07:31,120 --> 00:07:43,179
Okay. So basically what ah does when you add is ah subtracts two vectors of different lengths when it kind of

47
00:07:43,180 --> 00:07:50,280
runs out of values and the shorter vector it just starts to recycle the values in the shorter vector.

48
00:07:50,280 --> 00:07:58,300
And what that means is basically, let's say for adding a vector of length three and a like a vector of length four.

49
00:08:00,010 --> 00:08:08,350
So the first three elements are clear like x one plus y1x2 plus y2x3 plus y three.

50
00:08:09,850 --> 00:08:16,490
But then kind of on the next element kind of notices that it's run out of values for the X Factor.

51
00:08:16,510 --> 00:08:23,020
Just it kind of just starts over so that the fourth element of the sum is going to be X one plus Y four.

52
00:08:23,020 --> 00:08:28,120
So just kind of starts over from the beginning, in the short really does.

53
00:08:29,860 --> 00:08:36,900
So you can see that here, if we add the vector one, two, four with the vector six, zero, nine,

54
00:08:36,910 --> 00:08:44,740
ten know it's going to do what it's going to return is, you know, the first element is one plus six.

55
00:08:45,340 --> 00:08:50,290
Second element is two plus zero. Third element is worth plus nine.

56
00:08:50,770 --> 00:09:01,509
And it kind of notices that it's run out of components in the shorter vector and just starts that starts at the beginning again of the shorter vector.

57
00:09:01,510 --> 00:09:05,290
So the last element of this one is one plus ten.

58
00:09:05,290 --> 00:09:11,169
So it's the first element of the shorter vector plus the last one and the longer vector.

59
00:09:11,170 --> 00:09:17,620
So it's in the return of vector one four is just using cannabis recycling.

60
00:09:19,750 --> 00:09:28,750
Okay. So yeah, if you actually well unless you set up artist of certain warning messages,

61
00:09:28,750 --> 00:09:40,239
this should be try to run this and ah it should do a warning message like I don't remember what the exact message is, something like that.

62
00:09:40,240 --> 00:09:47,290
There is not a multiple of the shoulder or something like that. But even though even though it prints out a warning message, that's still fine.

63
00:09:47,290 --> 00:09:52,840
It just it still returns a result. It's just kind of a a warning, I guess, to say.

64
00:09:52,870 --> 00:09:59,910
Are you sure you want to are you sure you want to do this? This is kind of an unusual expression, but it's still you know,

65
00:10:00,040 --> 00:10:11,260
it's still a valid expression that it can return as a result of that kind of an interesting thing, which I know.

66
00:10:12,990 --> 00:10:23,760
That common, among other languages, is that it will not turn out a warning message if the shorter vector or the length of the shorter vector,

67
00:10:25,140 --> 00:10:30,660
or I guess the length of the longer vector is a multiple of the length of the shorter vector.

68
00:10:32,940 --> 00:10:37,560
You can see that here I have this vector on the right has like six.

69
00:10:38,070 --> 00:10:42,560
So that's a multiple of the length here instead of three.

70
00:10:42,570 --> 00:10:56,730
So it's six two times three. The reason for that, I think, is for certain kinds of things where certain kinds of computation is,

71
00:10:57,890 --> 00:11:07,550
you basically want to add a factor that has a like a repeating pattern versus maybe with a vector that has kind of no repeating pattern.

72
00:11:07,560 --> 00:11:16,220
So like if you had a vector actor on the left, which you think should really have like six, but it's just a repeating pattern.

73
00:11:16,230 --> 00:11:19,560
One, two, four. Sometimes it's just easier to write it this way.

74
00:11:22,170 --> 00:11:26,010
I mean, in those kinds of situations, I might use the rent function,

75
00:11:26,610 --> 00:11:33,389
although I guess it kind of creates a longer vector, which may not be quite as computationally efficient as this.

76
00:11:33,390 --> 00:11:36,959
But I don't think it makes a big difference in most cases.

77
00:11:36,960 --> 00:11:50,220
But that would be one justification for using kind of a using a recycling rule and kind of writing it in a shorter form like this where,

78
00:11:50,220 --> 00:11:57,120
you know, the shorter one of the vector has a stable, repeatable pattern or one of the vectors does not.

79
00:11:57,270 --> 00:12:10,950
So that might be a case where you want to write something like this, so you don't really need to do this if this is confusing.

80
00:12:10,950 --> 00:12:20,129
But I think it's good to be aware of the recycling rules and how are animals

81
00:12:20,130 --> 00:12:25,320
additions of or subtraction or multiplication of vectors and of different lengths.

82
00:12:25,620 --> 00:12:29,220
Okay. All right. So that's that's enough.

83
00:12:29,520 --> 00:12:37,679
That's I think that just we already covered this a little bit in an earlier and we talked about the logical and in all.

84
00:12:37,680 --> 00:12:44,309
But this is just a reminder of how we can do logical operations with vectors.

85
00:12:44,310 --> 00:12:54,000
So remember, this single ampersand is kind of like the vector and the single vertical bar is like the.

86
00:12:56,690 --> 00:13:01,399
The factory floor. Basically, I can do the ampersand with two logical vectors.

87
00:13:01,400 --> 00:13:11,370
It does kind of look logical and element by elements of the first element of this, and it is separate.

88
00:13:11,560 --> 00:13:19,129
That is true and true. Then the second element is the return vector is true and false, which you return false.

89
00:13:19,130 --> 00:13:24,210
And then it's following in false. Okay. Same thing with war.

90
00:13:24,400 --> 00:13:32,930
It's kind of everything element like true or true and the return vector and then true or false and false or false.

91
00:13:34,180 --> 00:13:38,509
And again, just a reminder that the with the double in percent,

92
00:13:38,510 --> 00:13:43,639
if you compare two logical vectors and just compares the compares the first two elements,

93
00:13:43,640 --> 00:13:49,680
it's not like a true kind of vector version of the logical hand or a larger.

94
00:13:52,200 --> 00:13:59,810
Alright. So. So maybe this is a little exercise.

95
00:13:59,850 --> 00:14:07,040
I think if we define this vector X, so x is part of this.

96
00:14:07,880 --> 00:14:22,040
So. And each of those three actually 1115, five, five and ten, ten, ten.

97
00:14:23,780 --> 00:14:31,560
And so there's really only three cases where it's greater than five, but it's a really big.

98
00:14:35,130 --> 00:14:39,720
You know, it's always the indices where X is equal to ten.

99
00:14:39,930 --> 00:14:47,130
Okay. So if we do X X greater than five, that's going to be the logic.

100
00:14:47,340 --> 00:14:50,489
That's going to be just the factor.

101
00:14:50,490 --> 00:15:02,160
Ten, ten, ten. Okay. So if you do the sum of actually three, this is actually.

102
00:15:04,930 --> 00:15:10,120
Actually 14 is basically going to be this factor on what I see.

103
00:15:11,000 --> 00:15:18,560
I'm 1155, five, ten, ten, ten.

104
00:15:21,000 --> 00:15:29,850
And then x x of x greater than five is basically bacteria.

105
00:15:30,510 --> 00:15:38,450
Ten, ten, ten, nine. This is an example of this kind of review.

106
00:15:38,450 --> 00:15:41,930
Exercise is an example of a logical subsection.

107
00:15:42,020 --> 00:15:50,479
Just this return kind of the values of X were executed in five.

108
00:15:50,480 --> 00:15:57,500
So just introduced these, these elements of X, you know, relating this back to the home.

109
00:15:59,060 --> 00:16:08,290
But those are two separate kind of vectors. How would we structure or think about it to make make sure they're equal means?

110
00:16:08,540 --> 00:16:15,890
Do we want them to always be tied to the smallest or to reduce them?

111
00:16:16,710 --> 00:16:21,650
I'm not sure if you want to make sure this oh, this is the same length in sentence.

112
00:16:21,680 --> 00:16:27,320
So you had three kind of been in the bottom. Nine in the top, right.

113
00:16:27,710 --> 00:16:35,090
Yeah. Nine. So what do you want?

114
00:16:35,120 --> 00:16:38,120
You want a vector of like the nine that has kind of the.

115
00:16:39,500 --> 00:16:43,090
I was just wondering because I think on the questionnaire. Yeah.

116
00:16:43,610 --> 00:16:47,420
And asked about X and Y being the same vector, same in length.

117
00:16:47,780 --> 00:16:53,810
Oh. Oh yeah. I think you.

118
00:16:54,020 --> 00:16:58,510
Well yeah. You can just assume that I don't think you have to check it.

119
00:16:58,520 --> 00:17:05,990
I mean you could do and you have to check it but you could check the length of.

120
00:17:08,010 --> 00:17:12,780
Why is equal to the. You don't have to do this in your column.

121
00:17:13,880 --> 00:17:20,970
It's only like a logical way to test that magic to return true or false, basically.

122
00:17:33,460 --> 00:17:37,940
Oh yeah. Just keep moving then.

123
00:17:38,510 --> 00:17:45,410
And I think I just mentioned this quickly ages because this is some you know, this is useful, I would say.

124
00:17:45,890 --> 00:17:50,000
So like R does have kind of a separate set type, I guess,

125
00:17:50,030 --> 00:18:01,009
or actually Python has a separate data type that are like sets that are you could think of like mathematical sense, but it doesn't have that exactly.

126
00:18:01,010 --> 00:18:05,960
But you can still do kind of set operations and different factors.

127
00:18:06,680 --> 00:18:16,700
When you're doing these set operations, you can think of like a set associated with an actor as like the set of movie elements of that vector.

128
00:18:18,260 --> 00:18:21,380
So I just did this example. Here we have X and Y.

129
00:18:22,730 --> 00:18:31,240
You can see here there's like repeated, there's repeated elements in this vector like X as 30 twice and so does Y.

130
00:18:32,150 --> 00:18:36,800
But when you're doing like the examples that we'll show in a minute,

131
00:18:36,840 --> 00:18:43,040
the kind of the set functions you can think of them as working with the set associated with X,

132
00:18:43,040 --> 00:18:47,449
which is like the unique values of X, which is it's one, two, three, four,

133
00:18:47,450 --> 00:18:52,310
five, and then the unique values of Y, which is one, three, five, seven, nine.

134
00:18:53,240 --> 00:19:02,600
So like if we look at the intersection of X and Y, it's basically going to return like the set intersection of these two sets.

135
00:19:02,600 --> 00:19:09,350
I used the intersection of one, two, three, four, five and ah with, with one, three, five, seven, nine.

136
00:19:09,810 --> 00:19:14,680
Right. So the intersection of these two sets is one, three, five.

137
00:19:14,690 --> 00:19:18,350
So it's just the elements that are in both sets.

138
00:19:18,860 --> 00:19:23,420
So one, two, one, three and five are the only numbers that are in both sets.

139
00:19:24,170 --> 00:19:32,060
So Intersect is sometimes useful. You can do a union like the unions.

140
00:19:32,420 --> 00:19:43,700
If we look at these two sets, it's basically one either of these, which is just one, two, three, four, five and seven.

141
00:19:44,470 --> 00:19:48,890
So that's that's what it's going to return to. It's one, two, three, four, five, seven, nine.

142
00:19:52,010 --> 00:20:01,400
The difference functions, the function, it's probably not used quite as often, but it's sometimes useful.

143
00:20:01,940 --> 00:20:10,159
It's basically just the elements that are in X. So you need elements in the vector x that are not.

144
00:20:10,160 --> 00:20:20,450
And what we can see in here, the elements that are in X but not in Y are just two, and for the two and four are in x, but they're not.

145
00:20:25,490 --> 00:20:30,820
Okay, so this operation in I end up surrounded by percent sign.

146
00:20:30,830 --> 00:20:41,270
I would say that's I use that quite a bit and it's kind of like a set operation.

147
00:20:41,930 --> 00:20:45,860
It basically just returns a logical vector the same length as X,

148
00:20:45,860 --> 00:20:56,630
and it's basically testing whether or not that element of X belongs to that kind of set of unique elements of Y.

149
00:20:57,500 --> 00:21:02,240
And so one example or I would use that to find that a smaller set of.

150
00:21:03,790 --> 00:21:16,089
Let's say ideas or something with your data set of pain patients and you want to test whether or not each patient is kind of in a larger database,

151
00:21:16,090 --> 00:21:26,350
you could just do kind of a set of ideas as is in this larger set and will return a logical vector for each element of x.

152
00:21:26,530 --> 00:21:35,890
Okay. So basically, if we look at X and Y, that returns a logical vector, the way to interpret that is just sort of X one.

153
00:21:37,570 --> 00:21:48,490
So the first element of the returned vector is true. So that just means that x of one is and why it belongs to my x two does not belong to y.

154
00:21:49,000 --> 00:21:54,960
Actually three is an element of yx4 is an on the y axis.

155
00:21:54,980 --> 00:21:59,490
Five is not an element of line, and x of six is another.

156
00:22:00,400 --> 00:22:03,280
So that's all that's all it means. So it's good.

157
00:22:03,490 --> 00:22:14,380
It's useful if you can just want to test whether or not each element is a member of some other, you know, collection of values.

158
00:22:15,740 --> 00:22:22,399
Okay. So what I would mention in a valley is just because they're going to they're going to come up at some point,

159
00:22:22,400 --> 00:22:32,690
I think we'd probably use them once before in a is basically just the way you typically represent missing data.

160
00:22:33,170 --> 00:22:36,490
You'll see that. That's pretty.

161
00:22:36,700 --> 00:22:46,060
I mean, if you open up any, ah, data set that has missing values, it will usually be stored as, as in a sock and that just stands for non available.

162
00:22:48,040 --> 00:22:57,589
So I mean you can create a vector of any values yourself or you can just type in a for one of the elements.

163
00:22:57,590 --> 00:23:05,790
So if you just try to create a numeric vector here, you know, the first elements, one,

164
00:23:05,800 --> 00:23:15,580
five and four, it will kind of automatically just treat that that vector as a double.

165
00:23:16,510 --> 00:23:19,960
Oh, yeah. All the types are double. Okay.

166
00:23:21,640 --> 00:23:25,390
So kind of doesn't matter what, what the type of the vector is.

167
00:23:25,930 --> 00:23:32,350
If you type it in a kind of just convert everything automatically.

168
00:23:34,750 --> 00:23:42,430
Okay. So you can see that here. If we try to create a character vector, you still do the same thing.

169
00:23:42,820 --> 00:23:46,450
We can type in an in a for the missing value.

170
00:23:47,170 --> 00:23:53,260
I still kind of automatically handles things correctly and still treating this as a character type of vector.

171
00:23:54,520 --> 00:24:05,980
So kind of regardless of whether or not your vector has characters logical or numbers, you can just type it in a for for your for your missing value.

172
00:24:05,990 --> 00:24:09,700
So that's. So that's how that works.

173
00:24:14,560 --> 00:24:17,980
So this is something I think is worth mentioning.

174
00:24:17,980 --> 00:24:29,440
I mean, you're going to run into this if you if you try to compute any type of statistics and are probably run into this problem fairly quickly.

175
00:24:29,890 --> 00:24:30,760
And that's the problem.

176
00:24:30,760 --> 00:24:39,490
If you try to do some of these standard, you using some of these standard built in order functions if your vector has a missing data.

177
00:24:39,620 --> 00:24:51,370
Okay. So for example, let's say we have a vector of numbers as kind of one missing values and we try to keep the standard deviation.

178
00:24:51,370 --> 00:24:56,580
So the standard deviation in Orange is computed by the function SD.

179
00:24:57,850 --> 00:25:06,370
So if we try to do that, we're going to have a problem or it may not be what we want, I guess.

180
00:25:08,020 --> 00:25:11,040
So it's going to return it. So that may not be what you want.

181
00:25:11,420 --> 00:25:17,620
You want it to return. So I've assigned about the variable to the value returned by SD.

182
00:25:18,190 --> 00:25:19,020
So that is in it.

183
00:25:20,530 --> 00:25:32,950
That's just because if if your vector contains any missing values, if it's one or more of basic values, as indeed is going to return,

184
00:25:32,960 --> 00:25:39,700
it doesn't matter how many missing values you have, as long as there's one or more, it's going to return.

185
00:25:41,230 --> 00:25:44,889
The way you get around this is just by adding kind of this keyword argument.

186
00:25:44,890 --> 00:25:50,320
When you call as indeed, if you just say in a forum that equals true,

187
00:25:50,990 --> 00:26:03,040
then then basically it basically returns the standard deviation among the the non missing elements of your vector.

188
00:26:05,130 --> 00:26:09,900
So you can see that here. This is kind of in return an actual number.

189
00:26:10,590 --> 00:26:22,410
And this needs to end, which is kind of a common argument for most of these types of functions, like the need or the strong or the variance.

190
00:26:23,970 --> 00:26:31,170
Things like in a image equals true is the way that we tell it to ignore the missing values.

191
00:26:32,400 --> 00:26:42,620
We started mentioned that because you almost certainly run into that issue if you are working with any kind of missing data and oh,

192
00:26:42,810 --> 00:26:54,780
so I just thought I would mention this just to connect this back to our, just to our discussion of functions and default values.

193
00:26:54,780 --> 00:27:04,710
So if you actually look up kind of the function definition for SD Nagar, M is an example of an argument with a default value.

194
00:27:04,850 --> 00:27:11,759
Okay. So there's actually like two arguments in SD in the SD function.

195
00:27:11,760 --> 00:27:15,530
So there's X, which is you should think about that.

196
00:27:15,540 --> 00:27:18,810
Usually a vector, X is a vector.

197
00:27:19,260 --> 00:27:23,560
And then there's another argument which is named in a dot.

198
00:27:23,710 --> 00:27:26,880
Ahram is an example of an argument with a default.

199
00:27:27,360 --> 00:27:30,360
The default value is false. Okay.

200
00:27:30,990 --> 00:27:36,720
So that's why when we run SD is X here.

201
00:27:38,640 --> 00:27:43,650
Since we didn't give it the second argument, it automatically kind of assumes a radical response.

202
00:27:44,100 --> 00:27:50,100
And I ran because false means that we're we're not removing the missing value.

203
00:27:50,100 --> 00:27:55,409
So it's going to return in a in a room equals true.

204
00:27:55,410 --> 00:28:10,110
Then it then removes this source just example of kind of a real are built in R function that uses the default values for certain arguments.

205
00:28:10,380 --> 00:28:13,440
Okay. Okay.

206
00:28:13,470 --> 00:28:18,360
So here's a here's just the last thing I'll say about any values.

207
00:28:18,360 --> 00:28:23,940
This is just another function. I mean, that I use a lot of just a useful function to know about.

208
00:28:24,480 --> 00:28:35,309
So it's is darkening. So this not in any just returns of vector logical values with the same length as the input vector.

209
00:28:35,310 --> 00:28:46,290
So basically the take element of the vector return vi is done in a it's just true is that the element of X is missing.

210
00:28:46,890 --> 00:28:54,750
Okay. That's all it happens if you're basically just testing whether or not each element of X is missing or not.

211
00:28:55,480 --> 00:29:04,500
Okay. So you can see that here X we define the vector so that the fourth element and the second element are missing.

212
00:29:04,500 --> 00:29:08,069
They have the values in a values.

213
00:29:08,070 --> 00:29:14,640
So if we do is not in of X, that's going to return a logical vector.

214
00:29:15,270 --> 00:29:19,499
And it's only true in the fourth and the sixth. Right.

215
00:29:19,500 --> 00:29:26,130
So it's only true where the corresponding element of X is missing.

216
00:29:28,320 --> 00:29:38,700
So this is also useful when we talk later about matrices so you can use is done in a directory on matrices.

217
00:29:38,700 --> 00:29:51,520
And matrices are just basically like two dimensional vectors and then it will still give a return like a matrix like true at the for the so.

218
00:29:53,350 --> 00:30:04,870
That are associated with innate values and false advertising, and also for data frames, which are kind of the most common way to store datasets.

219
00:30:04,870 --> 00:30:10,779
You can kind of identify where the missing values are in your your dataset pretty easily.

220
00:30:10,780 --> 00:30:24,970
Just using this has done it in a commission or I think that's that's it for vectors and the question before we move on.

221
00:30:34,870 --> 00:30:42,670
Hopefully so. So I think that they kind of let loose a little bit in the middle of the main.

222
00:30:43,660 --> 00:30:53,500
Our data structure just I think it's there are some examples where it's it's useful to know about vectors before we talk about those.

223
00:30:54,340 --> 00:31:05,140
So links are basically a tool to use when you just, you know, usually when you want to repeat some type of calculation many times.

224
00:31:08,440 --> 00:31:19,300
So the you know, the two main types of loops in our base are just basically the fourth while loop, and that's what we'll talk about today.

225
00:31:19,780 --> 00:31:30,640
So for us, I mean, really, if you if you write things correctly, you can use for loops and wire loops.

226
00:31:35,270 --> 00:31:40,740
You know, for any situation, I guess there's for any situation where you can use all four of them,

227
00:31:40,770 --> 00:31:44,970
you could write a while to do the same thing and vice versa.

228
00:31:45,780 --> 00:31:50,280
However, the way the syntax is set up, it's kind of a for a loop.

229
00:31:50,760 --> 00:31:58,799
It's kind of more natural to use it when you know exactly how many times you need to repeat a specific calculation.

230
00:31:58,800 --> 00:32:01,920
So, you know, kind of beforehand.

231
00:32:01,920 --> 00:32:06,150
Exactly. You need to repeat the calculation 1000 times.

232
00:32:06,240 --> 00:32:12,930
For example, I think the way that for a loop is set up, it's kind of easy to run it for a loop to do that.

233
00:32:14,460 --> 00:32:16,020
On the other hand, I would say a Y loop.

234
00:32:16,020 --> 00:32:26,850
The syntax is kind of set up so that it's easier to use in situations where you want to repeat a calculation until some conditions are satisfied.

235
00:32:28,020 --> 00:32:38,070
So you might want to repeat a calculate some computation until, you know, some number goes to low point one, for example.

236
00:32:40,170 --> 00:32:44,580
That's kind of a natural situation where you would want to use a while.

237
00:32:46,980 --> 00:33:01,580
But in any any rate, loops are used when you want to repeat some type of calculation many times and you want to avoid having to kind of.

238
00:33:03,130 --> 00:33:11,020
Type things out multiple times. All right. So I guess the general form of a follow up is following.

239
00:33:12,370 --> 00:33:15,880
This is kind of the general form, at least the way I've written it.

240
00:33:16,240 --> 00:33:19,990
And hopefully it becomes more clearer when we see some examples.

241
00:33:21,100 --> 00:33:36,970
But the general form is to first put the keyword for and then we have published that looping variable X and then we put in and then there's like a,

242
00:33:40,100 --> 00:33:44,590
I guess a vector or a indexing vector.

243
00:33:45,100 --> 00:33:54,459
And then you going to put you're going to put open curly braces and closed curly braces,

244
00:33:54,460 --> 00:34:03,520
and then you'll usually have a few lines of code inside of the curly braces and that that performs the calculation that you're interested in.

245
00:34:04,960 --> 00:34:10,550
And so you're you're going to repeat this calculation many times.

246
00:34:10,620 --> 00:34:23,470
Okay. So the way this works is that this back name is is basically the name of a vector or a define a vector here.

247
00:34:24,130 --> 00:34:31,450
Basically, the way a foil works is that you repeat this calculation inside the curly braces,

248
00:34:32,020 --> 00:34:39,820
let's say capital T number of times where T is the length of this vector, which is the end of the length of this vector here,

249
00:34:40,420 --> 00:34:46,510
determines how many times you can think of it as kind of going inside of doing this,

250
00:34:47,020 --> 00:34:54,820
the calculation inside of the curly braces and kind of each time you go inside the loop,

251
00:34:55,000 --> 00:35:01,690
basically doing the calculation inside the curly braces X takes a different value.

252
00:35:02,590 --> 00:35:11,260
So the first time you kind of go inside the loop accepts the value of the first element of this vector, right?

253
00:35:12,130 --> 00:35:22,220
So the first element and in fact Name X takes that value here and then kind of it does this calculation.

254
00:35:22,220 --> 00:35:26,170
Then it goes back the second time you go inside the loop,

255
00:35:26,830 --> 00:35:34,389
x takes the value of the second element of this vector and then does the calculation here and so on and so on.

256
00:35:34,390 --> 00:35:38,560
The third time X takes the value of the third element in fact name,

257
00:35:39,100 --> 00:35:46,179
and it does this calculation and it just keeps doing that until it reaches the, you know,

258
00:35:46,180 --> 00:35:56,440
the last element and back capital T then it takes that value does this calculation and then the and the loop is terminated with the group and stopped.

259
00:35:58,190 --> 00:36:03,290
So let's see. Hope. Hopefully.

260
00:36:07,010 --> 00:36:13,219
This makes it more clear. So Kay is like ex in the previous example and then this is like the fake name.

261
00:36:13,220 --> 00:36:17,690
So we could have we could have defined the name of a vector outside of the loop.

262
00:36:17,690 --> 00:36:26,270
But you can also you can also kind of create a vector within the loop definition itself.

263
00:36:26,720 --> 00:36:32,480
Okay, so this is so this loop here is just going to print out the values one, two, three, four, five.

264
00:36:33,230 --> 00:36:40,700
So the first time you go inside the loop takes the values line since that's the first element of this vector and.

265
00:36:42,400 --> 00:36:46,390
See inside these curly braces. The calculation is just a print.

266
00:36:47,090 --> 00:36:50,850
Okay. So the first time you go inside the loop has the value.

267
00:36:50,870 --> 00:36:57,699
1/2 time you go inside the loop K is the value two and so forth.

268
00:36:57,700 --> 00:37:01,899
And it goes all the way until it kind of runs out of values in this vector.

269
00:37:01,900 --> 00:37:04,990
One colon, five, one colon, five and just.

270
00:37:06,380 --> 00:37:09,240
As we mentioned, last time is the back door. One, two, three, four, five.

271
00:37:12,280 --> 00:37:18,280
So this is just kind of an illustration of out of how to write a basic overlap in art.

272
00:37:20,680 --> 00:37:28,350
Okay. So maybe this is. A slightly more useful example.

273
00:37:29,130 --> 00:37:33,660
So this is a for a loop that computes ten factorial.

274
00:37:34,260 --> 00:37:37,139
I mean, there is a function that does that for you,

275
00:37:37,140 --> 00:37:45,990
but if you kind of wanted to do this calculation yourself using a loop, this would be one way of doing that.

276
00:37:46,740 --> 00:37:52,470
So to do calculate ten factorial, you just do one times, two times three times four,

277
00:37:53,010 --> 00:38:00,720
etc. So the way you could do that with a loop is first you define prod, underscore ten as one.

278
00:38:02,710 --> 00:38:05,220
Then you can have a loop going from 2 to 10.

279
00:38:05,850 --> 00:38:18,509
And then each time you go inside the loop, you multiply the previous value of ten by x, so x x to start from two and it goes all the way up to ten.

280
00:38:18,510 --> 00:38:25,140
So kind of the first time you go inside the loop, prod ten becomes prod ten times two.

281
00:38:25,890 --> 00:38:29,730
So that's one times two. So from ten is now two.

282
00:38:30,390 --> 00:38:35,010
And then the next time you go inside, the blue is the value three.

283
00:38:35,610 --> 00:38:41,850
So pretend is then two times three, which is six and so forth.

284
00:38:41,970 --> 00:38:45,450
So it keeps going until until X reaches ten.

285
00:38:46,140 --> 00:38:53,040
So that's that's kind of does the same calculation as computing ten factorial.

286
00:38:53,100 --> 00:39:04,320
So this is this is the value of ten factorial at the end, three is 3.6 million.

287
00:39:05,670 --> 00:39:19,820
So let's go. So one thing I just thought I'd mention, I mean, usually for loops kind of this this vector here on the right hand side,

288
00:39:20,270 --> 00:39:24,530
let's say most of the times it's usually numeric, but it doesn't have to be.

289
00:39:25,430 --> 00:39:37,630
You could have a the vector used for the looping variable could be territory.

290
00:39:38,480 --> 00:39:46,070
So here for this example, well, I have fruit in fruit, so the length of fruit is three.

291
00:39:46,910 --> 00:39:53,450
So we're going to go inside the loop three times. So there's like three iterations to this movie and you could see that here.

292
00:39:53,450 --> 00:40:02,030
The first time we go inside of the loop, the variable fruit takes the value fruits of one, which is just apple.

293
00:40:02,630 --> 00:40:05,840
So it's going to apple. It's like a time you go inside the loop.

294
00:40:05,840 --> 00:40:13,040
Fruit affects the value of the second element of fruit, which is orange, and then the last time it goes inside the loop,

295
00:40:13,040 --> 00:40:18,080
fruit takes the value of the third elements of the vector fruit, which is just green.

296
00:40:18,650 --> 00:40:27,710
So she's just this is an example saying it does not have to be this this factor here does not have to be numeric.

297
00:40:28,920 --> 00:40:34,740
I I'd say most of it. It usually is. But there's no reason why it has to be.

298
00:40:37,030 --> 00:40:42,180
Okay. Let's try an example.

299
00:40:43,000 --> 00:40:43,990
One more example.

300
00:40:44,040 --> 00:41:01,030
Just hopefully you can share the syntax of writing loops in our and how they're used just to create it to create these Fibonacci numbers.

301
00:41:01,660 --> 00:41:12,790
So if you remember, Fibonacci sequence is kind of a sequence of numbers that's just defined by this relationship

302
00:41:12,790 --> 00:41:21,069
where the case element of the sequence or I think is as well defined in order.

303
00:41:21,070 --> 00:41:26,260
And you can think of this as an element of a vector. It's just the sum of the previous two values.

304
00:41:27,070 --> 00:41:34,730
And then just to get things started off with, the first element of the sequence is zero, and then the second element of the sequence is one.

305
00:41:34,810 --> 00:41:46,180
Then once you have those first two elements of the sequence as you can, you can basically construct everything else based on this equation here.

306
00:41:46,810 --> 00:41:50,620
And then you just have the sum, you just have the sum of the previous two elements.

307
00:41:52,210 --> 00:42:01,700
So let's say we wanted to write a little bit of our code that stores the first and the Nancy numbers.

308
00:42:01,720 --> 00:42:07,180
So in this kind of whatever we choose, so the first in Fibonacci numbers in a vector.

309
00:42:09,730 --> 00:42:13,420
So it's hard to do without a loop, at least. And it is.

310
00:42:16,330 --> 00:42:24,520
Reasonably large or not super small at least. So I think it's easiest to do that with a loop.

311
00:42:27,250 --> 00:42:33,340
So I would say in PA at least it's at least in terms of computational efficiency,

312
00:42:33,340 --> 00:42:39,040
it's it's easier to first create kind of an empty vector or let's say a vector with

313
00:42:39,040 --> 00:42:44,500
all the zeros and then then fill in the numbers kind of one by one into this vector.

314
00:42:45,250 --> 00:42:50,980
It's not the only way to do it, but I think it's probably the most, most computationally efficient.

315
00:42:53,830 --> 00:42:58,810
So the way I would do it is let's say let's say we chose an equals 12.

316
00:42:59,800 --> 00:43:09,190
I would first define a vector of a length 12, and actually it doesn't have to be all zeros,

317
00:43:09,190 --> 00:43:22,300
but I think it's easier just to create a vector length with all zeros and then we're going to fill it in kind of using this Fibonacci equation.

318
00:43:22,960 --> 00:43:30,010
So we're here, we're defining the first two elements of X as the first element of X as zero, although in Article zero.

319
00:43:30,010 --> 00:43:32,950
But I'm just doing that to make things clear.

320
00:43:33,310 --> 00:43:41,740
And then the second element of X is one, and then we can use a loop starting from the index three and going all the way up to 12.

321
00:43:43,600 --> 00:43:52,820
Then you can see that here. Exit K is equal to exit K minus one plus exit K minus two.

322
00:43:53,880 --> 00:43:59,030
So now kind of do what we want. Since it starts at three, k starts at three.

323
00:43:59,030 --> 00:44:02,810
So that for the first time we go a little bit.

324
00:44:02,930 --> 00:44:12,100
This is just going to say that exit three is equal to exit two plus exit one, and then the next time we go in the loop is four.

325
00:44:12,110 --> 00:44:16,450
So it's just going to say here that exit four is equal to exit three plus eight.

326
00:44:16,970 --> 00:44:23,150
So exit four is equal to exit three plus x two and so on and so on.

327
00:44:23,150 --> 00:44:27,050
And it'll kind of keep doing this until K reaches 12.

328
00:44:27,230 --> 00:44:33,320
So here it says can have all the signature numbers up to 12, which is eight.

329
00:44:34,130 --> 00:44:39,140
So this is just kind of the way you would write a for loop to do that in R.

330
00:44:42,620 --> 00:44:42,919
Okay.

331
00:44:42,920 --> 00:44:54,860
So I think this is this this is more computationally efficient to first kind of create a vector of length 12 and then kind of fill in the elements.

332
00:44:55,970 --> 00:45:00,650
There's some course. There is another way of doing this.

333
00:45:03,680 --> 00:45:13,579
It probably doesn't matter for this example in terms of speed, but it could matter if you were, for example,

334
00:45:13,580 --> 00:45:21,800
if you wanted to compute the first million Fibonacci, you would probably make a noticeable difference in terms of population speed.

335
00:45:22,490 --> 00:45:31,010
So this alternative is just to first create a vector of length two with like the first two elements of the first Fibonacci sequence,

336
00:45:31,490 --> 00:45:38,180
and then to just like add elements one by one kind of each time you go inside the loop.

337
00:45:40,820 --> 00:45:48,139
So here you could do that. This way you could say X is assigned the vector like C of x.

338
00:45:48,140 --> 00:46:01,040
And then I have pinned this number like I create this vector with x and then I'm adding on this, this extra number here.

339
00:46:01,250 --> 00:46:07,639
Okay. So this is actually with the same result.

340
00:46:07,640 --> 00:46:20,719
But it is I think it is kind of less computationally efficient because it has to do with the fact that you're creating a sense,

341
00:46:20,720 --> 00:46:24,900
a new vector every time you go inside the loop. Yeah.

342
00:46:25,680 --> 00:46:34,020
So this is this you know, this makes me come up with the idea of the recursion precedent,

343
00:46:34,890 --> 00:46:39,440
which is I call it a function inside another function to define.

344
00:46:39,480 --> 00:46:43,560
And can we define this as a function code itself in our.

345
00:46:45,630 --> 00:46:55,710
Now. You could do that. Yeah, you could do a kind of a recursive approach, right?

346
00:46:56,250 --> 00:47:02,890
Yeah. Yeah, you could do that, I think. I don't think that illustrates a trend and that illustrates that loop.

347
00:47:03,930 --> 00:47:06,630
Yeah, you can definitely do that. Yeah.

348
00:47:10,380 --> 00:47:20,010
I think basically what I was trying to show it, I used to write loops in our but you know, you could do a convert recursion type method.

349
00:47:21,310 --> 00:47:25,080
Think. Thank you.

350
00:47:32,400 --> 00:47:35,490
All right, let's keep going. Yeah, I guess the only other thing I mentioned.

351
00:47:35,850 --> 00:47:41,730
You can't have tested for loops. So that's basically just a for loop inside of for a loop.

352
00:47:44,100 --> 00:47:48,390
So here I.

353
00:47:49,960 --> 00:47:55,720
Basically this outside for loop with the eye index is called the outer loop

354
00:47:56,140 --> 00:47:59,800
and then this for loop with the J and that's usually called the inner loop.

355
00:48:00,460 --> 00:48:07,180
And you can also have this kind of structure and the inner will depend on kind of the looping variables in the outer.

356
00:48:07,420 --> 00:48:19,610
So you can see here, each time you go inside the outer loop, we execute this entire interlude and J goes from 1 to 2.

357
00:48:19,660 --> 00:48:24,490
You can see that here time. The first time we go inside the outer loop is equal to one.

358
00:48:25,090 --> 00:48:28,690
So J is basically going to go from 1 to 1.

359
00:48:28,690 --> 00:48:41,110
So just as one 1/2 time we go inside of the kind of the outer loop is equal to two and then j this inner loop is going to go from 1 to 2.

360
00:48:41,110 --> 00:48:45,720
So you can see that here again, it's going to print out to one and to two.

361
00:48:46,690 --> 00:48:59,409
And the third time you're inside the outer loop lies three. So we kind of do the full length j goes from 1 to 3, three, one.

362
00:48:59,410 --> 00:49:08,320
It's going to print out three. One, three, two, three, three. That's how it was.

363
00:49:08,800 --> 00:49:17,340
That's how it nested for the works. Kind of every time we go inside the outer loop, it does kind of the full look.

364
00:49:20,410 --> 00:49:29,170
So I would just mentioned this same break is something useful to know about it, basically.

365
00:49:31,330 --> 00:49:34,070
It's basically a way to terminate the loop. Okay.

366
00:49:34,090 --> 00:49:42,490
So whenever like the great statement is whenever you kind of hit the break statement, the entire loop is stopped.

367
00:49:42,730 --> 00:49:50,200
Okay. You can see an example of this. We have this basic loop where going is going from 1 to 5.

368
00:49:50,770 --> 00:49:58,990
One, two, three, four, five. What I'm saying if K is greater than or equal to three, you're going to execute that break statement.

369
00:50:00,100 --> 00:50:06,640
So this is break statements basically executed for the first time when K is three.

370
00:50:07,670 --> 00:50:21,340
Okay. And then once break is executed, that basically stops the four four loop, stops running, and then it'll move on to the next code.

371
00:50:21,970 --> 00:50:25,690
You can see that here. Prints out one, two, three.

372
00:50:26,410 --> 00:50:36,190
But just remember, case three, we go inside this statement in the break, statements executed and then this statement.

373
00:50:36,490 --> 00:50:41,380
Well, this entire four loop stops. Okay, so.

374
00:50:44,570 --> 00:50:53,100
This sport only ran for three iterations. And here's another example.

375
00:50:53,120 --> 00:51:04,550
Oh, this is I guess I included this because it's to show what happens if you include break statement within nested for loop so.

376
00:51:08,200 --> 00:51:16,020
Basically when you execute a brake statement, when you have a negative for loop, it only terminates the end.

377
00:51:16,060 --> 00:51:19,450
Or at least that break is inside of the inner loop.

378
00:51:19,690 --> 00:51:29,800
Okay, so you can see that here. So I'm saying so we have four items from 1 to 3 and J goes from 1 to 3 as well.

379
00:51:30,940 --> 00:51:36,990
So this inner loop is terminated for the first time when J is equal to high.

380
00:51:37,030 --> 00:51:43,930
So that's when J is equal to one and while in it is equal to one, so it only turns out one.

381
00:51:44,300 --> 00:51:48,640
Then it goes to the next iteration of the outer loop.

382
00:51:48,640 --> 00:51:51,910
So I becomes two and then J only goes.

383
00:51:52,210 --> 00:52:00,940
J is only going to run for two iterations because once a day goes by, this interlopers terminate.

384
00:52:02,560 --> 00:52:05,590
So we should pronounce to 1 to 2.

385
00:52:06,430 --> 00:52:13,840
And then the last the last time we go for the last iteration of the outer loop, where is equal to three?

386
00:52:14,560 --> 00:52:23,680
Here in this case, we print out all of the j j from 1 to 3 because this is not encountered until J in school.

387
00:52:23,680 --> 00:52:32,100
Three. That's just something I've mentioned. We have it nested for loop and you have a break statement at least inside the inner loop.

388
00:52:32,160 --> 00:52:38,530
If it only terminates the inner, it doesn't terminate like both at the same time.

389
00:52:40,330 --> 00:52:46,000
All right, I'll use the next uses that much, but it's sometimes useful.

390
00:52:46,480 --> 00:52:49,660
Next. Just skips to the.

391
00:52:53,330 --> 00:52:55,399
It basically just skips to the next iteration.

392
00:52:55,400 --> 00:53:06,290
So it's it ignores what it doesn't compute what's in the the remaining part of the current iteration, I guess, is the way to say it.

393
00:53:07,280 --> 00:53:11,630
See, hopefully this is somewhat in this example makes it a little bit more clear.

394
00:53:12,110 --> 00:53:18,110
So we have four take one, K and one, two, three, four, five.

395
00:53:18,890 --> 00:53:25,549
Okay. And each time we go inside of the loop we print unless we hit this next thing.

396
00:53:25,550 --> 00:53:32,750
So when K is equal to three, what happens?

397
00:53:32,750 --> 00:53:37,730
So it'll go inside this statement and they'll execute next.

398
00:53:38,270 --> 00:53:42,979
So when K is equal to three, it hits and it executes next.

399
00:53:42,980 --> 00:53:53,570
And it all that means that it basically just ignores. It ignores with what's below the next statement and then goes to the next iteration of the loop.

400
00:53:53,570 --> 00:54:03,470
So it would take us three. It ignores the print statement and automatically goes to the next the next iteration, one of four.

401
00:54:04,250 --> 00:54:07,850
So you can see that here. It just prints out one, two, four, five.

402
00:54:13,340 --> 00:54:24,140
So basically when one executes this next statement, it basically doesn't execute what's below the next statement,

403
00:54:24,650 --> 00:54:30,380
at least for that iteration, and then just automatically goes to the next iteration of the false.

404
00:54:33,980 --> 00:54:39,740
Oh, and that's just another comment about what happens with the inner one.

405
00:54:39,740 --> 00:54:49,520
You and you do this, this next statement within a nested for loop, at least when you have next within the inner iteration.

406
00:54:51,770 --> 00:54:56,629
So here it just goes to the next inner loop iteration.

407
00:54:56,630 --> 00:55:05,620
So it just, it just skips the kind of the remainder of this on the inner loop.

408
00:55:05,630 --> 00:55:06,620
It goes to the next one.

409
00:55:06,620 --> 00:55:20,870
So like if J goes I, let's say for example, J in either one or both one, it will just go to the next iteration of the inner loop and all purpose.

410
00:55:21,620 --> 00:55:27,379
So you can see that here it is not print out one one, but it still prints out one,

411
00:55:27,380 --> 00:55:33,530
two and one, three, etc. So that's what happens if you do it in in a loop.

412
00:55:34,280 --> 00:55:45,530
All right. So the and you say finishes off for loops, the other main type of loop in R is the while loop.

413
00:55:49,220 --> 00:56:01,370
So again, I'll say for most things, if you really want, I guess for any kind of loop type of code that you want to implement,

414
00:56:02,270 --> 00:56:08,750
if you really want to, you probably could write it as a for loop or a while if you want to comfortable it on the other.

415
00:56:09,200 --> 00:56:14,239
So that's kind of the way things are set up for a loop.

416
00:56:14,240 --> 00:56:17,389
It's more natural to use when you want to execute.

417
00:56:17,390 --> 00:56:27,170
A certain piece of code is set times. So you can see that in our previous example, if we have certain,

418
00:56:27,770 --> 00:56:39,709
if we want to execute something ten times will be expressed in a for with that kind of looping variable or that looping vector

419
00:56:39,710 --> 00:56:49,670
that has like a wire loop is kind of more natural when we want to execute a piece of code as long as a certain condition is true.

420
00:56:51,380 --> 00:56:56,210
So you can think of this condition as like a logical expression of some kind.

421
00:56:56,900 --> 00:57:05,910
So it's kind of a general form of a viable because we first have a while and then a condition say,

422
00:57:05,930 --> 00:57:12,400
I would think of this condition is usually a a logical expression or at least a

423
00:57:12,440 --> 00:57:16,760
logical variable that that could potentially whose value could potentially change.

424
00:57:17,930 --> 00:57:32,060
And then you have some chunk of code inside the curly braces and then often a well usually would have to have as part of the code chunk here you have,

425
00:57:32,570 --> 00:57:36,800
you would usually have to have something that's related to condition.

426
00:57:37,220 --> 00:57:40,549
That's the kind of holding this condition in some kind of way.

427
00:57:40,550 --> 00:57:45,200
Otherwise you're going to have an infinite loop. It'll it'll never stop.

428
00:57:46,880 --> 00:57:51,640
So I'd say the issue of the line of expression and then this code finished is.

429
00:57:53,090 --> 00:57:56,490
This code chop is really executing it.

430
00:57:56,520 --> 00:58:05,270
As long as condition is true. So this can if you didn't set it up in a way that the condition eventually becomes false,

431
00:58:05,900 --> 00:58:10,820
this ought to basically run forever until you can of kind of force are to stop.

432
00:58:11,300 --> 00:58:16,940
Okay. But this will run as long as condition.

433
00:58:16,970 --> 00:58:23,720
True. And then it's true. And then it'll stop immediately, like whenever the condition becomes false.

434
00:58:23,990 --> 00:58:36,800
Okay. So hopefully this example makes it a little more clear about the syntax and how it's how our function works.

435
00:58:37,370 --> 00:58:39,740
So this is an example where I just started.

436
00:58:40,190 --> 00:58:48,230
I used initialize the variable and see add one and then I'm just for every iteration of the loop by multiplying it by two.

437
00:58:48,920 --> 00:58:55,070
So it's kind of it's going to go grow pretty quickly. And then this loop stops.

438
00:58:55,940 --> 00:59:00,450
Well. It stops whenever it's greater than or equal to one.

439
00:59:00,810 --> 00:59:05,340
So basically it keeps running as long as prod is less than 100.

440
00:59:06,660 --> 00:59:11,490
So that just means it'll stop whenever prod is is greater than or equal to 100.

441
00:59:11,950 --> 00:59:22,320
Right. So you can see that here. So the first time we go inside the loop, prod is one or it's one at least before we do this updating.

442
00:59:23,190 --> 00:59:26,969
Second time it's two and four, then eight, etc.

443
00:59:26,970 --> 00:59:31,890
And then what happens? I guess like near the last iteration.

444
00:59:31,890 --> 00:59:36,420
So let's say we have prod is 64.

445
00:59:36,420 --> 00:59:47,250
So when prod becomes 64, I say it like this line, just kind of think of it as kind of going back to this line for it checks this condition.

446
00:59:47,790 --> 00:59:51,869
Fraud is 64, so it evaluates this logical expression.

447
00:59:51,870 --> 01:00:04,080
So it's still true. 64 is less than 100. So then it'll go inside the loop and then prod is and it prints that out and prints out 64.

448
01:00:04,680 --> 01:00:07,950
And then on this line, prod becomes 128. So then it.

449
01:00:09,210 --> 01:00:16,720
Wraps up the looping going back, wraps up, finishes that iteration of the loop.

450
01:00:17,410 --> 01:00:21,970
And you can think of it as going back here and evaluating this logical expression.

451
01:00:22,540 --> 01:00:27,250
It's comparing 128 versus 100. So that becomes false.

452
01:00:27,860 --> 01:00:31,190
All right. 128. This is not less than.

453
01:00:31,510 --> 01:00:40,800
So let's see what kind of. Its logical expression of values to follow as the entire loop is terminated.

454
01:00:41,400 --> 01:00:45,630
So it's it's not going to print out 128.

455
01:00:48,080 --> 01:01:07,040
Okay. So let's see, we just have one example of a wireless, if you can, just about if you're doing a little bit of an introduction of matrices,

456
01:01:08,360 --> 01:01:14,360
but this is an example of riding a wild loop to kind of find the first occurrence of a number and a vector.

457
01:01:14,360 --> 01:01:18,880
So that's kind of I call it a first which function of you can remember if you remember

458
01:01:18,890 --> 01:01:26,000
anything from last the last class we talked about the which function that finds the the index

459
01:01:27,060 --> 01:01:37,129
of every index where a certain number occurs in a vector here is like a first which function

460
01:01:37,130 --> 01:01:43,760
which just finds the index where the a certain number of first occurs in the vector.

461
01:01:44,780 --> 01:01:49,460
So one way to implement that yourself as with a while loop.

462
01:01:50,630 --> 01:01:59,750
So basically I'm writing a function where the input vector is X and I want to find the first index.

463
01:01:59,750 --> 01:02:13,040
Okay. So like the smallest index k such that x is equal num num is just a single number so like can length and then the function should also return.

464
01:02:13,520 --> 01:02:24,110
And then if there's another problem, since it's also possible that the number does not occur anywhere in the vector,

465
01:02:24,650 --> 01:02:33,500
and in that case, I want this function to return in any one way to do this is with a while.

466
01:02:34,880 --> 01:02:38,030
So this is again just written the entire function right here.

467
01:02:39,020 --> 01:02:47,360
So, yes, let's go through the components of this function.

468
01:02:48,910 --> 01:02:51,639
So the functions of the name of the functions first,

469
01:02:51,640 --> 01:03:02,540
while as to arguments X should be and you should think of it as a factory now as just a single number or a more technically a factor of like one.

470
01:03:04,300 --> 01:03:08,560
And then I'm going to define this variable called index account.

471
01:03:09,130 --> 01:03:18,370
So that's basically counting how many times I've got going inside of the while loop at its basic purpose.

472
01:03:18,970 --> 01:03:38,740
And then this match that Michael found is basically used or at least partially used to determine whether or not the loop is going to be terminated.

473
01:03:39,940 --> 01:03:45,190
Right. The violence is terminated. All right.

474
01:03:45,190 --> 01:03:48,730
So what so what's going on inside of the loop?

475
01:03:49,600 --> 01:03:55,440
So basically, this index account, it increases by one every time we go inside of wild.

476
01:03:57,250 --> 01:04:10,420
So if you go inside the wild loop and the number of times equals the length of X, that index account will equal the length of x.

477
01:04:10,420 --> 01:04:14,350
Okay. That's kind of its purpose.

478
01:04:15,160 --> 01:04:24,430
And so this this match knocked knockout found is a logical variable.

479
01:04:24,880 --> 01:04:35,900
It's basically saying whether or not the current index or X, the current element of X equals none.

480
01:04:36,250 --> 01:04:43,210
Okay. So you can think of that like the first time we go inside the loop, it's checking whether or not X of one's is equal or not.

481
01:04:43,890 --> 01:04:50,950
Sort of if x is equal to non or x one is equal to none.

482
01:04:52,030 --> 01:04:56,170
So basically it found a match at the first at the first index.

483
01:04:56,800 --> 01:05:06,490
This is going to be false, actually. So what's going to happen in terms of the while terminating or not?

484
01:05:06,490 --> 01:05:10,959
So let's say we found a match and the first iteration didn't match that.

485
01:05:10,960 --> 01:05:15,210
Not that found is false and also indexed.

486
01:05:15,970 --> 01:05:21,310
The account is false. So these are both no sorry.

487
01:05:21,310 --> 01:05:24,810
Indexed. So this expression is is true.

488
01:05:27,110 --> 01:05:31,999
So it doesn't matter. As long as as long as you've found a match, this is going to be false.

489
01:05:32,000 --> 01:05:37,100
That just means that you had to terminate the loop.

490
01:05:37,590 --> 01:05:44,360
Okay, so the reason for making this false is that it terminates the loop whenever a match is found.

491
01:05:44,630 --> 01:05:52,450
Okay. The reason for having this is that we want it to eventually want to eventually terminate.

492
01:05:52,460 --> 01:06:04,490
So whenever indexed account equals the length of the vector.

493
01:06:08,330 --> 01:06:12,260
And so I guess up here.

494
01:06:12,800 --> 01:06:18,370
So we want the last time it goes inside to Luke to be the length of the victory.

495
01:06:18,560 --> 01:06:23,030
Or at least we want the index devalue index account here.

496
01:06:24,850 --> 01:06:30,420
When this equals the length of the vector x, we want that to be the last time it goes inside.

497
01:06:30,430 --> 01:06:39,310
Or at least if there's no match. Right? So let's say there's no match between any of the elements of X and none.

498
01:06:41,110 --> 01:06:50,050
You kind of like the last time you go inside the loop to be the case where index account is equal to the dot the length of x.

499
01:06:50,320 --> 01:06:53,800
So when that happens here, it's going to terminate.

500
01:06:54,330 --> 01:07:00,680
It's just because on the next iteration index, count the length of X plus one.

501
01:07:01,180 --> 01:07:09,250
And we don't want that. We don't. We can't really. You don't want to check you cannot check elements of the vector that are longer than the length.

502
01:07:09,710 --> 01:07:13,840
Okay. So that's the reason for this condition.

503
01:07:14,410 --> 01:07:20,170
So this this wild statement will terminate whenever at least match that.

504
01:07:20,180 --> 01:07:28,660
Not that found is false or index account equals length of x kind of.

505
01:07:29,230 --> 01:07:38,230
If either one of those is false, this will terminate.

506
01:07:38,630 --> 01:07:43,460
Okay. And then if matched or not found.

507
01:07:44,150 --> 01:07:50,390
So if matched or not, not found is true. When we terminate that loop, that means we never found a match.

508
01:07:51,020 --> 01:07:54,020
So in that case, we're going to set that account in a.

509
01:07:56,900 --> 01:08:02,379
You see, this code here is just, if not magical.

510
01:08:02,380 --> 01:08:08,040
Not that found is true. After you ran the entire loop, that means you never found a match.

511
01:08:08,700 --> 01:08:13,070
Right. So in that case, you say return value is in.

512
01:08:14,380 --> 01:08:17,850
Then we return the return value in next account.

513
01:08:18,900 --> 01:08:24,990
So you can see that here. Index account is the index of the match.

514
01:08:25,560 --> 01:08:33,180
Okay. Since it's a our index account, none.

515
01:08:38,120 --> 01:08:45,010
Actually, that's. With explanations mostly clear.

516
01:08:47,680 --> 01:08:57,520
So you can see that if we were a few examples of the function, if we do first mile where the input factor x is one, two,

517
01:08:57,520 --> 01:09:04,180
three, four, five, and then we're trying to find the first match with three that returns effective two turns them into three.

518
01:09:04,570 --> 01:09:12,520
That's the index of the first match. If you try to match it with six, that returns in a first index with.

519
01:09:14,700 --> 01:09:20,880
We do one, two, three, four, five and five is the number five this year.

520
01:09:23,700 --> 01:09:31,470
First match with two is the next five. So that's kind of the way this this function is, is supposed to work.

521
01:09:32,250 --> 01:09:46,750
But. So I think that was it for us.

522
01:09:48,640 --> 01:09:59,350
Well, that's basically it for loops. I we'll move on it.

523
01:09:59,350 --> 01:10:03,159
Back to matrices. I didn't include this as an extra example.

524
01:10:03,160 --> 01:10:18,090
I mean, that is just too long to discuss in class, but there's any questions about it next time we discuss it briefly.

525
01:10:18,520 --> 01:10:26,380
So this is just kind of another example of using a using forum.

526
01:10:27,130 --> 01:10:31,340
And then it might be useful to really kind of combines a lot of our syntax, you know,

527
01:10:31,360 --> 01:10:36,579
so writing functions, using the for loops, using if statements, etc., etc.

528
01:10:36,580 --> 01:10:41,890
So that kind of combines a lot of features of our into a single example.

529
01:10:43,860 --> 01:10:51,430
Okay. So maybe I'll just do a quick introduction of what matrices are and are at least.

530
01:10:52,240 --> 01:10:58,060
So I think matrices are kind of the next big data structuring.

531
01:10:58,360 --> 01:11:05,410
So the first one was vectors. So you can think of matrices as basically kind of two dimensional vectors.

532
01:11:07,690 --> 01:11:19,329
So this is I mean, this is kind of a form of the matrix that you might see in linear algebra, which is basically a table of numbers,

533
01:11:19,330 --> 01:11:27,760
although it doesn't have to be numbers into the table of numbers or characters organized into rows and columns.

534
01:11:28,390 --> 01:11:33,640
So this is an example of like a matrix where we have in rows and columns.

535
01:11:34,190 --> 01:11:42,879
And so each of these elements one one is a number or it could be a character.

536
01:11:42,880 --> 01:11:50,620
And ah, so our does allow the elements of a matrix to be any type,

537
01:11:50,620 --> 01:12:00,930
even though we can think of matrices is kind of filled with numbers are does allow them to be any type because the characters are logical.

538
01:12:00,940 --> 01:12:09,010
However, it's kind of the same rule as with vectors and all of the elements of a matrix have to have the same types.

539
01:12:09,220 --> 01:12:12,129
So you can't have mixed types here,

540
01:12:12,130 --> 01:12:20,230
so you can't have some elements of the matrix be a number and some of the elements of the matrix to be a character that's not allowed.

541
01:12:20,240 --> 01:12:23,650
So they all have to be all numbers are all characters.

542
01:12:26,140 --> 01:12:31,270
Okay, so let's do a few examples of like how to create a matrix in R.

543
01:12:31,780 --> 01:12:42,020
So I think that most. When you're first starting out, I guess the most common way to just create a matrix is just to use the function called matrix,

544
01:12:42,680 --> 01:12:50,300
so you can basically just convert a vector into a matrix directly.

545
01:12:50,910 --> 01:13:04,320
So let's say X is a vector. And let's say collector of like six and I want to convert it into a three by two matrix.

546
01:13:05,070 --> 01:13:09,300
So the way to do that is just say matrix of X comma.

547
01:13:10,170 --> 01:13:14,790
Give it the number of rows you want it to have and then the number of columns

548
01:13:14,790 --> 01:13:23,080
you want to have in the row is the number of rows you want to have in common.

549
01:13:23,100 --> 01:13:31,290
That number of times actually could have a single number.

550
01:13:31,310 --> 01:13:38,680
You're just going to need a full. Factor with a bunch of different numbers.

551
01:13:38,680 --> 01:13:44,170
So if you wanted to create a matrix of all ones, you could just put a matrix of one.

552
01:13:44,770 --> 01:13:48,880
And the number of rows and the number of columns that you want to put one at attack of.

553
01:13:50,250 --> 01:13:59,170
So this first example shows that if I want to create a matrix that has all the elements or zero and it has two rows and three columns,

554
01:13:59,620 --> 01:14:03,940
you just a matrix of zero, comma two, comma three.

555
01:14:04,570 --> 01:14:12,910
So that's how you do that. If I wanted to create a matrix like let's say I have the vector one, two, three, four,

556
01:14:12,910 --> 01:14:18,340
five, six, and I wanted to convert that into a matrix with two rows and three columns.

557
01:14:19,000 --> 01:14:23,110
I would just do a matrix of X, comma two, comma three.

558
01:14:23,710 --> 01:14:34,840
And so that would convert the vector like all the vectors, all the elements of the vector X into the matrix, into a matrix.

559
01:14:35,260 --> 01:14:45,580
So it fills the, it fills the elements of the vector into the matrix in a certain order.

560
01:14:46,090 --> 01:14:54,340
So it kind of does, it fills in them, fills them in by column, basically reads by default, it fills them in by column.

561
01:14:54,350 --> 01:15:01,750
So it fills in the fills in the first, first column first,

562
01:15:02,290 --> 01:15:08,440
and then it moves on to the to the next column and fills it it until it fills in the entire matrix.

563
01:15:08,890 --> 01:15:15,930
So there is a way, there is an argument that you can use it to fill it in by row alternatively, but is it the default?

564
01:15:15,930 --> 01:15:21,430
So you can see that here it goes one to the first column in three four than five, six.

565
01:15:24,670 --> 01:15:34,180
Yeah, I think I just mentioned that on the next slide. So it fills, fills things in kind of by column so you can change that if you want to.

566
01:15:34,660 --> 01:15:40,000
So there's kind of a well, this is actually if you look at the function definition,

567
01:15:40,000 --> 01:15:44,829
this is another example of a function argument that has a default value.

568
01:15:44,830 --> 01:15:55,690
So there's a function argument called by row in the matrix function and the default value of by row is false.

569
01:15:55,690 --> 01:16:01,090
But you can change that when you call it a function. You could say by row equals true if you want to know.

570
01:16:01,840 --> 01:16:09,520
So that's just going to fill it in the first row, first thing, the second, first row, one, two,

571
01:16:09,520 --> 01:16:21,070
three and four, five, six, etc., etc. If you had a matrix with more rows, keep going in that way.

572
01:16:23,260 --> 01:16:33,079
Okay, so you can. So it does do a kind of a version of recycling the rules as well.

573
01:16:33,080 --> 01:16:45,979
So you the vector that you input as the first argument of the matrix function, it doesn't have to match the number of elements in the entire matrix.

574
01:16:45,980 --> 01:16:56,059
So like the factor that you put here doesn't have to match the dimension or the number of elements of the full matrix.

575
01:16:56,060 --> 01:17:02,570
So if we're trying to create a matrix with two rows and three columns, then there are six elements in that matrix.

576
01:17:02,780 --> 01:17:08,689
It's two times three, but we don't have to give it a vector of length six necessarily.

577
01:17:08,690 --> 01:17:17,500
It basically just basically just recycles once it runs out of elements and the vector just starts getting started on it.

578
01:17:17,520 --> 01:17:29,239
So it goes one to that fills in the first column and then it notices that it is no more element, you know, elements in this vector one, two.

579
01:17:29,240 --> 01:17:37,610
So just starts at the beginning. Okay. So it can see that here with this example, we're giving it this vector as the first argument.

580
01:17:37,620 --> 01:17:50,330
One, two, three. But it fills things in by Collins that there was one, two and three here in the second column and one, two, three.

581
01:17:54,080 --> 01:17:57,350
That might not be what you want, if you want is kind of a nice pattern.

582
01:17:58,330 --> 01:18:08,210
You like you wanted that to be 1 to 3 across rows, but you could and you could do that by just adding this by arrow equals true argument.

583
01:18:08,560 --> 01:18:16,549
So that's one way that that was just about it.

584
01:18:16,550 --> 01:18:31,130
So I just mentioned this. So yeah, to access elements of a matrix, you can kind of do, you can basically think of it as so you have these these two,

585
01:18:31,430 --> 01:18:41,410
you have these brackets like you access elements of a vector, but you need you can put in two numbers and separate them by a comma.

586
01:18:41,420 --> 01:18:46,960
So you could think of you would think of this as. The first.

587
01:18:49,230 --> 01:18:53,100
Entry. The first number that we put here, access is that row.

588
01:18:53,550 --> 01:19:00,190
And then the second number that the number that you put after the common kind of access is the column.

589
01:19:00,210 --> 01:19:12,320
So if you put a two column, one that accesses the the entry of a, which is that the row to column, column on the right.

590
01:19:12,780 --> 01:19:21,389
So you can see that with four. And then you can also access kind of multiple columns.

591
01:19:21,390 --> 01:19:32,010
Actually, I think we'll probably do some more examples next time. So if I want to access the second row, sorry, second row,

592
01:19:32,010 --> 01:19:40,379
and then that's in columns one and column two in the second row, you can do you can give it a vector of one too.

593
01:19:40,380 --> 01:19:44,700
So this, this is just another way of writing the vector one, comma two.

594
01:19:45,720 --> 01:19:57,629
So this ax, this access is now the second element of our sorry, the second row of a columns, one or two or you can even access the entire.

595
01:19:57,630 --> 01:20:05,460
It's kind of useful to do this. A lot of times you can access the entire second column by doing by leaving the first part blank.

596
01:20:06,090 --> 01:20:14,999
The first part, if I leave the row in next empty, you know, just kind of return everything from the second column and vice versa.

597
01:20:15,000 --> 01:20:23,250
If I did, I wanted to access everything from the second row. I would just do a bracket two comma and then leave whatever is after the comma.

598
01:20:23,250 --> 01:20:32,940
And I would just return the entire second row. There's some similar examples, any kind of familiar with this,

599
01:20:32,940 --> 01:20:41,040
but this is how you can actually do things to know for accessing elements of the matrix.

600
01:20:42,210 --> 01:20:45,870
But this with me use will stop there.

601
01:20:45,870 --> 01:20:54,630
So I'll see everybody on Wednesday.

602
01:20:56,790 --> 01:21:00,960
Let me talk about.

