1
00:00:11,740 --> 00:00:24,630
But. It's just a little bit weird.

2
00:00:44,040 --> 00:00:52,250
Others do it like, okay. See.

3
00:00:53,480 --> 00:01:53,090
See, he. I was just.

4
00:02:02,180 --> 00:02:05,580
Sorry. Obviously, we it.

5
00:02:05,900 --> 00:02:09,350
We'll just do it this way. Okay.

6
00:02:12,450 --> 00:02:18,720
Okay. So we'll just start getting a little.

7
00:02:22,830 --> 00:02:27,600
So I think today is basically the last kind of full lecture.

8
00:02:28,800 --> 00:02:43,620
We'll have class on Wednesday, but I think it'll be kind of short because I think there is the last day of classes, not until Thursday.

9
00:02:43,620 --> 00:02:49,290
So we still have a class, but it'll be probably pretty short.

10
00:02:49,290 --> 00:02:55,979
I think I want to finish most of the material today and just probably a little bit left over on Wednesday.

11
00:02:55,980 --> 00:02:59,790
So we'll probably be pretty short on Wednesday.

12
00:02:59,790 --> 00:03:11,310
And then also if you have extra questions about the final or whatever or anything else, you can ask them on Wednesday as well.

13
00:03:12,030 --> 00:03:12,329
Okay.

14
00:03:12,330 --> 00:03:28,559
So I guess these are trying to probably regenerate the slides too much and double check that came on slightly smaller font and supposed to be okay.

15
00:03:28,560 --> 00:03:34,260
So yeah, these are just the reminders.

16
00:03:35,490 --> 00:03:47,069
Uh, basically I guess this week we have a homework three and the quiz is to do on Wednesday and then a post.

17
00:03:47,070 --> 00:03:51,540
Yeah. Is your office hours still on this Wednesday afternoon.

18
00:03:52,530 --> 00:03:56,640
Yeah. Is it on the should be on the calendar.

19
00:03:58,290 --> 00:04:01,570
I'll add it for. I don't think I had enough one for next.

20
00:04:02,130 --> 00:04:09,750
I'll have another one next week as well. So I'll be early the next Monday because the deadline for final submission is next Friday.

21
00:04:09,750 --> 00:04:13,700
Standby to do on Monday.

22
00:04:13,710 --> 00:04:17,800
So that's easier. Yes, I'll pick anyone Monday.

23
00:04:18,120 --> 00:04:24,750
They can have both on Monday and Wednesday. Oh that'll be great. Yeah, that'll be just business class.

24
00:04:26,430 --> 00:04:34,410
Okay. So yeah that's basically these three things are basically the last three remaining things if you haven't done it so far.

25
00:04:36,480 --> 00:04:45,050
So yeah, these are last three things for this, for this class. So I think today we're basically I mean we did RCP last time.

26
00:04:45,060 --> 00:04:49,080
I think we're going to do all our CPV today as well.

27
00:04:52,830 --> 00:05:04,370
Okay. So the I guess the I don't know if we mentioned it last time, but uh, I mean there's kind of a,

28
00:05:06,570 --> 00:05:14,640
there's a variety of useful functions or at least I think useful if you're doing kind of more statistics type of applications.

29
00:05:15,030 --> 00:05:19,379
There's useful functions that are made available by RCP.

30
00:05:19,380 --> 00:05:24,150
So these are the functions that are I mean, if you know, are these,

31
00:05:24,150 --> 00:05:34,260
these are some of the functions for computing the like the probability distribution function or for generating random variables and a few other ones.

32
00:05:34,260 --> 00:05:40,930
These are kind of functions that are kind of in this ah double colon namespace.

33
00:05:40,930 --> 00:05:48,839
So if you do like R double colon, there's kind of a variety of functions in that namespace.

34
00:05:48,840 --> 00:05:54,749
So one is Nahm that's like this cumulative distribution function of a normal random

35
00:05:54,750 --> 00:06:01,200
variable P by known as the cumulative distribution function of a binomial random variable.

36
00:06:01,200 --> 00:06:07,679
So sometimes these are, sometimes these are useful at least if you're doing kind of more statistical types of programs.

37
00:06:07,680 --> 00:06:11,219
So like R Norm, I can use that directly.

38
00:06:11,220 --> 00:06:18,390
So that generates normally distributed random variables are units uniformly distributed random variables.

39
00:06:19,140 --> 00:06:20,360
And I just put in like a,

40
00:06:21,120 --> 00:06:30,930
a link here that I think this kind of has the full list of functions that you can use is from the the R double comma namespace.

41
00:06:34,820 --> 00:06:38,420
Okay. So yeah, we'll show that in an example in a minute.

42
00:06:38,430 --> 00:06:43,669
And also another useful thing that's probably as useful for the file as well,

43
00:06:43,670 --> 00:06:51,979
just to know that you can use a lot of these math functions directly if you're using RCP,

44
00:06:51,980 --> 00:06:59,020
so you don't have to import the C math header, you don't have to do include C mass or anything else.

45
00:06:59,290 --> 00:07:08,630
It's probably even recommended not to do it. If you're using RCP piece, there's no kind of conflict between the two versions of the function.

46
00:07:08,640 --> 00:07:14,270
So here, kind of just a list of the maybe the most common ones.

47
00:07:14,270 --> 00:07:18,770
I think there's there's a there's a lot more functions.

48
00:07:20,000 --> 00:07:29,780
These are probably the most useful. So like the absolute value of a number, you can just do abs with RCP log.

49
00:07:29,780 --> 00:07:32,570
If the log function confuses the actual log,

50
00:07:33,170 --> 00:07:44,150
it's base E and if you wanted to do the base ten that you have to do on ten for that you can't use the square root of the POW function,

51
00:07:44,210 --> 00:07:47,210
basically the same as in kind of regular C++.

52
00:07:48,140 --> 00:07:58,250
If you want to do exponential, should you do P.O.W. it's a comma, B and then round if you want to round to a certain level of precision.

53
00:07:59,150 --> 00:08:09,500
I would kind of like to argue and around two decimal places it's round x, comma two and then factorial computes the factorial of x.

54
00:08:09,500 --> 00:08:13,400
So I think, oh, I didn't mention XP.

55
00:08:13,760 --> 00:08:22,430
So yeah, if you want to do either the Race to the Top or something, that's just the XP of X that was just cosmetic.

56
00:08:24,050 --> 00:08:28,250
These are just useful to know that. It's useful to know that you can use these directly.

57
00:08:28,250 --> 00:08:36,889
You won't have to import any other libraries. Okay, so this is also pretty useful.

58
00:08:36,890 --> 00:08:48,680
I'll show an example of this. So I think in the previous examples with RCP, we were computing this some kind of writing the loop directly,

59
00:08:48,680 --> 00:08:55,130
but you don't have to do that at least if you're working with a numeric vector.

60
00:08:56,870 --> 00:09:06,979
If you're working with a numeric vector object, you can do you can use these functions directly and kind of get a number or return a number.

61
00:09:06,980 --> 00:09:14,630
Like if you have a numerical vector, you can use that as an input argument to sum and then returns a double.

62
00:09:15,740 --> 00:09:22,860
Since just the sum of the elements and the numeric vector, if you have to use the mean that you should returns a double as well.

63
00:09:22,890 --> 00:09:32,000
So the mean of the elements of the vector, etc., etc., medians, the same kind of thing as standard deviation or variance.

64
00:09:32,060 --> 00:09:38,209
I understand variance twice. And then min and max as well.

65
00:09:38,210 --> 00:09:46,730
Table doesn't return a number. It kind of returns the vector itself, which accounts for for each category.

66
00:09:50,210 --> 00:09:51,800
But this is useful to know sometimes.

67
00:09:52,220 --> 00:09:59,630
I mean, you can compute this directly by writing your own kind of C++ loop, but sometimes it's just makes the function.

68
00:10:00,200 --> 00:10:06,230
It's a little, you know, it might make your code shorter or easier to write in many cases.

69
00:10:06,890 --> 00:10:09,930
Okay. So here's I think where we stopped last time.

70
00:10:09,950 --> 00:10:15,319
So I just had this kind of little example of where we have like an input matrix.

71
00:10:15,320 --> 00:10:17,000
It's basically a numeric matrix.

72
00:10:17,000 --> 00:10:27,620
It's in by P, I'm calling it A and then like we write a function, we're going to have another input argument which is a basically a logical vector.

73
00:10:28,640 --> 00:10:40,220
So the j element equals true. It comes from what you might think of as like the treatment group, and then it equals false if it's like the control.

74
00:10:41,090 --> 00:10:46,010
So that's kind of the idea. And then from this, what do you want to do?

75
00:10:46,640 --> 00:10:52,010
You want to compute basically a T test for every row in your data.

76
00:10:54,170 --> 00:10:58,610
Well, I guess the Z values and the and the T well yeah.

77
00:10:58,610 --> 00:11:02,180
The Z values and the P value for the T test, basically.

78
00:11:06,390 --> 00:11:16,410
So the Z values basically come back. So for the I throw, you're comparing the means from the from the treatment group versus the control group.

79
00:11:17,160 --> 00:11:24,540
So the the Z value for the I0 calling it Z II, it's defined like this.

80
00:11:24,540 --> 00:11:30,090
It's the the mean from the treatment group.

81
00:11:30,330 --> 00:11:32,850
The treatment group and the ith promotions basically just.

82
00:11:35,100 --> 00:11:46,830
I throw the data from the I throw corresponding to the group equals true columns and then minus the mean from the control.

83
00:11:47,130 --> 00:11:52,620
And you divide by the standard deviation.

84
00:11:52,620 --> 00:11:58,709
I guess there's there's three potentially different ways of doing this, but this is where we're doing it.

85
00:11:58,710 --> 00:12:02,460
Here is the standard deviation.

86
00:12:02,460 --> 00:12:11,270
So it's basically just the standard deviation when you combine all of the data from the entire row and just compute this,

87
00:12:11,700 --> 00:12:16,680
the standard deviation of that. Okay, so that's the Z value.

88
00:12:16,700 --> 00:12:22,440
So we're going to compute that for each row. So we're going to have basically n z values at the end.

89
00:12:23,160 --> 00:12:30,310
So the. The pool standard deviation is defined this way.

90
00:12:34,390 --> 00:12:41,650
It's basically just this kind of sum of square or residual squares in the first group,

91
00:12:41,920 --> 00:12:49,500
plus the sum of residual squares in the second group divided by kind of as well.

92
00:12:50,200 --> 00:12:59,710
So I'm saying in one is kind of the number, the number in the treatment group and then in zeros that the number of columns from the control.

93
00:13:00,430 --> 00:13:08,680
Basically when you subtract by two, it's going to increase the freedom that you're using up.

94
00:13:10,390 --> 00:13:19,450
So in one plus n zero, it should equal p p columns in the matrix a and one plus n zero equals P.

95
00:13:21,040 --> 00:13:27,820
So I guess when I guess the first example I'm computing kind of this esp, I directly like using a loop.

96
00:13:29,260 --> 00:13:37,270
I guess another example where you can you can it's a little bit easier if you use the the var function from RCP,

97
00:13:37,750 --> 00:13:50,380
but if you're just doing everything directly, I think it's helpful to notice that you can compute this kind of residuals some squares I just this

98
00:13:50,830 --> 00:13:57,160
this is equivalent it's just kind of the squared some of the AJ minus the square of the sample.

99
00:13:58,030 --> 00:14:08,170
Okay. Since that will be useful when we're later on in the function when you see where we compute the gold standard deviation.

100
00:14:08,980 --> 00:14:12,430
And so the. So that's how do you compute the Z values.

101
00:14:12,430 --> 00:14:18,579
So we're going to compute a Z value for each row. The other thing that we're going to compute is a P value for each row.

102
00:14:18,580 --> 00:14:23,410
So in this setup, the P value is the two sided p value.

103
00:14:25,210 --> 00:14:38,830
It's basically just this formula. So it's it's just two times F of DF at function with kind of this is the input into the SDF function.

104
00:14:38,830 --> 00:14:49,270
So the SDF function is just the, it's just the CDF cumulative distribution function of the T distribution with the F degrees of freedom.

105
00:14:50,600 --> 00:14:54,700
So this is just some function and this is kind of the input that you put into it.

106
00:14:54,700 --> 00:15:05,620
So this is this will give you the P values and one is the number of columns from the true value, the number of columns from the false group.

107
00:15:05,620 --> 00:15:11,980
And then we don't have to write this functions. This can be computed using this.

108
00:15:12,520 --> 00:15:18,879
One of the thing that's made available by RCP, right, it's from under this R double column namespace.

109
00:15:18,880 --> 00:15:25,330
So if you just use the P t function so that computes the CDF of a T distribution.

110
00:15:27,100 --> 00:15:36,000
Okay. Slightly bigger city.

111
00:15:39,160 --> 00:15:48,250
Okay. So this is kind of the first bites to kind of to long to put in on one slide.

112
00:15:49,060 --> 00:15:53,920
But this is kind of the function definition and kind of defining the variables that we need.

113
00:15:54,760 --> 00:15:57,760
Okay. So the way we do this, we want to return a list.

114
00:15:58,450 --> 00:16:07,960
It's going to be a list of numeric vectors. So we're going to have one vector that has the Z values and one factor that has the P value.

115
00:16:08,090 --> 00:16:11,680
That's what it's going to return. Okay.

116
00:16:12,370 --> 00:16:18,280
So the input is a numeric matrix, A and then, as we said before, a logical vector.

117
00:16:18,520 --> 00:16:24,550
It's the group which tells you if it's in the treatment group or the control group.

118
00:16:24,760 --> 00:16:31,930
And then I guess in these first four lines in the function, we're just kind of declaring variables that we're going to need later on.

119
00:16:31,960 --> 00:16:37,540
So the first thing I think we're going to need at some point is basically the number of rows of a.

120
00:16:38,380 --> 00:16:47,200
So that's the end. So remember, you can kind of extract the number of rows of the numeric matrix by using a done in row.

121
00:16:48,120 --> 00:16:54,370
And then I'm declaring to numeric vectors, these are basically the Z values and P values that we're going to compute.

122
00:16:56,800 --> 00:17:02,800
So those are basically numeric vectors with length, with length and and elements.

123
00:17:03,910 --> 00:17:13,330
And then at some point we're going to need these double variables, MUSE zero, B one, etc. like you'll see later on I guess.

124
00:17:13,810 --> 00:17:19,150
Muse zero And you want to be like the sample means from each row.

125
00:17:23,470 --> 00:17:28,480
I guess. Yeah, I guess I'm just counting this.

126
00:17:28,720 --> 00:17:32,230
This is in zero and one like we had in the previous slides.

127
00:17:32,240 --> 00:17:44,140
Basically the number A and zero is the number of cases where group is false and one is the number of kind of elements where a group is equals one.

128
00:17:44,620 --> 00:17:51,099
So you can see that here I'm just in this for a loop is just defining and one and zero so

129
00:17:51,100 --> 00:17:57,580
it's saying kind of looping over all of the columns of EG and then if group J is true,

130
00:17:57,670 --> 00:18:00,910
then that means you increase in one by one.

131
00:18:02,890 --> 00:18:07,840
If group zero. If Group J is false, then you increase n zero by one.

132
00:18:08,590 --> 00:18:11,820
And then you.

133
00:18:13,840 --> 00:18:18,640
I think at some point it's easier to use. Oh, I think this is for the p values or of this.

134
00:18:19,540 --> 00:18:29,380
It's just easier to write it first. I think it's like this quantity, this ratio of zero and one and the square root of it.

135
00:18:29,500 --> 00:18:36,360
I think it's just easier to define it just code certain lines get too long if you kind of.

136
00:18:36,400 --> 00:18:38,200
Q if you keep using this.

137
00:18:39,400 --> 00:18:46,930
So yeah, again, I guess point out here you can use it as security function directly and add a little compute the square root.

138
00:18:47,110 --> 00:18:51,400
Okay. Okay. So that's kind of the set up of the function.

139
00:18:53,560 --> 00:19:01,150
Okay. So here's the basically the remainder of the functions of the second part.

140
00:19:02,200 --> 00:19:06,790
So I guess this loop well, maybe we can look at the bottom to see what we're returning.

141
00:19:06,790 --> 00:19:11,620
So we're basically we declare the vectors Z values in P values in the beginning.

142
00:19:12,010 --> 00:19:21,819
So that's basically what we're returning. It's a list typical to return a named list.

143
00:19:21,820 --> 00:19:26,290
So it's basically the name of the first component, A Z values.

144
00:19:26,710 --> 00:19:31,540
And the name of the second component is P values. So that's space that's all returning.

145
00:19:31,990 --> 00:19:37,120
And then this bigger loop here is basically doing all the all of the calculations that we did this.

146
00:19:37,570 --> 00:19:41,170
Okay. Okay. So let's see.

147
00:19:42,490 --> 00:19:47,200
So we have a loop. There's basically in iterations in the loop.

148
00:19:47,590 --> 00:19:51,729
I guess I could have put one here as the same thing.

149
00:19:51,730 --> 00:20:04,690
So and as the number of rows of a okay so in each row of a word or computing a1z value in one P value, that's basically all we're doing.

150
00:20:05,560 --> 00:20:14,260
So in each iteration of the loop, I, I reset muse zero and you want to zero.

151
00:20:14,920 --> 00:20:25,749
So it's kind of you have to re compute it in every loop and every iteration in the loop since it's, it's kind of a totally different calculation.

152
00:20:25,750 --> 00:20:36,770
So you should reset an equal to zero and then add this loop for when I'm, when I'm doing J when I'm looping over J And that's basically what.

153
00:20:36,830 --> 00:20:42,250
Going over the columns. This is where I'm computing them the means.

154
00:20:42,880 --> 00:20:49,580
Okay so muse zero you want is equal to AJ on it's plus equal.

155
00:20:49,600 --> 00:20:57,040
So it's same thing as I knew I knew one is equal to the new one plus AIG over N1.

156
00:20:57,040 --> 00:21:04,899
So that's the same thing as computing the mean from the group where a group that basically the

157
00:21:04,900 --> 00:21:15,370
treatment group is true and then S1 is basically kind of the sum of squares from the treatment group.

158
00:21:17,440 --> 00:21:27,669
And so if you look back at the formula for the pool's standard deviation,

159
00:21:27,670 --> 00:21:38,260
it's the square root of the remember you said we can rewrite it like the is residual sum of squares is like the the square root of the II,

160
00:21:38,260 --> 00:21:48,069
which is what we're doing here. The square, the AIG minus the NY Times, me one squared and plus the other term.

161
00:21:48,070 --> 00:21:54,160
So this is this is just kind of just using the formula we had before for the for this pool and standard deviation,

162
00:21:54,160 --> 00:21:57,310
you just divide by in one plus zero over two.

163
00:21:57,370 --> 00:22:02,470
So this is the pool standard deviation for that basically for the I throw.

164
00:22:03,100 --> 00:22:07,150
And so once we have that, we can just compute our Z value directly.

165
00:22:07,660 --> 00:22:12,760
It's just the difference in the means divided by the pool standard deviation.

166
00:22:13,870 --> 00:22:21,340
And then so that's the Z values. That's what we get for the IV component of the Z value and then the P value.

167
00:22:21,940 --> 00:22:31,209
Remember it's just two times the the T distribution CDF.

168
00:22:31,210 --> 00:22:34,240
So that's what we can do by P the function.

169
00:22:34,240 --> 00:22:41,680
And then we just plug in minus this G R which was just this ratio, right?

170
00:22:41,680 --> 00:22:50,499
The square root of the ratio here, those g r times the z value, that's the, that's the absolute value of the Z value.

171
00:22:50,500 --> 00:22:54,220
That's the formula for the P value in this case.

172
00:22:54,940 --> 00:23:02,349
So let's see. And then the other terms. Yeah, I guess we have to look at the documentation to remember.

173
00:23:02,350 --> 00:23:06,069
So the first so there's other arguments in the p t function.

174
00:23:06,070 --> 00:23:11,500
So the second argument is the degrees of freedom.

175
00:23:12,220 --> 00:23:16,120
So the degrees of freedom is this the.

176
00:23:18,460 --> 00:23:28,090
So let's go. I think I remember what the last two arguments are so that the third argument is whether or not it should be.

177
00:23:29,140 --> 00:23:34,209
There's an argument called lower tail versus lower tail.

178
00:23:34,210 --> 00:23:42,460
It just means you're comparing the CTF. If this is false, it computes one minus the CTF is the way that works.

179
00:23:43,510 --> 00:23:47,410
That's why we have true here. So we're computing the regular CDF.

180
00:23:47,860 --> 00:23:53,860
And then the last one, I think it's basically log probability is this one is what that means.

181
00:23:53,950 --> 00:23:59,950
Basically if you want to come in, if you wanted to return to log probability or just the probability.

182
00:24:01,270 --> 00:24:08,470
So if this is true, it would return the log probability. If this is false, it just returns the probability, which is what we want.

183
00:24:08,620 --> 00:24:12,880
So that's why that's why those last two arguments are true and then false.

184
00:24:13,660 --> 00:24:17,770
Okay. So that that should yeah.

185
00:24:17,770 --> 00:24:26,349
Once we have this, we should be able to run it. So once you define this, yeah.

186
00:24:26,350 --> 00:24:33,820
Once you define this and you do like it, maybe it's stored in a certain file and you do source copy.

187
00:24:34,410 --> 00:24:37,510
I can basically just run it and are not necessary.

188
00:24:37,600 --> 00:24:42,280
We have. So this is now our code.

189
00:24:42,940 --> 00:24:54,910
I showed up here, so this is our code, but we can basically use our RCP function as if it were just our function.

190
00:24:55,780 --> 00:24:57,249
So here's just an example here.

191
00:24:57,250 --> 00:25:07,090
I just, you know, if you don't know are this is just creating a matrix like a, basically a random matrix with eight rows and ten columns.

192
00:25:07,090 --> 00:25:07,960
That's all it's doing.

193
00:25:08,800 --> 00:25:16,550
And then this groups is just creating a logical vector where the first five elements are true and then the last five elements are false.

194
00:25:16,550 --> 00:25:24,430
So if you think of this matrix as like the first five columns are from the treatment group and in the last five college are from the control.

195
00:25:24,550 --> 00:25:33,100
So this, so this should return a list where the z value should be a vector with eight components.

196
00:25:33,850 --> 00:25:38,829
And also the P values should have a compound. So you can see that here.

197
00:25:38,830 --> 00:25:42,580
This is what we get. This is like the list. The Z values are here.

198
00:25:42,580 --> 00:25:49,150
These are the components for the Z values and these are the components and property values.

199
00:25:50,470 --> 00:25:59,530
So basically, basically at least, at least, at least runs and kind of just gives us what we expect.

200
00:26:01,570 --> 00:26:10,540
All right. Okay. So here is just somewhat of a verification that it works.

201
00:26:15,300 --> 00:26:22,120
So at least it's always a good idea to double check your code, at least if there's a way to double check it.

202
00:26:22,510 --> 00:26:26,020
So here are just comparing it to what you would get if you used the T.

203
00:26:26,020 --> 00:26:40,870
There's a function called T test. So here we have I'm just computing this t the t test values directly in r with

204
00:26:40,870 --> 00:26:46,720
this loop I'm using the t test function so that returns a p value as well.

205
00:26:48,220 --> 00:27:00,820
And then I'm just, I create this matrix in R called compare, which I just look at the P values that you get from them.

206
00:27:01,220 --> 00:27:12,129
We got from our RC p p function that we wrote down. And then in the second column is the P values as computed by the T test, the T test function.

207
00:27:12,130 --> 00:27:18,340
And so you can see it's just kind of kind of verifying that we're getting that the correct answer,

208
00:27:18,340 --> 00:27:22,390
at least for the this kind of small problem where we only have eight rows.

209
00:27:22,870 --> 00:27:26,649
So you can see here, I think we get all of the numbers match up.

210
00:27:26,650 --> 00:27:30,700
So like we did everything correctly.

211
00:27:33,610 --> 00:27:40,360
So that's. Okay.

212
00:27:40,370 --> 00:27:44,920
So I guess the. Yeah. The other thing I wanted to mention, so there's this, uh,

213
00:27:45,350 --> 00:27:56,600
you can write this function maybe a little bit of a shorter version if you use these mean and bar functions, for example, in RCP.

214
00:27:56,960 --> 00:28:01,280
So these functions that you mentioned can work on numeric vectors.

215
00:28:02,630 --> 00:28:07,700
So these will take numeric vectors as input. Okay.

216
00:28:07,710 --> 00:28:22,790
So the other thing I don't know, I mentioned if you want to like extract a certain row or a certain column and have it be treated as a numeric vector,

217
00:28:22,790 --> 00:28:36,320
you can use this, this type of syntax. So if you have a numeric vector, sorry, if you have a numeric matrix a if you do a of um,

218
00:28:36,950 --> 00:28:43,129
basically I comma and then underscore, so if you have this inside parentheses,

219
00:28:43,130 --> 00:28:48,410
you have I comma underscore that basically kind of like returns a numeric vector

220
00:28:48,410 --> 00:28:56,300
that just is basically just the I throw or yeah index the row index high.

221
00:28:56,420 --> 00:29:01,790
So it's basically from the row with index pi is what that extracts.

222
00:29:02,240 --> 00:29:03,590
Okay. So that's sometimes useful.

223
00:29:03,590 --> 00:29:13,660
I think it'll yeah, it'll be useful in this case because can each each iteration of the loop where basically all the using data from the row row.

224
00:29:14,240 --> 00:29:23,420
So it's, it's useful to use this. Okay. So I'm going to write just a shorter version of the function that we had before.

225
00:29:23,420 --> 00:29:30,020
I guess the I think it's easier to change the, the input arguments a little bit.

226
00:29:30,020 --> 00:29:36,739
So I'm just going to in this case, I'm going to have it the input arguments B two matrices.

227
00:29:36,740 --> 00:29:45,440
So basically a one matrix, those are like that's like just the the columns of a that are from the,

228
00:29:45,950 --> 00:29:58,880
the treatment group and then we'll have an A0 matrix which is basically the sub matrix of a, which is just the columns from the control.

229
00:30:00,200 --> 00:30:05,660
So it's, it's just, it's the same exact data. We're just kind of entering it in a slightly different way.

230
00:30:06,370 --> 00:30:10,230
It's simply the function definition here. Okay.

231
00:30:10,280 --> 00:30:13,970
So this is the summary.

232
00:30:17,990 --> 00:30:22,970
Okay. So I think we can write the entire function in basically a single slide.

233
00:30:24,230 --> 00:30:35,240
Okay. So I think so here yet again, we're returning a lists, so it should have list type.

234
00:30:35,930 --> 00:30:42,020
Uh, I guess the only thing that's different about what we're declaring is that we can.

235
00:30:43,070 --> 00:30:50,270
We could, uh, this is the way we're getting in zero and one.

236
00:30:50,270 --> 00:30:57,200
So n zero is the number of columns of a zero, and then in one is the number of columns and tables.

237
00:30:57,220 --> 00:31:07,460
And so I think the way I. Okay, so you do have to be careful about dividing integers, like we said before.

238
00:31:08,240 --> 00:31:23,840
So if you do this division, it'll, it'll round down like if end zero and one are integers it'll it'll kind of round it'll also create an integer.

239
00:31:23,840 --> 00:31:27,440
So that might when we take the square root it'll,

240
00:31:28,040 --> 00:31:34,910
I don't think it will be an integer but since it's doing a rounding it might be slightly different than the correct answer.

241
00:31:35,510 --> 00:31:42,589
Okay. So that's why I want these to be double. So what you can do with it is it's called casting.

242
00:31:42,590 --> 00:31:52,250
You just do this double in parentheses before before an integer and make sure that and and zero is a double typed.

243
00:31:53,630 --> 00:31:59,720
So this is basically in zero is the number of columns, but it's stored as a a double type.

244
00:31:59,840 --> 00:32:05,450
That's the reason for doing this. That's kind of one of the differences between what we had before.

245
00:32:08,150 --> 00:32:12,020
Okay. But other than that, I guess the loop is a little bit shorter.

246
00:32:12,500 --> 00:32:17,959
So this man loop for computing, the Z values and P values is a little bit shorter.

247
00:32:17,960 --> 00:32:24,590
So, you know, look here, we don't have to directly compute the new zero new one in a loop or anything.

248
00:32:26,120 --> 00:32:29,900
We can just do mean of this. And then a new one is the mean of this.

249
00:32:30,440 --> 00:32:34,010
Some new zero is the mean of a zero.

250
00:32:34,370 --> 00:32:38,300
The I0 of a zero. Right. We said before you can use this.

251
00:32:39,140 --> 00:32:48,560
If you use the underscore as the second argument that just kind of extracts the whole entire row and the new one is the mean of the I throw of a one.

252
00:32:49,010 --> 00:32:52,800
Okay. Okay. And then the pool SD.

253
00:32:57,220 --> 00:33:00,840
Uh. You don't have to. Yeah, we didn't really have to use a loop.

254
00:33:00,850 --> 00:33:06,100
You can use the fact that you can write the pool as t as if you just in the zero

255
00:33:06,160 --> 00:33:13,420
minus one times the variance of a zero plus two and one minus one times the variance

256
00:33:13,420 --> 00:33:20,260
at a one and then divide the entire thing by in one plus n zero minus two and then

257
00:33:20,260 --> 00:33:24,260
take the square root that's the same that features that if you write it honest,

258
00:33:24,360 --> 00:33:28,450
it kind of works out to the same formula that we wrote out before.

259
00:33:29,230 --> 00:33:37,710
So in that case, it's kind of convenient if we just use that, if we just use the variance function justifying into the high for a eight.

260
00:33:38,920 --> 00:33:46,629
And then here we're just using I guess the same, the same code as we had before for, for defining the Z values and key values.

261
00:33:46,630 --> 00:33:53,980
So this is just a shorter version. They can compute the exact basically the exact same thing as the other one,

262
00:33:53,980 --> 00:33:59,440
which is doing any more kind of a more compact way to write the same thing.

263
00:34:01,240 --> 00:34:12,580
Okay. Um, I guess it's not really necessary, but it's just verifying that it does give you the same, the same results.

264
00:34:12,580 --> 00:34:24,840
This is the p values using our original version of the T test function and then using the shorter version that gives you the exact same answer.

265
00:34:24,850 --> 00:34:29,770
So that's really the only purpose of that slide. Okay.

266
00:34:38,010 --> 00:34:41,790
Yeah. So that's hard to do with one other example.

267
00:34:41,790 --> 00:34:47,550
Well, I guess we have two major main examples left, but I wanted to do one example.

268
00:34:49,350 --> 00:35:01,110
I think this uses some of the RCP functions and I think it's just a realistic example at least of the types of things where

269
00:35:01,110 --> 00:35:11,910
you might want to use RCP over regular R since this type of simulation kind of requires that you use some type of looping.

270
00:35:13,380 --> 00:35:22,380
So this is an example of like, you know, a R or what's called an R one modeling or it's actually like a bivariate air one.

271
00:35:22,930 --> 00:35:31,600
Sometimes it's an example of a like a vector auto regression model in time series or at least vector with a link to it.

272
00:35:32,070 --> 00:35:35,760
So basically the model works like the following.

273
00:35:35,760 --> 00:35:49,890
There's, I mean basically the outcomes like the data that you observe in practice X, t, y, t and you would observed both X and y, t over time.

274
00:35:50,490 --> 00:35:54,720
And here's an example where we're going to, we're going to simulate that kind of fake, fake data.

275
00:35:56,400 --> 00:36:01,560
So we're, you know, the main interest is X and Y, T, okay?

276
00:36:02,040 --> 00:36:08,129
So X and y, t have this form X, it's basically just, you know, x,

277
00:36:08,130 --> 00:36:19,380
t is basically just a linear combination of x, t minus one and y, t minus one plus some kind of residual noise.

278
00:36:19,800 --> 00:36:23,640
Okay, so that's epsilon t zero.

279
00:36:24,540 --> 00:36:36,240
And then why T is kind of the same thing. It's a linear combination of X, T minus one and y, t minus one plus some, some other noise, epsilon, t one.

280
00:36:36,690 --> 00:36:47,400
Okay. And then these epsilon ts are just independent, normal random variables, which means zero and the standard deviation sigma zero signal one.

281
00:36:47,970 --> 00:37:01,070
So like the main kind of parameters of your simulation are these terms you 0a00011a10811.

282
00:37:01,170 --> 00:37:09,239
So those are kind of the main parameters of the simulation and I guess also the standard deviation sigma, sigma, zero sigma.

283
00:37:09,240 --> 00:37:15,210
What they're also kind of other important simulation simulation parameters.

284
00:37:16,140 --> 00:37:23,520
You would think of any kind of values you have to choose kind of to determine what the simulation looks like.

285
00:37:23,520 --> 00:37:30,329
So I guess there's four I'm sorry, I guess there's eight, eight numbers.

286
00:37:30,330 --> 00:37:34,210
You have to you have to choose when you're running the simulation. Okay.

287
00:37:34,710 --> 00:37:41,100
So like I said before, I think there is like an R package that that does this.

288
00:37:41,100 --> 00:37:49,319
But if you were to write it yourself, this is kind of dif difficult to simulate this directly in r without using a

289
00:37:49,320 --> 00:37:56,340
loop just because every value max t month y t depends on the previous value.

290
00:37:56,340 --> 00:38:01,540
So you kind of have to. Do it kind of one step at a time.

291
00:38:02,230 --> 00:38:12,040
You have to generate negative y, t minus one in the next step from using that generate x, t and then y team.

292
00:38:12,760 --> 00:38:21,630
Okay. Okay. So just basically just kind of write a function that simulates this type of thing in RCP.

293
00:38:22,770 --> 00:38:34,010
So the way we, I guess one of the things that we're going to use in RCP is the arm function kind of underneath the the R double colon namespace.

294
00:38:34,590 --> 00:38:40,300
So that that's basically just going to generate the epsilon. Okay.

295
00:38:44,610 --> 00:38:52,530
Yeah. This was just a little yeah, this is a list of a lot of the functions that are available under the R double colon namespace.

296
00:38:53,880 --> 00:38:59,870
It has like the documentation, I think, or at least it has to figure something at this one.

297
00:39:01,020 --> 00:39:12,650
Just click it. I think it has some. Well, maybe if you search around, you can find better documentation.

298
00:39:12,670 --> 00:39:19,570
Actually, this this particular link doesn't have that much, but I guess what we're interested in is our norm.

299
00:39:20,230 --> 00:39:24,520
So it's double. It has two arguments. There's double mute.

300
00:39:24,520 --> 00:39:29,440
It's basically a mean of a normal random variable and then double sigma.

301
00:39:29,950 --> 00:39:36,010
So it takes two double arguments. The first is just the mean of the normal and the second arguments, the standard deviation.

302
00:39:36,610 --> 00:39:42,730
So that's basically what we're interested in for this simulation is the approach, is this the standard deviation?

303
00:39:43,690 --> 00:39:47,260
So it's like Sigma zero versus Sigma one.

304
00:39:49,390 --> 00:39:53,290
Okay, so we're going to use that somewhere in the simulation,

305
00:39:53,770 --> 00:40:02,050
our norm where basically the first argument's going to be zero and the second arguments going to have either sigma zero or single one.

306
00:40:02,860 --> 00:40:12,670
Okay. So the inputs for this function are basically going to be, oh, did I put the sigma zero sigma not in Sigma one.

307
00:40:13,870 --> 00:40:18,100
Oh yeah, I forgot to, I forgot to mention that that's also an input.

308
00:40:18,460 --> 00:40:24,760
So our input arguments for this function is going to be I use zero you one so

309
00:40:24,760 --> 00:40:29,710
I'll put I just assume that's an input argument as just a single numeric vector.

310
00:40:30,400 --> 00:40:36,130
And then these values here a0001810811.

311
00:40:36,700 --> 00:40:41,650
Those will also be put in as a well actually numeric matrix having a two by two matrix.

312
00:40:42,250 --> 00:40:51,820
And I think we're also going to put in forgot to mention that sigma that will also be a vector with two arguments that sigma zero and sigma one.

313
00:40:53,230 --> 00:40:58,420
So that'll be those will be the main arguments of the function.

314
00:40:58,900 --> 00:41:03,520
And then what we're going to return is a list. It's just going to have two numeric vectors.

315
00:41:04,510 --> 00:41:11,050
There's just going to be one vector for the x, the x values, and then another vector for the Y values.

316
00:41:11,380 --> 00:41:18,940
Okay. So that's basically the setup. This is kind of what it looks like, oh, this does the entire thing.

317
00:41:19,690 --> 00:41:27,100
So it's actually it actually doesn't yeah, it doesn't have to be a super aligned function or anything.

318
00:41:27,700 --> 00:41:33,090
So the name of the function is simulated v r return type is a list.

319
00:41:33,100 --> 00:41:43,450
So include list here. So the first argument is and that's basically the the length of yeah,

320
00:41:43,450 --> 00:41:49,300
that's the length of X and the length of why source simulating in x values and by values.

321
00:41:50,290 --> 00:41:59,830
The second argument is a you like we said before in a two by two matrix and that we're also having a numeric vector for sigma.

322
00:42:01,820 --> 00:42:10,320
So the stigma is linked to, okay, so the way this works is we just initialize numeric vectors, X and Y.

323
00:42:11,250 --> 00:42:20,340
So that just creates two numeric vectors, X and Y. I think the initial values are right of all the elements are going to be zero and I say the first.

324
00:42:22,570 --> 00:42:28,950
Yeah. So that the description we had before didn't tell you how to do the first x zero and x one.

325
00:42:29,910 --> 00:42:40,469
And I mentioned, I mean it's kind of arbitrary. So whatever I kind of choose, yeah, it doesn't really matter that much.

326
00:42:40,470 --> 00:42:43,660
I don't think what the initial value of X and Y are.

327
00:42:44,490 --> 00:42:54,300
So we'll just choose them to be both equal to one. And then we're just going to do a loop and fill in all the values of X and Y.

328
00:42:54,960 --> 00:43:01,440
So I think I'm starting from, if you'll notice in the loop here, the first value of II is equal to one.

329
00:43:01,920 --> 00:43:04,829
So I'm starting from a lot of times you often start from zero,

330
00:43:04,830 --> 00:43:12,809
but I'm starting from on here just because we've already we've already filled in the values of zero on y zero.

331
00:43:12,810 --> 00:43:20,100
So I'm going to way I wrote it as we're starting from one and exile as equal to this stuff times EXI

332
00:43:20,100 --> 00:43:27,270
minus one so this already has like in the first iteration you're multiplying by x zero and y is zero,

333
00:43:27,960 --> 00:43:37,950
right? So here we're just using the formula that we had for just the air simulation, just using the formula.

334
00:43:37,950 --> 00:43:42,660
We're excited as a linear combination and exi minus one and y minus one.

335
00:43:43,050 --> 00:43:48,060
And then we're just adding the noise term. This is like epsilon zero.

336
00:43:48,810 --> 00:43:51,900
We're using this after we use our double colon, our normal.

337
00:43:52,440 --> 00:43:58,139
And again, if we do the first argument zero and then the second argument sigma zero,

338
00:43:58,140 --> 00:44:05,160
that just means it's generating a normal random variable, which means zero and standard deviation sigma zero here.

339
00:44:06,480 --> 00:44:16,950
So we just do it in the formula that once we run this loop, it fills in kind of all of the entries of X and Y basically.

340
00:44:17,910 --> 00:44:33,810
So let's say this should yeah, basically return a list with the X factor in the Y vector as the, as the components of the list.

341
00:44:34,380 --> 00:44:44,280
Okay. So let's just do an example. So once you define that as kind of an RCP function, you can use it within R as A as if it were an R function.

342
00:44:44,280 --> 00:44:50,939
So all of this code here is our code. So we're just going to do an example.

343
00:44:50,940 --> 00:44:54,460
We're just going to simulate ten time points.

344
00:44:54,990 --> 00:45:03,600
So with these kind of simulation parameters, so these this value for you, this value for a and then these values for Sigma.

345
00:45:05,580 --> 00:45:14,100
So you can see that here. When you do this in R, you would create a two by two matrix A and then just a length to vector.

346
00:45:14,100 --> 00:45:17,610
You add a link to vector for sigma sake.

347
00:45:18,120 --> 00:45:21,690
So those are the inputs of the simulate var function.

348
00:45:23,760 --> 00:45:32,670
Okay. So the output of this function like simple values is basically a little bit more, it's basically a list.

349
00:45:34,920 --> 00:45:42,000
So send out vowels is a list. Two components of the list are named X and Y.

350
00:45:42,420 --> 00:45:49,020
So both X and Y should have ten components.

351
00:45:49,320 --> 00:45:55,020
Okay, so these are like ten. So these are just the values of X and then these are the values.

352
00:45:55,400 --> 00:46:04,590
So you can see the first element of X is one and then the first element of Y is one, but the rest are kind of some random.

353
00:46:04,590 --> 00:46:11,010
This which determines the specific values for either the remaining components.

354
00:46:16,700 --> 00:46:24,470
So this is what it looks like forever. Ten, ten with ten elements for both X and Y.

355
00:46:26,690 --> 00:46:36,350
And here is just maybe more a more realistic example of something you might want to do in practice is a simulation with with 200 time points.

356
00:46:36,370 --> 00:46:39,979
I just if you look at this exact example,

357
00:46:39,980 --> 00:46:47,630
I guess the key thing here is that we're running simulate VR where N is equal to 200 numbers and is equal to 200.

358
00:46:48,080 --> 00:46:54,470
And we use that just the same the same simulation, design and parameters as on the previous slide.

359
00:46:55,280 --> 00:46:59,089
I guess the rest of this, we don't really have to know for this class,

360
00:46:59,090 --> 00:47:03,890
this is just plotting this is just plotting the values of X and Y so we can see

361
00:47:04,550 --> 00:47:08,900
this is kind of what it looks like if you actually kind of run this in practice.

362
00:47:08,900 --> 00:47:13,820
This if you plot X and y axis in black, y is in red.

363
00:47:14,120 --> 00:47:18,230
And it's unusual. It looks kind of something like this.

364
00:47:21,240 --> 00:47:24,350
Okay. So that's another example.

365
00:47:24,360 --> 00:47:27,420
Okay. So. Something.

366
00:47:27,530 --> 00:47:40,129
That's you. Yeah, it's another I think I want to talk about one more main example or kind of a slightly longer example in RCP.

367
00:47:40,130 --> 00:47:45,200
That's where it's kind of a slightly more complicated application.

368
00:47:45,200 --> 00:47:48,320
So if you're doing something a little bit more complicated,

369
00:47:49,010 --> 00:48:00,590
it's useful to kind of write multiple RCP functions where one's RCP function calls another RCP function.

370
00:48:01,160 --> 00:48:11,149
So I guess the examples we had been using before up to now as we just wrote down one RCP function and

371
00:48:11,150 --> 00:48:17,780
then call that function from R in many cases at least if you're doing something more complicated,

372
00:48:17,780 --> 00:48:23,629
you want to have multiple, you're going to have kind of like one main RCP function that you call from.

373
00:48:23,630 --> 00:48:29,750
R, but that main RCP function calls other RCP functions.

374
00:48:31,400 --> 00:48:35,360
Yeah, it's useful if you have a kind of a more complicated program or you want to

375
00:48:35,360 --> 00:48:45,170
split kind of the computations involved in the function into different pieces.

376
00:48:45,680 --> 00:48:50,630
That's really kind of I mean, one of the main benefits of writing out separate functions.

377
00:48:54,360 --> 00:49:00,930
So here's an example. Here's a smaller example before we get to kind of a longer example of how you can basically do it.

378
00:49:02,100 --> 00:49:10,860
So this is an example or I have, I guess the main function that I would want to use in R might be called simulate normals.

379
00:49:11,340 --> 00:49:16,560
But this function calls another RCP function. So this is basically how you would write it.

380
00:49:17,040 --> 00:49:28,350
And RCP this way kind of like maybe the main function I exports are is called simulate normals.

381
00:49:32,550 --> 00:49:36,540
And but inside of the function, simulate normals.

382
00:49:36,540 --> 00:49:39,959
You have this function call that I mean, you don't really need it.

383
00:49:39,960 --> 00:49:44,310
In this case, it was just an example of how to do it. Had to just add two numbers.

384
00:49:46,140 --> 00:49:53,160
So basically the simulation just adds X and Y here, but I just written it as a separate function.

385
00:49:54,390 --> 00:49:57,210
It takes two double arguments and returns it as a double.

386
00:49:57,960 --> 00:50:03,060
So if you do this, this, this is the way you write it out, and this should work perfectly fine.

387
00:50:03,640 --> 00:50:14,810
If you source this when you run an R, you could just use simulate normals directly as as if it were in our function.

388
00:50:14,820 --> 00:50:24,180
So this is how you can kind of use multiple RCP functions where one is calling the other RCP function.

389
00:50:25,130 --> 00:50:30,140
Okay. This is an example of this showing how to run it.

390
00:50:30,150 --> 00:50:34,080
So this is showing that it runs in honor.

391
00:50:34,100 --> 00:50:39,270
So this is basically how what it might look like if you run it inside of R.

392
00:50:40,260 --> 00:50:53,370
Okay. So here's in a longer example where I just thought it was slightly more realistic example where you have a case where you kind

393
00:50:53,370 --> 00:51:02,100
of want to break up a computation into separate functions just because it kind of gets a little bit kind of the main function.

394
00:51:02,730 --> 00:51:08,100
Like it's a little bit long if you're if you're not separating things out into separate functions.

395
00:51:09,240 --> 00:51:15,010
So here's an example of kind of coding a it's called a metropolis hosting algorithm.

396
00:51:15,390 --> 00:51:20,970
And this is a Metropolis Hastie algorithm for Bayesian logistic regression.

397
00:51:21,450 --> 00:51:25,320
Okay. So for this example,

398
00:51:25,800 --> 00:51:33,030
it helps to be able to use multiple RCP functions just because I guess that's it's often called

399
00:51:33,420 --> 00:51:40,890
modularized and your code is just kind of separating a lot of the computations into separate pieces.

400
00:51:41,280 --> 00:51:48,090
And just in many cases it just makes your program kind of your main program, easier to read or write and debug.

401
00:51:48,870 --> 00:51:58,830
So as an example of this, we're going to do a Metropolis Hastings algorithm for posterior sampling from a a Bayesian logistic regression model.

402
00:52:01,210 --> 00:52:16,320
Okay. So kind of, I guess one of the main parts of the Metropolis Hastings algorithm is computing what it's called the Metropolis Hastings ratio.

403
00:52:19,730 --> 00:52:24,680
So I'll call that the inmate ratio. So that's basically a ratio that depends.

404
00:52:25,160 --> 00:52:34,040
At least if we're doing a kind of a regression application, that's basically a ratio that depends on two factor of regression coefficient.

405
00:52:34,040 --> 00:52:41,660
So often it's called like the current value of your regression coefficients, which we call beta.

406
00:52:42,230 --> 00:52:48,830
And then there's like a proposal that you want to look at. So there's a proposal beta, we'll call it the our beta subsequent.

407
00:52:48,830 --> 00:52:59,930
P So the Metropolis, Haitian, Haitian Metropolis Hastings ratio really is, um, it's,

408
00:53:00,100 --> 00:53:04,340
it's kind of comparing to values of data that's really is really what it's doing.

409
00:53:04,800 --> 00:53:07,040
Okay. So that's the kind of computing,

410
00:53:07,040 --> 00:53:13,700
this image ratio is one of the kind of the main things that you're doing when you're running a Metropolis Hastings out.

411
00:53:14,720 --> 00:53:20,450
Okay. Okay. So, I mean, let's see.

412
00:53:22,440 --> 00:53:27,809
Yeah. We don't have to go to the full derivation for why this is the appropriate ratio,

413
00:53:27,810 --> 00:53:32,340
but I just wrote down the formulas for the ratio for a kind of a Bayesian.

414
00:53:33,660 --> 00:53:44,370
Have a Bayesian logistic regression at least where we have like a normally distributed prior so that it turns out that the image ratio,

415
00:53:44,400 --> 00:53:56,970
I'm just calling it our image as this form, it's, it's e res to the power of r one plus two, so r one and r to have this formula are these formulas.

416
00:53:58,140 --> 00:54:13,060
So basically the data that you have in a Bayesian logistic regression is a vector Y, so a vector of length in which the elements are Y.

417
00:54:13,080 --> 00:54:21,240
And then we're going to have a design matrix which is in by P and like the I throw the design matrix is this is XY transpose

418
00:54:21,330 --> 00:54:30,870
that's like the I throw supposed to represent the I throw in the design matrix x and then this is the these are the form.

419
00:54:30,990 --> 00:54:34,320
This is actually the maybe I should clarify, this is the natural log.

420
00:54:35,040 --> 00:54:44,760
So the natural logarithm. So we're going to we can use the log function in the X Peter functions directly in our C P.

421
00:54:45,870 --> 00:54:52,320
So this is the image ratio that we really need to compute if we're going to run an image out in each algorithm.

422
00:54:55,530 --> 00:55:02,249
So this is just an overview of the image algorithm for Bayesian logistic regression.

423
00:55:02,250 --> 00:55:10,860
So the way it works is that you well you basically just choose some starting value for your, your vector of regression coefficients.

424
00:55:11,490 --> 00:55:17,370
Okay. So it's beta zero g base probably doesn't make a big difference on the final result.

425
00:55:17,840 --> 00:55:27,330
You basically choose that whatever you want. So once you have that, the way this works is that you're going to basically have a big loop each time,

426
00:55:27,380 --> 00:55:32,820
each iteration of the loop, you're going to basically do these steps, these kind of subtopic points.

427
00:55:33,390 --> 00:55:37,380
So the first thing you do is you sample a proposal vector.

428
00:55:38,220 --> 00:55:50,490
So it's called beta P. The way we're doing that is we're basically sampling, we're basically saying beta P is equal to beta plus epsilon.

429
00:55:50,490 --> 00:55:55,170
It's kind of the way it works of beta is like that, the current value of beta as we were saying.

430
00:55:56,430 --> 00:56:02,820
So that's how we're sampling our proposal of using this proposal and the current value of beta,

431
00:56:03,660 --> 00:56:12,780
you compute the image ratio based on those two things and then you draw you from a uniform, random number, uniform distributions.

432
00:56:12,780 --> 00:56:19,140
All right. And then if you is equal, is lesser than or equal to the Metropolis Hastings ratio that we computed,

433
00:56:19,710 --> 00:56:22,950
you set the new value of beta equal to the proposal.

434
00:56:23,820 --> 00:56:31,050
Otherwise you just set it to the next value theta to the previous value of a beta.

435
00:56:31,710 --> 00:56:37,500
Okay. So that's just the way it works. Yeah, that's basically the way it works.

436
00:56:37,500 --> 00:56:41,040
You just these are all the steps inside of each iteration.

437
00:56:41,040 --> 00:56:45,690
Okay, so you just do this a bunch of times, so you're just going to get a bunch of betas.

438
00:56:46,230 --> 00:56:49,740
And that's the way you can think of this.

439
00:56:50,250 --> 00:56:54,149
You're getting a kind of a bunch of betas the way and applications.

440
00:56:54,150 --> 00:57:04,260
And when you think of this, this is basically pretty close to like a sample from the posterior distribution in this model,

441
00:57:04,950 --> 00:57:09,570
a posterior distribution for the for the the beta vector.

442
00:57:11,340 --> 00:57:13,980
Okay. It's the way the basic outline.

443
00:57:13,990 --> 00:57:23,100
So the way we're going to do this in our speech, we're going to basically have one kind of main function which does this image sampling.

444
00:57:23,100 --> 00:57:32,190
So basically it's basically kind of doing the steps and it's basically just inside the functions.

445
00:57:32,200 --> 00:57:37,950
It's basically going to have a loop that's kind of implementing this, these overall broad steps.

446
00:57:39,930 --> 00:57:47,850
And then we're also going to have a function, another separate function called image ratio, which only computes to image ratio.

447
00:57:47,850 --> 00:57:54,270
So it's a little bit kind of it'll make this image sampling function a little bit easier to read,

448
00:57:54,270 --> 00:58:00,899
a little bit more compact if we can kind of separate out the calculation of the image ratio to another function,

449
00:58:00,900 --> 00:58:10,200
we don't have to do the full inmate's ratio calculation every know within the main image sampling function.

450
00:58:10,770 --> 00:58:20,400
So the function image ratio is going to be called from the image sampling function kind of every time this ratio needs to be computed.

451
00:58:21,260 --> 00:58:26,120
We're also going to pass by reference at least the design matrix and the vector of outcomes.

452
00:58:26,120 --> 00:58:35,660
So I think you can basically you can pass by reference in asking people, you know, the same way that you do and C++, I think.

453
00:58:36,190 --> 00:58:46,640
I think we had an example of that before, but I'll show. I'll show it now that you could do it in our sleep as well.

454
00:58:46,660 --> 00:58:54,130
You could pass things by reference, and the way you do it is basically the same syntax as for for C++.

455
00:58:56,050 --> 00:59:03,700
Okay. Okay. So I guess the thing these are the things that I wanted to point out are just two things to notice in this example.

456
00:59:06,980 --> 00:59:09,490
Oh, sorry. I meant to say by reference here.

457
00:59:10,210 --> 00:59:20,200
So when we pass X and Y by reference, I think in this case it's a little bit of more efficient just because y an x scope,

458
00:59:20,260 --> 00:59:23,500
potentially pretty large objects depending on the data size.

459
00:59:24,220 --> 00:59:27,760
Also, I think it makes sense to pass a lot of things by reference.

460
00:59:28,210 --> 00:59:38,890
If you're just kind of using them in the function, you're not they don't really you're not really changing them in any way because sometimes you

461
00:59:38,890 --> 00:59:46,180
have to be careful if you if you need to change things when you're passing by a reference.

462
00:59:46,180 --> 00:59:50,139
But if you're just there, they're just used in the calculation.

463
00:59:50,140 --> 00:59:53,620
You don't change the values of X and Y in any way.

464
00:59:54,010 --> 00:59:58,030
I think it kind of makes sense to pass them by reference because you're just

465
00:59:58,090 --> 01:00:02,320
you're not you're not altering the values stored inside of X and Y anyway.

466
01:00:04,030 --> 01:00:06,309
And then the other thing to note, I think we mentioned before,

467
01:00:06,310 --> 01:00:12,190
just if you need to compute the natural logarithm and the exponential function, you can just use that.

468
01:00:12,250 --> 01:00:17,140
Do those directly in our CPT just using log and the xp.

469
01:00:17,350 --> 01:00:24,040
Okay. So that it can do things to or some of the things to note in this example.

470
01:00:24,670 --> 01:00:29,600
So here's a function that computes the. Yeah.

471
01:00:29,650 --> 01:00:36,520
Here's the function that computes the image ratio, basically. So we're going to call this function from the main function later on.

472
01:00:38,830 --> 01:00:48,400
So basically the arguments of the image ratio are a numeric vector data or a proposal data and a numerical data.

473
01:00:49,210 --> 01:00:54,550
And then we're going to pass by reference to the desired X, that's a numeric matrix.

474
01:00:54,550 --> 01:01:00,850
And then after outcomes Y and then we also have a sigma squared that shows up in image

475
01:01:00,850 --> 01:01:06,880
ratio and then and in P and is like the number of rows of X and P is the number of columns.

476
01:01:07,780 --> 01:01:11,559
And then you could also do this constant, remember, and you don't have to,

477
01:01:11,560 --> 01:01:16,690
but sometimes, you know, it's often recommended as good price, good practice.

478
01:01:17,220 --> 01:01:22,540
You add in cards if you're passing something by reference and you definitely

479
01:01:22,540 --> 01:01:27,580
don't want any of the values of that to be changed inside of the function.

480
01:01:28,120 --> 01:01:40,060
You just put this cost here so I can make sure that if anywhere inside of the function kind of x tries to be changed in any way at all,

481
01:01:40,510 --> 01:01:51,160
it'll it'll cause some type of error. So we don't want to, we don't want to change X or y, x and y should be thought of as fixed of.

482
01:01:53,260 --> 01:01:57,850
So now inside the function, let's see.

483
01:01:58,840 --> 01:02:06,190
I mean, it's just basically implementing. You could probably implement this actually in a shorter way a little bit if you're using

484
01:02:06,670 --> 01:02:11,979
some of the main functions and so forth like we talked about in the T test example here,

485
01:02:11,980 --> 01:02:22,210
I'm just calculating everything directly. If there's a lot to say about this, I think we're basically just using the the formula that we had before.

486
01:02:24,720 --> 01:02:34,270
You know, the formula that we had on the original slide is basically just a bunch of summations.

487
01:02:34,810 --> 01:02:39,400
I guess this maybe this, this term, this, this in our loop because remember,

488
01:02:39,400 --> 01:02:43,809
we had there was a term like there is like xy transpose beta that you have to compute.

489
01:02:43,810 --> 01:02:53,110
So this kind of inner loop is computing that this is like computing xy transpose data for for that for that I.

490
01:02:56,170 --> 01:03:00,170
But otherwise it's just a summation.

491
01:03:00,170 --> 01:03:08,629
So the way and the way I do it, I think it's a little bit it's a little bit more numerically stable if you compute

492
01:03:08,630 --> 01:03:16,190
the the log of the inmates ratio because that's determined by sums of the products.

493
01:03:16,190 --> 01:03:21,200
So here in this case, I'm just returning the log ratio.

494
01:03:27,170 --> 01:03:31,940
Yeah. So there's basically this like the are one in our team for sure.

495
01:03:32,960 --> 01:03:41,930
Well actually it's like ah one in ah two is what I'm actually computing there as the log ratio and.

496
01:03:42,620 --> 01:03:49,440
Yeah. Okay. And then I'm returning to exponential.

497
01:03:49,560 --> 01:03:55,870
That's the actual ratio, that's the exponential function is be XP directly.

498
01:03:57,550 --> 01:04:01,750
So that's basically the function of the page ratio.

499
01:04:02,320 --> 01:04:08,410
And this is the main function that should be called mean.

500
01:04:08,410 --> 01:04:11,610
It's not like it's not like man made C++ 12.

501
01:04:11,650 --> 01:04:15,760
It's kind of like that's the main function that you're going to call from.

502
01:04:15,770 --> 01:04:20,740
R. So this does the, the kind of the actual image algorithm.

503
01:04:22,390 --> 01:04:27,920
So the name of the functions, image sampling, it takes a vector beta.

504
01:04:27,940 --> 01:04:39,340
So I think that's just going to be the initial value of and give it a numeric matrix X and a numeric vector Y which are just the that's like the data.

505
01:04:40,300 --> 01:04:45,850
And then there's going to be an integer that I'm draws. That's basically how many betas you want to simulate.

506
01:04:46,720 --> 01:04:54,670
And then a double sigma squared, which is related to the prior of the regression coefficients and then a double lambda,

507
01:04:54,670 --> 01:05:01,630
which is basically related to how you sample the proposals, the proposal betas.

508
01:05:02,040 --> 01:05:05,590
That's that's what Lambda is used for.

509
01:05:06,430 --> 01:05:11,470
Okay. So let's see here.

510
01:05:12,970 --> 01:05:19,150
So I guess I'm not going to go through all the details, but I guess the thing I'll point out.

511
01:05:20,140 --> 01:05:25,670
So the numeric matrix beta draws. That's what that's what the function is going to return.

512
01:05:25,690 --> 01:05:37,030
You're basically going to return a matrix. The number of let's see, the number of rows is basically how many betas you're going to simulate.

513
01:05:39,370 --> 01:05:48,110
So it's none draws plus one since we're going to cheat the first beta and then each row of beta draws is going to have to the,

514
01:05:48,910 --> 01:05:52,540
the, the vector of regression coefficients. So that has p components.

515
01:05:53,080 --> 01:06:01,390
So that's why we have P columns. Okay. So each row of beta draws is a a separate draw of the beta vector.

516
01:06:04,690 --> 01:06:07,710
And then we initialize it for the first row.

517
01:06:08,760 --> 01:06:12,239
Beta draws, we initialize it here, we just give it the, the components.

518
01:06:12,240 --> 01:06:15,440
That's the input and the input bonus.

519
01:06:15,440 --> 01:06:19,860
So the first input part is just that and the initial value of beta.

520
01:06:20,700 --> 01:06:31,440
And then I guess if we walk through the function, so K is that like the index for the number of betas we're going to simulate?

521
01:06:32,130 --> 01:06:42,870
So that just goes from zero to number draws. And the first thing you do in an MH algorithm is you do this proposed beta, right?

522
01:06:42,870 --> 01:06:47,040
So we generate a proposed beta for the P components of beta.

523
01:06:47,490 --> 01:06:55,379
So remember, we can use proposals based on simulating kind of a normal random variables.

524
01:06:55,380 --> 01:07:02,490
So remember you can use the RR function under the R double colon namespace so that we're

525
01:07:02,490 --> 01:07:08,910
generating the proposal beta and we compute the image ratio using the beta proposed in the beta.

526
01:07:09,660 --> 01:07:20,129
Okay. So we're just calling the function that we wrote on the previous slide image ratio function that gives us our image ratio.

527
01:07:20,130 --> 01:07:28,440
And then the next thing we do after that is generate our uniformly random, randomly distributed number.

528
01:07:28,980 --> 01:07:34,920
So that's you. So we can use the our unit function under the R double code name space.

529
01:07:34,920 --> 01:07:40,980
And then so let's see.

530
01:07:41,370 --> 01:07:44,650
So if it's less than that, platelets.

531
01:07:47,860 --> 01:07:58,830
I missed the second part. So if you're, if it's less than this, then kind of the next beta.

532
01:07:58,920 --> 01:08:02,010
Oh, I see. I see the way I do it. So that.

533
01:08:02,820 --> 01:08:10,830
Yeah. If it's less than this that becomes that new and that's stored in beta kind of the way I did it.

534
01:08:11,160 --> 01:08:16,560
Beta here represents kind of a new beta in in this current iteration.

535
01:08:17,400 --> 01:08:21,750
So this beta proposed becomes the new one. Otherwise, it's just the previous value.

536
01:08:22,860 --> 01:08:26,550
So beta doesn't change basically.

537
01:08:27,690 --> 01:08:40,589
And then you store that inside of the beta to take plus one row of the beta drops and you store that value per here plus

538
01:08:40,590 --> 01:08:53,820
one row of beta draws is kind of storing the values of beta and that are generating kind of a tail iteration of this loop.

539
01:08:54,210 --> 01:09:03,900
Okay. So this should return a. I think I cut off the bottom part of this function, but I think I think I missed.

540
01:09:04,560 --> 01:09:08,070
There's like one line. It's just returning the matrix. Okay.

541
01:09:08,430 --> 01:09:13,410
It's returning the beta draws matrix. Okay.

542
01:09:14,070 --> 01:09:17,820
So I thought I'd just try this on a kind of a real example.

543
01:09:18,330 --> 01:09:28,830
So there's this. If you look at, ah, there's a this biopsy data from there's a mass package called mass and ah, so it kind of looks like this.

544
01:09:28,830 --> 01:09:33,840
These are the first few rows of the matrix. It's called biopsy.

545
01:09:35,700 --> 01:09:41,550
So I'm defining a vector. Why should the why should have contain ones and zeros?

546
01:09:42,180 --> 01:09:45,270
So I'm just defining this vector y equals one.

547
01:09:45,840 --> 01:09:50,999
If that observation observations class is malignant, it's zero.

548
01:09:51,000 --> 01:09:55,650
If it's benign. So the length of Y is 699.

549
01:09:56,190 --> 01:10:02,010
And then I just the other thing I'm doing is defining a design matrix that has.

550
01:10:02,700 --> 01:10:07,530
So in this case, it has 699 rows and three columns.

551
01:10:07,680 --> 01:10:18,900
So the first row is just all ones. The second row contains the, the, the V one variable from the biopsy data and then the other.

552
01:10:19,200 --> 01:10:24,720
The third column contains the G2 column from the ah the V2 variable from that.

553
01:10:28,890 --> 01:10:36,120
The biopsy data. Okay. So that gives us y r y a vector in our x designed matrix.

554
01:10:36,630 --> 01:10:42,060
So if we want to run this in R, this is all we basically own.

555
01:10:42,810 --> 01:10:44,700
This is all we basically have to do.

556
01:10:45,120 --> 01:10:54,240
We just since since the beta has like three that we're interested in, we just define our vector beta 000 to start out with.

557
01:10:54,990 --> 01:11:01,620
And now we just use that as input in our image sampling function that we wrote in RCP.

558
01:11:02,880 --> 01:11:08,460
So first arguments beta that we have a design x our outcome vector lie.

559
01:11:08,880 --> 01:11:13,230
And then we have 10,000 is the end of the fourth argument.

560
01:11:13,240 --> 01:11:19,250
So we're going to have 10,000 draw, I guess really 10,001 draws of,

561
01:11:19,330 --> 01:11:25,440
of betas and then we have sigma squared is equal to 100 hundred and then lambda is equal 2.2.

562
01:11:28,150 --> 01:11:35,650
So basically what it's got, this function is going to return as a matrix with 10,001 rows and three columns.

563
01:11:35,930 --> 01:11:38,610
Okay. So that's what it does actually.

564
01:11:38,620 --> 01:11:49,360
So this, this, this line of coherence runs the function image run is just a matrix of 10,001 rows and three columns.

565
01:11:51,010 --> 01:11:55,030
Okay. So this is what it looks like if you plot it.

566
01:11:55,930 --> 01:12:02,800
As you can see here we start this first point is zero zero or let's see.

567
01:12:03,820 --> 01:12:06,930
Oh, this is for just one of the one other parts, right?

568
01:12:06,940 --> 01:12:16,090
So generating three different pages. But this is just one of them for the V, the one variable basically.

569
01:12:16,480 --> 01:12:20,950
So it starts at zero and it kind of goes up here and then it the way these usually look,

570
01:12:21,850 --> 01:12:27,370
the way these usually look, at least if everything's working properly, is something like this.

571
01:12:27,370 --> 01:12:33,909
There's kind of the early iteration can drift to somewhere and then it kind of it's just random around some value.

572
01:12:33,910 --> 01:12:39,570
So and in this case it's called it's like converging to it's stationary distributions.

573
01:12:40,560 --> 01:12:44,200
It should kind of look like this even if you do many,

574
01:12:44,200 --> 01:12:51,370
many more iterations should kind of bounce around this value, at least if everything is kind of working nicely.

575
01:12:55,120 --> 01:13:04,450
Okay, so here is just like I always say, at least if there's a way to test that your function is kind of working properly, I would do it.

576
01:13:05,200 --> 01:13:12,730
So to do that, I just compared it with the regression coefficient estimates that you get from the GL and function in R.

577
01:13:13,270 --> 01:13:18,709
So these these are not they shouldn't be exactly the same because we're doing kind of a Bayesian logistic regression.

578
01:13:18,710 --> 01:13:28,280
This is doing this what you might call a classic logistic regression, but they they should be pretty fairly similar, you know,

579
01:13:28,300 --> 01:13:38,830
they shouldn't be like you shouldn't have one valid value be equal to two from GLM and negative five from our MH sampler.

580
01:13:39,790 --> 01:13:43,300
So they should be kind of roughly the same, but they don't need to be exactly the same.

581
01:13:44,680 --> 01:13:51,820
So we're going to do that here. So I did that glm function.

582
01:13:52,240 --> 01:13:56,380
So these are the estimates of the three regression coefficients.

583
01:13:57,040 --> 01:14:04,150
The first one is -7.15 and 0.62 and then like 1.17 basically.

584
01:14:06,100 --> 01:14:11,050
And then this is what we get from our, our function or our CP function that we wrote down.

585
01:14:11,830 --> 01:14:17,130
So it's -7.27, 0.63 and then 1.1.

586
01:14:17,410 --> 01:14:21,190
So they're actually pretty close. Are these are the means actually.

587
01:14:21,190 --> 01:14:26,470
So if you take the mean of each column, this is what you get.

588
01:14:26,890 --> 01:14:34,510
Okay. So it's I think it's I think it's probably correct or at least if there is a bug, it's pretty small.

589
01:14:34,510 --> 01:14:42,139
It doesn't really affect the final answer that much. So here we just kind of ignored the first 1000 iterations.

590
01:14:42,140 --> 01:14:45,070
So that's often done in these type of examples.

591
01:14:45,070 --> 01:14:55,720
The reason is that is that you're basically trying to eliminate this this type of early burn in before you get to the kind of the stationary part.

592
01:14:56,800 --> 01:15:04,600
Because what you really want to use is kind of the stationary, these stationary draws, and you don't want to use this this type of thing.

593
01:15:05,470 --> 01:15:13,930
That's the reason for kind of eliminating the first 1000 rows from our from our return to matrix.

594
01:15:14,830 --> 01:15:22,290
Okay. I'm.

595
01:15:24,890 --> 01:15:34,550
Maybe we'll stop there today. Maybe we'll finish this next time. So I think we've I mean, we covered all the material that you need for the final.

596
01:15:36,380 --> 01:15:40,270
This is just a little bit of wrapping up that we'll do next.

597
01:15:40,400 --> 01:15:48,889
I was just showing that you can use basically I don't have a ton of examples,

598
01:15:48,890 --> 01:15:56,660
but you can basically use the the data structures from the steel library inside of RCP.

599
01:15:56,660 --> 01:16:09,700
So you can you could do that without a problem. So you can use the vector type or the example with a, you can use a map map type within RCP.

600
01:16:09,710 --> 01:16:20,910
And just that's probably the one thing I mentioned and then you can have a few extra slides on doing that,

601
01:16:21,200 --> 01:16:25,969
at least getting started with like object oriented programing in C++.

602
01:16:25,970 --> 01:16:31,459
But it's just a little bit of an intro since we won't have time to do it in detail.

603
01:16:31,460 --> 01:16:38,420
But I guess we'll just do that. We'll just do that on Wednesday, and I think it'll take the whole.

604
01:16:42,020 --> 01:16:46,579
I don't think it'll take the whole time. Maybe like half, half of Wednesday's class.

605
01:16:46,580 --> 01:16:58,260
And if that'll be, that'll be it. Questions are.

606
01:17:02,990 --> 01:17:09,860
So yeah, I think we're almost done. But if you have questions, you can ask them now or us after class.

