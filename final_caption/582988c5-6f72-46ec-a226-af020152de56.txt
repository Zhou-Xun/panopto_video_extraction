1
00:00:04,170 --> 00:00:28,560
I don't think she wants to be separated from the clan.

2
00:00:41,340 --> 00:00:53,570
Pretty much every single sketch.

3
00:00:59,390 --> 00:01:09,080
Oh, okay. Yeah. So this is the second footage from last time.

4
00:01:18,110 --> 00:01:24,710
Today, we'll get into more details on today's topics and the ones listed here.

5
00:01:26,010 --> 00:01:35,270
Really logical expressions. And we need to know how to read logical expressions in order to.

6
00:01:35,960 --> 00:01:48,770
But if statements are itself statements, that's really the main point purpose of discussing logical expressions and also logical expressions.

7
00:01:48,770 --> 00:02:00,680
Very strange, but whatever on here. Some upsetting factors are matrices and then function as some of the main topics today.

8
00:02:02,750 --> 00:02:19,160
So if those statements are or functions which we'll talk about later on or just examples of what we were saying, sometimes call it control flow.

9
00:02:21,980 --> 00:02:39,830
These are just things that can control for how different statements are executed in your computer program or control which statements are executed.

10
00:02:40,160 --> 00:02:49,370
So statement is just basically ignoring to think of it as just one line of code statement to just one line of code that does something.

11
00:02:49,640 --> 00:02:58,049
Okay. And the way you can interpret it, our programing program is running it and it starts at the top of your script.

12
00:02:58,050 --> 00:03:01,250
That executes one line at a time.

13
00:03:03,530 --> 00:03:06,799
So kind of starting from the top statements are executed one by one.

14
00:03:06,800 --> 00:03:17,900
But, you know, you can, depending on how you structure your program for your program with different control flows,

15
00:03:17,900 --> 00:03:24,620
you can ignore certain sections of code or repeat certain sections of code.

16
00:03:24,620 --> 00:03:31,999
So this is illustrated on the right. This is something like this is it false statements?

17
00:03:32,000 --> 00:03:40,400
So you know something, the data that comes in your comment at the top of your program and you define a variable,

18
00:03:41,570 --> 00:03:50,570
do something with that variable, and then if it's negative, you do something here or if it's positive, you do it to this.

19
00:03:52,910 --> 00:04:01,670
And then you kind of think maybe we're trying to resolve this issue with infection control, flow controls,

20
00:04:01,670 --> 00:04:11,749
how kind of the lines of code are executed as you move from the top of your our strip down to the to the to the bottom of your script.

21
00:04:11,750 --> 00:04:21,079
So, yeah, I just divide the main type of control statements as conditional statements,

22
00:04:21,080 --> 00:04:28,730
functions or loops, conditional statements that are is basically just if statements be if statements.

23
00:04:29,990 --> 00:04:43,670
So these are basically a statement or a false statement that basically controls whether or not you execute

24
00:04:43,670 --> 00:04:51,379
a certain statement depending on whether or not a condition is a certain condition satisfied a function.

25
00:04:51,380 --> 00:04:53,660
I guess you could think of it as kind of a control statement.

26
00:04:53,760 --> 00:05:05,180
This allows you to kind of do this basically the same execute the same type of code in different locations in your program.

27
00:05:05,180 --> 00:05:13,309
So once you have written a function, you can kind of use it all over the place within your function and then loops,

28
00:05:13,310 --> 00:05:15,260
which I think we'll talk about next time.

29
00:05:16,640 --> 00:05:27,320
This just allows you to repeat the same type of statement or similar statement bunch of times without having to rewrite it inside a program.

30
00:05:28,940 --> 00:05:35,060
So that's the reason for talking about logical expressions first.

31
00:05:38,410 --> 00:05:42,879
If statements are if statements, you have to know how to write in logical expression.

32
00:05:42,880 --> 00:05:49,600
So a logical expression is kind of a formal way of stating a condition.

33
00:05:50,440 --> 00:05:56,560
So, I mean, when you write, you write a program.

34
00:05:58,330 --> 00:06:06,100
It's very common to have a case where you only want to perform an operation, you know, certain conditions or sentence.

35
00:06:06,370 --> 00:06:16,510
So, for example, in my view, sort of transformation of your data for numbers that are greater than zero.

36
00:06:16,630 --> 00:06:28,510
So that is an example of that. And then logical expressions are just a formal way of stating conditions like that, formal way within are.

37
00:06:29,830 --> 00:06:37,870
So what we mean by a logical expression in our it's just that it's an expression that if it's just an expression,

38
00:06:37,870 --> 00:06:41,400
it evaluates to either true or false. That's all it is.

39
00:06:41,420 --> 00:06:48,430
So if you run a logical expression in R, it should kind of turn out either true or false.

40
00:06:48,580 --> 00:06:59,350
And that's really all of these are these are sometimes called Boolean expressions in other computer languages,

41
00:06:59,350 --> 00:07:05,890
but it's our usually call them logical expressions, but it's it's the same things, the same concept.

42
00:07:07,220 --> 00:07:10,600
Okay. So these are examples of logical expressions in our.

43
00:07:11,200 --> 00:07:15,860
So you can kind of type them and directly into the console and they, you know,

44
00:07:15,880 --> 00:07:22,450
they're valid are expressions and they should print out something like if you

45
00:07:22,450 --> 00:07:27,220
just type in five square determination to enter it should print out true.

46
00:07:29,440 --> 00:07:34,739
This one's true as well. And this is this one would be false.

47
00:07:34,740 --> 00:07:41,060
So this is saying is kind of the text number equal to the text digit.

48
00:07:41,140 --> 00:07:48,970
So it's false. So these are all just examples of valid, logical expressions.

49
00:07:51,910 --> 00:08:00,490
So that's just some kind of an introduction to why you need to we want to know how to write logical expressions in R.

50
00:08:00,520 --> 00:08:04,899
So I guess now we'll get into kind of the details of how to do that.

51
00:08:04,900 --> 00:08:07,870
So I think you can really break it down.

52
00:08:09,150 --> 00:08:19,389
You know, I think pretty much any logical expression that you are going to write is kind of some combination of these two operations.

53
00:08:19,390 --> 00:08:27,070
I mean, you could have a complicated, logical expression, but when you kind of break it down piece by piece,

54
00:08:27,210 --> 00:08:42,790
it's just some combination of some comparisons between different variables or others, along with some combination of different logical operators.

55
00:08:43,540 --> 00:08:47,890
So these are things like and or or not.

56
00:08:49,110 --> 00:08:52,170
So those are the main logical operators.

57
00:08:52,830 --> 00:08:59,879
So and is basically is saying if if truth, if you're comparing two things,

58
00:08:59,880 --> 00:09:10,110
if both of those things are true or is the logical outright or is if you had two two things that you're

59
00:09:10,110 --> 00:09:17,219
comparing at least one of them true and then not is just you're basically looking at the opposite of something.

60
00:09:17,220 --> 00:09:21,110
So if you do not something, it's just the opposite.

61
00:09:21,120 --> 00:09:24,719
So if you have a logical variable, let's see what are true.

62
00:09:24,720 --> 00:09:28,810
If you look at not variable, it's equal to false.

63
00:09:28,840 --> 00:09:33,150
And the other way around it converts false into true.

64
00:09:33,840 --> 00:09:41,790
So if you kind of look at these examples here, you can kind of type these directly into the are a console like five is greater than three.

65
00:09:42,540 --> 00:09:48,150
That's true. So I mean, these are just the examples from the previous slide.

66
00:09:52,020 --> 00:10:02,729
Okay. So I think this is just kind of a table that summarizes all the comparison.

67
00:10:02,730 --> 00:10:14,640
Operators like these are probably fairly common or you have less than greater than, less than or equal to, greater than or equal to.

68
00:10:17,430 --> 00:10:19,680
If you haven't seen this before,

69
00:10:19,680 --> 00:10:31,200
the double equals sign is what you have to use to to test for equality just because a single equal sign is to be used for assignment,

70
00:10:31,200 --> 00:10:43,050
assigning a value to a variable. So if you want to test whether or not two things are equal, you have to use a double and double equals sign, right?

71
00:10:43,800 --> 00:10:50,250
So like if I in this case, sort of testing two is equal to two.

72
00:10:50,370 --> 00:11:00,059
So that's true. I mean, often you'll write it in kind of a general sense where you're testing whether or not two variables are equal.

73
00:11:00,060 --> 00:11:07,290
So you often write something like X double B as two equals signs next to Y.

74
00:11:08,190 --> 00:11:16,410
So this is just testing equality and then this exclamation point equal is just not equal to.

75
00:11:16,500 --> 00:11:20,129
So you're testing whether or not two things are are not equal to each other.

76
00:11:20,130 --> 00:11:31,620
So I think this this one is true because these these two character variables are not static because the case sensitive.

77
00:11:31,620 --> 00:11:38,400
So in the capital bar the as the last letter here.

78
00:11:38,640 --> 00:11:44,330
Okay. So these are saying these two character variables are not equal to each other.

79
00:11:46,140 --> 00:11:57,450
So those are comparisons. So the other kind of components you'll use in building a logical expression are just logical operators.

80
00:11:57,450 --> 00:12:06,179
So this double ampersand is used in order to represent the logical.

81
00:12:06,180 --> 00:12:15,329
And so actually we'll see later on in a few slides later on,

82
00:12:15,330 --> 00:12:32,250
there's actually two ways to do a logical and in R you can actually just use a single ampersand or mostly the same way.

83
00:12:32,250 --> 00:12:38,370
That kind of a distinction is how they handle scales versus vectors.

84
00:12:39,630 --> 00:12:47,100
So I think it's just it's good to be aware of the distinction between using kind of the double ampersand versus ampersand.

85
00:12:47,100 --> 00:12:50,969
Although once you get started doing our programing,

86
00:12:50,970 --> 00:12:59,730
I think it's possible to kind of do everything with just using a single ampersand for all of your logical expressions.

87
00:13:00,810 --> 00:13:09,930
But we'll kind of start off with just discussing a logical and using this syntax for the using the double ampersand.

88
00:13:11,310 --> 00:13:23,670
So double this double ampersand is, is just used to test whether or not two statements are really two kind of logical variables are both true.

89
00:13:24,240 --> 00:13:36,870
Okay. So we have two logical expressions and B, so these are going to evaluate to true or false in some way, both and individually.

90
00:13:37,530 --> 00:13:47,460
And then if we come, you know, if we combine those two, we can combine those two logical expressions in kind of this joint statement, A and B.

91
00:13:48,360 --> 00:13:52,360
Really this is only going to be true if both A and B are true.

92
00:13:52,470 --> 00:14:07,350
Right. So if you look at these examples, so the first one we have four is greater than two and then the logical and I'd like to be equal.

93
00:14:09,720 --> 00:14:12,750
So this is actually kind of joining two logical expressions.

94
00:14:12,750 --> 00:14:18,840
So four is greater than two is a logical expression by itself that is true,

95
00:14:18,840 --> 00:14:26,129
that evaluates to true and then five divided by two is equal to one is also a logical expression.

96
00:14:26,130 --> 00:14:29,370
So that evaluates to false.

97
00:14:31,890 --> 00:14:40,680
And then when we put an ad in the middle, kind of that entire logical expression will evaluate to false.

98
00:14:40,680 --> 00:14:43,709
That's just because because one of these is false.

99
00:14:43,710 --> 00:14:48,960
As long as one of these is false, it really doesn't matter whether or not the other one's true.

100
00:14:49,650 --> 00:14:53,540
All of them will evaluate the false. Same thing here.

101
00:14:53,540 --> 00:14:58,049
And this on the left hand side. This part is true, but this part is false.

102
00:14:58,050 --> 00:15:01,440
So the entire thing is false, and then it's all edge.

103
00:15:02,370 --> 00:15:08,099
And it'll only be true if kind of both things are true.

104
00:15:08,100 --> 00:15:13,080
So four is greater than two is true and three is less than five is true.

105
00:15:13,530 --> 00:15:25,680
So when we had both things true looking at and will give us kind of a true statement, kind of the other thing is the logical.

106
00:15:26,880 --> 00:15:35,640
So here we're looking at basically whether or not one of the statements is true or false statement is true.

107
00:15:39,720 --> 00:15:48,959
So if a so this is going to be if we are going to evaluate the truth, at least one of these.

108
00:15:48,960 --> 00:15:56,100
True, it's kind of a double bar, double vertical bar notation can be used for that.

109
00:15:56,670 --> 00:16:06,410
So there's also a sit there's same thing with and there's also a single double bar or that you can use and we'll talk about that later.

110
00:16:12,480 --> 00:16:24,060
So this will be true. So A or B is true if you know exactly one of A and B are true, or if both A and B are true, it really doesn't matter.

111
00:16:24,180 --> 00:16:27,990
As long as at least one of them is true, it's going to evaluate to true.

112
00:16:28,560 --> 00:16:31,260
So I think in all of these examples I have here,

113
00:16:31,800 --> 00:16:42,870
the OR evaluates to truth since in each case we have at least one of the one of the statements is true which case.

114
00:16:43,350 --> 00:16:47,280
The only way it would evaluate false is if both things are false.

115
00:16:48,920 --> 00:16:56,100
You look at if you're looking at A or B, the only way that evaluates 2000 is both.

116
00:16:57,240 --> 00:17:07,110
Both A and B are false. So here's kind of the last main logical operator, which is not.

117
00:17:09,780 --> 00:17:23,300
This represents the logical. Basically it's a is true and exclamation point K is false is really how it works or vice versa.

118
00:17:23,340 --> 00:17:28,059
So if A is false, then exclamation point.

119
00:17:28,060 --> 00:17:32,300
That is true. Okay, let's see what's going on here.

120
00:17:32,790 --> 00:17:35,820
So why this evaluates the focus of why it is that.

121
00:17:38,400 --> 00:17:42,930
Okay, so it does the second kind of this comparison first.

122
00:17:47,310 --> 00:17:52,290
So so does four is greater than two and evaluates that first.

123
00:17:53,220 --> 00:17:58,140
So that becomes true. And so the notion is basically like not true.

124
00:17:58,600 --> 00:18:02,140
So this becomes false. So.

125
00:18:04,470 --> 00:18:09,970
Okay, so what's. The one on here.

126
00:18:09,970 --> 00:18:22,120
So another. Yeah, some of these things, I think parentheses can make it a little bit more clear, but I'll say what's going on here?

127
00:18:22,310 --> 00:18:27,700
So, you know, four is greater than two, which is true.

128
00:18:28,450 --> 00:18:37,299
But then we have, I guess the weights once it does these comparisons and it's going to do a logical operation.

129
00:18:37,300 --> 00:18:42,820
So it's like from left to right. So that's like true, but it's oriented.

130
00:18:44,890 --> 00:18:48,730
This whole thing becomes false. So four is greater than two.

131
00:18:48,730 --> 00:18:56,220
It's true. But then we do that not that's false and then it's and it's true.

132
00:18:56,230 --> 00:19:03,910
State So the way you can read this is like false and true, which evaluates to false.

133
00:19:04,150 --> 00:19:08,710
Okay. Okay. So, I don't know.

134
00:19:08,720 --> 00:19:20,500
I think this is. If you're writing code, sometimes it's helpful to put things into parentheses, at least to make it more readable.

135
00:19:22,690 --> 00:19:34,970
Anyway. Here is. So I believe this would be everything inside the parentheses is a logical expression.

136
00:19:36,310 --> 00:19:42,220
So everything when you put things inside parentheses, kind of everything inside parentheses is evaluated.

137
00:19:42,690 --> 00:19:51,660
The fourth kind of things outside the parentheses. So this logical expression inside the parentheses is that evaluates to focus.

138
00:19:51,730 --> 00:19:56,650
And that's kind of like false. And actually it's in the policies.

139
00:19:57,010 --> 00:20:01,660
So everything inside the parentheses evaluates to false, right?

140
00:20:02,470 --> 00:20:09,670
And so when you put the kind of the exclamation point outside of, it's kind of the whole thing that becomes true.

141
00:20:12,400 --> 00:20:17,320
So that's that's kind of why that one why that expression evaluates to true.

142
00:20:19,330 --> 00:20:25,040
Okay. So I think this is just this is just a table that summarizes everything.

143
00:20:25,070 --> 00:20:37,560
So. This is kind of this is kind of like in this column, it's kind of like every combination of true and false that you could have.

144
00:20:38,310 --> 00:20:42,780
So that not logical, not just kind of reverse is true and false.

145
00:20:43,650 --> 00:20:49,500
And then when we look at and this is kind of every combination of true and false that you can have.

146
00:20:50,140 --> 00:20:56,730
And so the only case when and is true is when both of them are true and or as kind of the opposite.

147
00:20:56,940 --> 00:21:05,100
The only case where you can have a false statement is when both of them are false.

148
00:21:05,280 --> 00:21:11,790
Okay. So that's just kind of summarizing what we do and it doesn't become a single table.

149
00:21:14,400 --> 00:21:22,229
Okay. So something to know, something to keep in mind a little bit.

150
00:21:22,230 --> 00:21:31,190
I mean, I when I write logical expressions, I try to use parentheses as well.

151
00:21:32,310 --> 00:21:38,460
A good amount of parentheses and certain expressions can be confusing without parentheses,

152
00:21:41,700 --> 00:21:47,099
but it's still good to keep in mind these these are precedents of operation.

153
00:21:47,100 --> 00:21:59,030
So I'd say the way to think of this is basically kind of all the math is done first before the logical operations boolean,

154
00:22:00,570 --> 00:22:08,760
unless things are in parentheses so that things in parentheses, kind of everything inside of the parentheses is done first.

155
00:22:10,020 --> 00:22:18,899
But if you don't have parentheses separating anything, kind of all the math is done first, is evaluated first,

156
00:22:18,900 --> 00:22:28,080
and then kind of the logical or these these kind of logical operations or comparison operations are performed after that.

157
00:22:28,740 --> 00:22:38,190
Okay. So you can see that here. So in this example, we have four plus two is greater than five.

158
00:22:38,200 --> 00:22:44,340
I mean, I mean, you could conceivably think that this would be four plus.

159
00:22:45,870 --> 00:22:50,879
We could evaluate two is greater than 5/1. That's not what's going on.

160
00:22:50,880 --> 00:22:53,990
Basically, it's going to do the math first.

161
00:22:53,990 --> 00:22:59,459
So it's going to compute four plus two. And so it's really comparing six and five.

162
00:22:59,460 --> 00:23:02,850
So it's it's saying is six greater than five? Okay.

163
00:23:02,850 --> 00:23:05,940
So that's why it's true. And you can see that again here.

164
00:23:05,940 --> 00:23:12,929
So it's doing kind of the the addition first, then it's doing the addition of four plus 2/1,

165
00:23:12,930 --> 00:23:20,040
and then it's doing the the logical comparison that's saying is six equal to six.

166
00:23:20,190 --> 00:23:29,260
So that's that's true. Yeah, I.

167
00:23:33,440 --> 00:23:38,940
This is just I guess the saying, I guess if you type it in ah it kind of matches what we had in the table.

168
00:23:38,940 --> 00:23:49,679
So I mean you don't, you don't really have to type in kind of a formal logical expression here.

169
00:23:49,680 --> 00:23:53,310
You can, you can write out the explicit words, true and false.

170
00:23:53,790 --> 00:23:59,940
So that's fine as well. So you can actually write up true and false and that should evaluate to false.

171
00:24:03,210 --> 00:24:05,800
Okay. So here's another thing.

172
00:24:05,810 --> 00:24:19,550
I mean, it's not it's it's not super important, but I thought I'd mention it because you'll often see it and the other people are code.

173
00:24:22,400 --> 00:24:27,020
So you can actually write those or you can use the letters TANF,

174
00:24:27,880 --> 00:24:37,820
Capital T and Capital F and place a true and false as kind of a abbreviations like shorthand for true or false.

175
00:24:38,990 --> 00:24:40,010
I don't usually do that.

176
00:24:40,010 --> 00:24:49,520
I mean, I like to write out the full true and false, but it's not it's reasonably common to see this in other people's articles.

177
00:24:49,520 --> 00:24:53,240
And so, you know, if you see this, you know, don't be confused.

178
00:24:54,650 --> 00:24:58,610
Capital T capital has to be used as true and false.

179
00:24:58,610 --> 00:25:08,660
So if you just like cap, like if capital T has not been defined first, if you just, you know,

180
00:25:08,750 --> 00:25:14,840
type in capital T and hit enter in and the R console, the way it kind of prints it out is, is true.

181
00:25:15,770 --> 00:25:20,300
Same thing for kind of false. If you type in capital life, it should print out false.

182
00:25:21,230 --> 00:25:33,560
And if you can even do these kind of logical comparisons of t f filtering out false 40 or f, so that should be true.

183
00:25:34,130 --> 00:25:44,450
Okay. So you can use you can basically use capital T or capital F in as if they were the values, true or false.

184
00:25:46,160 --> 00:25:52,430
I guess the only thing to be careful about if you're doing that is that you can redefine the capital T,

185
00:25:53,450 --> 00:25:57,560
you can redefine it as a variable with a different value.

186
00:25:58,610 --> 00:26:07,340
So that has the potential to mess up your program if you're using sort of logical expressions later on that only use t I mean,

187
00:26:07,460 --> 00:26:22,190
that's the only I would say the only reason is to be a little bit cautious about using capital T rather than the full, full word.

188
00:26:22,190 --> 00:26:25,610
True. So that we have so you could see that here,

189
00:26:25,610 --> 00:26:37,610
if you assign the value to capital to you to and then type in capital to insert and you can see it'll

190
00:26:37,610 --> 00:26:43,249
have it has the value is an actual express bullet point for the last time did you have a capital

191
00:26:43,250 --> 00:26:49,940
that had been delivered to mine and don't want to sign for it for English Express present one and

192
00:26:49,940 --> 00:27:04,200
Chinese please press to actually pay to generate cultural paperwork for international business.

193
00:27:08,390 --> 00:27:22,980
Yeah, that's coming from my old school, so.

194
00:27:25,220 --> 00:27:27,190
Yeah. So I guess the point yeah.

195
00:27:27,230 --> 00:27:38,629
The point here is, you know I the run in but you can't really define false or true you can't assign them different properties.

196
00:27:38,630 --> 00:27:50,390
Right. So you can't say true is equal to two for example, you know, print, if you try to do that, it will give you some kind of error message.

197
00:27:50,840 --> 00:27:56,180
Okay. So in that sense, it's a little bit safer.

198
00:27:56,180 --> 00:28:04,550
You like if it is true or or false, that means it really has to be really represents the logical value, true or false.

199
00:28:05,180 --> 00:28:12,260
Whereas in T and F there's is the potential that it could equal something else.

200
00:28:14,660 --> 00:28:34,110
Let's. So these are just some additional examples, I guess I just listed.

201
00:28:36,150 --> 00:28:42,580
So I guess it can be true.

202
00:28:44,130 --> 00:28:47,880
Oh, I think one, it is kind of have equal precedence.

203
00:28:47,880 --> 00:28:59,430
So this kind of goes left is the way to interpret this example is like false or true is the way that you do it in parentheses.

204
00:28:59,910 --> 00:29:04,020
It kind of evaluates this first true or true. That's true.

205
00:29:04,020 --> 00:29:08,480
And it put the exclamation point in front of that.

206
00:29:09,150 --> 00:29:12,870
It does the negation of that, so the whole thing becomes false.

207
00:29:14,370 --> 00:29:18,809
Okay. Okay. So yeah, this is what I was talking about before.

208
00:29:18,810 --> 00:29:22,770
So there's actually not confusing.

209
00:29:22,770 --> 00:29:29,250
There's actually kind of two ways to do and, and ah, and there's two ways to do or in r as well.

210
00:29:30,060 --> 00:29:43,700
I, I guess the way to interpret this is it is like the double ampersand is like scalar and, and then the single ampersand is vector and,

211
00:29:43,890 --> 00:29:52,380
and then this double bar is kind of like the scalar or, and plus the single bar is like a vector effect arised.

212
00:29:53,310 --> 00:30:04,080
Okay. So if you're comparing like logical vectors of length one, so kind of single variables that have the value,

213
00:30:04,080 --> 00:30:08,670
true or false, these are these are all actually these are actually identical.

214
00:30:08,670 --> 00:30:09,750
They do the same things.

215
00:30:10,520 --> 00:30:22,320
But the really the only the only difference that comes up is when you are comparing logical factors that have links longer than one.

216
00:30:23,070 --> 00:30:34,470
Okay. And so, I mean, that's useful later on when you talk about vectors, some settings useful to do logical expressions with with vectors.

217
00:30:35,280 --> 00:30:48,180
Um, okay. But if we're looking at it kind of vectors of like one of these two, there's two different types of notation give you the same result.

218
00:30:48,330 --> 00:30:57,030
Okay? So you can see that here, if we just teach true and false with a single ampersand, it returns false and then true or false.

219
00:30:57,810 --> 00:31:03,990
It's kind of the single vertical bar that also returns true, just like the superclass.

220
00:31:06,500 --> 00:31:11,760
All right. So the difference can come up if we're talking about the fact.

221
00:31:11,940 --> 00:31:15,210
So I think we'll talk about vectors next time.

222
00:31:16,260 --> 00:31:21,120
The vectors are just like a collection of variables.

223
00:31:21,120 --> 00:31:27,900
I guess you can think of it that way. So this is the notation for variable or or creating variable.

224
00:31:28,090 --> 00:31:33,209
Sorry, creating vectors in R. So this is the notation.

225
00:31:33,210 --> 00:31:39,210
This just creates a factor of like for the kind of each component of the vector is logical.

226
00:31:39,780 --> 00:31:46,590
It's either true or false. Okay. So we have two different factors of of length for okay.

227
00:31:47,940 --> 00:31:57,150
So what happens if we do the double ampersand in double ampersand y and just returns a single logical kind of value.

228
00:31:57,840 --> 00:32:06,150
So just return. True. So what it's actually doing is it's returning a comparison of the first two elements.

229
00:32:07,230 --> 00:32:14,340
So it's X is basically the first component of X and the first component of Y.

230
00:32:14,340 --> 00:32:18,840
So this is really like true and true. It's the first component of X.

231
00:32:18,840 --> 00:32:32,940
It's true. The first component of Y is true. If you do X and Y with the single ampersand, it does kind of a logical and one at a time.

232
00:32:33,600 --> 00:32:35,490
So it compares the first two elements,

233
00:32:36,210 --> 00:32:43,950
the first element of X with the first element of Y and the second element of X with the second element of Y and so on and so on.

234
00:32:45,180 --> 00:32:52,560
Until, until you go to the to the to the end of the vector.

235
00:32:52,680 --> 00:32:58,920
Okay. So it will return a vector of the same length of X and Y.

236
00:33:02,400 --> 00:33:02,690
Okay.

237
00:33:04,800 --> 00:33:15,540
So you can actually use a single ampersand kind of for every type of comparison to return to the same thing, even if you're looking at single values.

238
00:33:15,540 --> 00:33:20,820
But I still think it's good to define the distinction between the single ampersand,

239
00:33:21,450 --> 00:33:27,900
the double ampersand and R Yeah, same thing with this kind of double.

240
00:33:29,060 --> 00:33:32,440
RF or or versus the single vertical bar.

241
00:33:33,010 --> 00:33:41,230
This double vertical bar, even though X and y are vectors, it just does the kind of the logical comparison for the.

242
00:33:45,030 --> 00:33:51,090
The first two, the first two elements of X and Y, but the kind of the single vertical bar is everything.

243
00:33:51,750 --> 00:33:53,760
That element by element. One at a time.

244
00:33:56,040 --> 00:34:06,990
This is not a logical, not actually just automatically returns a vector of the same length of zero as the original.

245
00:34:07,260 --> 00:34:15,120
So not x just returns a vector of the same length kind of with everything is all the true switch to false.

246
00:34:15,120 --> 00:34:25,950
And I'll also switch to true. So let's do it for logical expressions.

247
00:34:27,300 --> 00:34:31,350
Hopefully we'll see how it can be useful.

248
00:34:31,890 --> 00:34:42,120
If we talk about infinite false statements. So first talk about if statements.

249
00:34:44,070 --> 00:34:56,340
So if statement is the purpose of the statement is really if you just want to only execute a piece of code, only if a certain conditions.

250
00:34:56,340 --> 00:35:01,559
True. That's really the purpose of this kind of the way you write it down in R is the following

251
00:35:01,560 --> 00:35:09,090
you say If you open parentheses and then what you write here where I have condition here,

252
00:35:09,690 --> 00:35:13,229
what you write there is going to be some logical expression.

253
00:35:13,230 --> 00:35:16,010
So that's where the logical expressions come in.

254
00:35:16,800 --> 00:35:26,850
You're going to write down some logical expression, and the way to interpret that is only if this logical expression evaluates to true,

255
00:35:27,450 --> 00:35:33,270
you know, only if that's true, then you're going to execute kind of the code you have here.

256
00:35:33,810 --> 00:35:40,950
So you're going to have some additional R code kind of in between these these curly braces.

257
00:35:42,300 --> 00:35:47,310
And that's only going to be executed if this kind of logical expression evaluates to true.

258
00:35:49,150 --> 00:35:54,240
I mean, it doesn't actually have to be a full logical expression, although it usually is.

259
00:35:54,240 --> 00:35:54,750
But it could.

260
00:35:54,900 --> 00:36:03,990
It could just be, if true, if you just write down the key true in that case here, it kind of all here always even executes this code here.

261
00:36:08,400 --> 00:36:14,430
So. So if you have okay.

262
00:36:14,430 --> 00:36:23,280
So if you have more than one line of code in this code chunk, you should use the curly braces function.

263
00:36:24,150 --> 00:36:29,280
Then you don't have to do that if you have a single line. I'll mention that in a later slide.

264
00:36:30,360 --> 00:36:36,780
I would say I usually indent meaning like I'll write it like this.

265
00:36:36,780 --> 00:36:45,900
Like each line of code will start here, but you don't have to as long as it's inside the curly braces.

266
00:36:46,710 --> 00:36:55,980
But I usually write it that way. I think it makes it easier to read if and then in this code chunk, everything is indented.

267
00:36:56,740 --> 00:37:00,450
It just makes that's kind of a separate little chunk of code.

268
00:37:00,780 --> 00:37:04,140
It makes it makes the entire program more readable.

269
00:37:09,360 --> 00:37:19,290
So yeah, if you can run this code directly in ah, you can write this in a script and just run it would say if true then.

270
00:37:19,850 --> 00:37:29,129
Hello. So this, this is where if you just run this, this is this is kind of equivalent to running the print.

271
00:37:29,130 --> 00:37:40,440
Tell all you can actually write the there's a function called the print and then you can you put print and hello inside the parentheses for prints.

272
00:37:40,530 --> 00:37:45,320
You know, it'll do the same thing. That's kind of the same thing, the same breath.

273
00:37:46,440 --> 00:37:49,739
So if you run this, if true friends.

274
00:37:49,740 --> 00:37:54,299
Hello, it'll hello. Just because none of this is true.

275
00:37:54,300 --> 00:38:02,550
So it's going to execute the code inside the code chunk if you do false if you run this context.

276
00:38:03,000 --> 00:38:17,100
Okay, let's guess the logic of an statements down here is probably a slightly more realistic example.

277
00:38:17,850 --> 00:38:22,229
So if statements, which depends on kind of a logical expression.

278
00:38:22,230 --> 00:38:30,990
So here we have if X is less than Y, we print out the message X is smaller than Y.

279
00:38:32,490 --> 00:38:36,330
If X is greater than Y, print out the message X is greater than Y.

280
00:38:37,230 --> 00:38:42,000
If you run these two statements, kind of only. Only the code here is going to be.

281
00:38:42,520 --> 00:38:46,780
And since kind of only this logical expression is true.

282
00:38:48,490 --> 00:38:56,080
So, you know, I just switched.

283
00:38:56,200 --> 00:39:00,279
If you switch up the numbers, it prints out the message from the bottom line.

284
00:39:00,280 --> 00:39:11,110
So now X is greater than Y. Okay, so let's do a few more, slightly more involved examples.

285
00:39:12,040 --> 00:39:16,030
So let's see. Okay.

286
00:39:16,130 --> 00:39:21,290
So I guess if we had these three, I don't think this is that helpful really.

287
00:39:21,290 --> 00:39:32,960
This printout now that I'm looking at it, which which one of these, since they each have the same message in each one,

288
00:39:33,380 --> 00:39:42,560
it's hard to see which one printed out which message, but I would say this logical expression is false.

289
00:39:42,560 --> 00:39:46,910
So it did not execute the code here.

290
00:39:47,750 --> 00:39:57,740
But if we look at Doug is equal to Chad and it's false. So if it didn't execute that one, uh, if we look at this logical expression is equal to two.

291
00:39:59,480 --> 00:40:05,270
So that's this one is true. This one is true, but this one is false.

292
00:40:05,930 --> 00:40:12,420
So it's not going to it's not going to print out. This is the only one that prints out is it's kind of the bottom one.

293
00:40:12,440 --> 00:40:22,219
So if we look at if two is less than three, that's true or two is equal to 2.5.

294
00:40:22,220 --> 00:40:34,190
So that's false. But since we're doing a kind of an for comparison, kind of the whole this entire logical expression here evaluates to true.

295
00:40:36,130 --> 00:40:43,540
So it's going to print out this yellow statement, but it goes for these two statements above.

296
00:40:43,540 --> 00:40:46,600
It doesn't print, print, anything else. Okay.

297
00:40:49,060 --> 00:40:50,320
Do I have any more?

298
00:40:51,640 --> 00:41:02,020
Well, this is just a comment about it's kind of the body of the if statement is short, meaning, like you could write it in one line.

299
00:41:06,700 --> 00:41:13,029
You can you can write a kind of if statement in a single line, basically.

300
00:41:13,030 --> 00:41:17,830
So you can write it this way, let's say X equal to five.

301
00:41:19,630 --> 00:41:25,660
And I have if x server's greater than four and true, then axis, you've got a two times x.

302
00:41:27,220 --> 00:41:31,360
So this is true. So you should execute kind of the body of the statement.

303
00:41:31,360 --> 00:41:36,280
So you should look at x is equal to two times x.

304
00:41:36,280 --> 00:41:40,810
So here is ten.

305
00:41:41,230 --> 00:41:47,300
So this the single line as statement is basically the same thing as writing this whole thing.

306
00:41:47,920 --> 00:41:52,630
So if you prefer to write it in a little bit, a shorter format, you can do it.

307
00:41:53,650 --> 00:41:57,040
You can also write it in the line immediately below it.

308
00:41:57,460 --> 00:42:04,660
It would be the same. If you have one line, you can write in the line immediately, but will you?

309
00:42:04,840 --> 00:42:08,910
It kind of be the same things as this one is.

310
00:42:09,010 --> 00:42:17,100
This is kind of formally putting everything inside of the curly braces.

311
00:42:17,140 --> 00:42:22,080
Okay, so sometimes you might see statements written by.

312
00:42:23,950 --> 00:42:29,620
So that's there's no right or wrong way to do it.

313
00:42:29,810 --> 00:42:34,150
It's just one which style you prefer.

314
00:42:36,100 --> 00:42:45,250
I mean, I do think this is a little bit can be a little bit clearer, but I think that's just that's just the style style thing.

315
00:42:47,050 --> 00:42:55,560
Okay. So if else. So how do you write if all statements are the first first of all,

316
00:42:55,560 --> 00:43:03,490
a default statement is basically expressing the logic is if you want to do something, you do.

317
00:43:04,530 --> 00:43:08,620
So if some condition is true, you do a if it's not true,

318
00:43:08,650 --> 00:43:21,470
you're going to do so in if statement is saying if some condition is true, execute a otherwise kind of keep going for it,

319
00:43:22,750 --> 00:43:35,379
keep going and start executing those the lines of code, the letter that it felt statement is saying If it's not true, you don't just ignore it.

320
00:43:35,380 --> 00:43:40,280
You do something else. You do kind of execute this code here.

321
00:43:40,570 --> 00:43:46,060
Okay. So if condition is true, you execute this chunk of code here.

322
00:43:46,270 --> 00:43:57,550
So just one. If it's not true, you execute the code jump to okay, so, so condition is again,

323
00:43:57,790 --> 00:44:01,660
it's a logical expression, although it could be the keyword true itself.

324
00:44:05,090 --> 00:44:08,709
But this is the way you write it. False statements in order.

325
00:44:08,710 --> 00:44:19,000
So if this and then you open and close curly braces and then you write two else

326
00:44:19,810 --> 00:44:30,750
on kind of the same line as you closed the curly braces with like you mean.

327
00:44:30,840 --> 00:44:37,059
So that's that's the syntax there and also a function in are called the officials

328
00:44:37,060 --> 00:44:45,160
which is sometimes level it's often useful sometimes it kind of depends

329
00:44:45,160 --> 00:44:59,080
on exactly the condition that you're writing and I guess the length of the code chunks that you're executing each which which approach makes sense.

330
00:44:59,080 --> 00:45:04,690
But if you want to look up the the function it false in R that's often a function.

331
00:45:05,650 --> 00:45:11,410
Okay so here is kind of just a direct example of how you might use an if statements,

332
00:45:13,420 --> 00:45:20,670
let's say computing the absolute value of a number is you have an input of number one of the absolute.

333
00:45:20,920 --> 00:45:29,470
You can say that if X is greater than zero, absolute value is basically just the number itself.

334
00:45:30,040 --> 00:45:34,540
If it's negative, it's all right.

335
00:45:34,540 --> 00:45:38,210
It's not a. You can take that negative number. All right.

336
00:45:38,230 --> 00:45:45,130
So here's just the way you would write that in our, you know, if X is greater than zero.

337
00:45:45,940 --> 00:45:55,870
You just assign this other variable, the value X. Otherwise, the only other option is if it's not positive.

338
00:45:55,870 --> 00:46:02,350
The only other option is to be non positive, basically zero or negative.

339
00:46:02,890 --> 00:46:06,700
In that case, you can assign X to negative effects.

340
00:46:07,210 --> 00:46:13,930
So and then so that result is an absolute value.

341
00:46:16,030 --> 00:46:20,980
And if it's negative, the negative is the absolute value.

342
00:46:22,580 --> 00:46:26,310
So if we just run this, this'll print out 3.3.

343
00:46:27,490 --> 00:46:31,000
And this originally assigned in the value -3.2.

344
00:46:31,750 --> 00:46:37,180
And so you run this code now it's now it's 3.2, as you would expect.

345
00:46:37,190 --> 00:46:47,709
So it's basically actually it's it's really only executing this this this piece of on line six.

346
00:46:47,710 --> 00:46:50,740
So it's it's not executing this this line.

347
00:46:52,660 --> 00:46:56,889
All right. Okay. So let's just do some more examples.

348
00:46:56,890 --> 00:47:07,690
So here in this example, the first example it's executing and the else part of the Aflw statement so down here.

349
00:47:08,500 --> 00:47:20,620
So why is that? So we had originally XS five and then if you remember this kind of modulus or remainder operation that double percent science.

350
00:47:20,620 --> 00:47:25,480
So that takes the remainder kind of after division of five and two.

351
00:47:26,380 --> 00:47:31,240
So they're kind of the remainder. That's true.

352
00:47:31,240 --> 00:47:36,850
Dividing five by two is one. So it's basically just testing it if one is equal to zero.

353
00:47:36,850 --> 00:47:43,270
So that's false. Okay. So that's that's why you execute the else part of the statement.

354
00:47:45,190 --> 00:47:51,579
All right. So the other example is executing, I guess, the if part of the AFL statement.

355
00:47:51,580 --> 00:47:57,819
So it's looking at this X kind of remainder two is equal to zero.

356
00:47:57,820 --> 00:48:05,020
So that's false. But we're really a logical or so as long as this is true of the entire thing is true.

357
00:48:05,710 --> 00:48:14,710
So five is greater than four. So indeed the entire logical expression evaluates to true.

358
00:48:16,420 --> 00:48:19,630
So that's why we're executing this piece.

359
00:48:22,600 --> 00:48:27,880
Okay, so that's your false statement.

360
00:48:29,410 --> 00:48:40,000
So you can kind of extend this and keep going. I mean, you could have, you know, more than two possible outcomes, right?

361
00:48:40,000 --> 00:48:49,750
So you can look at a case where if a condition is true, you execute one thing.

362
00:48:49,750 --> 00:48:53,560
But if it's not true, you want to test something else.

363
00:48:54,430 --> 00:48:59,469
That's true, you execute. B But if that's not true, you want to execute.

364
00:48:59,470 --> 00:49:08,110
C to be like three possibilities. So you can kind of do to do as many of these as you like.

365
00:49:08,140 --> 00:49:15,850
You could have four or five different possibilities based on a series of conditions.

366
00:49:16,360 --> 00:49:27,490
So the way you to do that is with you just combine kind of a bunch of ifs and elements and you can kind of have an else at the bottom.

367
00:49:31,060 --> 00:49:36,730
So the way I guess to interpret that is, you know, each case you're going to have a logical expression.

368
00:49:37,330 --> 00:49:43,840
So in this example here, if condition one is true, it's going to execute the first code chunk.

369
00:49:44,770 --> 00:49:52,320
Okay, so that's and then so it executes the first code chunk and then it goes all the way to the bottom line.

370
00:49:53,860 --> 00:50:00,250
Once that's been executed, it goes it starts running, evaluating the I think,

371
00:50:01,990 --> 00:50:09,639
you know, the R code that comes after kind of this big elusive else chain.

372
00:50:09,640 --> 00:50:16,840
Okay. So it kind of does the first code chunk and it starts running the code that's down here right after this.

373
00:50:19,420 --> 00:50:23,469
You know, the other option is this condition.

374
00:50:23,470 --> 00:50:27,310
One is false and then it but a condition two is true.

375
00:50:27,310 --> 00:50:32,290
It'll execute this code sharp and then it'll just take of.

376
00:50:33,430 --> 00:50:39,340
And you could keep going if. If both conditions two and three are false.

377
00:50:39,850 --> 00:50:47,780
Sorry if conditions one and two are false, but condition three is true, you would execute kind of coach on three and then jump to the.

378
00:50:48,250 --> 00:50:55,780
And lastly, if all of the conditions for Elsa follows, it'll just go to that.

379
00:50:56,560 --> 00:50:59,590
She'll just go to the house part and execute this.

380
00:51:00,370 --> 00:51:07,030
And then after executing the are statements right after this big defensive change.

381
00:51:08,650 --> 00:51:17,170
So that's kind of the logic of that. It would if all else changed or kind of, you know, go to the first, you know,

382
00:51:17,200 --> 00:51:25,630
go to the first code chunk kind of associated with the first kind of logical expression that evaluates the true

383
00:51:25,780 --> 00:51:35,410
and and run that code chunk and then jump to right below if you didn't start executing the state of the state.

384
00:51:37,630 --> 00:51:41,740
So that's how kind of the logic of the defensive loss chain.

385
00:51:43,150 --> 00:51:56,020
So you could see that here. Like if we define a variable X is equal to now we have a different message for each possibility

386
00:51:56,080 --> 00:52:02,260
of X if it's negative or now something that's zero in the front on another message.

387
00:52:02,860 --> 00:52:14,230
If it's positive, print out another message. So like, yeah, so if it were negative, you would print that out.

388
00:52:16,060 --> 00:52:19,780
If it were equal to zero, this would be false.

389
00:52:19,780 --> 00:52:21,879
So it would jump to this one.

390
00:52:21,880 --> 00:52:32,650
If I make this friend front this message out and then kind of only this message and then executing our statements as follows.

391
00:52:33,490 --> 00:52:38,920
In this case, kind of both of these statements are false, right?

392
00:52:39,580 --> 00:52:47,110
So it prints out kind of this this pattern. All right.

393
00:52:47,110 --> 00:52:57,670
So here's just another example. So if I kind of assign this variable called message, the this is a character variable.

394
00:52:59,980 --> 00:53:08,290
It only executes kind of the itself. So that's because the first logical expression is false, but the second one is true.

395
00:53:08,910 --> 00:53:15,430
Search executes the logical expression here.

396
00:53:15,940 --> 00:53:22,570
And then it would move on to kind of whatever code is kind of below that it fails.

397
00:53:23,440 --> 00:53:35,130
Yes. Else check. Okay. That's kind of the logic of this flip if if I was channels and kind of the syntax in here.

398
00:53:35,290 --> 00:53:40,029
So if you're doing these,

399
00:53:40,030 --> 00:53:48,309
I would say you usually have to do kind of these open and closed curly braces and then you

400
00:53:48,310 --> 00:53:55,810
should put kind of the else ifs and the else on the same line as the the curly braces.

401
00:53:56,680 --> 00:54:00,550
Okay. Okay. See, I showed an example of this.

402
00:54:02,490 --> 00:54:04,990
Yeah. I try to run this type of code.

403
00:54:06,250 --> 00:54:19,870
Like if you put if you try to write a defensive statement like this, like what else on the line below, closing curly braces.

404
00:54:20,500 --> 00:54:24,400
You know, it'll give you some kind of error message.

405
00:54:29,880 --> 00:54:33,100
So you don't want to start a life with without separate things.

406
00:54:34,020 --> 00:54:42,090
But he doesn't like that. So that's just something something to keep in mind or, you know,

407
00:54:42,180 --> 00:54:50,290
hopefully this error message is informative enough to tell you that you should put the else on the comments.

408
00:54:51,000 --> 00:54:55,950
I mean, you shouldn't start a line without such kind of be following a closing curly braces.

409
00:54:56,910 --> 00:55:02,790
All right. Okay. So you can definitely make things more complicated if you want to.

410
00:55:03,030 --> 00:55:07,080
Sometimes it's helpful to do so.

411
00:55:07,090 --> 00:55:12,810
Like you can have you know, you can have it false statements within the thing.

412
00:55:13,320 --> 00:55:25,390
If statements are if all of our statements. So here I have a beautiful statement within kind of a larger elseif else chain like.

413
00:55:26,940 --> 00:55:36,089
So what is the point of doing this? So this is kind of a more detailed type of print message.

414
00:55:36,090 --> 00:55:43,110
So I'm printing out whether things are kind of we're thinking of these as integers,

415
00:55:43,110 --> 00:55:55,229
if things are even and negative or odd and negative or even positive and or odd and positive.

416
00:55:55,230 --> 00:56:04,590
So there's kind of a lot more conditions. I mean, you could you could you could write this as a longer effects of change.

417
00:56:05,010 --> 00:56:10,680
So there's kind of more than one way to write this that you can you could also write this as kind of as

418
00:56:10,850 --> 00:56:19,280
an AFL statement within a log with within and if it else changed so that you can see the logic here.

419
00:56:19,290 --> 00:56:23,180
So we have. Okay.

420
00:56:23,250 --> 00:56:34,649
So the first thing is the first condition is this basically tests whether or not this is and so this is actually,

421
00:56:34,650 --> 00:56:39,510
I would say, probably the most common use of this remainder of this remainder.

422
00:56:39,510 --> 00:56:51,690
OPERATOR You know, a lot of you know, it's kind of it's common that you want to test whether or not certain numbers are even are odd.

423
00:56:52,140 --> 00:57:00,060
And so kind of an easy way of doing that is just to look at the modulus of that variable with two.

424
00:57:00,060 --> 00:57:04,340
One is the modulus with two is it's zero.

425
00:57:04,770 --> 00:57:09,150
I mean, even number if it's one, that means it's an odd number.

426
00:57:09,880 --> 00:57:15,610
I mean, if you're if you're thinking of looking at just an integer numbers.

427
00:57:16,410 --> 00:57:19,650
So this first condition is just testing whether or not it's even.

428
00:57:20,280 --> 00:57:31,020
Okay, so you're saying so if it is even then I'm going to go in in this section only if it's even going to go in this section.

429
00:57:31,860 --> 00:57:35,940
But the even numbers you can kind of subdivide the even further.

430
00:57:37,020 --> 00:57:45,430
I'm going to have a different message for the negative versus the non negative in dollars.

431
00:57:45,720 --> 00:57:49,980
Okay. So if it's negative, I'll print out the message.

432
00:57:49,980 --> 00:57:54,660
Even a negative. If it's basically not negative.

433
00:57:54,660 --> 00:58:01,740
So non negative for now, a message X, even a non negative and beautiful.

434
00:58:01,830 --> 00:58:09,180
Okay. So if this first thing is not true, the first condition at the top is not true.

435
00:58:09,660 --> 00:58:15,960
You're going to go down and check with this. But let's see.

436
00:58:16,920 --> 00:58:26,160
Yeah. So you're going to check this message. So if it's less than zero, you automatically know that it's odd and negative.

437
00:58:26,550 --> 00:58:38,330
Okay. If that's not true, you're going to go to the bottom and the bottom takes you.

438
00:58:38,780 --> 00:58:43,820
You know, you already know that it's it's not even know that it's not negative.

439
00:58:45,080 --> 00:58:50,030
So you know that it's odd and non-negative. Print out this message at the bottom.

440
00:58:50,930 --> 00:58:58,640
So the fact that these two messages and some of these two conditions here are false.

441
00:58:59,240 --> 00:59:07,520
And so if you're here inside this country else, if you're executing the body of the house part,

442
00:59:08,120 --> 00:59:17,190
you know that the these two conditions are so you know that it's first of all, that it's odd and you know that it's not nice.

443
00:59:17,570 --> 00:59:22,130
So it's okay to print out the message that it's odd and non-negative.

444
00:59:26,210 --> 00:59:38,450
So that's just kind of one way, an example of, you know, if false statements within the false statements or if else if statements could be used.

445
00:59:39,410 --> 00:59:47,090
I mean, you could even go further if false statements within if some statements within a false statements.

446
00:59:47,090 --> 00:59:54,350
But I think if you're doing that, I think there's usually a better way to write it.

447
00:59:54,350 --> 01:00:05,810
I think, yeah, I think it fails state if you want it full statement within the larger the false statement if I do that that's fairly common.

448
01:00:13,420 --> 01:00:20,560
Okay. So let's just want to pause. Is this really just a simple example for us to think?

449
01:00:21,430 --> 01:00:26,580
So we have. So what if we just run this principle?

450
01:00:27,040 --> 01:00:35,620
So we have to. So where is the first line where assigning x value to.

451
01:00:35,650 --> 01:00:40,299
Right. So access the value to what is in the second line.

452
01:00:40,300 --> 01:00:44,410
And we have a logical expression where we're saying if.

453
01:00:45,280 --> 01:00:50,460
Well, the logical expression itself is three is less than two or four.

454
01:00:51,550 --> 01:00:55,810
It actually doesn't really matter what's here since we have true here,

455
01:00:56,740 --> 01:01:04,120
since we're doing or we kind of automatically know that this entire logical expression is true.

456
01:01:05,530 --> 01:01:15,390
True, and one is. The entire thing will evaluate to true.

457
01:01:16,650 --> 01:01:21,730
So I think we already know that we're going to execute kind of this this pass.

458
01:01:21,750 --> 01:01:26,730
We're going to execute that the code corresponding to it part of the income statement.

459
01:01:27,420 --> 01:01:34,559
So we're going to have if we're going to have X is equal to two times X or is that is that just

460
01:01:34,560 --> 01:01:44,760
means that we're going to assign the value to X two times what was previously stored here.

461
01:01:44,760 --> 01:01:52,710
So actually for I think it's right so if you run this and should print out the value for.

462
01:01:56,750 --> 01:02:02,390
That's just the. A previous little.

463
01:02:04,600 --> 01:02:12,459
Jews are still very uneasy before we move on.

464
01:02:12,460 --> 01:02:18,130
So that was the covered logical expressions and the false statements.

465
01:02:23,720 --> 01:02:32,660
So these, you know, the decent amount of time. So I think, you know, just start talking about functions for the rest of the class.

466
01:02:33,140 --> 01:02:37,790
I don't know if we'll finish everything. Everything that I have on the slides, but let's get started.

467
01:02:40,190 --> 01:02:53,090
So functions is just I mean, in R at least it's kind of a way to think about it as it's similar to any kind of mathematical function that,

468
01:02:53,600 --> 01:03:02,090
you know, they take some input and they do a kind of a sequence of some sequence of computations and then it returns some output.

469
01:03:02,380 --> 01:03:07,670
Okay. So that's what a function does. An argument function takes some type of input.

470
01:03:08,300 --> 01:03:14,570
It has a bunch of code inside the function that does some things, but then it just returns a result.

471
01:03:16,070 --> 01:03:21,080
Okay, so why why did you need to worry about functions?

472
01:03:22,160 --> 01:03:31,350
So it's, you know, it's very useful so I can use modularized, meaning, you know,

473
01:03:31,490 --> 01:03:38,360
you can write if you have some necessary computation that needs to be used a lot,

474
01:03:38,360 --> 01:03:46,310
you can kind of write, write that type of computation in a, in a separate function, kind of separate from your main code.

475
01:03:46,730 --> 01:03:49,730
And then just, you know, use that function whenever you need it.

476
01:03:49,730 --> 01:03:55,700
You don't have to keep re redoing that type of computation in your in your main program.

477
01:03:57,260 --> 01:04:08,840
So this increases the readability. So if you just have code that kind of calls use a sub function,

478
01:04:13,790 --> 01:04:24,740
it's a lot more it's a lot easier to see what's going on rather than kind of repeating maybe a lot of your computations here, here and there.

479
01:04:24,830 --> 01:04:32,230
Okay. And then to reduce the need to repeat code or really to reduce the number of errors.

480
01:04:32,240 --> 01:04:41,300
So it's easy to write a general function once and kind of test that function a lot and make sure that it works.

481
01:04:41,780 --> 01:04:52,340
And then you can kind of reuse function a lot and a lot of other code to be kind of more confident that, you know,

482
01:04:53,300 --> 01:05:00,860
those sorts of computations that don't have errors since they're just using a function that you've kind of tested thoroughly.

483
01:05:02,090 --> 01:05:07,309
All right. So there's, I guess, two ways of using functions and ah, there's basically,

484
01:05:07,310 --> 01:05:16,070
I guess using built in functions for these built in meaning that these are available in base R,

485
01:05:16,460 --> 01:05:20,570
which is, which is technically a package, but it's, it's always loaded by default.

486
01:05:21,180 --> 01:05:30,680
And so the base R package and then graphics and the stats package are usually always loaded into R started.

487
01:05:31,550 --> 01:05:34,340
So those are those are always kind of available.

488
01:05:34,700 --> 01:05:42,710
So these include things like the print function or the sum function, which is some function just computes the sum of a bunch of numbers.

489
01:05:43,310 --> 01:05:48,240
I mean, there's, there's many more functions than this, but these are examples of functions.

490
01:05:48,260 --> 01:05:54,350
There's also functions that you could use on other packages that people have written.

491
01:05:54,350 --> 01:06:00,149
So, you know, there are many packages that you can load into R and once you've loaded them,

492
01:06:00,150 --> 01:06:04,340
then you can use the functions that are made available on that package.

493
01:06:04,880 --> 01:06:13,760
Okay. So that's one, one way to use R functions and just using directly using functions that that other people have written.

494
01:06:16,790 --> 01:06:23,630
Another way of using functions is just using functions that you've written yourself so you can define your own function in order.

495
01:06:24,230 --> 01:06:41,030
Okay. Well, I think that's about being able to use functions that are available, that are useful or knowing how to use those functions is is useful.

496
01:06:41,030 --> 01:06:44,820
I think being able to write your own functions is very useful as well.

497
01:06:44,840 --> 01:06:53,389
It gives you a lot of flexibility when you're working with this, you know, if you need to do some type of computation,

498
01:06:53,390 --> 01:06:58,280
but there's kind of no function available that does exactly what you want.

499
01:06:58,280 --> 01:07:03,620
Kind of being being able to write your own functions gives you kind of a lot more flexibility, right?

500
01:07:03,620 --> 01:07:13,110
You can. You don't have to depend on something, some something being implemented, which if it doesn't exist, you can just write your own function.

501
01:07:13,290 --> 01:07:15,149
Okay. All right.

502
01:07:15,150 --> 01:07:27,770
So there are kind of the general form of writing a function, you know, or there's really just three main components in the function definition.

503
01:07:27,780 --> 01:07:31,109
There's the I mean, you have to pick a name of the function.

504
01:07:31,110 --> 01:07:35,099
So there's the function name that we used to call function.

505
01:07:35,100 --> 01:07:42,360
So these are calling. The function just means you're using the function in your code.

506
01:07:42,520 --> 01:07:55,860
Okay. So you're using your function in the code later on each time to you as that's what we referred to as calling the function.

507
01:07:56,610 --> 01:08:01,320
And then the arguments are something called parameters.

508
01:08:02,100 --> 01:08:10,379
Those are like the input of a function. So you have to specify a names for the arguments or parameters of your function.

509
01:08:10,380 --> 01:08:16,080
So that's the input function. And then you have to do a return.

510
01:08:16,950 --> 01:08:27,929
Are you are you should always think of a return value. So you actually you don't actually have to do this explicit return keyword.

511
01:08:27,930 --> 01:08:31,260
So they have this this function called return.

512
01:08:31,710 --> 01:08:39,240
If you kind of want to explicitly say what the function is, return, you don't absolutely have to use it.

513
01:08:40,430 --> 01:08:45,479
If you don't have this return, keyword R will just return.

514
01:08:45,480 --> 01:08:53,850
The value of the is the last missed the last thing that was executed in the function.

515
01:08:55,680 --> 01:09:01,280
So some people write it like that. I actually kind of like to put a return at the end.

516
01:09:01,310 --> 01:09:07,680
I think it just makes it a little bit more clear exactly what the function is returning.

517
01:09:10,560 --> 01:09:14,490
But you absolutely have to if you don't if you don't want to.

518
01:09:16,320 --> 01:09:20,459
So here are just a kind of a basic function, but I think it's helpful to look at it.

519
01:09:20,460 --> 01:09:33,270
Just so you know, for a specific example, you can see how to write the different pieces of the function.

520
01:09:33,270 --> 01:09:43,350
So if you wanted to write a function with the function named Square, this is the way you would do it in R So you write,

521
01:09:43,530 --> 01:09:51,809
you write the name of the function first and then you kind of have this assignment to

522
01:09:51,810 --> 01:09:58,170
square and then you write the keyword function and then you open and close parentheses,

523
01:09:58,170 --> 01:10:02,230
and then you're going to put the of the arguments inside of the friends.

524
01:10:02,400 --> 01:10:06,270
So you could have here we only have it in this example.

525
01:10:06,270 --> 01:10:12,870
We only have a single input of a you could have multiple.

526
01:10:13,290 --> 01:10:22,740
So I'll probably show some examples later at the other multiple arguments, you're going to separate each argument by cut by a comma.

527
01:10:23,820 --> 01:10:33,780
But here we only have a single argument and we're thinking of this as just a single number, and then you can just return the value that we want.

528
01:10:34,320 --> 01:10:38,310
So this function just returns to square in that number.

529
01:10:38,460 --> 01:10:42,000
Okay, so it's just going to return X times x.

530
01:10:42,600 --> 01:10:53,790
So once you define this function, so once you once you've run this code here that defines it, you can basically use one square is in your environment.

531
01:10:54,150 --> 01:11:00,360
Environment means in square of ten, so that'll output the correct number.

532
01:11:00,720 --> 01:11:06,150
Okay. So that's just example of writing a function.

533
01:11:06,150 --> 01:11:11,940
So kind of the key, key things are following is this format where you know,

534
01:11:11,970 --> 01:11:20,220
the keyword after the function name and then add the body of the function is inside of curly braces.

535
01:11:21,030 --> 01:11:22,860
You have the function name,

536
01:11:24,390 --> 01:11:33,930
start things out and arguments here and we should at least be clear about it and you should at least know what you're returning.

537
01:11:33,950 --> 01:11:47,429
I guess you don't absolutely have to use the keyword that's I usually do it so that let's do a slightly more complicated example.

538
01:11:47,430 --> 01:11:53,309
So let's say we wanted to write a function that does the following things.

539
01:11:53,310 --> 01:11:59,130
So it takes again, it's going to take a single number, let's say it's an integer.

540
01:12:01,560 --> 01:12:12,150
It's basically the pointer return, I guess. Each combination of positive or even positive are not positive.

541
01:12:12,150 --> 01:12:19,870
And even so, there's like four possible things that can be done with you to tell us if changed.

542
01:12:22,290 --> 01:12:24,300
So one way of writing it is this way.

543
01:12:24,900 --> 01:12:32,520
So we have we're going to call our function positive, even kind of the arguments, the name of the argument we're calling X.

544
01:12:33,360 --> 01:12:40,020
And so we can kind of express the logic if all else changed.

545
01:12:44,250 --> 01:12:53,280
And so we're going to return a number to one negative two or negative one, kind of depending on which of these four possibilities we have.

546
01:12:55,230 --> 01:13:01,100
So yeah, so I'm just doing this offensive change.

547
01:13:01,110 --> 01:13:11,910
So the first condition is positive and even second condition is positive and on current condition is non positive.

548
01:13:12,660 --> 01:13:21,240
Even then, you know, if all of those are false, then the only remaining option is non positive and odd.

549
01:13:22,680 --> 01:13:31,290
So this function should kind of implement the logic expressed here.

550
01:13:31,830 --> 01:13:39,420
There's four options which we can express as a with the effects of change.

551
01:13:39,430 --> 01:13:43,800
So again, once you've kind of run this function definition,

552
01:13:44,670 --> 01:13:53,490
you can use it as many times as you want again and again to the positive, even just run in a bunch of bunch of times as an example.

553
01:13:53,890 --> 01:14:05,560
Okay, so let's. Maybe we'll talk about a little bit more of different ways of making it, I guess, more user friendly.

554
01:14:05,560 --> 01:14:18,790
But basically this example, we kind of prints out it, it stops the function and prints out an error message.

555
01:14:20,500 --> 01:14:28,580
If this if you don't enter an integer. So I guess and guess what it does, if you insert an integer here, it's finished.

556
01:14:28,710 --> 01:14:37,780
It doesn't necessarily do what you want. So in this version of positive, even say yes, I gave it a different name.

557
01:14:38,320 --> 01:14:47,290
Positive, even safe. This kind of gives an error message if the if it's not an integer.

558
01:14:47,470 --> 01:14:56,500
Okay. So if you run this type of thing, if you if you run this function and you enter it, not a non integer number,

559
01:14:58,540 --> 01:15:04,359
it's going to look at this if statement it executes this stop function and ah,

560
01:15:04,360 --> 01:15:09,130
so it basically just kills the function, it doesn't really return anything.

561
01:15:09,640 --> 01:15:12,730
And when it does that, it also prints out this message.

562
01:15:15,130 --> 01:15:21,700
So yeah, if you run it here in this example, I ran the function with the values 7.1.

563
01:15:22,360 --> 01:15:27,660
So it just prints out an error and it prints out the error message that you get.

564
01:15:27,850 --> 01:15:38,340
So that's sometimes useful to know if you're writing functions that others might use and you want to make them a little more friendly.

565
01:15:38,350 --> 01:15:48,280
If you wanted to print out a error message as to why things are not running properly.

566
01:15:49,690 --> 01:15:56,080
All right. So, yeah, I guess this is not it's just something worth mentioning.

567
01:15:58,420 --> 01:16:01,530
You can choose function names, basically, however you want.

568
01:16:01,540 --> 01:16:08,530
You just have to follow the same rules for variable names that we talked about on Monday.

569
01:16:10,510 --> 01:16:19,060
So it's just the exact same rules as for variable names, but you can't have these special characters, for example.

570
01:16:20,450 --> 01:16:25,120
There's nothing new there. It's funny, I just finished with this slide.

571
01:16:29,860 --> 01:16:39,160
So there's a few. Yeah, I guess the other. The only other thing I mentioned to you on are reserved words and you can use as a function name.

572
01:16:42,130 --> 01:16:48,640
So these are the reserved words like is else while word function itself.

573
01:16:48,640 --> 01:16:54,910
So you you can't create a function called if and so that'll mess everything up.

574
01:16:56,530 --> 01:17:08,260
You can't create a function called true, for example, but they're not that many reserve ones.

575
01:17:08,310 --> 01:17:19,209
I think there's only. So you actually can use some of the built in function names when defining your own function,

576
01:17:19,210 --> 01:17:24,310
but I wouldn't recommend it like you couldn't define your own function called print.

577
01:17:24,310 --> 01:17:36,220
And it would change that. It would change the print function bar, or at least within that bar session.

578
01:17:36,670 --> 01:17:44,590
It would it would change what the print function does. But I generally don't recommend that, you know, there's really no point.

579
01:17:44,590 --> 01:17:58,989
And it could it could screw some other parts of your cover up and it's just over six or seven slides left.

580
01:17:58,990 --> 01:18:09,070
So I think next time we'll start with what the default arguments are in functions, and that's it for today.

581
01:18:09,760 --> 01:18:15,549
So you don't have class on Monday next.

582
01:18:15,550 --> 01:18:21,960
The next time you use.

583
01:18:45,980 --> 01:18:47,080
Do anything make.

