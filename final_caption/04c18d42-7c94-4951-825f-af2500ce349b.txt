1
00:00:07,820 --> 00:00:25,040
Okay. Let's get started. So just to remind a reminder for a reminder that there is a form of two.

2
00:00:25,060 --> 00:00:42,379
Today Omokri is out so you can check it and see whether I believe that we already cover all the material needed for home of three,

3
00:00:42,380 --> 00:00:49,220
so you can start right away. But if you see anything you don't understand.

4
00:00:50,330 --> 00:00:55,160
Feel free to ask questions about the material.

5
00:00:57,120 --> 00:01:11,360
So, uh. You and the group assignment was done in the project proposal assignment is also out.

6
00:01:11,870 --> 00:01:18,300
So those are those are the the due date is October 28.

7
00:01:18,340 --> 00:01:27,890
So you have more time. Uh, but yeah, probably you need to work on the both portable assignment together a little bit.

8
00:01:30,560 --> 00:01:34,940
And so that's you know, that's all I have.

9
00:01:35,300 --> 00:01:39,320
You should have information about it.

10
00:01:41,420 --> 00:01:44,570
So if you go to home page there.

11
00:01:44,690 --> 00:01:48,430
So there is information of it.

12
00:01:48,470 --> 00:02:00,760
So there is a commentary, but also there is information about these, uh, final project and uh, the team assignment is here.

13
00:02:00,770 --> 00:02:06,740
So if you see, if you lose your name or if you think that they'll send what was done incorrectly.

14
00:02:07,360 --> 00:02:20,900
I just let me know. Okay. Any, any other question before starting your project, which implies of past projects.

15
00:02:20,920 --> 00:02:24,050
So, uh, yeah. So I can.

16
00:02:25,160 --> 00:02:30,680
Uh, yeah, they, they have, there are a lot of examples people have done.

17
00:02:32,060 --> 00:02:36,530
I think it's a good idea to share what others have done.

18
00:02:36,530 --> 00:02:43,820
I think so. Because it's a, you know, either you don't want to do the same thing and, but you can also,

19
00:02:45,170 --> 00:02:50,120
uh, you can also get some hint, give some direction about what, what others have done.

20
00:02:50,180 --> 00:02:57,200
So I'll try to, uh, I'll try to share some of the examples.

21
00:02:57,200 --> 00:03:01,849
So I'm just trying to figure out what, what's the right way to do it.

22
00:03:01,850 --> 00:03:08,600
But at least I think I can easily share the titles of what others have done.

23
00:03:09,050 --> 00:03:18,010
And, uh, yeah, so, so I'll prepare some material, uh, in the next, the next few weeks.

24
00:03:18,020 --> 00:03:21,790
Yeah, that's a good question. Are there other questions?

25
00:03:23,770 --> 00:03:29,360
Okay. So let's get started.

26
00:03:29,480 --> 00:03:37,639
Okay. So, so this is the we're starting the single optimization.

27
00:03:37,640 --> 00:03:48,170
Optimization. So before doing the single dimension optimization, we're going to also start with the root root finding problem.

28
00:03:48,170 --> 00:03:56,120
So let's formulate the problem a little bit. So let's say you have a function, then take the.

29
00:03:56,870 --> 00:04:01,820
So it's a one dimensional function, meaning that the input is a scalar, output is scalar.

30
00:04:02,000 --> 00:04:06,409
So usually take the real value and output.

31
00:04:06,410 --> 00:04:12,120
Real value. So. Question.

32
00:04:12,130 --> 00:04:24,210
So if you have. So the problem of the root finding is they're solving these problems.

33
00:04:24,240 --> 00:04:29,980
So. So finding X that the F of X is zero.

34
00:04:30,250 --> 00:04:36,580
Okay. So that's the root finding problem, but usually root finding problem.

35
00:04:36,730 --> 00:04:43,150
In this case, we're trying to find the find the solution numerically, not analytically.

36
00:04:43,150 --> 00:04:48,160
So usually we are not trying to find the root for all possible root.

37
00:04:48,460 --> 00:04:54,400
So when you are given root, finding problem usually are given one point.

38
00:04:54,580 --> 00:05:02,110
So you you're given an interval where you actually know the which values are positive, which values are negative,

39
00:05:02,590 --> 00:05:10,920
and you're trying to find the X value or that where F of x is zero assuming the the function is continuous.

40
00:05:10,930 --> 00:05:18,820
So it's not is a is not very general version of root defining problem is a more specific person or root finding problem.

41
00:05:19,300 --> 00:05:30,100
Okay. So in the minimum of the image and problem can be formulate this way so that

42
00:05:30,350 --> 00:05:36,259
you're trying we're trying to find a local optimum okay so local minimum usually.

43
00:05:36,260 --> 00:05:48,350
So let's say you have a minimum year where you're trying to find the X star, where a star is strictly smaller than any other f of x nearby.

44
00:05:48,860 --> 00:05:55,069
So that that's a local minimum, local minimum and optimism problem can be formulated.

45
00:05:55,070 --> 00:06:03,049
Find the minimum. Okay. Sometimes you may want to find the maximum, but the finding maximum is basically just change the sign of function.

46
00:06:03,050 --> 00:06:10,130
Then if you minimize it, that'll be equivalent of the maximum aging so that we're going to function.

47
00:06:10,970 --> 00:06:18,050
So root finding and optimization are quite closely related problems, but not exactly the same.

48
00:06:19,040 --> 00:06:28,190
Okay. So we're going to we're going to address course but so, so.

49
00:06:30,220 --> 00:06:36,940
So in a certain circumstances, you can convert one problem into the other problem.

50
00:06:37,240 --> 00:06:41,330
So. So how do you do it?

51
00:06:41,570 --> 00:06:52,280
Okay. So if you so you can you can convert the root finding problem into a optimization problem.

52
00:06:52,460 --> 00:06:55,920
If you define a new function this way. Right.

53
00:06:55,970 --> 00:07:09,290
So I'm going to square my function then, you know, the finding the root is a is equivalent to finding the local minimum at that at the point.

54
00:07:09,290 --> 00:07:19,910
So you can do the root finding using the optimization, the routine, if you don't how to, how to do the one dimensional optimization.

55
00:07:21,020 --> 00:07:28,610
So same thing you can if you so if you know how to the root of finding you can solve the

56
00:07:28,610 --> 00:07:34,939
optimization problem by taking a derivative and try to find the point where derivative is,

57
00:07:34,940 --> 00:07:43,099
you know. So this is not not as straightforward as a previous case because you can imagine that even if the derivative is zero,

58
00:07:43,100 --> 00:07:49,219
it may not be it may not be actually the local minimum.

59
00:07:49,220 --> 00:07:53,020
Sometimes the second derivative is zero, then it may not.

60
00:07:53,030 --> 00:08:00,439
So you need to do the extra check. But in principle, you know, those problem can be interchangeable like this.

61
00:08:00,440 --> 00:08:03,960
So these are quite related problems. Okay.

62
00:08:06,900 --> 00:08:19,980
So. So to do this we're going to use a basically framework using so I trading framework three framework that we're using.

63
00:08:19,990 --> 00:08:27,549
You are trying to find a solution using some iteration. So how so what's the overall scheme.

64
00:08:27,550 --> 00:08:37,540
So we're starting with some initial guest X, you know, which, so you need a, you need a good starting point.

65
00:08:37,540 --> 00:08:45,700
So I'm going to guess my, my route is zero but is the most likely your initial guest is wrong.

66
00:08:46,690 --> 00:08:55,500
Then you produce a sequence of value x one and x two and so on, based on the result of evaluation.

67
00:08:55,690 --> 00:09:05,260
Okay. So each of the step does a very minimal amount of operations, addition multiplication and some function evaluations.

68
00:09:08,200 --> 00:09:14,590
But, you know, those addition multiplication is usually very, very, very fast.

69
00:09:15,190 --> 00:09:20,649
The we assume that the function evaluation takes quite a long time.

70
00:09:20,650 --> 00:09:23,950
So your function could be sometimes very quick.

71
00:09:23,950 --> 00:09:27,550
But a lot of cases when you have a whole team is your problem.

72
00:09:28,210 --> 00:09:36,740
Your function is a function of your data. So you need to you need to iterate all the data points and to produce some value like a likely.

73
00:09:36,740 --> 00:09:46,030
The function, for example is a good example, but many, many cases your function evaluating a function itself is not very cheap operation.

74
00:09:46,270 --> 00:09:49,870
So we are assuming that your function evaluation can be quite expensive.

75
00:09:51,310 --> 00:10:02,710
So, so when you, when you try to evaluate the, how well my algorithm works, it's a, you know, most important thing is the how,

76
00:10:02,890 --> 00:10:11,530
how, how much I can save the number of evaluation of the of my function if if the function evaluation very cheap.

77
00:10:11,980 --> 00:10:20,440
Well I can just scan all possibilities of X and try to find find the root of minimum so it becomes a trivial problem.

78
00:10:21,220 --> 00:10:31,030
But if you are, you know, it takes 1/2 for evaluating function every time that you really don't want to do it to excessively, for example.

79
00:10:32,110 --> 00:10:36,310
So, so we are assuming that the function evaluation is about a length.

80
00:10:37,150 --> 00:10:43,360
So the efficient it when you say that some optimization method or with finding method is efficient,

81
00:10:43,780 --> 00:10:47,650
that means that it requires a small number of function evaluation.

82
00:10:48,940 --> 00:10:54,610
Okay. And the you cannot really get that exactly same solution than me.

83
00:10:55,060 --> 00:10:58,180
You understand that because there is a there's an errors involved.

84
00:10:58,180 --> 00:11:08,770
So we are allowing some error. So to to the amount of error you can quantify is that if you know that resolution is X star,

85
00:11:09,310 --> 00:11:20,020
then if you the difference between the that the the best guess at the step N and a with a resolution

86
00:11:20,020 --> 00:11:33,190
is a is an error and a that's that's the e of and so if we say that your organism is an order of P,

87
00:11:33,670 --> 00:11:42,459
that means that if you so your error is are reducing by certain polynomial degree.

88
00:11:42,460 --> 00:11:50,740
So let's say I have an error of 0.1, then the next, next, in the next next iteration,

89
00:11:50,740 --> 00:12:01,660
if there is a guarantee that my error will reduce by, you know, reduced to 0.21 next time, next time, 0.0001 and so on.

90
00:12:01,930 --> 00:12:08,950
That's a, that's a good algorithm because you're. Excuse me.

91
00:12:13,800 --> 00:12:18,750
Uh huh. Okay. Um. Sorry. If you.

92
00:12:19,300 --> 00:12:29,459
Yeah. If you expect that your error goes down exponentially, then you basically will have a good confidence that these are going to be the conversion,

93
00:12:29,460 --> 00:12:34,140
that your solution will be closer and closer to the real solution.

94
00:12:34,140 --> 00:12:38,340
The actual solution. As you increase the number of iterations.

95
00:12:39,480 --> 00:12:47,600
So that's a general just the description. So we're going to start with the root finding algorithm, and there will be four methods.

96
00:12:47,600 --> 00:12:56,360
We're going to try first methods by section method and uh, well, I mean second fixed point iteration,

97
00:12:56,360 --> 00:13:05,450
we're actually just going to skim over because that's really, really a very simple extension.

98
00:13:05,540 --> 00:13:13,700
But so by section method and Newton's method, the second method is actually the method we're going to deeply look at in terms.

99
00:13:16,150 --> 00:13:20,760
So, uh, bisexual method. Okay, so you're.

100
00:13:20,770 --> 00:13:27,040
You have a, uh. I mean, I mean, before before going through this.

101
00:13:27,190 --> 00:13:30,880
Okay, so let's say, you know that.

102
00:13:32,350 --> 00:13:38,890
So it's a it's a good to visualize it. So let's say you you have a function.

103
00:13:58,510 --> 00:14:04,280
So you saw it here. If you know how the function looks like, it's very easy, right?

104
00:14:04,870 --> 00:14:10,890
The problem is that you don't know how the function looks like. You only have some value evaluated.

105
00:14:12,100 --> 00:14:22,420
So let's say you have F of a, you know that F of A is greater than zero, f a, b is less than zero.

106
00:14:23,020 --> 00:14:29,290
Okay. But you have no idea how this function will look like in between.

107
00:14:29,950 --> 00:14:34,360
Okay. So. But you need to find the root.

108
00:14:35,330 --> 00:14:39,220
Okay, so what? What would you do?

109
00:14:39,250 --> 00:14:44,130
What's your ideal? If you need to find out, do.

110
00:14:44,590 --> 00:14:48,460
So I want to specify these kind of steps.

111
00:14:48,790 --> 00:14:56,610
What don't you do? I would say at this point, we're close to the midpoint.

112
00:14:56,820 --> 00:15:03,030
Okay. So what I do is the ball I have, these two values are going to start start at the midpoint.

113
00:15:03,240 --> 00:15:08,900
Okay. So, so. That's just one idea.

114
00:15:09,500 --> 00:15:15,500
Okay, very good. What if you have a full day here.

115
00:15:17,270 --> 00:15:22,710
For be here. You can start you can try the midpoint.

116
00:15:23,280 --> 00:15:30,329
Okay. And so this is like, you know, typical, you know, guessing problem, you know,

117
00:15:30,330 --> 00:15:36,270
is it is a greater you have a you have a magic secret number you you need to

118
00:15:36,270 --> 00:15:40,860
guess and I'll try to go is a higher than this value lower than this value.

119
00:15:41,310 --> 00:15:47,010
But in this case, if you do the midpoint, you know it it will work eventually.

120
00:15:47,400 --> 00:15:52,350
But maybe maybe should I try this?

121
00:15:52,950 --> 00:16:01,320
Because even even though I know that this function is not going to be linear, uh, maybe, maybe this is,

122
00:16:02,640 --> 00:16:10,080
this is, this is a, this has a more chance to be closer to higher chance to be closer to the actual solution.

123
00:16:10,080 --> 00:16:17,040
So that could be some idea, right? So there there are multiple different kind of ideas like this.

124
00:16:17,640 --> 00:16:24,510
So in the this method implements those idea into working algorithms so that that's what we are going to try.

125
00:16:24,840 --> 00:16:33,200
So conceptually, it's actually very easy to just say, oh, I'm going to do this, I'm going to do this.

126
00:16:33,210 --> 00:16:36,570
Okay, but let's say you're doing the midpoint.

127
00:16:36,870 --> 00:16:41,520
Okay, very, very good idea. Let's say you're doing the linear interpolation somehow.

128
00:16:42,180 --> 00:16:51,960
So and there might be other way when you have this idea, can you actually articulate this idea into working algorithm?

129
00:16:52,290 --> 00:16:55,320
Okay. That's that's what you need to practice.

130
00:16:55,370 --> 00:17:04,980
And so in that, uh, from that perspective, because it, this midpoint idea is very simple.

131
00:17:06,180 --> 00:17:08,730
Instead of just looking at the code right away,

132
00:17:09,330 --> 00:17:17,580
it's really recommended that you actually try to write the code yourself and see how, how close your, your algorithm is.

133
00:17:17,580 --> 00:17:28,379
And you don't have to come up with the exact same function, but you can, you can see whether your implementation also works in the column page.

134
00:17:28,380 --> 00:17:32,610
And that's why having the color page would be great because it's just the same function

135
00:17:32,610 --> 00:17:37,970
that the same name and just run that cell into the other cells and see what happens,

136
00:17:37,980 --> 00:17:48,120
right? So that's a good exercise to increase your competence, improve your skills, to implement some sophisticated algorithms.

137
00:17:49,590 --> 00:17:53,670
So yeah, that being said, let's try to start with a by section algorithm.

138
00:17:54,090 --> 00:18:01,739
Okay. So bisexual algorithm, the assumption is that we assume that our function is a continuous.

139
00:18:01,740 --> 00:18:04,890
If it's not continuous, it's very tricky to find the root.

140
00:18:06,000 --> 00:18:10,950
And so the requirement is that we have a zero and we, you know,

141
00:18:11,880 --> 00:18:16,890
it doesn't matter which one is plus and which one is minus, but they have to have an opposite sign.

142
00:18:17,380 --> 00:18:22,510
Okay. So then the algorithm is simple.

143
00:18:22,690 --> 00:18:28,710
So take the midpoint. Okay. Calculate F of x.

144
00:18:29,200 --> 00:18:33,820
Okay. Then if F of x is zero.

145
00:18:33,850 --> 00:18:37,000
Wow. We are lucky. And done. Yeah. So nothing.

146
00:18:37,540 --> 00:18:41,140
Nothing to do. But if.

147
00:18:41,830 --> 00:18:47,680
When? If not, then we need to decide which way we want to go.

148
00:18:48,400 --> 00:18:51,820
So if we know that, which one is which.

149
00:18:51,850 --> 00:18:56,350
So in this case, we know F of X plus f f of these negative.

150
00:18:56,980 --> 00:19:02,380
So if a midpoint is plus, we need to we know that we should go to the right.

151
00:19:02,890 --> 00:19:12,880
But in the general case, if we don't know F, f, f of a zero is a plus or minus, instead of a evaluating sign of F of x is zero.

152
00:19:13,450 --> 00:19:24,910
You can just multiply this together and if f f f over eight, zero and zero or the are negative,

153
00:19:24,920 --> 00:19:31,030
that means that there there is a solution between the eight and zero because these are multiplication negative.

154
00:19:31,600 --> 00:19:40,420
So that means that I'm going to find the next solution between the between the A-1 and so a zero and X.

155
00:19:40,690 --> 00:19:47,170
So I'm going to say I'm going to say my, my next interval is A to X.

156
00:19:47,350 --> 00:19:51,880
So A1 is A zero and B one is now X zero.

157
00:19:52,130 --> 00:19:58,480
Okay. If A and an x are the same sign, that means that the solution is between the x and B.

158
00:19:59,140 --> 00:20:04,060
So I'm going to set my new interval into x and B you can.

159
00:20:06,740 --> 00:20:17,059
So instead said X one is a new midpoint and keep doing this until you find that your interval is

160
00:20:17,060 --> 00:20:23,720
small enough or you actually find the actual route where f of x equals exactly exactly zero.

161
00:20:26,160 --> 00:20:29,360
So. So these are freedom.

162
00:20:32,070 --> 00:20:42,440
How do you think distribution works in terms of letters? So you so well in terms of errors.

163
00:20:42,510 --> 00:20:47,360
So. So your your error should reduce.

164
00:20:47,570 --> 00:20:51,410
In which order? What is a p? What is a P here?

165
00:21:06,730 --> 00:21:10,880
One. Why is it one? So your error is.

166
00:21:10,940 --> 00:21:16,210
Yeah. Okay. So your error is the P one because.

167
00:21:16,840 --> 00:21:22,569
So what is a C and D? That's probably better, but a better way to say it.

168
00:21:22,570 --> 00:21:25,960
CFP P, it's a PS1.

169
00:21:26,140 --> 00:21:32,720
What is C? Yeah, I have.

170
00:21:32,930 --> 00:21:42,020
Right. So, you know, if you if you say that my error is well, it's not exactly one half, but just conceptually.

171
00:21:42,170 --> 00:21:52,880
So if we just defined the error, has a actually in this case just a redefine error as the the size of the size of the interval we're looking at.

172
00:21:53,240 --> 00:22:01,700
Then the interval, each interval becomes half. So in some sense, this Caesar, Caesar half, she's actually not important.

173
00:22:02,090 --> 00:22:13,040
But the important thing is that this is a this is the other p the method in terms of the reducing to the one method.

174
00:22:13,040 --> 00:22:17,230
Sorry, indeed. Reducing the, uh.

175
00:22:19,030 --> 00:22:27,010
The reducing the interval. So this method is a linearly convergent if we say the convergence factor is one half.

176
00:22:32,330 --> 00:22:35,890
So let's try to implement this idea.

177
00:22:35,900 --> 00:22:41,870
So I think the idea is very, very straightforward and the matter of how to implement this.

178
00:22:42,020 --> 00:22:56,120
Okay. So, again, if you don't want to be spoiled by by this, you can you have you have a choice of not to look at it and try to implement yourself.

179
00:22:57,860 --> 00:23:08,800
So this basically an algorithm is basically implementing this procedure into working working software here.

180
00:23:09,600 --> 00:23:21,620
So, you know, evaluating if a way and F of B and the the terminating condition here is that so always when you make a function,

181
00:23:22,250 --> 00:23:25,940
it's important to think about how how do I set up the function.

182
00:23:25,960 --> 00:23:30,650
So it's really important to define what's my input, what's my output.

183
00:23:30,650 --> 00:23:40,580
So your input is a function and a two to point and B, but also you need to have a parameter to decide when do I stop?

184
00:23:40,920 --> 00:23:47,920
Okay, so that's when do I say that this is good enough so that that could be subjective.

185
00:23:47,930 --> 00:23:54,980
So you we enter this under the parameter tolerance to your L and the default is ten times ten.

186
00:23:55,820 --> 00:23:59,690
So this tolerance is the tolerance of X.

187
00:23:59,870 --> 00:24:08,090
So I'm going to say if my interval is smaller than this tolerance, then I will say this is good enough.

188
00:24:08,270 --> 00:24:12,010
So I don't need to exactly find the right spot here.

189
00:24:12,020 --> 00:24:27,230
So this is a terminal condition. Okay. So if if this happens, okay, then you can define your routines.

190
00:24:27,670 --> 00:24:36,569
I'm going to say my duties of just the midpoint and I'm going to return the value that what I'm going what I'm going to return is that

191
00:24:36,570 --> 00:24:47,120
the X value that I believe that that that's a that's close to the root and the Y value of the evaluation of the function evaluation.

192
00:24:48,260 --> 00:24:53,510
The nice thing about this are is that you can pass a function as an argument.

193
00:24:53,510 --> 00:25:01,670
So even if you don't know what the function of f f is here, you can still use the F and let them decide how to evaluate.

194
00:25:03,020 --> 00:25:07,429
So if being a is not close enough, you need to reduce the radius.

195
00:25:07,430 --> 00:25:09,290
The interval, how do you reduce the interval?

196
00:25:09,980 --> 00:25:21,370
So to find the midpoint is and check whether F of a and a why the Y value at the midpoint at the same sign or not if it's not the same side

197
00:25:21,380 --> 00:25:31,580
and then the reduce the interval to a to the midpoint otherwise the decision to what the midpoint to the B so that's that's the rule.

198
00:25:32,420 --> 00:25:39,140
So as you see, this is a defined a recursive way and this is the recursive version of a by section and with.

199
00:25:41,530 --> 00:25:49,510
So let's try to run this by section method to find the find the route here.

200
00:25:49,750 --> 00:25:58,180
Okay. So for this function, because F of one is an E minus one minus two.

201
00:25:58,180 --> 00:26:01,299
So E minus three. So we know that is less than three.

202
00:26:01,300 --> 00:26:06,700
So this will be less than zero. F of two is E squared minus four.

203
00:26:06,700 --> 00:26:12,700
So it is greater than zero. So the true solution should be somewhere between those two value.

204
00:26:13,270 --> 00:26:21,130
So let's try. Okay. So when you try this, this is the route you're getting.

205
00:26:21,370 --> 00:26:24,540
Okay. So and this is why value.

206
00:26:24,550 --> 00:26:28,209
So this this is a this is a X value.

207
00:26:28,210 --> 00:26:36,190
And those where it doesn't have exactly, exactly zero, but the F of F of X is very close to zero.

208
00:26:36,190 --> 00:26:42,530
So this seems to be working. Okay. Okay.

209
00:26:43,010 --> 00:26:46,340
But so this is totally fine implementation.

210
00:26:46,550 --> 00:26:58,040
Using recursive recursion is is is totally okay this way sometimes if you use recursion software can be sometimes you know less

211
00:26:58,040 --> 00:27:07,259
efficient less efficient than using using loop it's 111 possible cases especially when you when you run this a lot of times.

212
00:27:07,260 --> 00:27:15,530
So you probably have seen this in the homework too. Sometimes, you know, if you use a tail, just the last problem doesn't work.

213
00:27:15,710 --> 00:27:22,670
So you need to divide a problem to have so that you don't you don't call the crazy number of functions.

214
00:27:23,270 --> 00:27:31,970
Okay. So so if you if you run if you run the five function 5000 times detect each other, then that that'll be really, really slow.

215
00:27:33,710 --> 00:27:38,240
So or sometimes it fails because of the each of the step uses memory.

216
00:27:38,720 --> 00:27:45,920
So I mean this, this version is totally fine, as I said, but if oh I don't want to use recursion.

217
00:27:45,980 --> 00:27:52,390
So this is, I want to use a loop too so that I, I don't have to use recursion.

218
00:27:52,640 --> 00:27:59,900
This is a hard to understand where sometimes your language, it doesn't, doesn't support the recursive formula very well.

219
00:28:00,470 --> 00:28:04,549
So sometimes it's too hard to just implement some rudimentary recursion in the case.

220
00:28:04,550 --> 00:28:12,800
You can use a the loop so you can you can also implement this by using loop.

221
00:28:13,400 --> 00:28:20,450
So in this case, instead of calling them in a recursive way, you can put the wild comment here.

222
00:28:21,110 --> 00:28:25,490
The wild command is basically doing this.

223
00:28:25,670 --> 00:28:33,110
So so in this implementation, we're keeping track of a number of iterations.

224
00:28:33,350 --> 00:28:44,960
Okay? So iterate, so number of iterations of how many, how many times we went over this loop and this is the midpoint.

225
00:28:46,100 --> 00:28:55,610
So and you keep evaluating and if f over eight times these are what the Y value at the midpoint is greater than zero change.

226
00:28:55,760 --> 00:28:58,940
Update your. So.

227
00:28:59,900 --> 00:29:05,180
So in this case, if it's agreed at zero, that means that, you know, like.

228
00:29:05,780 --> 00:29:18,380
Sorry. I'm sorry about that.

229
00:29:19,280 --> 00:29:22,970
So you're so.

230
00:29:23,430 --> 00:29:29,120
Because it's the same size or your. The next interval should be X to be.

231
00:29:29,600 --> 00:29:31,879
So you're you don't need to update the V.

232
00:29:31,880 --> 00:29:40,820
You just did update to a to the midpoint because A becomes the the starting point of the new you got a new interval in the next iteration.

233
00:29:41,600 --> 00:29:46,190
If there is different sign, you need to go through an X.

234
00:29:46,310 --> 00:29:59,960
So in the you update the interval midpoint so that you can start from the right interval so you can keep doing this and okay.

235
00:30:00,350 --> 00:30:09,560
And when, when you find the B and A are less than tolerance value, you just declare that that as a root and return the value.

236
00:30:09,860 --> 00:30:13,310
Okay, so this implementation is much longer.

237
00:30:13,520 --> 00:30:20,299
Maybe you didn't like it already, but there are parts that might be useful here.

238
00:30:20,300 --> 00:30:24,720
So in this version include.

239
00:30:25,310 --> 00:30:29,360
So you have a tolerance but you also have this mix iteration.

240
00:30:29,900 --> 00:30:42,150
Yeah. So. So for whatever reason, you know, these you may want to stop limit the number of iterations you want to run.

241
00:30:42,630 --> 00:30:52,840
So in this case, you can use this next iteration as a parameter and and include them as on other criteria.

242
00:30:52,860 --> 00:31:01,050
So in this case, if number of iterations is greater than the max iteration, you're just a stopping your iteration so you can do this.

243
00:31:02,760 --> 00:31:08,370
Also, if if this happens, that means that this is not converged.

244
00:31:08,670 --> 00:31:18,590
So you return the convergence or convergence equals one so that the users know that, oh, this algorithm didn't converge.

245
00:31:18,600 --> 00:31:24,850
But the answer they gave before, before the stopping criterion is this.

246
00:31:24,870 --> 00:31:28,390
Okay. So that's additional information.

247
00:31:29,880 --> 00:31:40,140
So compared to the, you know, compared to this recursive formula, recursive formula, you can also have an option to.

248
00:31:42,900 --> 00:32:00,460
Sorry. Talking in the morning is not what I'm used to.

249
00:32:02,110 --> 00:32:05,470
So, so sorry for that. My voice problem.

250
00:32:06,160 --> 00:32:09,930
So. Sorry.

251
00:32:12,300 --> 00:32:17,670
So here we have. So if you want to.

252
00:32:18,060 --> 00:32:21,280
So in this case, we are returning iteration and the convergence.

253
00:32:21,300 --> 00:32:27,660
You can do that here too. But doing that is much more complicated in the recursive version.

254
00:32:28,140 --> 00:32:34,760
So that's one region you might want to stay away from some recursive implementation,

255
00:32:34,760 --> 00:32:38,310
although the recursion usually makes your code all simpler and compact.

256
00:32:38,640 --> 00:32:42,990
There are some limitation. You may have to deal with.

257
00:32:43,650 --> 00:32:50,520
So most of the case you you can convert some recursive implementation into non-equity version.

258
00:32:51,000 --> 00:32:55,260
But that could make your code a little bit more a little bit longer.

259
00:32:55,590 --> 00:33:04,530
Okay. So if you do this, then you basically have almost exactly the same answer.

260
00:33:04,650 --> 00:33:10,980
But here it says there how many iteration it use it uses in is 34.

261
00:33:11,400 --> 00:33:14,730
If a convergence is zero, it means that it did converge.

262
00:33:14,910 --> 00:33:22,310
So there's a good sign. So how about this?

263
00:33:22,470 --> 00:33:40,190
So let's. Let's try to find a route. Okay, so I have F over x equals x, and we're trying to find find this find a route using this algorithm.

264
00:33:40,910 --> 00:33:52,010
Okay. And in this case, it uses 35 iterations, and it did find a route that is close to zero.

265
00:33:52,400 --> 00:33:56,890
And this is obviously this function is a route of zero, but seems like it.

266
00:33:57,320 --> 00:34:02,120
You know, you have you have these values.

267
00:34:02,300 --> 00:34:07,700
So here, you know, one values is a heap here, one that is here.

268
00:34:07,850 --> 00:34:12,390
And you wanted to find this value, but you need to try like 35 times that.

269
00:34:12,410 --> 00:34:17,000
That seems like a little bit too much. So can you can it be better?

270
00:34:17,210 --> 00:34:21,710
Are there other other way that it could it could find the route faster.

271
00:34:21,920 --> 00:34:25,100
So that's the next thing we can try.

272
00:34:25,450 --> 00:34:33,570
Okay. So. So Newton Reps method is the next thing we're going to try.

273
00:34:34,890 --> 00:34:48,540
So. So so we didn't go to the fixed point iteration because that's that's very, very, very simple.

274
00:34:49,800 --> 00:34:54,870
For the simpler version of the international method. But I don't think that that's necessary.

275
00:34:54,870 --> 00:34:59,580
So let's think about just the just the this this version directly.

276
00:35:00,600 --> 00:35:12,489
So let's say you're making. So making a function of a g of x as a is a this way.

277
00:35:12,490 --> 00:35:20,590
So you're making x minus and you have f of X here.

278
00:35:21,020 --> 00:35:32,350
Okay. And you have that so so f prime x, you have a derivative here and you have the actual function value.

279
00:35:32,590 --> 00:35:39,400
Okay. So then, then this one, this one has a very interesting.

280
00:35:42,870 --> 00:35:47,060
Interesting properties.

281
00:35:48,900 --> 00:35:52,050
So can you can you figure out what this is?

282
00:35:54,470 --> 00:35:59,890
What? What is this? So f of x divided by so and so.

283
00:35:59,900 --> 00:36:03,410
X divided by a prime x.

284
00:36:03,530 --> 00:36:08,480
What is this? You have.

285
00:36:09,200 --> 00:36:13,490
This is a slope, right? This is this is y value.

286
00:36:14,240 --> 00:36:17,330
So what does it rank? What what does it try to do?

287
00:36:19,120 --> 00:36:31,409
So you have in this country, you have F of X and F of x may have some slope right to F of x.

288
00:36:31,410 --> 00:36:35,890
It may look very complicated, but this one is a slope, right?

289
00:36:36,490 --> 00:36:42,310
So if you divide this, therefore F of X by the slope, what do you get?

290
00:36:43,060 --> 00:36:51,520
You get the delta x, right? So basically F of X can be approximated as a delta, the Y divided by Delta X, right.

291
00:36:52,210 --> 00:36:56,230
So if you see this is of delta wide, then.

292
00:36:58,980 --> 00:37:06,140
So. So Delta X is a delta y divided by f, f5x.

293
00:37:06,150 --> 00:37:12,030
So what we are trying to do is trying to find this delta delta x, right?

294
00:37:12,930 --> 00:37:24,750
So let's say your index is this, then let's move by delta x in the backward, then this will be the route.

295
00:37:25,230 --> 00:37:29,430
If this function was fully, totally linear, right.

296
00:37:29,760 --> 00:37:34,620
So that, that was, that was the idea of this international method for route of finding.

297
00:37:35,910 --> 00:37:39,980
So, so, yeah.

298
00:37:39,990 --> 00:37:45,660
So, so that's, uh, that's the idea. So with the return, nothing.

299
00:37:45,680 --> 00:37:51,220
I was going to basically I'm going to assume, I don't know what the, what the function will,

300
00:37:51,740 --> 00:37:56,940
will look like, but I'm going to assume that my function is linear here.

301
00:37:57,240 --> 00:38:02,550
Okay. So if I was this linear, this must be the route.

302
00:38:02,820 --> 00:38:08,370
So I'm going to guess. Guess my point is a this one I assuming this is a route.

303
00:38:09,750 --> 00:38:15,710
Okay. So I'm not going to cover this today.

304
00:38:15,950 --> 00:38:20,659
But this one has it's not linearly convergent.

305
00:38:20,660 --> 00:38:26,990
This is a quadratic convergent. So you can deduce the error a lot more.

306
00:38:27,020 --> 00:38:33,950
So think about why we can't. I'm going to I'm going to cover this in the next lecture.

307
00:38:34,490 --> 00:38:38,120
But this is a this is an interesting point you can think about.

308
00:38:38,660 --> 00:38:44,130
Okay. So this is a visual interpretation of the two maps, and I would do so.

309
00:38:44,150 --> 00:38:54,730
Obviously, the function is not going to be linear. But when you try to use this a linear approximation, let's say this is a true,

310
00:38:54,760 --> 00:39:01,190
true route, then it is always a linear approximation is a good surrogate.

311
00:39:03,020 --> 00:39:11,960
I mean, it's a it's a closer, closer to the real how the function we usually behave.

312
00:39:12,440 --> 00:39:20,870
Then you can actually find closer point X and plus one is actually better than using the midpoint here.

313
00:39:20,990 --> 00:39:31,130
Right. So you can converge faster. Okay. So that's that's the idea of this Newton's Newton's methods for the finding the finding the route.

314
00:39:31,580 --> 00:39:35,910
Okay. Any questions so far?

315
00:39:37,520 --> 00:39:41,390
If Council survives. Oh, yeah.

316
00:39:43,170 --> 00:39:50,950
I enjoy my family. Oh, because I think the first is.

317
00:39:52,870 --> 00:39:59,359
I like that from. So, uh, very good point.

318
00:39:59,360 --> 00:40:05,720
And I think this is a typo. I didn't realize until now this was, uh, flipped in a.

319
00:40:06,680 --> 00:40:09,800
Yeah. So obviously this is not right. Okay.

320
00:40:09,830 --> 00:40:16,850
Sorry about that. So, yeah, this this has to be flipped, and the thing's for finding it, and, uh, I.

321
00:40:16,910 --> 00:40:22,610
Yeah, this is. This is not the figure I made, but, yeah, obviously, I should have checked about that.

322
00:40:23,660 --> 00:40:28,290
Okay. Uh, so.

323
00:40:30,850 --> 00:40:34,060
So let's, uh, let's try to implement this.

324
00:40:34,240 --> 00:40:37,810
Okay. So this is an algorithm.

325
00:40:38,380 --> 00:40:47,970
So one thing, one little bit annoying thing about the international wisdom is that you need to provide your function F,

326
00:40:48,520 --> 00:40:55,600
but also you need to provide the function derivative of prime together because you need to vary the prime.

327
00:40:56,270 --> 00:41:00,819
So provide both of them and you need to have a starting point.

328
00:41:00,820 --> 00:41:05,590
You don't need to provide interval here. You're just providing a starting point.

329
00:41:05,890 --> 00:41:13,090
Okay. And you have a tolerance and the maximum iteration and uh, the run this.

330
00:41:13,090 --> 00:41:18,940
So initially you a convergence one because you, you don't know, you haven't reached the convergence yet.

331
00:41:19,450 --> 00:41:26,020
Convergence becomes zero if if you reach a convergence. So evaluate the derivative.

332
00:41:26,470 --> 00:41:30,760
Okay. And check whether if your derivative is really small.

333
00:41:32,080 --> 00:41:35,840
If your derivative is really small, then uh.

334
00:41:36,940 --> 00:41:40,890
Uh. The.

335
00:41:40,930 --> 00:41:44,780
The the the. I'm sorry, I. I don't know what I.

336
00:41:45,100 --> 00:41:53,980
Why I did this. This is the second one. I must I must have made a mistake when I, when I went to change this this code.

337
00:41:54,610 --> 00:42:00,690
So if derivative is too small, so the little left that I would have may fail, right?

338
00:42:00,790 --> 00:42:03,190
Because this is this is a danger zone.

339
00:42:03,730 --> 00:42:13,240
So sometimes you you have you're very unlucky that you have you are trying to do the Newton assignment on this point, for example.

340
00:42:14,050 --> 00:42:20,170
Then you know it's not going to work. Right. So you're dividing dividing by zero.

341
00:42:20,710 --> 00:42:25,600
So in this case, you cannot do this. So this is where the Newton Newton upset and I wouldn't fail.

342
00:42:26,080 --> 00:42:30,010
So in this case, we just to return it, we say convergence is one.

343
00:42:30,610 --> 00:42:34,180
And I give a warning message and we we, we break. Okay.

344
00:42:35,050 --> 00:42:39,910
So, but yeah, that that I yeah.

345
00:42:40,900 --> 00:42:45,360
So that yeah. So in this case, there should be a convergence equal one.

346
00:42:45,370 --> 00:42:59,110
And so about that, so and otherwise we evaluate F of x zero and the next point evaluate this value F of zero divide by f f f f prime zero.

347
00:42:59,140 --> 00:43:04,810
Okay. So then we can check the convergence here.

348
00:43:05,320 --> 00:43:14,860
And if this is less than the difference between zero and one is less than your tolerance level, then I say that this is converged and you break.

349
00:43:15,040 --> 00:43:24,579
Otherwise I'm going to set x x1 is a new zero and just keep doing this until I reach the convergence.

350
00:43:24,580 --> 00:43:35,140
So that's the R with. Okay. So, uh, if if you run this, this is what happens.

351
00:43:35,290 --> 00:43:47,200
Okay. So. If you, for example, this function e e of X minus x minus two that you have a derivative here.

352
00:43:47,210 --> 00:43:53,540
So if you try this the previously you remember that this took 34 iterations.

353
00:43:54,020 --> 00:44:08,630
Now when you started at the value of X equals one, you get the value of the same set, almost similar value of the same same root.

354
00:44:08,810 --> 00:44:13,850
And a f of root is even more precise. It for brute is exactly zero.

355
00:44:14,750 --> 00:44:20,000
So you're getting more precise convergence and the number of iterations is only five.

356
00:44:20,210 --> 00:44:30,470
So this looks a lot better actually. But what what happens if I try in different place.

357
00:44:30,650 --> 00:44:36,890
So, so e e of X minus x minus two.

358
00:44:37,490 --> 00:44:41,630
Okay. So how does it look like here?

359
00:44:42,500 --> 00:44:53,360
You can see that. So this one, if so, if x equals zero, then this would be minus one, right?

360
00:44:53,990 --> 00:44:58,070
So I think this is going to be almost.

361
00:45:04,150 --> 00:45:14,380
The. So so this this this will have basically two to.

362
00:45:17,120 --> 00:45:25,850
I am not I'm not throwing this now, but this this will be very close to the.

363
00:45:28,040 --> 00:45:34,309
So if x x is negative, so if this are be eventually going to this, right, it's going to this.

364
00:45:34,310 --> 00:45:39,720
But eventually it'll look like something like this waiting in here.

365
00:45:40,250 --> 00:45:44,570
So this is a this is linear. And that this will just go very quickly.

366
00:45:44,660 --> 00:45:53,780
Right. And I am not doing well it but you get the idea that this will be a lot faster, but this will be linear.

367
00:45:54,460 --> 00:45:58,340
Okay. So you will have a you will have a two growth here.

368
00:45:58,580 --> 00:46:04,250
And when you when you start with from one, you're going to find this root.

369
00:46:04,400 --> 00:46:07,130
So that that's that's what's happening here.

370
00:46:07,940 --> 00:46:17,180
But if you if you start from negative one, which should be somewhere in here, if you start with the negative one, then.

371
00:46:20,080 --> 00:46:29,530
Yeah. It should be something here. So then I wanted to find this root, but it wasn't always like that.

372
00:46:30,070 --> 00:46:39,460
It doesn't always work like that. So it does work by trying to find the root that are this way because the slope is now negative.

373
00:46:40,360 --> 00:46:43,360
So it's a it's trying to go in this direction.

374
00:46:44,230 --> 00:46:50,469
Okay. So that could be a potential problem with the root of the nutrition algorithm.

375
00:46:50,470 --> 00:46:52,140
So we saw two problems.

376
00:46:52,160 --> 00:47:03,100
One is that for whatever reason, if you're if you reach a point where your derivative is actually zero, then you can solve the problem.

377
00:47:03,430 --> 00:47:10,080
So you need to give up. And when you have a case where you know you.

378
00:47:10,510 --> 00:47:16,420
So because you are just you cannot give an interval you just to give a single point to start to start from.

379
00:47:16,900 --> 00:47:22,330
So you can really have a very fine level of control in which kind of root you can find.

380
00:47:22,810 --> 00:47:27,980
So those are those are two problems. Okay. Okay.

381
00:47:29,300 --> 00:47:35,990
So the the third case is that we're trying to.

382
00:47:36,590 --> 00:47:40,129
So the international team also can enter a cycle.

383
00:47:40,130 --> 00:47:55,880
So this is a we keep Wikipedia posts at it in the very, very strange cases it keeps, uh, it is outgoing and keeps iterating.

384
00:47:56,150 --> 00:48:02,690
Okay. So the this, this looks like, you know, not very complicated function, actually,

385
00:48:03,110 --> 00:48:15,139
but if you give a very bad initial value, then it so it can, it can just rotate, um, a lot of value.

386
00:48:15,140 --> 00:48:21,170
Then in this case it does use a thousand iteration and the convergence, it doesn't converge.

387
00:48:21,320 --> 00:48:30,000
So this could also happen. Okay. So overall, the impression of the new international nationalism is that this is a definitely, uh.

388
00:48:30,950 --> 00:48:39,320
So on average, these are expected to perform better, that there is a lot of corner cases you may end up falling into.

389
00:48:39,410 --> 00:48:46,320
So this is a less reliable than, uh, the, the U.S. average, which is the,

390
00:48:47,530 --> 00:48:52,220
you know, guaranteed to be almost always guaranteed to find the, find the root.

391
00:48:52,460 --> 00:48:59,360
Uh, because it does, it does reduce the interval, you know, you know, in a consistent manner.

392
00:49:01,320 --> 00:49:01,620
Okay.

393
00:49:03,630 --> 00:49:14,940
So some potential problems are sometimes if you're if you're if a crime is very similar, very close to zero, you're going to have to have huge jump.

394
00:49:14,940 --> 00:49:28,679
And that's not that's not right. And cycles if you if the if you can have a two, you can just, uh, just go back and forth between the two values.

395
00:49:28,680 --> 00:49:34,259
And in the worst case, this could happen and sometimes ex of anything bigger and bigger.

396
00:49:34,260 --> 00:49:37,920
So it doesn't really converge. It diverge, those those can happen.

397
00:49:38,250 --> 00:49:45,270
So these things are all kind of problems that there are solutions, but those solutions are kind of heuristic.

398
00:49:47,220 --> 00:49:53,490
Okay. So the next thing we're going to look at is a second method.

399
00:49:53,490 --> 00:49:59,370
Second method is, uh, a discrete version of the data maps anomalies.

400
00:49:59,640 --> 00:50:06,270
Okay. So second method is basically is a same is a very similar idea to Newton apps tonight with them.

401
00:50:07,080 --> 00:50:12,510
But it does not require to have a derivative because a giving a derivative is a hassle.

402
00:50:12,510 --> 00:50:17,910
That's a, that's the main reason that otherwise it's using pretty much the same thing.

403
00:50:18,090 --> 00:50:21,930
So so if you see this equation here.

404
00:50:22,430 --> 00:50:31,860
Okay, okay. So if you see this equation, okay, this looks very, very similar to the Nutrinet-SantÃ© vision,

405
00:50:32,250 --> 00:50:37,350
except that this part is not derivative, it's a approximation of derivative.

406
00:50:37,620 --> 00:50:46,169
So you get the idea. So you have two values and in the interval you are just using this linear slope

407
00:50:46,170 --> 00:50:52,830
between those two intervals and use them as a approximation of your slope.

408
00:50:53,220 --> 00:51:00,690
And after that you use the same routine that the nutrient rest of the exhibit is using to find the next point.

409
00:51:01,110 --> 00:51:05,080
So that's the idea. So.

410
00:51:07,940 --> 00:51:13,250
Then. Uh, then, uh.

411
00:51:13,530 --> 00:51:19,320
So this one is a little hard to prove, but you basically the error.

412
00:51:19,590 --> 00:51:31,780
So both of you turn up the volume and this is, you know, the errors are multiplied because you have so so you can you can use this.

413
00:51:31,780 --> 00:51:40,140
So the hint is that you can use the tail expansion to to prove that this the error goes to read is a quadratic.

414
00:51:41,190 --> 00:51:45,899
But in this case, because there is an X of an excellent plus one, it's not exactly quadratic.

415
00:51:45,900 --> 00:51:59,190
This is a multiplication of two. Two is so but this one is this is almost quadratic and if you do some does that.

416
00:52:00,150 --> 00:52:04,950
So if you solve this, what is this ratio maybe come out of nowhere.

417
00:52:04,950 --> 00:52:11,600
But these ratios are sort of the gold golden ratio that comes comes in the next slides, too.

418
00:52:12,150 --> 00:52:20,729
But basically this is the with you seeing the the bottom line is that this reduces the error interval quite,

419
00:52:20,730 --> 00:52:24,390
quite rapidly, almost similar to the turnips in way with.

420
00:52:24,870 --> 00:52:31,139
Okay, so I'm not going to go to the detail of proving this or why this this has connection.

421
00:52:31,140 --> 00:52:35,330
But you can look it up from the from the source easily.

422
00:52:37,020 --> 00:52:41,730
So you get you can look at the second method more deeply if you are interested in this.

423
00:52:42,900 --> 00:52:49,440
But the basic idea is that you're, you're basically you're using the Newton of some Arabism like method of updating.

424
00:52:51,960 --> 00:52:56,040
So here this is second method is very, very similar.

425
00:52:56,130 --> 00:53:02,850
You don't need to give a F of crime. And similarly, you just won't want them.

426
00:53:02,850 --> 00:53:09,780
If your you have if your two values are very, very similar to each other, then that means that your.

427
00:53:13,150 --> 00:53:21,940
So you have this this value to this value will become very close to zero.

428
00:53:22,030 --> 00:53:29,980
Right. So that's a problem. So just to give a warning and a break and I say that this has not converged.

429
00:53:30,730 --> 00:53:35,170
Otherwise you do so.

430
00:53:36,160 --> 00:53:42,400
So calculate the calculate the the amount of changes you need to.

431
00:53:42,520 --> 00:53:46,630
You need to make and add the changes. Sorry.

432
00:53:48,330 --> 00:53:55,560
And and if if that that change is small enough, then I say converges.

433
00:53:55,590 --> 00:53:59,240
Otherwise, keep doing this. Changing the now change.

434
00:53:59,250 --> 00:54:10,050
Change of zero to F1 and x1x2. So you need to you need to evaluate the two two version of it, two version of F here because you are talking about.

435
00:54:11,460 --> 00:54:15,060
So there's F of X and plus one and F of X then.

436
00:54:15,180 --> 00:54:18,210
So this is F one and this is F, you know, in this code.

437
00:54:18,750 --> 00:54:22,860
So in you keep iterating those two values.

438
00:54:23,040 --> 00:54:31,530
And of the until you find you find the find the amount of data you can make is small, smaller than some threshold.

439
00:54:32,820 --> 00:54:37,649
Yeah. So that's all. So it, it's a pretty much similar to the Newton apps on average.

440
00:54:37,650 --> 00:54:40,960
And except that you need to keep track of two values of X with.

441
00:54:43,860 --> 00:54:47,550
Okay. Then if you try to do the second method.

442
00:54:47,850 --> 00:55:01,500
Okay. On the, uh, on the same f which is, uh, which, which is in this case this F, then, uh, you're going to, you're going to have this root.

443
00:55:02,190 --> 00:55:10,910
So in this case, you don't have the problem of a c cycling through, uh, the, the two intervals in this particular cases.

444
00:55:11,730 --> 00:55:15,990
But the second method it shares of some many problems that they need them.

445
00:55:15,990 --> 00:55:22,680
That's what I would have. So.

446
00:55:23,040 --> 00:55:31,350
So that's the second method. So my recommendation is that if you don't mind using so when you do the route finding,

447
00:55:31,770 --> 00:55:41,850
if you don't mind using a by section method, I, you know, if I'd evaluate three times, 35 times,

448
00:55:42,060 --> 00:55:49,709
I don't care then then just using the by section method is actually just easy enough if you want it to be

449
00:55:49,710 --> 00:55:57,390
oh my evaluation is a really expensive so I want it to reduce the number of iterations that you can use.

450
00:55:57,400 --> 00:56:02,610
Second method I don't recommend you to invest in that region because you need to calculate the prime.

451
00:56:02,610 --> 00:56:08,130
And also, you know, compared to the second method, there is a there's a very little gain and there are more problems.

452
00:56:09,210 --> 00:56:16,410
But the second method also have a problem. Problems like a similar problem, for example, are expecting huge dump sometimes.

453
00:56:16,710 --> 00:56:28,170
So that's not ideal. So I'm going to talk about what what you what I recommend to use at the end after this slide.

454
00:56:28,800 --> 00:56:32,550
But let's let's keep it now.

455
00:56:32,550 --> 00:56:38,640
So so second method is has advantages in terms of reducing the number of iterations so that that's all

456
00:56:38,640 --> 00:56:47,790
I can say so and we're going to so we're going to change the problem into the minimization problem.

457
00:56:48,300 --> 00:56:52,320
And I'll go through this and come back to the practical solution.

458
00:56:53,340 --> 00:57:00,110
Good. So let's talk about the minimization problem. So this this part is our is a more that requires more attention.

459
00:57:00,210 --> 00:57:08,340
Okay. This might be new to many people. So motivation problem is just finding the global minimum.

460
00:57:08,850 --> 00:57:13,590
Okay. Is a general problem, right? The lowest possible value of the function.

461
00:57:13,650 --> 00:57:17,580
This is a very hard problem if you have some very, very complicated function.

462
00:57:18,210 --> 00:57:21,930
So the problem we are going to solve here is the finding local minimum.

463
00:57:22,410 --> 00:57:29,250
So you are trying to find the smallest value within a certain neighborhood and this is a relatively easy problem.

464
00:57:30,720 --> 00:57:39,030
So if you are interested in the maximization problem, I want to do the a lot of cases when you do the, uh, when,

465
00:57:39,290 --> 00:57:43,520
when you need to apply this numerical optimization method is the case where you have

466
00:57:43,530 --> 00:57:49,080
some function depend on the data like the likelihood that the Bayesian formula of the,

467
00:57:49,470 --> 00:57:51,810
the posterior know you're trying to maximize it.

468
00:57:52,380 --> 00:57:59,550
Okay so when you try to maximize, if you just simply say change the sign and those becomes a minimization problem.

469
00:57:59,550 --> 00:58:03,270
So not a problem. Okay, so.

470
00:58:05,230 --> 00:58:11,049
So the first thing we are going to try is a derivation free minimization strategy,

471
00:58:11,050 --> 00:58:22,840
which you basically you have three points A and B and C, so B, so in a, F of B is smaller than F of A and F, obviously.

472
00:58:23,200 --> 00:58:29,400
So in this case, you you know that the the function has this kind of shape, okay?

473
00:58:29,980 --> 00:58:35,100
So then that there must be some local minimum, but the local minimum could be like here.

474
00:58:35,260 --> 00:58:38,799
So it could be somewhere like here where it could be it could be here.

475
00:58:38,800 --> 00:58:44,380
I mean, you don't know, right? It's a it could be it could look like a lot of different cases.

476
00:58:45,190 --> 00:58:51,400
So in a, how should we try to minimize the interval and the how should we choose the next point?

477
00:58:51,550 --> 00:58:54,550
And that's that's the idea. We want to get it.

478
00:58:54,800 --> 00:59:00,070
Okay. So for example, here you have a start.

479
00:59:00,070 --> 00:59:06,570
You start with a one, two, three. So three is smaller than the F of one and F of two.

480
00:59:06,580 --> 00:59:09,280
So this is a valid bracket. Okay.

481
00:59:10,720 --> 00:59:21,610
So and after this, let's say I decide to evaluate here in the this value is is a smaller than f a smaller than this, but not smaller than that.

482
00:59:22,030 --> 00:59:30,579
My next bracket is one, three, four. Right. And let's say I evaluate this and now this is smaller than three and four.

483
00:59:30,580 --> 00:59:34,930
So now new bracket is three, four, five, three, three, five, four.

484
00:59:35,080 --> 00:59:38,950
Right. And after that, if you evaluate this, this is smaller.

485
00:59:38,950 --> 00:59:42,460
So now the next bracket is three, six, five.

486
00:59:42,670 --> 00:59:47,170
So that that's how you do the minimization once you find the bracket.

487
00:59:47,710 --> 00:59:56,230
Okay. So I'm going to go through a very briefly, very briefly how to find the bracketing interval.

488
00:59:56,950 --> 01:00:00,630
So first, you need to find this so you don't know.

489
01:00:00,670 --> 01:00:08,440
So you're starting out of, you know, nothing, so you don't know how the function looks like.

490
01:00:08,710 --> 01:00:16,550
Okay. So this problem is actually a little more challenging to generalize because you don't know how the function looks like.

491
01:00:16,570 --> 01:00:22,840
So easiest way is to unless tried to do a certain interval, this is very, very heuristic.

492
01:00:23,560 --> 01:00:27,740
I just try to evaluate a function good.

493
01:00:28,410 --> 01:00:34,480
When you try to evaluate function. You you may you may encounter something like this.

494
01:00:35,260 --> 01:00:41,800
Then, then, oh, I found the bracket here. Now I can try to locally minimize this.

495
01:00:42,010 --> 01:00:47,280
Good. So that that's all that all these parties are trying to explain.

496
01:00:47,290 --> 01:00:56,650
So you just need to find some A and b, c triplet where F of B's are smaller than F of an F of C.

497
01:00:57,280 --> 01:01:01,270
So that's that's that's this part.

498
01:01:01,480 --> 01:01:10,740
So this part, I think is very trivial, but I think it's a it's a it's necessary to implement this article.

499
01:01:10,900 --> 01:01:15,150
So I'm going to explain. So this is very, very simple.

500
01:01:15,160 --> 01:01:20,770
So you start with a major and B0 and there is a scale factor in the Y.

501
01:01:20,770 --> 01:01:29,590
The scale factor is a 1.618. I'm going to explain later after after explaining the whole the search algorithm.

502
01:01:30,280 --> 01:01:39,490
But just to take it as given now you evaluate to function of to evaluate to function.

503
01:01:40,450 --> 01:01:49,360
And after that what is trying to do is you find the C that is a there is basically of so some.

504
01:01:49,870 --> 01:01:57,699
So you have a and P zero and the C zero is just a after a year and bigger with a certain certain

505
01:01:57,700 --> 01:02:06,310
scaling factor the multiplied here and evaluated and what you are trying to do is just a finding this.

506
01:02:06,460 --> 01:02:11,920
So find the ABC pairs where F4 B is a smaller than that.

507
01:02:12,180 --> 01:02:18,400
Okay. If not, keep doing this until you find interval that that's what it is.

508
01:02:18,880 --> 01:02:23,530
That's all. That's all. That's all. One as all this algorithm is doing.

509
01:02:23,530 --> 01:02:28,210
Doing so it looks looks very complicated. But this is really, really not complicated.

510
01:02:28,780 --> 01:02:30,880
And this is very, very crude algorithm.

511
01:02:31,330 --> 01:02:41,040
So obviously these are within doesn't work all all the cases and you may fail to find the bracket and then you need to just do it again and again.

512
01:02:41,040 --> 01:02:48,790
Again and again. Okay. So this function, for example, in this case, this particular function, if you try to run this over,

513
01:02:49,000 --> 01:02:58,330
I'm going to give a zero in one, then it's going to find the interval that the zero one and 2.618 as a as a interval.

514
01:02:58,750 --> 01:03:04,030
And the function values are this the one and 0.2 and a five.

515
01:03:04,030 --> 01:03:08,080
So indeed F of these are smaller than F of A and C.

516
01:03:08,620 --> 01:03:10,870
So it did work for some time.

517
01:03:10,990 --> 01:03:20,830
So sometimes let's say the same function you can try with an x equals one and a equal or one and be equal to the needles of fine.

518
01:03:20,830 --> 01:03:34,210
So in this case, we try to do a try to try to do the the bracketing and these are what you will find the interval as a two and one and this okay

519
01:03:34,900 --> 01:03:44,770
and because the F of one is a smaller than effort to so it does try to go backward and it does find the interval here too.

520
01:03:45,580 --> 01:03:52,900
But sometimes it doesn't work, so it doesn't find the interval in this case after 733 rounds.

521
01:03:53,680 --> 01:03:59,350
So this in this case, you just need to find a new starting point.

522
01:03:59,350 --> 01:04:02,829
I'm going to try to try to redo and redo until I find the bracket.

523
01:04:02,830 --> 01:04:10,840
So this is not very elegant argument that this is just the algorithm you need to find the bracket.

524
01:04:10,840 --> 01:04:15,670
So this part is not that important, but the need to be explained.

525
01:04:16,010 --> 01:04:23,230
Okay. So, so now the step two is a really important part.

526
01:04:23,440 --> 01:04:26,940
So let's say you have three points. Okay?

527
01:04:27,010 --> 01:04:34,870
So now you find the bracket. Okay? Now, the question is, how do I find the new trial point?

528
01:04:35,530 --> 01:04:39,070
That's the in a how do I how do I do this?

529
01:04:39,080 --> 01:04:43,900
So in this case, there's a one and two and one and two and three.

530
01:04:44,380 --> 01:04:48,670
So how do I find four? And did I find the four efficient?

531
01:04:48,950 --> 01:04:51,250
Sometimes you can try an arbitrary point,

532
01:04:51,260 --> 01:05:03,770
but what is the right strategy to find a new point to make sure that I have a certain guarantee that I'm reducing my interval in an efficient way?

533
01:05:04,130 --> 01:05:09,050
Okay. So let's say you have this bracket.

534
01:05:09,050 --> 01:05:12,110
F of B is a smaller than F of A and FC.

535
01:05:13,340 --> 01:05:18,470
But let's not worry about the F value. Let's focus on these x value.

536
01:05:18,890 --> 01:05:23,420
ABC And what is the best location to.

537
01:05:24,770 --> 01:05:28,630
For New Point. Without.

538
01:05:29,550 --> 01:05:43,250
So the question is that regardless of how the F of F of X, it looks like there is a some arguably best location you can try in this city.

539
01:05:46,770 --> 01:05:54,420
Okay. So how do I find it? Okay, so let's say my new trial point is ex.

540
01:05:54,690 --> 01:06:00,710
Okay. Okay. Then there is only two cases here.

541
01:06:01,190 --> 01:06:04,820
I already know that f of these are smaller than these and these.

542
01:06:04,910 --> 01:06:12,860
Right. So F of x could be bigger than larger and therefore B or smaller than F will be agreed.

543
01:06:13,460 --> 01:06:23,720
Right. So if F over x is a smaller than that for B, that means that this is a this is this is the best point so far.

544
01:06:24,290 --> 01:06:30,100
So now the new interval has to be an X and C right away.

545
01:06:31,250 --> 01:06:36,260
If F of X is a greater than four, B, B is still the best point.

546
01:06:36,260 --> 01:06:43,850
So the the bracket should be centered from B, so that means that my new interval should be a, b, x, right.

547
01:06:44,510 --> 01:06:50,060
And we don't know which would be the case until we evaluate the F of X.

548
01:06:51,140 --> 01:06:59,270
Okay. So one arguably best strategy to go about this is that why don't we minimize the risk?

549
01:07:00,050 --> 01:07:05,450
So I know that the new interval will be this or this.

550
01:07:06,020 --> 01:07:12,260
So why don't we make the the interval size the same for both of them?

551
01:07:13,100 --> 01:07:17,530
Does it make sense? So make this part and this part the same.

552
01:07:18,380 --> 01:07:25,520
So that's the then no matter. So we don't know because we don't know which which would be which which case.

553
01:07:25,760 --> 01:07:36,170
It'll happen. In both cases, we have a certain guarantee that your interval is reduced by specific amount and guaranteed.

554
01:07:37,910 --> 01:07:41,210
Okay. So how do I do this?

555
01:07:41,430 --> 01:07:44,660
Okay. So that means that. So this is a.

556
01:07:44,900 --> 01:07:48,780
So now I'm going to back and forth A, B and C here.

557
01:07:48,800 --> 01:07:59,630
So A, B and C here. So that the ratio between these and these, let's say this is x, a, this is W, okay.

558
01:08:00,830 --> 01:08:04,190
And I'm going to define Z as this.

559
01:08:04,400 --> 01:08:09,530
So B, X and AC, so B, X and AC.

560
01:08:09,650 --> 01:08:15,800
So the ratio between these and these as a as a as a Z.

561
01:08:16,010 --> 01:08:27,340
Okay. Then my new segment will be either this segment or this segment.

562
01:08:27,350 --> 01:08:34,520
Right? So if my new segment is this, that means that Z plus W sorry.

563
01:08:35,210 --> 01:08:39,860
So now if you have this is it one minus W, right.

564
01:08:39,860 --> 01:08:45,110
So this was a this was a if you think that this is one.

565
01:08:45,560 --> 01:08:53,210
So this is the W one minus the new interval because of one minus W, so one minus W times a C.

566
01:08:54,560 --> 01:09:08,780
If we if the new choice will be is a, B, remains the remains the smallest, then this part will be the new new bracket I'm going to minimize.

567
01:09:09,650 --> 01:09:16,070
Then this will be this is a W, this was G, so this is a W plus z times ac.

568
01:09:16,490 --> 01:09:28,940
Okay, so, so optimal case here is that we can try to make that the ratio between those two.

569
01:09:29,300 --> 01:09:33,710
Okay. Is, uh, is the same.

570
01:09:33,720 --> 01:09:44,540
So, so no matter whether we choose A, B, C or x, a x, so no matter which one was, was chosen, we want to make them to be the same.

571
01:09:44,930 --> 01:09:48,920
Okay? Because we don't know which, which one is. Okay. So this is one criteria.

572
01:09:50,390 --> 01:10:02,880
The other criteria is that we want to. So so so if you see this this the the ratio between these and these.

573
01:10:02,900 --> 01:10:09,800
So a B divide by AC is the ratio between the following table and the shorter interval.

574
01:10:10,560 --> 01:10:20,850
Okay. So in the previous iteration and when when we choose, when we reduce the interval, this is a new interval or this is a new interval.

575
01:10:20,870 --> 01:10:26,520
Either way, this is going to be shorter interval. The shorter interval divided by the bigger interval.

576
01:10:26,540 --> 01:10:31,160
Right. So this ratio, we want this ratio to be consistent, constant.

577
01:10:31,340 --> 01:10:39,440
Okay. So if you you can also have have these criteria that I want to keep having the same constant,

578
01:10:40,100 --> 01:10:48,200
same same ratio of the same ratio that the my bracket is being reduced.

579
01:10:48,410 --> 01:10:52,370
So here, if you see this. So how much?

580
01:10:52,970 --> 01:10:57,300
So here the key question you want to answer. Is that how much?

581
01:10:57,430 --> 01:11:01,000
So when you when you do this, what is the game?

582
01:11:01,420 --> 01:11:06,790
What what kind of game do you have to narrow down your search area?

583
01:11:08,230 --> 01:11:16,990
So you started with AC, but either way, you're you are getting rid of either this region where you are getting rid of this region.

584
01:11:17,110 --> 01:11:27,490
So you're you're losing certain percentage of your bracket, so you're improving your precision of this iteration.

585
01:11:28,240 --> 01:11:32,500
So I want to have these and these the same.

586
01:11:32,830 --> 01:11:43,090
Okay. So that's the first criteria here. And second criteria is that I want I want the ratio of this to become constant across all iterations.

587
01:11:43,360 --> 01:11:44,500
So those are the two.

588
01:11:45,310 --> 01:11:56,620
So rates are becoming constant, meaning that this divided by the, the big area should be the same that is divided by the by the next interval.

589
01:11:57,070 --> 01:12:00,280
Okay, so that's that, that's this. Okay.

590
01:12:01,450 --> 01:12:13,480
So if you solve these two, then this w w w was, if you remember, w was the ratio of this, this was about 38%.

591
01:12:13,900 --> 01:12:18,400
Okay? So 38.38338197.

592
01:12:19,060 --> 01:12:25,210
That means that this has to be 38%. This has to be 38% roughly, and this is a 24%.

593
01:12:25,990 --> 01:12:37,570
Okay. So that's the then then if you if we set this value, you can keep reducing your interval by 38% each time guaranteed.

594
01:12:38,170 --> 01:12:43,570
So that's that's the strategy of the this and is important search.

595
01:12:43,810 --> 01:12:53,920
I'm going to I want to have a guarantee that I can mean I can reduce my bracket by certain amount at each iteration.

596
01:12:54,310 --> 01:13:00,220
And I want it I want to maximize the amount that I can reduce using these equations.

597
01:13:03,750 --> 01:13:07,740
So the codes are universal like this.

598
01:13:07,800 --> 01:13:13,290
Let's say this. You start with a one and two and three is a three points here.

599
01:13:13,460 --> 01:13:18,690
Okay. So then because because this is shorter interval.

600
01:13:18,860 --> 01:13:22,920
Okay. Now, now you can evaluate the next point here.

601
01:13:23,010 --> 01:13:29,420
Right. But when you evaluate it, it's next point. So you wait before you evaluating.

602
01:13:29,460 --> 01:13:37,280
You actually don't know how this function looks like. So you only have these three value in the in the beginning and that is for value.

603
01:13:37,290 --> 01:13:41,820
Could it be here or a bit or down? But when you evaluate it, it goes up.

604
01:13:42,030 --> 01:13:46,410
That means that, oh, one, two, three, four is my new bracket.

605
01:13:46,740 --> 01:13:53,340
So you lost about 38% here and and after that.

606
01:13:55,140 --> 01:14:00,270
So because now you have a one, three, four here. So you need to evaluate somewhere here.

607
01:14:00,300 --> 01:14:04,560
So it is so 33, 38% from this side.

608
01:14:05,010 --> 01:14:09,960
So when you evaluate this was higher. So it went down.

609
01:14:10,160 --> 01:14:16,950
Okay. So so now now you're doing table is of three, four, five.

610
01:14:17,130 --> 01:14:21,960
And when you when you have this and that, my new value to evaluate you somewhere here.

611
01:14:22,530 --> 01:14:26,820
So you keep doing this. So after that it after that.

612
01:14:27,540 --> 01:14:30,810
At the point that you need to evaluate should be somewhere here. Okay.

613
01:14:31,560 --> 01:14:42,050
So and if it is. Yeah. If this becomes smaller then the new the interval will be some you your interval will be it this interval.

614
01:14:42,060 --> 01:14:49,800
So you keep reducing this. Okay. So, so these are 38%,

615
01:14:50,040 --> 01:15:05,190
0.381196 is a is actually the happen to be the these the golden mean or the golden ratio that is studied by the Pythagorean Pythagoras.

616
01:15:05,700 --> 01:15:11,620
So this is there is a there was if you if you, you know,

617
01:15:12,600 --> 01:15:17,130
follow like what what the golden ratio means, these is connected with a lot of different things.

618
01:15:17,400 --> 01:15:25,230
So that that's kind of fun. But the point is that this 38% is corresponding to the golden ratio.

619
01:15:25,620 --> 01:15:35,640
And if you stick with it, you can, uh, you can maximize the, the worst case.

620
01:15:37,530 --> 01:15:47,400
The well, you can, you can, you can maximize the, uh, the efficiency of these iterations, even in the worst case.

621
01:15:47,650 --> 01:16:01,920
Okay. So. So for example, if you have a so if you have a exceed and as I said, either your new interval will be this or this.

622
01:16:02,100 --> 01:16:14,250
So either way, you are reducing the 38%. And in in the new bracket, the ratio between this and this will be still three lovely 30% and 62%.

623
01:16:14,370 --> 01:16:25,650
And that's that's what it's designed for. Okay. So if you use a body search, this reduces the bracket by 40% after function evaluation.

624
01:16:25,830 --> 01:16:32,580
So well, in by section nine wisdom, I reduce the 50%.

625
01:16:32,940 --> 01:16:35,640
Okay. Then why do I reduced to 40%?

626
01:16:35,670 --> 01:16:45,520
Well, you can reduce like 33%, but you cannot be this more than this, this 38%, because that's the maximum you can get.

627
01:16:45,540 --> 01:16:49,860
So this is a this is a better than output evaluation.

628
01:16:49,870 --> 01:16:56,429
You just divide divide it by three equal points.

629
01:16:56,430 --> 01:17:02,670
And you can you can do the similar kind of things. But it does it doesn't work very nice as nicely as a body search algorithm.

630
01:17:03,150 --> 01:17:11,010
So this this works the best in terms of the amount of interval you can minimize without looking at the the value of F.

631
01:17:11,850 --> 01:17:20,070
So the nice thing about this coordinate search algorithm is that you don't you don't have.

632
01:17:20,250 --> 01:17:24,930
So in this case, we're not actually using those F of X values at all.

633
01:17:25,140 --> 01:17:31,170
Just, you know, we are using F of X only to decide decide to the next interval.

634
01:17:31,170 --> 01:17:34,709
Just that we're checking whether F of X is A greater than therefore B or not.

635
01:17:34,710 --> 01:17:38,100
That that's it. We're not actually using that value self.

636
01:17:39,180 --> 01:17:43,530
So, so that's the nice thing about golden search.

637
01:17:43,800 --> 01:17:52,050
No matter what, how your function looks like, you're always guaranteed to reduce your bracket by 40%.

638
01:17:52,170 --> 01:17:56,270
Lovely. Okay. Okay.

639
01:17:56,960 --> 01:18:01,970
So that's that. And we have almost that.

640
01:18:02,270 --> 01:18:08,780
We have 2 minutes. Okay. So this is the step that this is a potential target.

641
01:18:09,110 --> 01:18:13,640
I explained a very complicated way, but this is actually not very complicated.

642
01:18:15,050 --> 01:18:23,840
So you just find. So this is the new X you need to try if you have A and B and C based on this golden step.

643
01:18:24,260 --> 01:18:35,120
Okay. After that, if X is a new minimum, you just update the A, my new interval will be A and B, an X, right.

644
01:18:35,990 --> 01:18:44,719
And if if P's are still the minimum, then my new interval will be extended X and B and C.

645
01:18:44,720 --> 01:18:48,860
So that that's what that's what this algorithm is doing.

646
01:18:49,190 --> 01:18:56,600
And other than that, there's nothing complicated. So this is the by section like version.

647
01:18:56,930 --> 01:19:01,310
So this is a similar to the bisexual origin, but bisexual because when you work for root finding,

648
01:19:02,120 --> 01:19:10,550
if you want to do similar to the bisexual algorithm to have have some guaranteed amount of the reduction in your bracket.

649
01:19:10,980 --> 01:19:14,510
This is called the search algorithm is the I will be looking for.

650
01:19:15,800 --> 01:19:20,480
Okay. Any questions is is it too confusing?

651
01:19:23,190 --> 01:19:27,569
So try to take a look at the code and try to digest that.

652
01:19:27,570 --> 01:19:31,380
That'll, that'll help. And yeah, that's that's all for today.

653
01:19:32,700 --> 01:19:33,150
Thank you.

