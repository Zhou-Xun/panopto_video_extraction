1
00:00:12,870 --> 00:00:22,960
Okay. How's work? Yeah.

2
00:00:26,260 --> 00:00:42,480
Yeah. Let's go ahead and get started. I mean, the questions are like your homework.

3
00:00:43,680 --> 00:00:51,670
Your homework and see it to this post, this you should be able to read.

4
00:00:51,730 --> 00:01:00,630
It is definitely is integral. I think some of it involves since we're going to talk about politics today.

5
00:01:01,980 --> 00:01:07,720
So once we've done surveys, material things you can do.

6
00:01:08,040 --> 00:01:12,990
We all should be able to do all of the homework that's there.

7
00:01:13,140 --> 00:01:17,350
That'll be due on Monday. A week from today. Yeah.

8
00:01:17,430 --> 00:01:25,259
So today it's basically to fill all the time, but only focus on you.

9
00:01:25,260 --> 00:01:30,980
Basically do. Oh yeah. There were some issues.

10
00:01:31,500 --> 00:01:36,610
And let's see, um.

11
00:01:38,190 --> 00:01:42,870
That's why you did this. Yeah. So it's going to be a file upload.

12
00:01:43,860 --> 00:01:50,430
I would do the C++, so just a C++ file, I think.

13
00:01:52,110 --> 00:01:55,230
But which foods?

14
00:01:58,910 --> 00:02:02,120
So, yes, let me just pull up the homework real quick.

15
00:02:03,500 --> 00:02:20,960
So I think I mean, the code should be not c p p file so you can put the yeah, I probably put that on two separate files to C P files.

16
00:02:22,340 --> 00:02:32,300
Would it be good if you could take a minute to run them separately to take a screenshot or something of what happens when you run it?

17
00:02:34,170 --> 00:02:38,969
One problem one, you have to run two examples.

18
00:02:38,970 --> 00:02:50,780
So if you do to take it either a screenshot or just put the allocation of your in the text file just to show what the output is.

19
00:02:53,360 --> 00:03:06,439
So basically like for problem one, you see the file has basically the header and the main part of the main part of the program.

20
00:03:06,440 --> 00:03:15,710
And then just either a screenshot or a like a text file which shows what was printed when you run these two examples.

21
00:03:17,450 --> 00:03:27,249
And just the same thing for problem two, I think there's just a CPP prop program and then there's like two examples you should do.

22
00:03:27,250 --> 00:03:34,440
The best is. Any other questions?

23
00:03:35,920 --> 00:03:45,190
Almost one. It's not clear when you start working on it.

24
00:03:45,220 --> 00:03:49,590
Tell us. Ask it. And once there, you know, we.

25
00:03:50,680 --> 00:03:55,630
All right. So. So.

26
00:03:56,440 --> 00:04:05,520
Yeah. Today's main topics are just looks and functions. I think those are kind of the three main types of control flows which are sort of.

27
00:04:09,080 --> 00:04:13,969
Useful for constructing programs.

28
00:04:13,970 --> 00:04:19,110
Basically, it fails or switch statements which we talked about last time,

29
00:04:19,110 --> 00:04:24,860
and because the other two parts of our control flows are in loops and function so on.

30
00:04:25,640 --> 00:04:37,820
We'll cover that tonight. And I think next time we can start talking about factors and arrays and things like that, but we have to cover this first.

31
00:04:38,390 --> 00:04:44,240
Okay. So loops are basically just things that allow you to repeat something a bunch of times.

32
00:04:45,490 --> 00:04:52,580
It's just syntax tells you to repeat the same type of same code or similar code a bunch of times.

33
00:04:55,460 --> 00:04:59,300
So there are three really main types of loops in C++.

34
00:04:59,300 --> 00:05:03,440
There's like themes, there's the violent, the do while loop and the for loop.

35
00:05:04,250 --> 00:05:19,100
So while you can really kind of do the same thing with each type of loop, but I think for certain types of certain types of tasks,

36
00:05:19,100 --> 00:05:25,280
I think a lot of them might be more natural than a for loop or vice versa, for example.

37
00:05:25,280 --> 00:05:32,359
So a wire loop is kind of set up really the logic of a while loop is set up.

38
00:05:32,360 --> 00:05:45,950
So you want to use it in cases where you want to repeat a calculation until a certain condition holds or or or until a certain condition is not true.

39
00:05:45,950 --> 00:05:51,860
So you want to repeat you repeat a calculation while certain conditions.

40
00:05:52,270 --> 00:05:59,570
And when that condition becomes false, you stop repeating that calculation.

41
00:05:59,810 --> 00:06:02,270
It's kind of the logic of a while loop.

42
00:06:03,410 --> 00:06:14,299
Do a while loop is kind of the same thing is the main difference is there do while off you always at least do one

43
00:06:14,300 --> 00:06:27,290
iteration once basically you do at least you do the calculation first before you check the determination condition.

44
00:06:28,220 --> 00:06:35,450
So that guarantees that you always do the kind of the calculation in the body of the do while with because at least once.

45
00:06:36,800 --> 00:06:47,450
But other than that it's pretty similar to a while that really the main difference is where you're checking the condition of the loop in a while loop.

46
00:06:47,450 --> 00:06:56,510
You're just you're checking the condition and kind of at the beginning of the loop in a do while you're checking the condition at the end.

47
00:06:58,840 --> 00:07:03,860
I mean, it'll be more clear when we see some examples, but they're pretty similar.

48
00:07:04,790 --> 00:07:07,010
So for loops are typically used,

49
00:07:10,260 --> 00:07:19,159
which kind of the basic for a loop is you use it when you kind of know how many times you need to repeat a calculation.

50
00:07:19,160 --> 00:07:28,580
So let's say, you know, you need to repeat a calculation 100 times for a loop is set up for that type of situation.

51
00:07:30,340 --> 00:07:34,550
I mean, you can have it terminate based on a condition.

52
00:07:35,360 --> 00:07:44,269
So you can do that if you put a break statement inside of a formula, let's see some examples of that as well.

53
00:07:44,270 --> 00:07:51,499
But kind of the basic syntax of a formula is set up to handle the situation

54
00:07:51,500 --> 00:07:56,540
where you know exactly how many times you want to repeat a certain calculation.

55
00:07:57,650 --> 00:08:01,640
So let's go over the syntax of a for a while.

56
00:08:01,790 --> 00:08:09,050
First, I guess it's C++, so it's pretty similar to a lot of other languages.

57
00:08:09,410 --> 00:08:17,149
Sometimes they differ slightly, but this is kind of the exact syntax we would use in C++.

58
00:08:17,150 --> 00:08:27,620
So it's basically you start with a keyboard file and then you have some condition which determines kind of when the wild start stops,

59
00:08:28,580 --> 00:08:36,570
this is typically some type of Boolean expression or a or the name of a variable where the other

60
00:08:36,610 --> 00:08:42,020
the variable might be updated by some Boolean expression in the bottom of the line statement.

61
00:08:42,030 --> 00:08:52,400
So this condition is usually a boolean expression itself or a variable or a boolean variable.

62
00:08:52,520 --> 00:08:59,569
Okay. And then the Boolean variable would typically be something in the body of the wild statement.

63
00:08:59,570 --> 00:09:05,540
So when I say body of the wild statement, that's just basically this code chunk here.

64
00:09:05,540 --> 00:09:13,340
It's kind of every average thing. Inside of sterling braces itself is the body all the wild statement.

65
00:09:13,350 --> 00:09:21,409
So here inside of the curly braces, you're just going to have one line of code or many lines of code.

66
00:09:21,410 --> 00:09:26,690
It's just some some piece of code inside of the curly braces.

67
00:09:26,690 --> 00:09:33,739
And kind of each time you go inside the loop will refer to that as kind of each time we go inside the loop,

68
00:09:33,740 --> 00:09:36,890
it's like one she's one iteration of the loop.

69
00:09:37,760 --> 00:09:41,690
Each time you go inside the loop, you execute this chunk of uncovered.

70
00:09:41,700 --> 00:09:50,570
That's kind of what's the logic of a wild loop. And then the wild loop is terminated whenever a kind of condition evaluates difference.

71
00:09:56,460 --> 00:09:59,600
So the coach could run? Well, it doesn't have to run at all.

72
00:09:59,610 --> 00:10:10,320
If the if kind of the first time you run into the wild statement, if it's on the first try condition is false.

73
00:10:10,330 --> 00:10:15,090
You're you're not going to execute the body of the wild, wild statement at all.

74
00:10:16,110 --> 00:10:24,630
Kind of the opposite case is where you don't update condition or you haven't set up the logic of your wild statement correctly.

75
00:10:25,110 --> 00:10:35,430
So condition never evaluates to false. In that case, it'll run infinite number of times until you can kill the kill approach.

76
00:10:37,410 --> 00:10:43,500
So that's the logic of the wild statements. So I think it's probably slightly more clear if we just do an example.

77
00:10:43,510 --> 00:10:54,870
So let's just say we want to write a program that prints out and well, you get an input from the user, an integer and positive integer.

78
00:10:54,870 --> 00:11:05,189
N And then I want it to print out the, I want to turn out each.

79
00:11:05,190 --> 00:11:10,170
k0i know. And I guess I just print out one number.

80
00:11:10,830 --> 00:11:12,899
So I'm just printing out the sum of squares,

81
00:11:12,900 --> 00:11:21,360
basically the user inputs an integer and then I just compute that some and then we print out the result to the screen.

82
00:11:21,360 --> 00:11:28,680
So that's, that's kind of a nice case where a loop comes in handy.

83
00:11:29,190 --> 00:11:38,870
So we just we're basically just going to do a cumulative somewhere each time we go inside that we add one of these extra square terms.

84
00:11:38,880 --> 00:11:49,860
Okay? So we can do that directly with the Y loop, but we could also pretty you also might want to do this with a for a loop,

85
00:11:50,550 --> 00:11:53,760
but this is just kind of an example of how you can use a line rule to do that.

86
00:11:55,890 --> 00:11:57,420
Okay. So the way this is going to work,

87
00:11:57,420 --> 00:12:07,830
so remember when you want to get input from the user from the keyboard you would use see in scene from the IO string library.

88
00:12:09,630 --> 00:12:12,810
So that's kind of one thing we're going to have to have our program.

89
00:12:18,390 --> 00:12:20,490
What's the other thing? So we're going to have a wild loop.

90
00:12:21,330 --> 00:12:29,850
It's going to have the number of iterations it should kind of terminate after we've had in iterations basically.

91
00:12:30,330 --> 00:12:39,360
So each each iteration in the wild loop, we're going to add an extra squared terms which we should have kind of in iterations in the wild.

92
00:12:40,020 --> 00:12:50,999
And then what the way this works is we're going to start with an integer variable called sum before the Y loop.

93
00:12:51,000 --> 00:12:54,540
We're going to initialize it with a value of zero.

94
00:12:54,990 --> 00:12:59,250
And then kind of each time you go inside the loop, you kind of add a squared terms.

95
00:13:00,000 --> 00:13:06,329
So that's that's kind of the approach for this example. This is kind of the actual code that's written out.

96
00:13:06,330 --> 00:13:14,220
So here you have that either string libraries and someone to use see and see out.

97
00:13:18,210 --> 00:13:25,740
So we get the we get the integers from the user using C and then you have to do even though you're getting it from the user,

98
00:13:25,740 --> 00:13:30,180
you still have to declare it first. So we're going to declare it first.

99
00:13:30,180 --> 00:13:36,989
This is this is an integer type. And first they also need this variable sun.

100
00:13:36,990 --> 00:13:44,670
So this is going to compute this variable is going to be used to kind of store the cumulative sum of squares.

101
00:13:44,670 --> 00:13:48,810
So you have to do you still have to declare first before it's used.

102
00:13:50,340 --> 00:13:58,350
So here in this case, we're just to see how statement to little message to the user to input a integer.

103
00:13:58,350 --> 00:14:02,280
And here we're getting the integer from the user.

104
00:14:02,850 --> 00:14:07,709
And then here is kind of a wild statement, part of the part of the program.

105
00:14:07,710 --> 00:14:15,600
So we start with I'm saying and is equal to one and then we just do this calculation

106
00:14:19,890 --> 00:14:27,570
starting from is equal to one and to keep repeating the calculation until it is equal again.

107
00:14:27,690 --> 00:14:31,950
And then whenever it becomes greater than and then it terminates the loop.

108
00:14:34,360 --> 00:14:39,820
So here in this line of code, you can just see that we're we're just adding ice square every time we go inside.

109
00:14:40,060 --> 00:14:47,770
So the first time you go inside, the loop just adds one square to the second time it's two squared, etc., etc.

110
00:14:48,640 --> 00:14:51,250
And then here again, we're using this kind of increment.

111
00:14:52,180 --> 00:14:59,590
If you remember, I guess last time this increment operator that increases I by one every time you go inside the loop.

112
00:15:00,310 --> 00:15:04,420
This is just set. This is the equivalent of writing is equal to I was born.

113
00:15:05,320 --> 00:15:10,600
And then the last case we're just the last line. We're just printing out a message.

114
00:15:10,600 --> 00:15:15,040
The sum of squares of two in is one.

115
00:15:15,050 --> 00:15:20,630
So some should be this, some squares up to two.

116
00:15:21,530 --> 00:15:28,970
Okay, so here here's just a screenshot of what it looks like when you write.

117
00:15:29,050 --> 00:15:36,850
So this is an example of and tell you if I enter the integer five, it'll print out to some of the squares.

118
00:15:36,850 --> 00:15:47,319
Up to five is 55. Right. So that's an example of the use and the syntax of a while loop in C++.

119
00:15:47,320 --> 00:15:52,570
So here's probably is probably more a slightly more realistic example,

120
00:15:53,650 --> 00:15:58,630
at least for the kind of a typical type of termination condition for a while loop.

121
00:16:00,070 --> 00:16:07,270
So let's say we wanted to write our own code to compute the and this is like the natural log of one class x.

122
00:16:07,270 --> 00:16:14,500
I mean, there's plenty of libraries that compute this, but let's say we just wanted to do our own implementation.

123
00:16:17,290 --> 00:16:26,350
So to compute this and in the computation of this kind of usually uses this kind of

124
00:16:27,040 --> 00:16:33,010
infinite sum representation of the natural log of OnePlus X so you can write down the,

125
00:16:34,770 --> 00:16:41,050
the natural log of OnePlus X, kind of the Taylor series, which is infinite.

126
00:16:42,160 --> 00:16:52,000
And so you can get a pretty good approximation if you, if you use this some you take kind of a large number of terms.

127
00:16:52,080 --> 00:17:01,090
Okay. So this is an infinite somewhat if we take the sum of the first 100 terms in the sum,

128
00:17:01,100 --> 00:17:06,910
you get a kind of a very, very good approximation of the natural log of OnePlus X.

129
00:17:07,690 --> 00:17:16,450
Okay, so you can do this with a loop. So basically what we're going to do is we're going to start off at the first time, we go inside the loop.

130
00:17:16,450 --> 00:17:18,910
We're going to give you X.

131
00:17:19,720 --> 00:17:27,700
Next time you go inside the loop, you're going to add the term minus X squared to that x third time, you're going to go inside the loop.

132
00:17:27,700 --> 00:17:37,810
You add x cubed over three to the existing sum, etc., etc., and you just keep doing this until there's a certain tolerance.

133
00:17:37,990 --> 00:17:48,730
So the way that's often done is you just compare kind of the neighboring values of X or the X to the neighboring.

134
00:17:49,560 --> 00:17:58,480
I guess you can think of it as X to neighboring terms in your in your loop.

135
00:17:58,480 --> 00:18:08,140
So like if you have a variable that stores the sums, if you look at the value of that compared to the previous iteration,

136
00:18:08,620 --> 00:18:14,319
if that's super small, like 0.01, for example, you could just think of that.

137
00:18:14,320 --> 00:18:19,270
That's, that's basically saying that kind of series has converged.

138
00:18:20,290 --> 00:18:26,470
It's not really changing much anymore. So once you do that, you say that kind of your.

139
00:18:28,900 --> 00:18:37,000
Your series has converged and just we'll just use that as our our value of natural order.

140
00:18:37,000 --> 00:18:42,250
1.6 is a very close approximation of the of the number that we're interested in.

141
00:18:43,060 --> 00:18:46,670
Okay. Okay.

142
00:18:46,700 --> 00:18:52,490
So here is a I guess the full program for for implementing this.

143
00:18:53,780 --> 00:19:01,610
So let's walk through a little bit, step by step, which leads to small things.

144
00:19:02,150 --> 00:19:05,260
Just wanted to squeeze it in on one slide.

145
00:19:05,270 --> 00:19:11,960
So the first is sort of I guess the first three lines are just kind of headers.

146
00:19:12,440 --> 00:19:19,849
So we need IO stream since we have they can have some synapse and some scenes here for this part.

147
00:19:19,850 --> 00:19:23,720
And it's why we need IO stream for C studio.

148
00:19:24,320 --> 00:19:28,820
That's because I have some print f and here instead of a print f statements.

149
00:19:28,820 --> 00:19:33,930
And that's why we need that. And then, Sebas, why?

150
00:19:34,220 --> 00:19:37,910
Why do I need that? Yeah, you do need it.

151
00:19:37,910 --> 00:19:48,650
So remember I talked about exponential actions is not really implemented in C++, at least without importing any libraries.

152
00:19:49,220 --> 00:19:53,120
So for this power function, that's why I need to include the header.

153
00:19:53,120 --> 00:19:58,100
See math. So that's where they are, including each of these three headers.

154
00:20:00,470 --> 00:20:05,130
All right, so let's see. Okay.

155
00:20:05,300 --> 00:20:09,890
What are the other parts I'm declaring? All of these variables are so x.

156
00:20:11,090 --> 00:20:20,350
X is going to be like basically kind of like the X and basically the X here.

157
00:20:20,360 --> 00:20:23,450
So that's it's kind of playing that role.

158
00:20:24,200 --> 00:20:27,290
So before you use it, you have to declare it.

159
00:20:28,040 --> 00:20:38,310
So since we want to do kind of a. You go, this is like a decimal number, so it makes sense to set it as a variable.

160
00:20:39,480 --> 00:20:48,180
Also declaring the sum variable. So that's going to basically record the cumulative total sum as we go along.

161
00:20:48,840 --> 00:20:54,210
And then this tolerance calling it tall, that's basically going to be the stopping criterion.

162
00:20:54,870 --> 00:21:07,050
So that's going to determine when you stop basically and when terms of the series kind of get sufficiently close to the Delta.

163
00:21:10,740 --> 00:21:21,840
Yeah, Delta is basically the value of the additional term adding to the series and then is equal to one.

164
00:21:22,800 --> 00:21:26,490
Well you'll see down here why we need it. I guess this part.

165
00:21:26,490 --> 00:21:32,640
Yeah, we're just getting stuff from the user. So the prompt the user to enter something here, we're getting the value.

166
00:21:33,810 --> 00:21:38,350
So you're going to input the value of X and we want to compute the natural log of one X.

167
00:21:39,030 --> 00:21:44,890
Okay. So here's the wild loop that does that. So we're going to say Wild Delta is the times.

168
00:21:45,840 --> 00:21:54,210
So Delta the way the way out of column Delta is just it's just like one of these terms.

169
00:21:54,840 --> 00:22:00,150
So this be the value of Delta. The third time we go inside the loop is executed plus three.

170
00:22:01,080 --> 00:22:05,700
I think it's the yeah it is execute plus three.

171
00:22:08,830 --> 00:22:13,660
So you're either subtracting or adding delta each time you go inside the this.

172
00:22:14,160 --> 00:22:20,580
So this, this is Delta and then we're going to stop whenever a delta is kind of sufficiently small,

173
00:22:20,580 --> 00:22:27,120
whenever you're adding the additional thing that you're adding or subtracting is very small in absolute value.

174
00:22:27,120 --> 00:22:34,380
Whenever that happens, you change, you terminate the loop.

175
00:22:35,310 --> 00:22:42,750
Is this really only works? Well, x is. Less than one year.

176
00:22:44,250 --> 00:22:47,910
So that's kind of the way we set it up. I set it up.

177
00:22:49,500 --> 00:22:57,239
Okay. So that's going to this is going to terminate when Delta is small.

178
00:22:57,240 --> 00:23:01,740
So it keeps going while Delta is greater than top.

179
00:23:02,190 --> 00:23:08,650
Whenever Delta is lesser than or equal to my o one, then that will stop.

180
00:23:08,970 --> 00:23:14,800
Okay. We can see that here. Delta is just the x to the eighth power raised over I.

181
00:23:15,090 --> 00:23:19,320
Now X to the eighth power divided by I. That's the value of Delta.

182
00:23:19,920 --> 00:23:26,460
And so depending on whether or not I is even or odd, you either subtract or add that term.

183
00:23:27,420 --> 00:23:34,600
That's what I'm doing here. If it's even we add delta, if I is odd, we subtract Delta.

184
00:23:35,630 --> 00:23:46,650
Okay. So some is the variable that's going to store the the cumulative sum eventually going to approximate natural log of OnePlus X.

185
00:23:47,550 --> 00:23:59,490
And then in each iteration I'm printing out the value of the iteration number and the kind of the current approximation of natural log of OnePlus X.

186
00:24:00,060 --> 00:24:11,310
So that's kind of the current current. So then also we need to increase high every time we each time we go inside the loop since that affects Delta.

187
00:24:11,490 --> 00:24:22,830
Okay. And then at the end, after we've kind of done enough iterations to converge to come out of a final the final value of our approximation,

188
00:24:22,830 --> 00:24:26,190
it's kind of the last line equals.

189
00:24:29,970 --> 00:24:33,480
Okay. So this is kind of what it looks like. I mean, I think this works.

190
00:24:33,480 --> 00:24:39,180
If x x should be really where set this up, x should be between zero and one.

191
00:24:40,110 --> 00:24:48,209
So if I enter 0.833, this is kind of what it looks like printing out something.

192
00:24:48,210 --> 00:24:54,990
Every iteration prints all of this out. So it takes like it takes 22 iterations to converge.

193
00:24:55,590 --> 00:25:02,010
Okay. And then here just kind of just the value after running 22nd iteration.

194
00:25:02,760 --> 00:25:06,840
So it gives us a value of about 0.06055.

195
00:25:08,050 --> 00:25:17,129
So our final approximation so you could see this terminates basically terminating whenever the difference between

196
00:25:17,130 --> 00:25:24,810
this and this value here and the previous current value whenever that's sufficiently small that that it terminates.

197
00:25:24,810 --> 00:25:34,170
So you can see here, I think it's it's finally less than slightly less than 0.0 and these two values.

198
00:25:37,020 --> 00:25:42,630
Okay, so that's kind of a more realistic example of a while where.

199
00:25:46,840 --> 00:25:50,260
Terminating based on the condition. And you kind of don't know ahead of time.

200
00:25:51,040 --> 00:25:54,720
You don't really know how many iterations it's going to take to converge.

201
00:25:54,730 --> 00:25:59,470
But, you know, we want to stop whenever this this criterion is met.

202
00:26:00,970 --> 00:26:11,590
So that is why I would so I think that do the do while loop is kind of similar as well.

203
00:26:11,600 --> 00:26:23,770
Just do it quickly. I guess the the main difference is that when you kind of evaluate the code chunk of code first before checking the condition,

204
00:26:25,420 --> 00:26:29,649
so you kind of always do this code chunk at least once.

205
00:26:29,650 --> 00:26:35,980
So even if the even if the condition is false, when you you know,

206
00:26:36,130 --> 00:26:41,950
when you start out and you didn't change it here, you're still going to execute this chunk of code at least once.

207
00:26:42,400 --> 00:26:51,700
Okay? You always do this at least once. And then you're checking this this condition kind of after after the sentence.

208
00:26:55,480 --> 00:26:58,600
But other than that, it's pretty, pretty, pretty much the same thing.

209
00:26:58,600 --> 00:27:04,450
So you just keep repeating this code chunk until this condition becomes false.

210
00:27:04,690 --> 00:27:11,589
Okay. So yeah, it's pretty much the same thing as a wild statement.

211
00:27:11,590 --> 00:27:21,460
Just the main difference is that while kind of this chunk of code at least has to at least has to run once.

212
00:27:22,270 --> 00:27:28,630
Okay, so here's a nice small example, just showing how they can be different.

213
00:27:29,560 --> 00:27:35,590
So here, have an example. Okay. So I have, I have two integer variables, you and I,

214
00:27:37,560 --> 00:27:46,209
that kind of set up the logic saying that the terminated condition is the same for the wild and dual file which is

215
00:27:46,210 --> 00:27:56,200
based on you is less than one versus is less than one the same type of thing here when we run this wild statement,

216
00:27:56,200 --> 00:27:59,560
it doesn't it doesn't even go inside the body of the wild.

217
00:27:59,710 --> 00:28:07,090
Right. And so it's kind of the first the first time we checked this condition, it's it's false.

218
00:28:07,090 --> 00:28:11,049
So is equal to one. We're checking if is less than one.

219
00:28:11,050 --> 00:28:18,960
So that's false. So it doesn't even print out the message inside the wild if we look at the Dubai loop.

220
00:28:19,470 --> 00:28:23,860
So this is this is false. Even without incrementing use, it's false.

221
00:28:23,860 --> 00:28:30,160
But you still you still execute the the body of this do statement, the response.

222
00:28:30,250 --> 00:28:42,910
Okay, so here it turns out this this message inside the do while loop graph didn't do the same thing for the while.

223
00:28:44,740 --> 00:28:47,889
Here's another message example here.

224
00:28:47,890 --> 00:28:54,370
They actually do the kind of the same thing, you know.

225
00:28:59,890 --> 00:29:07,660
You have no reason not to, I guess. I guess in the violin case, he threw out this message twice.

226
00:29:09,810 --> 00:29:13,420
Each time in the second time, you go inside the loop.

227
00:29:14,740 --> 00:29:23,110
I becomes three. So kind of when you go back and check this condition, since I is three, this is evaluated to false.

228
00:29:23,110 --> 00:29:28,820
So it terminates to one so that it doesn't print anything.

229
00:29:29,980 --> 00:29:34,020
It's kind of only executing the body of the file state twice.

230
00:29:34,900 --> 00:29:38,350
Kind of the same thing for the do while the first time you go inside the loop.

231
00:29:38,950 --> 00:29:43,000
He was one. Print this out and then you becomes two.

232
00:29:44,050 --> 00:29:47,980
So you're going to go back and do the body of the do while statement again.

233
00:29:49,000 --> 00:29:54,460
So you has to sing this out and then comes he's free.

234
00:29:55,900 --> 00:30:04,840
So then it checks that condition. So that terminates the condition that terminates the do while loop since he was three.

235
00:30:05,410 --> 00:30:07,540
So it doesn't print anything out more than twice.

236
00:30:07,540 --> 00:30:22,420
So that's why to do while statement on frozen is also only printing something else twice so we can see here they're pretty they're pretty similar.

237
00:30:25,480 --> 00:30:38,890
It's just as this things these conditions always change to kind of weeks until after the body of the two while statement is X is executed.

238
00:30:39,010 --> 00:30:46,510
Okay. You said that since they're quite similar, I just can do my statement too quickly.

239
00:30:49,990 --> 00:30:53,680
Just so hopefully that's clear.

240
00:30:53,680 --> 00:30:58,120
So the last type of loop is the for loop basically.

241
00:30:58,690 --> 00:31:04,179
So the for loop in C++ has the following kind of syntax.

242
00:31:04,180 --> 00:31:18,010
The way you can do it is you have four and then Mix said basically is usually initialize some variable involved in the for loop.

243
00:31:18,640 --> 00:31:22,150
I'd say it's typically an integer is the most common type of thing.

244
00:31:23,140 --> 00:31:32,950
So you usually have an integer variable that's involved in your for loop and then in this piece of code, you're initializing it.

245
00:31:33,700 --> 00:31:38,950
So often it's it's zero. It doesn't have to be, but often it is.

246
00:31:39,490 --> 00:31:43,750
So you'll say like I equals zero is pretty common.

247
00:31:46,820 --> 00:31:53,120
So that just says when we're starting to for loop I as an integer variable and we're setting it equal to zero.

248
00:31:54,560 --> 00:32:00,500
So after that runs, it's not run again any time throughout before.

249
00:32:00,650 --> 00:32:11,240
So the net part is only run once. Okay. So the next piece is the condition.

250
00:32:11,250 --> 00:32:17,090
So this is kind of the same type of thing as the while loop or do like loop.

251
00:32:17,100 --> 00:32:25,700
So this is either a kind of a variable or often a boolean expression and something that evaluates to true or false.

252
00:32:26,270 --> 00:32:33,799
So if if this is true, you're going to execute the body of the false.

253
00:32:33,800 --> 00:32:43,010
You're going to execute this chunk of code. Okay. If this is true and also at the same time, this this update.

254
00:32:43,310 --> 00:32:49,450
So every time condition evaluates to true, you run this update and the chunk of code.

255
00:32:49,460 --> 00:33:00,020
So update is update is something that's well because it changes the value of some variable.

256
00:33:00,560 --> 00:33:08,290
Typically the the variable that it was initialized here is that usual way to write it for a loop.

257
00:33:08,300 --> 00:33:15,530
So if you initialized an integer variable I here usually this update is like you're

258
00:33:15,530 --> 00:33:20,739
just going to say I'm going to increase the value by by one half to be that.

259
00:33:20,740 --> 00:33:29,060
But that's pretty common. So typically you'll have something like four int equals zero.

260
00:33:29,600 --> 00:33:38,840
I have a condition like let's say I is less than five and then you'll have an update like is equal to I plus one.

261
00:33:39,090 --> 00:33:49,729
It's kind of a very typical format that you would use in a form and then kind of every

262
00:33:49,730 --> 00:33:55,219
time kind of like basically every iteration while this is still running updated run.

263
00:33:55,220 --> 00:34:00,340
So you're updating the value of some variable in every iteration of the format.

264
00:34:03,900 --> 00:34:07,280
And then and then the fourth loop terminates.

265
00:34:08,090 --> 00:34:16,670
The first time this this condition evaluates to false whenever that the first time that becomes false and for loop is terminated.

266
00:34:18,230 --> 00:34:22,220
All right. So I think probably just some examples of make it a little more clear.

267
00:34:22,230 --> 00:34:34,370
So here's an example where we're just printing out the value of the first five integers and the first five integers squared.

268
00:34:36,330 --> 00:34:40,170
So that that can be turned directly down with a loop.

269
00:34:40,680 --> 00:34:50,010
Are particularly for loop in this case. So here in this case we have a for loop for initializing the integer variable to one.

270
00:34:51,210 --> 00:34:54,120
And then since we're going to do this five times,

271
00:34:54,660 --> 00:35:01,590
basically each iteration of the loop are going to increase by by one and then you're going to check this condition.

272
00:35:01,590 --> 00:35:09,810
So this should it should run until it becomes five or more.

273
00:35:10,710 --> 00:35:23,280
Okay. So this once this becomes five three, it'll terminate here actually for four integers.

274
00:35:23,280 --> 00:35:27,690
I guess I should should have said, since this is looking at less than five.

275
00:35:32,670 --> 00:35:42,299
So yeah, each time we go inside the loop, the value of turning out the value of AI is basically that value.

276
00:35:42,300 --> 00:35:48,410
So it's going to be one or an AI squared, which here is ID.

277
00:35:49,590 --> 00:35:57,060
So this prints out, this executes like four iterations of the loop.

278
00:35:57,120 --> 00:36:09,540
So I is one, two, three and four and then kind of the next time as after the fourth iteration, I becomes five.

279
00:36:10,560 --> 00:36:16,590
And so before you start the fifth iteration, this condition is checked.

280
00:36:17,910 --> 00:36:23,820
And so I see that this is false since I is now five, so that the loop is terminated.

281
00:36:23,980 --> 00:36:31,020
So after the fourth iteration loop is terminated and you don't,

282
00:36:31,050 --> 00:36:36,810
you don't pronounce the message for the fifth iterations and since it's already been terminated.

283
00:36:37,050 --> 00:36:43,230
So this is code here, prints out the first four four integers and you're squared.

284
00:36:48,270 --> 00:36:57,480
Okay. So here's another example. Basically computing ten factorial sex just one times, two times 3 to 10.

285
00:36:57,930 --> 00:37:05,790
So we can also do that with a four loop. Like each time you go inside the loop, you're going to multiply a variable by a certain number.

286
00:37:05,790 --> 00:37:12,000
So the first times multiply our variable by one, the second time we go inside the loop.

287
00:37:12,510 --> 00:37:20,069
So multiply it by two and we'll store that value a third iteration of the loop, we multiply it by three, etc., etc.

288
00:37:20,070 --> 00:37:26,910
So to store the the value that we're going to use to compute the ten factorial,

289
00:37:26,910 --> 00:37:39,239
I just created this integer variable ten initialize it at one and then in the loop I've initialized our integer

290
00:37:39,240 --> 00:37:49,440
variable by an equal to one and I want to keep using I until well up through is lesser than or equal to ten.

291
00:37:50,130 --> 00:37:53,150
And so it's going to be terminated whenever I becomes 11.

292
00:37:54,270 --> 00:38:04,169
So here you can see inside the loop we're just multiplying like the current value of fact ten by so in fact,

293
00:38:04,170 --> 00:38:10,409
ten starts at one the first time we go inside the loop and multiply by one second time or the

294
00:38:10,410 --> 00:38:18,000
second iteration multiplied by two becomes one times two third time we are iteration in the loop.

295
00:38:18,000 --> 00:38:28,770
It becomes one times two times three. So after we've repeated this ten times, fact ten, the variable 510 should be storing the value of ten factorial.

296
00:38:30,040 --> 00:38:33,720
So you can see here at the bottom, just print out this value.

297
00:38:35,970 --> 00:38:39,090
All right. So that is just another example of a loop.

298
00:38:39,810 --> 00:38:45,540
I think this is a good example of a loop since this is a case where we kind of know

299
00:38:46,080 --> 00:38:51,610
exactly how many iterations we need to do the computation that you're interested in.

300
00:38:51,630 --> 00:38:58,860
So here we know exactly kind of ten, ten iterations to compute ten.

301
00:38:58,870 --> 00:39:07,499
In fact, that was oh. So I think that's basically at least for the description of the loop.

302
00:39:07,500 --> 00:39:13,170
So I just have kind of a final question just to use a little bit of a review,

303
00:39:13,170 --> 00:39:21,299
and I think I have one more example, just as an additional example so we know how to use loops.

304
00:39:21,300 --> 00:39:31,820
So this is just a quick example. So this is. So what is this going to turn out if we run this company?

305
00:39:31,820 --> 00:39:35,900
So this is we have an integer X.

306
00:39:36,620 --> 00:39:43,489
You started at one and then we have a for loop, which for a loop should have five iterations.

307
00:39:43,490 --> 00:39:48,470
We start iin equal one and we go up to I lesser than or equal to five.

308
00:39:49,160 --> 00:39:55,040
So it only terminates when I become six. So we should have five iterations in that slope.

309
00:39:55,820 --> 00:40:05,810
Then we have kind of this false statement going on inside. So if I is less than three, we increase X by one, otherwise decrease x51.

310
00:40:07,220 --> 00:40:16,490
So the first two iterations we should be increasing expired on the first iteration is equal to one.

311
00:40:17,180 --> 00:40:21,530
So in that case X becomes two, second iteration is two.

312
00:40:21,530 --> 00:40:25,729
So we're still doing this part of the L statement.

313
00:40:25,730 --> 00:40:35,930
So X would become three in the third iteration, and we're doing this as part, so we're decreasing X by one.

314
00:40:35,930 --> 00:40:43,130
It becomes two. In the last two iterations, we also decrease X by, so it should go down to zero.

315
00:40:45,890 --> 00:40:50,629
So by the time we go through all of the iterations of the loop actually zero.

316
00:40:50,630 --> 00:40:54,200
So what's printed out here should be x equals.

317
00:40:54,720 --> 00:41:00,200
But this should just point out the number zero, since I don't have any additional message to add.

318
00:41:00,800 --> 00:41:12,420
So this should print out zero if you run this. So just kind of a small example just to make sure we knew some of the for loops.

319
00:41:12,420 --> 00:41:18,469
So let's do another thing in our module as well.

320
00:41:18,470 --> 00:41:27,760
So this is just a. An example of using loops to check whether or not a certain number is prime or not.

321
00:41:28,450 --> 00:41:38,500
So let's say we want to write a program. C++ programing basically gets a like a positive integer from the user greater than or equal to two.

322
00:41:39,100 --> 00:41:45,730
And then it basically just prints out a message telling us whether or not that input number is a prime number or not.

323
00:41:46,420 --> 00:41:54,879
So that's really all it should do is take the integer from the user and print out a message saying whether or not it's prime.

324
00:41:54,880 --> 00:42:00,100
So let's just remember what a prime number is.

325
00:42:00,100 --> 00:42:04,240
It's a it's a person or at least an integer.

326
00:42:06,640 --> 00:42:17,320
There's not or we don't have another integer greater than or equal to two that divides that number.

327
00:42:18,670 --> 00:42:28,000
So if we think of the numbers 12, for example, so they're the numbers six divides 12 so that's that's not prime.

328
00:42:28,180 --> 00:42:37,750
Okay. But the number 13 is prime since there's no there's no number between one and 13 that kind of divides 13.

329
00:42:40,540 --> 00:42:43,569
All right. So let's line here.

330
00:42:43,570 --> 00:42:51,940
A little integer is, okay, so this is kind of a program that would that would check whether or not something's prime.

331
00:42:51,940 --> 00:42:57,729
So the way I've done that is just with a loop, basically.

332
00:42:57,730 --> 00:43:03,610
So let's I guess this is kind of the the main part of the program is loop part.

333
00:43:04,660 --> 00:43:09,880
So what are we doing here? So X is kind of the the integer that the the user inputs.

334
00:43:11,310 --> 00:43:15,660
So I'm just checking each number from to up to X minus one.

335
00:43:16,350 --> 00:43:26,340
So if you check each integer from two to X minus one, if you check whether or not each one of those divides X, you can determine if it's prime or not.

336
00:43:27,300 --> 00:43:33,240
So if all of the numbers between two an X minus one at first.

337
00:43:34,400 --> 00:43:37,420
I guess if none of them divides acts, then you know that it's prime.

338
00:43:40,120 --> 00:43:49,719
So we can do that each as an individual checking by just looking for a loop where we started to go up to less than X.

339
00:43:49,720 --> 00:43:55,060
So this is basically going into all of the I's from two up to X minus one.

340
00:43:56,950 --> 00:44:05,650
So at the beginning we have this variable is prime, the variable is prime.

341
00:44:06,520 --> 00:44:09,639
I have initialized that equal the true.

342
00:44:09,640 --> 00:44:17,260
So this is a a boolean variable. So remember a bully invariably use this keyword be overkill.

343
00:44:18,280 --> 00:44:29,290
So it starts out if it's true, then inside the loop I only I only change the value of his prime if I detected a well,

344
00:44:30,000 --> 00:44:37,510
you know, if you detected a reason for not to be prime. So you, if you determine that it's not prime, you change the value of his prime.

345
00:44:38,260 --> 00:44:43,210
Otherwise the value of his prime is going just going to stay as true.

346
00:44:44,140 --> 00:44:51,500
And so after you finish the loop, if it's never changed to false, you're going to execute this part of the if l statement.

347
00:44:51,530 --> 00:45:02,920
So it's going to say X is a prime if it has been changed to false, you're going to this part is prime has been changed to false.

348
00:45:03,400 --> 00:45:08,870
You're going to throw out you know, X is not a prime number. That's kind of how it works.

349
00:45:08,890 --> 00:45:14,280
So you can see this if statement is really the key part that's checking whether or not it's problem.

350
00:45:14,290 --> 00:45:22,779
So the same if x modulus is zero just basically me.

351
00:45:22,780 --> 00:45:28,300
That means that I divide x, so that automatically means that x is not the promise.

352
00:45:29,440 --> 00:45:33,580
So when that when that is true, you just set is prime false.

353
00:45:35,590 --> 00:45:42,850
You can actually include a break statement as well since you don't really need to do any of the other remaining iterations.

354
00:45:42,850 --> 00:45:47,290
Once you've found one of the i's that divides x, you already know that it's not prime.

355
00:45:47,830 --> 00:45:52,990
So what is break? Break? Just whenever you run the break statement, it just terminates the loop.

356
00:45:53,290 --> 00:46:04,690
Okay. So for example. Well, yeah, let's just say if the user inputs 12, I mean, I think that's an easy case like to divide 12.

357
00:46:05,470 --> 00:46:16,510
So in the first iteration, where is two, you should this you should go inside this statement since this should be true so it's

358
00:46:16,510 --> 00:46:23,620
going to change the is primed to false and then you're going to hit the break statement.

359
00:46:23,620 --> 00:46:31,480
So it's going to terminate the loop. So if you if you input X is 12, it should only do one iteration of the other four.

360
00:46:32,740 --> 00:46:37,510
That's kind of in the first iteration you hit the break statement and that terminates.

361
00:46:37,870 --> 00:46:43,870
So if you enter 12, for example, you should only have one iteration, the fourth.

362
00:46:47,270 --> 00:46:55,190
Okay. So that's kind of how that how that works. So yeah, this is just a screenshot of how this kind of works in practice.

363
00:46:56,170 --> 00:47:01,790
So here, this is code on the left.

364
00:47:01,790 --> 00:47:04,940
This is here is compiling it.

365
00:47:05,600 --> 00:47:09,470
And each time you do that slash main, that's just running the program.

366
00:47:11,780 --> 00:47:16,400
So here it promises to enter a positive integer greater than or equal to two.

367
00:47:17,100 --> 00:47:20,840
In the first example, two two is a prime number.

368
00:47:21,770 --> 00:47:29,360
The second case 12 prints out 12 is a prime number, but it's not a prime for sorry.

369
00:47:33,020 --> 00:47:38,000
So it's correct. So other case 33, that's not a prime number.

370
00:47:39,050 --> 00:47:42,830
59 is a prime number seven is not a prime.

371
00:47:42,830 --> 00:47:49,740
Number one over one is a prime number. So I think it seems to work properly.

372
00:47:50,900 --> 00:48:02,870
So that's just kind of how you can run it in practice. So the last couple of things I'll mention is just you can use you can certainly use nested

373
00:48:02,870 --> 00:48:14,059
loops that are just loops within a loop mean you often have close combat to loops.

374
00:48:14,060 --> 00:48:17,960
Maybe, I guess you could have more than that.

375
00:48:20,540 --> 00:48:24,410
The way that works, for example, if you have a loop within a loop,

376
00:48:24,800 --> 00:48:31,820
kind of a loop inside of the bigger loop is referred to as the inner loop and kind of the outer side.

377
00:48:31,820 --> 00:48:35,240
A loop containing that loop is usually referred to as the outer loop.

378
00:48:35,930 --> 00:48:46,520
So the way that works is that for each iteration of the outer loop, the entire inner loop runs nested loop works.

379
00:48:48,650 --> 00:48:50,840
Example one Following these lines.

380
00:48:51,680 --> 00:49:03,049
The other kind of keywords that are often useful with working with loops or specifically for loops are our break the break statement.

381
00:49:03,050 --> 00:49:07,070
We just saw an example of that. I think Contenu is also pretty useful.

382
00:49:07,880 --> 00:49:15,560
So the break statement that basically just whenever it runs the break statement by itself, that just terminates the loop.

383
00:49:16,160 --> 00:49:24,230
That's really its purpose. Okay. The only thing to keep in mind, especially if you're using nested loops,

384
00:49:24,800 --> 00:49:32,870
it doesn't kill whenever that runs, doesn't kill like the entire chain of loops.

385
00:49:32,870 --> 00:49:39,740
I guess if you want to think of it that way, if you have it inside of two loops, it only kills like the inner.

386
00:49:40,190 --> 00:49:45,400
Like if you have two loops and a nested loops type of sentence.

387
00:49:45,950 --> 00:49:52,160
If your break statement is inside the inner loop, that only will terminate the inner loop.

388
00:49:53,270 --> 00:49:58,280
You'll still go. You can still run another iteration of your your outer.

389
00:50:01,890 --> 00:50:04,950
Okay. So continue. I don't know if I have an example of this.

390
00:50:07,200 --> 00:50:14,910
Basically, the way that works is that whenever that's run,

391
00:50:15,780 --> 00:50:24,540
it's basically skips the stuff in the loop and the loop below it and then goes to like the next iteration.

392
00:50:25,740 --> 00:50:33,420
It doesn't terminate the loop, but it kind of just automatically skips to the next iteration.

393
00:50:33,420 --> 00:50:38,729
So if you have some code below your continuous statement, it won't execute that.

394
00:50:38,730 --> 00:50:44,570
And like the, the current iteration, it'll kind of automatically go to the next iteration.

395
00:50:44,580 --> 00:50:55,020
Sometimes it's useful. Sometimes you have a condition where you don't necessarily want to terminate the loop when the condition calls,

396
00:50:55,020 --> 00:51:01,160
but you don't want to execute any of this stuff inside the loop if that condition is true.

397
00:51:01,950 --> 00:51:06,330
So that that that's the type of situation where you might want to use content.

398
00:51:07,980 --> 00:51:12,150
Okay. So here's just an example of a quick example of a nested loop.

399
00:51:14,220 --> 00:51:18,800
So here we have a loop, kind of a loop inside of a loop.

400
00:51:18,810 --> 00:51:25,860
So the outer loop is up here and the outer loop is kind of the I part of the loop.

401
00:51:26,490 --> 00:51:38,219
It's use it and it's the looping variable associated with the outer loop is high and then kind of the looping variable associated with the inner loop.

402
00:51:38,220 --> 00:51:49,260
AJ So the way this works is for each iteration of the outer loop, where I'm going from 1 to 3,

403
00:51:49,980 --> 00:51:56,090
we do this entire interlude, and so it's going to turn out Jay, where Jay only goes from one.

404
00:51:56,100 --> 00:52:00,179
And I actually find the first iteration of the outer loop.

405
00:52:00,180 --> 00:52:05,639
It's only going to we're only going to have one iteration of the inner loop after

406
00:52:05,640 --> 00:52:11,250
the second iteration of the outer with or ties to two iterations of the loop.

407
00:52:11,850 --> 00:52:17,430
And then for the third iteration of the outer loop, we're going to have three iterations for the inner.

408
00:52:17,580 --> 00:52:23,879
So we should have kind of one plus two plus three, which kind of print messages in total.

409
00:52:23,880 --> 00:52:29,130
So there should be six messages in total. So that's what's shown here.

410
00:52:30,060 --> 00:52:38,040
So we have one one. So that's like the case where I is equal to one, equal to two.

411
00:52:38,070 --> 00:52:44,129
You have two different messages to one and two, two, and then one is equal to three.

412
00:52:44,130 --> 00:52:54,900
We have three printing messages. So it's just hopefully it makes it a little more clear that for each iteration in the outer loop,

413
00:52:54,900 --> 00:53:06,480
we're executing the entire inner for several you know, here's just an equivalent way of doing the same thing using a brace statement here.

414
00:53:06,870 --> 00:53:11,850
I guess the difference here and the previous nested for which we're going from

415
00:53:12,420 --> 00:53:17,970
we're going for PI is equal to one up to three and j from 1 to 3 in every case.

416
00:53:19,080 --> 00:53:23,050
Okay. Rather than j to i.

417
00:53:23,630 --> 00:53:31,750
However, in each of the inner loops, we do this thing whenever j is equal to high.

418
00:53:32,320 --> 00:53:40,320
So that actually does say exactly the same thing, since whenever J reaches I and terminates this interlude,

419
00:53:42,150 --> 00:53:48,010
the first for the first iteration, the outer loop only do one these and terminates this.

420
00:53:49,480 --> 00:53:55,750
And in the second iteration, the outer loop will have two of these print statements are going to terminate the inner loop.

421
00:53:56,920 --> 00:54:07,030
Third, after that, for the third iteration in our loop, we have three iterations of the interlude before it kind of entered a loop is term.

422
00:54:07,300 --> 00:54:13,810
So this is often not the exact same sequence of numbers as the previous the previous example.

423
00:54:15,370 --> 00:54:22,150
Okay. All right. So that's that's it for loops.

424
00:54:29,080 --> 00:54:33,880
Three clear questions about that before we move on or.

425
00:54:43,110 --> 00:54:49,019
Okay. So let's not let's keep moving. So it's kind of a big, big topic, Don.

426
00:54:49,020 --> 00:54:53,490
So the next big topic is how to write functions in C++.

427
00:54:54,570 --> 00:55:01,979
So let's see. So we'll just start out with like how to declare functions, I guess,

428
00:55:01,980 --> 00:55:08,250
and then kind of the key things that you have to include in a function declaration

429
00:55:08,880 --> 00:55:14,730
and then hopefully some examples will make this a little bit more clear,

430
00:55:14,730 --> 00:55:16,260
kind of how to use it in practice.

431
00:55:16,260 --> 00:55:25,910
But here, just to get started, just kind of the overall key features that you have to have in a function declaration.

432
00:55:25,920 --> 00:55:33,480
So in a function declaration in C++, you have to include the type.

433
00:55:34,080 --> 00:55:41,100
So just like variables, when you declare variables in C++, you have to have a type associated with it.

434
00:55:41,610 --> 00:55:47,459
You do have to have a type for your function.

435
00:55:47,460 --> 00:55:55,530
So that's basically the type for that you need to have with your functions, basically the type of the variable that returns.

436
00:55:56,190 --> 00:56:01,470
And so your functions typically return something, some number or something.

437
00:56:01,990 --> 00:56:06,700
And so the type of that number that's supposed to return is, is the type that you have here.

438
00:56:06,820 --> 00:56:10,770
Okay. So it returns a double.

439
00:56:11,250 --> 00:56:19,379
You would put on double. The second component is just the name of the function itself.

440
00:56:19,380 --> 00:56:25,530
So I just put function name here. But you usually have a name of some kind.

441
00:56:26,200 --> 00:56:30,810
Now typically be related to what the function does.

442
00:56:32,190 --> 00:56:35,700
So you see some examples of that as well.

443
00:56:36,300 --> 00:56:40,990
And then your function has kind of a collection of inputs basically.

444
00:56:41,100 --> 00:56:47,580
Lot of that will call it arguments that those are basically like those are just inputs to the function.

445
00:56:48,090 --> 00:56:51,300
You could have multiple arguments.

446
00:56:51,330 --> 00:56:57,750
You could have a single argument, like if you are read one here, you could have kind of many arguments in your function.

447
00:56:57,750 --> 00:57:05,280
So those are just those are just the terms that are inputs to the function and your function declaration.

448
00:57:05,280 --> 00:57:08,700
You also have to include the title of the arguments.

449
00:57:09,810 --> 00:57:12,270
You have to include the type of each one of the arguments.

450
00:57:13,050 --> 00:57:24,510
So that's kind of, I guess, the key thing that you need to keep in mind when writing function declarations in C++,

451
00:57:24,510 --> 00:57:30,950
kind of everything has to have a type that's to manifest its function itself, has to have a type.

452
00:57:31,000 --> 00:57:39,360
Every of the arguments have to have a type. The other thing, I still see some examples.

453
00:57:39,360 --> 00:57:43,680
There are there are cases where you have functions that don't necessarily return anything.

454
00:57:46,290 --> 00:57:54,990
In that case, you still have to have kind of a type that you that you have you have with the function declaration.

455
00:57:55,000 --> 00:57:58,530
So in that case, you just do the void. So you have the keyword void.

456
00:57:58,950 --> 00:58:05,520
Whenever you have a function that doesn't return anything. And I think I have at least a few examples of that.

457
00:58:07,140 --> 00:58:19,650
I guess the other thing is that you can if you if you prefer, that way you can have kind of a function declaration at the top of your C++ file,

458
00:58:19,650 --> 00:58:32,610
but have your the actual like body of the function written somewhere much later in your your C++ file, for example.

459
00:58:33,120 --> 00:58:35,040
So you could declare your function.

460
00:58:35,040 --> 00:58:46,079
Let's, let's to the top of your C++ file and then have the the main domain as kind of the main thing that shows up first.

461
00:58:46,080 --> 00:58:54,170
And then you could have the function kind of way below that and your C++ C that is allowed if you prefer to do it that way.

462
00:58:54,180 --> 00:59:04,170
So you can kind of separate the function declaration from the, from the actual like definition of the components of the function.

463
00:59:05,010 --> 00:59:11,430
So like these. Okay.

464
00:59:12,630 --> 00:59:19,500
So here is kind of an example of how you could do this prime checker type of program where

465
00:59:19,500 --> 00:59:29,310
you've separated kind of the prime check part out into a into a separate function from Main.

466
00:59:29,490 --> 00:59:37,500
Okay. So let's say we also we wanted a well basically kind of the same thing that we had in the previous example.

467
00:59:39,600 --> 00:59:50,260
We basically want to have a program where the input is an integer and the output is basically like a oh.

468
00:59:52,980 --> 00:59:56,880
So the output is the same print message.

469
00:59:58,140 --> 01:00:05,040
So you want to do this where we have a separate function outside of Main that kind of does part of it.

470
01:00:05,610 --> 01:00:12,730
So the separate outside function outside of Main is going to be a function called in prime.

471
01:00:13,410 --> 01:00:22,230
So we want that function to have an integer input. And then basically what it returns is going to be a a billion variable.

472
01:00:22,440 --> 01:00:26,819
Okay. So it's going to be true if the integers prime and then false.

473
01:00:26,820 --> 01:00:36,900
Otherwise supposing we have that function implemented somewhere, so we're talking about actual implementation on it.

474
01:00:38,010 --> 01:00:41,930
On the next slide. So just assume that we have that already written.

475
01:00:42,670 --> 01:00:47,640
Okay. So this is kind of the way that man this is the way man would look.

476
01:00:49,050 --> 01:00:54,780
This is how a man would look like most likely. Look at it.

477
01:00:54,780 --> 01:01:03,540
With this you would just declare an integer variable and then you would do prompt the user to input that variable.

478
01:01:03,960 --> 01:01:12,600
And then you would just say if is prime number, that's basically saying if is prime returns the value true,

479
01:01:13,440 --> 01:01:19,290
you're going to print out this is a prime number message. Otherwise it's going to print out.

480
01:01:19,290 --> 01:01:31,829
This is not a prime. So this is so the fact that we have this is prime function implemented somewhere outside of Main.

481
01:01:31,830 --> 01:01:35,700
I think it makes Main a lot simpler and a lot easier to read.

482
01:01:36,820 --> 01:01:46,080
This is would especially be true of is let's say the is prime calculation where even like a lot more or substantially more complicated.

483
01:01:46,440 --> 01:01:52,980
I think this is a lot like it makes main a lot easier to read kind of the logic is a lot more clear.

484
01:01:53,460 --> 01:01:56,850
Okay, so that's kind of one of the main purposes of functions.

485
01:01:56,850 --> 01:02:06,100
I think it makes your code in that kind of logic a lot, a lot easier.

486
01:02:06,300 --> 01:02:13,150
You don't have to put huge chunks of code inside of me.

487
01:02:13,160 --> 01:02:22,410
You can kind of separate out certain of the key calculations into separate functions.

488
01:02:22,560 --> 01:02:28,400
Okay. So this man is pretty straightforward to.

489
01:02:29,810 --> 01:02:40,100
Okay. So here is what it would look like if we added kind of a line where we actually add to that the function itself outside of this.

490
01:02:40,700 --> 01:02:47,510
So if you want to put it in a single C++ file, this is this is basically what it would look like.

491
01:02:48,530 --> 01:02:56,720
Although, as we said before, you can put it below if you want, but we're just putting it kind of before, man, this is what it would look like.

492
01:02:57,470 --> 01:03:00,920
So here, up here is the is prime function.

493
01:03:03,110 --> 01:03:09,620
So the is prime function kind of just does what we had on the the previous one when we're talking about for.

494
01:03:09,930 --> 01:03:15,020
But here I've just kind of put everything inside of the inside of a single function.

495
01:03:15,860 --> 01:03:20,479
Okay. So here this is what the function declaration looks like.

496
01:03:20,480 --> 01:03:23,750
We have rule since it returns a boolean variable.

497
01:03:24,290 --> 01:03:29,570
So we have to have that first and then the name of the function is underscore prime

498
01:03:30,350 --> 01:03:36,110
and then the input argument and only takes one argument which is like an integer x.

499
01:03:36,920 --> 01:03:42,160
But you know, keep in mind you have to declare the type of the variable and then it takes its input.

500
01:03:42,180 --> 01:03:50,120
So you since it takes X is input that's assumed to be an integer, we have to declare that it's an integer.

501
01:03:51,170 --> 01:03:55,549
And then inside of the function we just do the same kind of for loop calculation that we

502
01:03:55,550 --> 01:04:04,010
were talking about before we start it from two and then check whether or not I divisor x.

503
01:04:04,400 --> 01:04:13,730
Okay? So if I divides x, if I ever divide x, we just return false.

504
01:04:14,480 --> 01:04:23,990
So whenever this return statement is used that, that returns that value and it kind of kind of kills that function.

505
01:04:24,530 --> 01:04:36,559
I mean, maybe not kill is the right word, but it's not that's not even because even though we have stuff after this that this is

506
01:04:36,560 --> 01:04:41,630
assumed to be the return value and it doesn't really do anything else with that function.

507
01:04:41,900 --> 01:04:52,970
Okay. So basically, whenever the first time we see a number that divides X, it returns false as to the value that's returned by the function.

508
01:04:54,020 --> 01:05:02,000
If you've never seen a value of either returns that defines X, the function is going to return.

509
01:05:05,150 --> 01:05:14,750
So this is kind of a nice example of the kind of separated out it's the detailed this.

510
01:05:18,590 --> 01:05:23,959
Math part of the calculation that determines whether or not it's a prime or not.

511
01:05:23,960 --> 01:05:32,720
And then basically main is just for simply calling that function and putting out kind of the right that the right messages.

512
01:05:34,670 --> 01:05:38,520
Okay. So here's just an example.

513
01:05:38,540 --> 01:05:40,430
Yeah, this is just an example of running it.

514
01:05:42,560 --> 01:05:58,190
So I left the actual code and there are just a few examples of running it and but 447 the first time it was 3737 So this is based on these examples.

515
01:05:58,190 --> 01:06:02,620
It's it seems to be running correctly. Okay.

516
01:06:08,490 --> 01:06:13,440
Okay. So, yeah, like I said before, you can at least if you're writing in the same file,

517
01:06:13,440 --> 01:06:18,990
you can kind of separate the, the declaration and the function definition.

518
01:06:20,010 --> 01:06:27,240
Um, you know, this is useful, especially if, you know, if you want to have one kind of main first.

519
01:06:28,410 --> 01:06:35,910
So in that case, you just have to put the function declaration before main.

520
01:06:36,030 --> 01:06:46,080
Okay. So here I just the key thing is that you have to have is just the return type of the function and then the name of the function and then the,

521
01:06:46,560 --> 01:06:50,550
the types of the the variables. Those are kind of the key things to keep in mind.

522
01:06:51,270 --> 01:06:54,300
It just puts the function declaration first.

523
01:06:54,930 --> 01:07:00,630
And then down here I have the actual kind of the implementation of the function.

524
01:07:01,080 --> 01:07:05,100
So pretty after name. So this is perfectly fine to use addition.

525
01:07:05,910 --> 01:07:15,350
This should work basically the same as the. Exactly the same as the previous example where we had this entire function definition before.

526
01:07:16,480 --> 01:07:27,630
Okay. Okay. So the other thing I think I mentioned before is that you can have a function that doesn't return anything.

527
01:07:29,470 --> 01:07:36,720
Right. And typically, in that case, you might, you know, come an example, it might just print something out to the screen.

528
01:07:36,720 --> 01:07:43,860
So you call it functioning. Wanted to just print something out, but doesn't really return anything back.

529
01:07:45,450 --> 01:07:51,480
You know, that's perfectly fine. In that case, you just use the keyword void rather than a certain type.

530
01:07:51,750 --> 01:07:54,450
Okay, so here is this an example?

531
01:07:55,130 --> 01:08:08,490
I think I would just print where the user input a positive number and then you just print out like the like if they enter eight,

532
01:08:08,990 --> 01:08:13,320
you just prints out eight, seven, six, five, four, three, two, one.

533
01:08:13,620 --> 01:08:18,210
Basically the idea but it doesn't really return anything. You just prints out a list of numbers.

534
01:08:18,810 --> 01:08:22,590
Okay. So that's the purpose of this function.

535
01:08:22,590 --> 01:08:28,739
So this. So this function called print underscore top x.

536
01:08:28,740 --> 01:08:34,049
So it takes an integer takes an integer number and then I guess a boolean variable.

537
01:08:34,050 --> 01:08:43,560
So I guess that was whether or not it prints them from high to low or Princeton from low to high is basically what that that determines.

538
01:08:45,810 --> 01:08:49,170
Okay. So you can do that with a loop.

539
01:08:49,200 --> 01:08:57,390
So I have a loop inside of the function. So I start from I going from one up to X.

540
01:08:57,790 --> 01:09:00,899
Okay. And then I'm saying if descending.

541
01:09:00,900 --> 01:09:09,270
So it's just basically saying if the descending argument is true, I print out X minus I plus one.

542
01:09:09,270 --> 01:09:21,569
So that basically so like in the first iteration it's going to turn out X, so basically prints out x x minus one all the way down to.

543
01:09:21,570 --> 01:09:28,650
So I guess in the last iteration it prints out one, prints out x x minus one, x minus two all the way down to one.

544
01:09:29,610 --> 01:09:31,890
Basically, what happens if descending is true?

545
01:09:32,910 --> 01:09:41,110
If descending is false, it starts with one is basically the first number prints out, then two prints out.

546
01:09:41,130 --> 01:09:44,370
One, two, three, four, five, six, up to X. Okay.

547
01:09:44,850 --> 01:09:47,370
That's basically what all of this function does.

548
01:09:47,370 --> 01:09:54,230
Whenever we give it a number X and just prints out a list number of numbers, but it doesn't really return anything.

549
01:09:54,240 --> 01:10:00,860
It doesn't return since this prints. So that's in that case, we just want to include this voice keyword.

550
01:10:01,120 --> 01:10:07,980
Okay. So here, once we have this implementation of this function, this is what name might look like.

551
01:10:08,910 --> 01:10:14,350
So Main, we're just prompting the non the user to input a number.

552
01:10:14,370 --> 01:10:21,359
We're going to store it in this variable now. So remember, you have to declare everything before you use it.

553
01:10:21,360 --> 01:10:25,050
So we're declaring a variable non before we get it from the user.

554
01:10:25,980 --> 01:10:33,690
And then just to print out this list, all I have to do is just call this function and it kind of makes it makes me pretty easy.

555
01:10:34,590 --> 01:10:44,010
I would have to do it just called print topics. I would just give it this number and then in this case I just give it the boolean value.

556
01:10:44,340 --> 01:10:51,719
Since I wanted to print out the numbers, I guess from high to low, I guess like we want to do in this case.

557
01:10:51,720 --> 01:10:55,860
So here's just an example of of running it.

558
01:10:59,160 --> 01:11:04,590
So now in the first case, I just give it to number six points out, six, five, four, three, two, one.

559
01:11:05,190 --> 01:11:13,920
And then eight four, four, six, seven, six, five, four, three, two.

560
01:11:14,310 --> 01:11:18,299
So it's kind of what we expected. Okay.

561
01:11:18,300 --> 01:11:24,030
So here's another thing that sometimes is useful, which is best using default arguments.

562
01:11:24,840 --> 01:11:38,540
So basically that allows us to have certain arguments that we don't always have to provide those input arguments when we do.

563
01:11:38,990 --> 01:11:47,370
We call the function. So here in this case, this example X basically has no default arguments.

564
01:11:47,370 --> 01:11:53,040
But the second argument, a descending that has that has a default argument.

565
01:11:53,130 --> 01:11:54,960
So that's set to false.

566
01:11:55,620 --> 01:12:05,460
So all that means is that when we only give this function a single number, so we're just giving it the value of X, but not the second argument.

567
01:12:06,000 --> 01:12:09,900
It's just going to assume the value of the second arguments. False. That's all that is.

568
01:12:10,890 --> 01:12:16,980
The default target stuff. Things never give it a value.

569
01:12:16,980 --> 01:12:23,550
It just assumes that descending is equal to this default value of false.

570
01:12:23,670 --> 01:12:35,340
Okay. Okay. So when we when we call it and may like this, we call it in main, but we're only giving a single number when the function runs.

571
01:12:35,340 --> 01:12:40,229
It's going to run as if kind of descending is equal to descending.

572
01:12:40,230 --> 01:12:45,210
Has that value false? Okay. So that's kind of how that's how the false values would work.

573
01:12:46,410 --> 01:12:50,520
Okay. So here's an example of running it.

574
01:12:50,520 --> 01:12:59,160
So when it's false, it goes from low to high. So here it's just printing out the numbers, starting from one up to x.

575
01:12:59,250 --> 01:13:04,409
Okay. Since normally give it a number and sending as follows.

576
01:13:04,410 --> 01:13:11,130
So that's how you can use default arguments in C++.

577
01:13:11,880 --> 01:13:19,390
Okay. So this is a. Oh, yeah.

578
01:13:19,390 --> 01:13:20,340
I guess here's a point.

579
01:13:20,350 --> 01:13:34,239
Yeah, you do have to if you're if you if you kind of have a if you have a a declaration that's separate from the kind of implementation,

580
01:13:34,240 --> 01:13:38,230
you should only have the default argument in the function declaration.

581
01:13:44,640 --> 01:13:50,430
They definitely have to happen. This should not happen in this part as well.

582
01:13:53,030 --> 01:14:01,440
Okay. So you should add your function declaration that you have separate from the implementation you should have.

583
01:14:03,120 --> 01:14:08,519
You should specify the default value. But here you don't you should not use it.

584
01:14:08,520 --> 01:14:13,500
You should just have it without any specific default value defined.

585
01:14:18,570 --> 01:14:30,479
So I think that's just an extra detail about if you're using default values and the separation of the declaration from the implementation.

586
01:14:30,480 --> 01:14:36,870
Just a little detail to keep in mind is that she is avoiding any sorts of errors.

587
01:14:38,250 --> 01:14:48,780
Okay. So here's just kind of a little bit of a wrap of the question or review question before we kind of move on to some other topics.

588
01:14:50,310 --> 01:14:56,330
Okay. So let's kind of run the following through on the following program.

589
01:14:56,340 --> 01:15:06,209
So we have this function called pull underscore problem and it doesn't return anything.

590
01:15:06,210 --> 01:15:11,280
So it's just as a void type. So it's basically in this case, it just prints something out.

591
01:15:11,280 --> 01:15:16,440
So let's look at main first. So what are the numbers that we're giving it?

592
01:15:17,670 --> 01:15:23,320
So we're giving it the number zero as the first argument. So that's going to be let's see.

593
01:15:27,460 --> 01:15:40,330
Yeah, that's S1. So I think this this actually does work if we give it a zero or should to convert it in a sense to a p false.

594
01:15:41,020 --> 01:15:46,990
So you can think of S1 as false. And then the second argument is set.

595
01:15:47,110 --> 01:15:54,639
So even though it has a default value, this set overrides that, since we're giving it a value of seven.

596
01:15:54,640 --> 01:16:02,560
So you should think of X as having seven in this function and then S2 has the value to this function at least,

597
01:16:03,310 --> 01:16:12,810
at least when we're running disfunction. So S1 is false, x is seven and then S2 is true.

598
01:16:12,820 --> 01:16:20,740
So it's going to happen. So we have this if statement here which is saying whether or not if S1 and S2.

599
01:16:21,430 --> 01:16:25,540
So since S1 is false, this is kind of automatically false.

600
01:16:26,440 --> 01:16:32,829
So it's not going to print this part. So it's basically going to print the else part of the event statement.

601
01:16:32,830 --> 01:16:37,120
So it's going to print out X divided by two.

602
01:16:38,060 --> 01:16:51,760
So this was another thing that slightly I think it's another part about this question just to keep in mind, this is going to print out an integer.

603
01:16:51,760 --> 01:16:56,710
So keep that in mind if you're doing like division with integers.

604
01:16:57,310 --> 01:17:02,290
So this is, this is, this should print out three, you should print out the number three.

605
01:17:02,290 --> 01:17:11,469
So even though seven divided by two is 3.5 integer division in C++, it keeps them as integers.

606
01:17:11,470 --> 01:17:15,370
So it comes down to the first integer.

607
01:17:15,370 --> 01:17:24,150
So this you should actually print out three, which is something that's something to be careful about doing math with integers.

608
01:17:24,160 --> 01:17:40,270
Just make sure when you're making sure that a certain part of your calculation doesn't depend on the integer division doing kind of the correct thing.

609
01:17:40,510 --> 01:17:43,660
Okay. All right. So.

610
01:17:49,440 --> 01:17:57,150
Yeah, I guess. Yeah, this is just one or two slides. Uh, this is just one way of handling errors, I guess.

611
01:17:58,860 --> 01:18:04,829
So. It's often useful to have kind of error handling your programs.

612
01:18:04,830 --> 01:18:15,030
Like if somebody puts an invalid value or something else goes wrong with the program to have a.

613
01:18:19,550 --> 01:18:21,340
A way of handling that. I yes.

614
01:18:21,960 --> 01:18:36,040
So the way a man works is that if if zero is returned by man, that's really the main point of doing return zero in the form of I guess the.

615
01:18:41,390 --> 01:18:50,650
The right way to save the program in some sense of the system that the program is kind of completed successfully.

616
01:18:51,620 --> 01:18:55,730
Okay. So that's the purpose of including returns.

617
01:18:56,160 --> 01:19:05,260
You don't actually have to do a return zero if you might notice again, if you don't return anything else, it kind of does the term zero automatically.

618
01:19:07,040 --> 01:19:13,390
But I still think it's something it's common to include a return zero at the bottom of the name.

619
01:19:14,380 --> 01:19:22,510
However, if you if you have a non if you have a non zero return value, if that's returned,

620
01:19:23,020 --> 01:19:31,390
kind of informs the system that you're finished with, with with error and some error somewhere.

621
01:19:31,730 --> 01:19:37,510
Okay. And there, I guess there are different error codes that can give you things.

622
01:19:38,260 --> 01:19:42,150
So I guess there's two kind of common ways.

623
01:19:42,160 --> 01:19:49,720
So in your main function, you can of just return something that's basically non zero is one way to do it.

624
01:19:53,170 --> 01:19:56,710
And then there's also another way is using an exit keyword.

625
01:19:57,310 --> 01:20:03,880
Okay. That's another that's another way to kind of.

626
01:20:06,210 --> 01:20:18,360
Kind of terminate the program, and I would kind of inform the system that there was apparent error in the program somewhere.

627
01:20:19,800 --> 01:20:26,760
Okay. So let's say we wanted to modify our prime checker program so that it kind of prints an error message.

628
01:20:26,760 --> 01:20:38,940
Like if the user is invalid, invalid, for example, like the input should be an integer greater than or equal to two, but the user doesn't input.

629
01:20:39,810 --> 01:20:52,440
So the input something else we want it to just kind of program to terminate an error and maybe print out an error message as well.

630
01:20:53,280 --> 01:20:54,780
So here's the way you could do that.

631
01:20:54,780 --> 01:21:06,450
So let's say, well, I guess we in this in this case, I guess we're still assuming that it's the enter a integer number.

632
01:21:06,450 --> 01:21:08,210
But let's say they're not necessarily into.

633
01:21:11,130 --> 01:21:24,620
There's something that's greater than or equal to the way we could do that is if now is a great one, we kind of run the program as usual.

634
01:21:25,220 --> 01:21:38,780
Otherwise, we have this we print out this error message and then we return exit failure, let's face it, and type this.

635
01:21:39,560 --> 01:21:49,940
I did notice that there's been some kind of failure in the program and didn't run successfully.

636
01:21:50,480 --> 01:21:56,300
Alternatively, he said of return exit failure you can use exit.

637
01:21:58,490 --> 01:22:06,150
I don't even know how. I remember the exact difference.

638
01:22:07,220 --> 01:22:20,299
Both in exit and return. I think it has to do with I think it destroys some kind of destroy some variables that

639
01:22:20,300 --> 01:22:31,250
have been created inside of me and should be returned as return failure does tend to exit.

640
01:22:31,250 --> 01:22:32,270
Failure doesn't do that.

641
01:22:32,480 --> 01:22:42,799
And I think it's it's related to whether or not it kind of destroys the memory or kind of empties the memory associated with certain variables,

642
01:22:42,800 --> 01:22:46,670
but a problem for the details.

643
01:22:47,540 --> 01:22:51,460
I don't think it's important for for this class to do that for her.

644
01:22:51,470 --> 01:22:54,860
Just listing two different options and you might see.

645
01:22:56,210 --> 01:23:00,170
Oh. Yeah.

646
01:23:00,260 --> 01:23:02,959
Mean we'll just finish with this. I just had this last example.

647
01:23:02,960 --> 01:23:10,370
This is just I thought it's just another example just to have more examples to go through of of using different functions.

648
01:23:10,370 --> 01:23:13,819
And I thought this might have been a slightly more practical example.

649
01:23:13,820 --> 01:23:18,440
So this is just an example of an implementation of a gradient descent method.

650
01:23:18,980 --> 01:23:25,400
So gradient descent is often used for finding the minimum or a maximum of the function, so forth.

651
01:23:26,010 --> 01:23:31,700
Want to find the minimum of a function? F Usually something like this is two plus one.

652
01:23:32,480 --> 01:23:42,590
Usually you start with a numbers zero and you create a sequence of numbers x one, x two, x three, etc. Using this kind of updating equation,

653
01:23:42,600 --> 01:23:54,530
80 plus one is equal to x two minus lambda times that the derivative of f evaluated in an extreme sense like a gradient descent update.

654
01:23:54,530 --> 01:24:00,200
So lambda is usually some positive, some kind of relatively small positive number.

655
01:24:01,160 --> 01:24:07,640
And if you do this long enough, you should get pretty close to minimize the function.

656
01:24:07,760 --> 01:24:16,790
Okay. So you basically just repeat you repeat this updating of X to a bunch of times until it's kind of coverage.

657
01:24:16,880 --> 01:24:22,520
So it's kind of a natural type of example where you would want to do that.

658
01:24:22,630 --> 01:24:28,520
Loop looping has a nice way of just kind of repeating this type of calculation.

659
01:24:31,310 --> 01:24:34,370
So as an example, I just looked at let's look at this function.

660
01:24:34,370 --> 01:24:41,060
This is just an F of X is just the sum of two kind of natural logs, types of things.

661
01:24:41,330 --> 01:24:52,430
Okay. So that's the function we want to find the minimum of, I guess the minimizing roughness and the value of an X, which is F as a minimum.

662
01:24:54,140 --> 01:24:57,290
So if you you don't have to do that.

663
01:24:57,290 --> 01:25:06,500
I already took the derivative. So if you take the derivative and set it up, the gradient descent iteration for this is the following.

664
01:25:07,910 --> 01:25:16,850
Oh I should have put x two here. Sorry. So x plus one is equal to x t minus two lambda times.

665
01:25:16,850 --> 01:25:21,760
The stuff where all of these x's should have a subscript of t okay.

666
01:25:23,450 --> 01:25:26,509
On the x's here should have a t subscript.

667
01:25:26,510 --> 01:25:29,149
So this is the gradient descent iteration.

668
01:25:29,150 --> 01:25:41,930
For this example, let's say we wanted to write a little C++ program that does so let's do a C++ program that implements this.

669
01:25:42,560 --> 01:25:47,810
So I want this to have the following components. I want I want there to be two functions outside of Main.

670
01:25:47,870 --> 01:25:51,350
I wanted to write two separate functions outside of Main.

671
01:25:52,430 --> 01:26:00,500
So one of the functions outside of Main should basically compute the gradient descent update so that basically basically this part,

672
01:26:00,620 --> 01:26:08,479
that's all the function should do. And then the other function should just compute the, the value of F of x, t, okay?

673
01:26:08,480 --> 01:26:15,530
So if you give it a value of x two, you should just compute everything and then kind of using a wild loop.

674
01:26:16,340 --> 01:26:28,430
We should basically do this iteration should terminate on either of these conditions.

675
01:26:28,700 --> 01:26:41,749
So it'll terminate whenever x plus minus x, t plus one minus x t is less than tall and the absolute value of that or t is greater than 200.

676
01:26:41,750 --> 01:26:44,780
So whatever, whichever. And those happens first.

677
01:26:45,380 --> 01:26:51,920
That's when the while loop is going to turn. Okay. So that's kind of the other thing I want from this program.

678
01:26:51,920 --> 01:26:56,720
And then basically in each iteration of the wild loop, I want it to kind of print out something.

679
01:26:57,320 --> 01:27:06,670
So I want to print out the kind of a current value x, t and then the current value F of x two is you can just see how exit C is changing and each.

680
01:27:06,960 --> 01:27:13,610
Patience. That's kind of a nice thing to see when you're running a kind of gradient descent algorithm.

681
01:27:15,170 --> 01:27:21,680
So the the function that does the gradient descent update, I just call it grad des update.

682
01:27:21,860 --> 01:27:25,670
So I just basically does this type of thing, just updates.

683
01:27:26,810 --> 01:27:32,210
So the way we can do it here, I just wrote it as a function, as a double type.

684
01:27:32,780 --> 01:27:39,560
It's going to return a double type. And then the two arguments are X.

685
01:27:39,710 --> 01:27:43,820
So it's X is kind of like x T here, and then step size.

686
01:27:44,360 --> 01:27:50,450
So step size is just lambda. And the both of those are we can assume those are our double variables.

687
01:27:51,560 --> 01:27:58,520
So to do this update inside the function, I just create this, I declare this function x new.

688
01:27:59,540 --> 01:28:03,470
I just say x new is equal to x minus two times.

689
01:28:04,250 --> 01:28:11,690
Step size times. This expression here, which is basically our constant times.

690
01:28:11,690 --> 01:28:19,370
The derivative of f of x. Okay. So that's how you can do this type of updating.

691
01:28:20,240 --> 01:28:29,210
The other thing is just to two other function that we wanted was just to compute F of x t.

692
01:28:29,240 --> 01:28:30,440
So I just did this here.

693
01:28:30,920 --> 01:28:42,600
I guess you could return this directly, but I just created I declare another variable first called F Val and I just say F Val is equal to this.

694
01:28:42,600 --> 01:28:53,000
So this is the this is like F of x that we did we had on the previous slide in returns this initially double time.

695
01:28:53,960 --> 01:28:59,810
You'll see when we put everything together for this, this log is the natural log.

696
01:29:00,440 --> 01:29:03,860
So this is from you'll have to include the C math library.

697
01:29:04,550 --> 01:29:11,060
So this is not something that's kind of available in C plus plus without importing any library.

698
01:29:11,060 --> 01:29:15,590
But you can use logs if you import the C math library.

699
01:29:16,700 --> 01:29:23,260
Okay. So this is what main looks like as well, I think.

700
01:29:25,480 --> 01:29:28,590
Excuse me. So this is what man looks like.

701
01:29:28,600 --> 01:29:32,140
So assuming we have those other functions already written.

702
01:29:32,740 --> 01:29:43,690
So for Main, I need I'm calling these values old and new and it's basically like just play the role of X plus one.

703
01:29:44,830 --> 01:29:51,610
I'm just kind of keeping track of X, T, T and X plus one with these two variables x all the next new.

704
01:29:53,260 --> 01:30:03,670
We also need the tolerance. So that basically determines when it stops or when when when convergence is reached.

705
01:30:04,270 --> 01:30:08,010
And then I also need this integer variable count.

706
01:30:08,020 --> 01:30:13,239
So I'm going to use that to determine whether or not we've reached to iterate 200 iterations.

707
01:30:13,240 --> 01:30:21,790
So remember we wanted it to kind of terminate the loop if we were to it or 200 iterations and we still haven't converged yet.

708
01:30:21,790 --> 01:30:27,040
So. Okay, so let's start.

709
01:30:27,040 --> 01:30:36,160
I'm just getting input from the user. So this x diff variable just records the difference between X plus one and T and in each iteration.

710
01:30:36,880 --> 01:30:39,900
And I've just initialized it as something greater than total.

711
01:30:39,910 --> 01:30:52,570
So we at least go inside of the loop once. So in this wild loop, I'm just, I keep doing the wild loop wild while both of these conditions are true.

712
01:30:53,800 --> 01:30:58,330
So whenever, whenever one of these becomes false, that's terminated.

713
01:30:58,330 --> 01:31:05,980
So whenever we've reached convergence, even if count is still less than 200, it's still terminated.

714
01:31:06,710 --> 01:31:11,320
Okay, a vice versa if we still have a converge.

715
01:31:11,320 --> 01:31:15,190
So this is still rated and tall by count is greater than 200.

716
01:31:15,190 --> 01:31:23,350
We still terminate the loop. So this guarantees that we terminate the loop whenever one of the conditions becomes false.

717
01:31:26,190 --> 01:31:34,900
Okay. And then in each iteration I just have to call these functions so I get ex noob by his calling credits and update.

718
01:31:35,890 --> 01:31:40,480
I get the new value of F by just calling objective function.

719
01:31:41,140 --> 01:31:51,450
I print both of these out like x f of x and I just record x def which would just be x new minus x old.

720
01:31:51,460 --> 01:32:01,990
So it's like x plus one minus x t and then I just, I set the old value becomes x new.

721
01:32:01,990 --> 01:32:07,480
So, okay, so in the next iteration x all of was like the previous value maximum.

722
01:32:08,260 --> 01:32:13,419
And then you have to update the value of count in every iteration by point,

723
01:32:13,420 --> 01:32:20,320
just so we know that we don't want to terminate when we've reached more than 200 iterations.

724
01:32:20,980 --> 01:32:29,080
Okay. So that's yeah, I think we're just out of time. So yeah, I think that was actually but here's just a big I don't know how well you can see,

725
01:32:29,080 --> 01:32:34,680
but this is just a screenshot that's basically just everything we've had before.

726
01:32:34,700 --> 01:32:40,510
These are the two functions that we defined before outside of Main and just put them on top.

727
01:32:41,230 --> 01:32:45,850
And then here, sure, we have to include the C library as a header.

728
01:32:46,540 --> 01:32:50,559
And then here's the main that we have before. So here's what happens if you run it.

729
01:32:50,560 --> 01:32:53,980
It prints out kind of a message for every iteration.

730
01:32:53,980 --> 01:32:58,420
So I think there's actually runs for 109 iterations.

731
01:32:58,540 --> 01:33:10,240
So that's what it did for this case. I get it. At least when we did this initial by definition value that I gave you that one or something like that.

732
01:33:11,230 --> 01:33:20,350
So yeah, it's six or six at a time for today.

733
01:33:20,350 --> 01:33:25,679
So we had. No.

734
01:33:25,680 --> 01:33:29,670
Stop there. See, on Wednesday. Unless there's any final questions or.

735
01:33:34,530 --> 01:33:40,840
Of course, we will not stop there.

736
01:33:40,850 --> 01:33:43,640
And that started on Wednesday. So.

