1
00:00:01,950 --> 00:00:09,850
What's happening now in New Orleans.

2
00:00:10,590 --> 00:00:26,930
Well, go ahead. So I have started listening to this post for my second homeworks and mentioned the

3
00:00:26,940 --> 00:00:43,290
importance of this primary school for which there are many lessons for our class.

4
00:00:43,290 --> 00:01:00,830
And during that time, allow me to do this writing and then probably to post the solutions to homework one tonight.

5
00:01:08,470 --> 00:01:18,730
So the final solution was really just cut those little bits and pieces to two different parts.

6
00:01:21,340 --> 00:01:32,760
The other thing I'll probably approach the some point during this week on post the final assignment for this module,

7
00:01:33,420 --> 00:01:47,190
and I'll try if you like, and let me do after like the last column, like Friday or Saturday or something like September 30th or.

8
00:01:50,330 --> 00:01:58,760
After that. And then I guess the second quiz, you've probably seen that as well as the second piece.

9
00:02:00,200 --> 00:02:04,430
Yeah, it's already been posted, so it's not due until at least next Monday.

10
00:02:04,580 --> 00:02:07,850
So those and those are the main assignments.

11
00:02:11,070 --> 00:02:15,320
As of now, the second homework and the second quizzes, I guess we just have.

12
00:02:16,810 --> 00:02:25,360
After that, there's just the final assignment and class quiz for the last two things for this module.

13
00:02:27,760 --> 00:02:35,020
All right. So, yeah, I mean, so for today, I think we're just going to finish up with the lists,

14
00:02:35,020 --> 00:02:39,600
although I don't think there's not too much more I'm going to say about lists.

15
00:02:40,340 --> 00:02:49,060
I think for that kind of the remainder of the class will try to do a little more data on the actual data.

16
00:02:49,600 --> 00:02:59,169
I think data frames are really the main kind of data structure that they're storing and working with kind of real data.

17
00:02:59,170 --> 00:03:04,630
And ah, so we'll talk about that and then we'll talk about factors.

18
00:03:04,660 --> 00:03:14,350
I just think it's just because it's kind of a special thing in all of the things we're having a little bit of a separate section on.

19
00:03:14,350 --> 00:03:25,210
And so factors are really just kind of a way through the usual way are just recommends kind of handling categorical variables.

20
00:03:25,810 --> 00:03:30,860
So it's kind of good to know, if only you know,

21
00:03:30,920 --> 00:03:47,739
a few of the features of how factors work because you're probably you're going to come across it at some point of view, a lot of programing.

22
00:03:47,740 --> 00:03:55,110
And I'll just say a few things about actually reading in data files into ah, how to do that.

23
00:03:55,120 --> 00:04:06,860
So you work with data and actually read and things like file things, aren't you.

24
00:04:07,420 --> 00:04:11,680
So let's go back to the lists was last time.

25
00:04:11,680 --> 00:04:24,160
So lists are really kind of a good way of storing kind of a collection of items that have kind of different types or maybe different dimensions.

26
00:04:24,580 --> 00:04:29,710
You're kind of storing those collection of items under what's a single variable need.

27
00:04:30,640 --> 00:04:31,750
That's kind of the advantage.

28
00:04:32,410 --> 00:04:40,180
So if you kind of have this kind of heterogeneous information and all of that is stored some kind of under a single variable name,

29
00:04:40,600 --> 00:04:47,170
you call that in underscore info. So that's the main advantage of lists.

30
00:04:49,840 --> 00:04:58,420
And so lists, you kind of think of it as a factor that has further components of the factor of heterogeneous types,

31
00:04:59,440 --> 00:05:02,290
roughly a reasonable way of looking at lists.

32
00:05:03,130 --> 00:05:12,160
And so I mentioned this, this is kind of a common way of using list in R where you have a function that returns kind of a bunch of different stuff,

33
00:05:12,160 --> 00:05:20,950
but there are kind of different data types or different dimensions of the each component.

34
00:05:21,400 --> 00:05:35,229
So here we kind of had an example of a, of a function that kind of returns the rows, some the call sums, the kind of the total sum of a matrix.

35
00:05:35,230 --> 00:05:38,740
And so each of these components can have a different dimension.

36
00:05:38,740 --> 00:05:45,760
So when you have computed all of that, a lot of times it's just easier to return it as a list.

37
00:05:45,760 --> 00:05:53,080
And each component of the list kind of it has one feature of the collection that you're trying to determine.

38
00:05:55,390 --> 00:06:08,770
So yeah, I think this just says that again in words lists are not really useful when you have a collection of items and different types of dimensions.

39
00:06:08,910 --> 00:06:22,330
And overall those items underneath the name of a single very crime type of situation where lists are huge.

40
00:06:23,510 --> 00:06:33,100
Before we stop last time, so the finish up list and I'll just talk about apply type functions for lists and so you'll see that a lot.

41
00:06:33,820 --> 00:06:41,410
So we talked about like the apply functions for for matrices, right?

42
00:06:41,410 --> 00:06:48,580
So that's you're basically just applying a function to each column of a matrix.

43
00:06:48,760 --> 00:06:52,870
So one by one or each row of a matrix, one by one.

44
00:06:53,380 --> 00:07:01,870
So L applies like list applied basically applies a function to each component of a list of elements.

45
00:07:02,500 --> 00:07:08,680
That's really all those rules apply some function to each component of the list and then it will return the result.

46
00:07:08,690 --> 00:07:14,170
So it returns the result. Well, it actually returns a list with the same.

47
00:07:16,320 --> 00:07:28,890
Number of components as the input lists and each component of the returned list is basically just the output from that function.

48
00:07:28,950 --> 00:07:32,599
Okay. So can you give me some good examples?

49
00:07:32,600 --> 00:07:42,870
So if I do I think are of matrix some a so are are is a list of three components.

50
00:07:42,870 --> 00:07:49,590
I think the first component is a vector length to the second component is a factor of length three.

51
00:07:50,100 --> 00:07:53,819
And the third component is just a number and it's really just a vector length one.

52
00:07:53,820 --> 00:08:03,800
So I look like, ah, the list and then I, this is like the function not only applying to each element of them,

53
00:08:03,840 --> 00:08:11,060
applying the length function to each element of the most part returns to the first component.

54
00:08:11,520 --> 00:08:22,290
That's because the length of the, the first element of the list is, is too, it's a vector of length to call is a vector.

55
00:08:22,290 --> 00:08:26,460
Once the second component are vector three.

56
00:08:27,000 --> 00:08:32,430
So this returns three. And then the third component of R is a vector one.

57
00:08:32,430 --> 00:08:37,650
So we can apply that the third party is one.

58
00:08:38,520 --> 00:08:52,559
That's how l apply works. So the multiplier returns a list and it has the same number of components as the important thing you do.

59
00:08:52,560 --> 00:08:59,000
L apply a sum so this this would do with the sum of each component.

60
00:08:59,340 --> 00:09:05,010
So actually in this case it's all the same number since that if you take the sum of the row sums,

61
00:09:05,010 --> 00:09:12,540
it's just the total sum sum of the factor of column sums is just the sum of the entire matrix.

62
00:09:12,540 --> 00:09:22,890
So it equals this as well. Again, it's kind of same syntax that you use for regular apply.

63
00:09:24,180 --> 00:09:27,299
You can define a function kind of within the applied statement itself.

64
00:09:27,300 --> 00:09:29,750
You can do the same thing with l apply.

65
00:09:29,760 --> 00:09:36,300
So if I want to apply that sum of squares function to each component of the list, this is the way you would do it.

66
00:09:36,990 --> 00:09:47,790
This is the sum of squares of the row. Some of the squares of the sounds and the square and the partial is just 21 squared.

67
00:09:51,690 --> 00:10:00,690
Okay, so there's so that's basically all I'll say about elements just applies a function to each component of the list.

68
00:10:01,470 --> 00:10:08,340
S apply basically does the same thing. It's just the the output of supply is kind of a different format.

69
00:10:10,230 --> 00:10:16,800
So in many types of I guess depending on exactly what type of code you're running,

70
00:10:17,700 --> 00:10:24,920
it's often more convenient to have some of which returned as a factor rather than a list.

71
00:10:26,430 --> 00:10:34,320
So this returns a list with three components. Sometimes it's just more convenient to have this be returned as a vector.

72
00:10:34,890 --> 00:10:38,040
So the three components in the list.

73
00:10:39,240 --> 00:10:42,390
So that's really almost all that supply does.

74
00:10:42,660 --> 00:10:46,230
That's the only difference between how supply and L apply.

75
00:10:46,240 --> 00:10:54,479
So as supply just stands for simplified L applies, the output is a little bit simpler.

76
00:10:54,480 --> 00:11:05,040
So as apply as and we put the sum total return three components like we had with s l apply,

77
00:11:05,040 --> 00:11:11,639
but it just returns as a vector with three components rather than as a list of the three components.

78
00:11:11,640 --> 00:11:16,440
So that's really the main difference between L apply and supply.

79
00:11:19,570 --> 00:11:23,620
So again, if we. Oh, this is just a note.

80
00:11:23,680 --> 00:11:27,670
You can you can have kind of a multi-dimensional functions.

81
00:11:30,220 --> 00:11:39,580
Although I would say the the function that you usually use supply or apply returns kind of a scalar, but you're certainly not limited to that.

82
00:11:40,360 --> 00:11:46,990
Here again, if you look at this example of the list are these are the components of the lists.

83
00:11:47,630 --> 00:11:55,900
The first components and factors link to the second component is a vector of link three, and the third component is a vector of like three.

84
00:11:56,360 --> 00:12:06,600
The SSRI in is the function that I apply to the components of R as and this output is two dimensional.

85
00:12:06,610 --> 00:12:10,960
It's a factor of the minimax rather than a single number.

86
00:12:11,320 --> 00:12:16,990
In that case, it returns a return to matrix rather than a single vector.

87
00:12:18,670 --> 00:12:24,330
So here guess it returns it as a two by three matrix.

88
00:12:24,380 --> 00:12:40,660
I guess that the way it works is like that when you run a supply like this with a multi-dimensional output up into, let's say,

89
00:12:41,410 --> 00:12:50,350
where the output or the function has dimension to it would return like a Q by P matrix where P is

90
00:12:50,350 --> 00:12:58,179
the number of components of the list and then Q is the dimension of the output of this function.

91
00:12:58,180 --> 00:13:06,610
So it's kind of the default output for supply when you have a function that returns multi-dimensional output.

92
00:13:08,920 --> 00:13:12,910
Okay. So I think that was it for an hour.

93
00:13:13,300 --> 00:13:20,220
I guess I had another small exercise, but I guess this was just like a a review question in case you forgot.

94
00:13:20,230 --> 00:13:30,490
So let's say we defined respect to X and then you kind of ran this code in.

95
00:13:30,820 --> 00:13:36,910
So what would it output of this question?

96
00:13:37,660 --> 00:13:43,800
So I think list of X does a list of X, you just do list of X like that.

97
00:13:43,830 --> 00:13:47,920
That's going to it should be just like a list.

98
00:13:49,360 --> 00:13:52,480
You know, X is C one of the A's, I think.

99
00:13:53,140 --> 00:14:04,330
I think the type you type is like X, C, one, two, three.

100
00:14:05,890 --> 00:14:12,780
It's much better. So this shouldn't still the.

101
00:14:13,770 --> 00:14:25,260
Well, let's just say like I don't think they assigned it any variable name only to say I knew is I think you were just.

102
00:14:28,500 --> 00:14:40,530
It's just you. So you would be you as a list with one element.

103
00:14:45,530 --> 00:14:50,380
If you just kind of write it this way, it's just as and like the first.

104
00:14:50,670 --> 00:14:55,020
So this is really an unnamed list. So we just do like so.

105
00:14:58,550 --> 00:15:02,330
So this equals this. This is the continent.

106
00:15:03,290 --> 00:15:10,550
The first component equals this. Because that vector will interpret that.

107
00:15:12,560 --> 00:15:18,530
So if you just knew you was assigned list of X, it's just going to be a list with one element.

108
00:15:19,440 --> 00:15:27,919
And the first element of the list, if you look at this one, you double bracket one, it should be a vector.

109
00:15:27,920 --> 00:15:40,510
So if you do the length. Length of view, I guess equals the length equals one.

110
00:15:41,230 --> 00:15:48,490
So the length of Mr. and Mrs.

111
00:15:55,680 --> 00:16:03,030
Whether I see testing, whether or not it's equal to a lot O the length of X, I guess the length of X.

112
00:16:03,870 --> 00:16:22,100
So this is this is a very. It's going to it's going to be a publicity ruckus.

113
00:16:23,400 --> 00:16:28,240
It's just going to print out a response. So length of X is three, actually.

114
00:16:39,620 --> 00:16:48,069
So that's just slightly confusing. When you apply the length to a vector, it gives the length of that vector,

115
00:16:48,070 --> 00:16:59,580
but instead used to list of that vector that that implies that that that's creating a list of one from one of your own kind of this code,

116
00:16:59,590 --> 00:17:08,570
which it should point out for us. On this side, it's one on the sides, 38.

117
00:17:11,960 --> 00:17:23,830
So let's just say we go through this exercise as well.

118
00:17:23,830 --> 00:17:35,799
So we have a six. So this is more just exercise just to make sure you have kind of all the exact ah syntax straight.

119
00:17:35,800 --> 00:17:38,830
You just know how to make sure everything fits together.

120
00:17:40,630 --> 00:17:43,960
It's a super complicated exercise or anything.

121
00:17:44,680 --> 00:17:57,130
But okay, so let's say we want to write a function that takes a list of X as an argument, as input, and you can think of this,

122
00:17:57,480 --> 00:18:10,300
you're going to assume that the elements of the list are numeric, but there's so many things ranked in our list.

123
00:18:14,520 --> 00:18:20,310
In a way, I would just started out writing it this way.

124
00:18:20,910 --> 00:18:24,660
It was called List F and for now.

125
00:18:25,320 --> 00:18:33,270
So X is X is a list of numerical vectors.

126
00:18:37,770 --> 00:18:40,620
And then I guess the next thing you know,

127
00:18:41,670 --> 00:18:52,499
so it should return a matrix or the number of columns equals the number of elements of the input list and the number of rows equals four.

128
00:18:52,500 --> 00:18:59,340
So in the way I usually do, that is just yes, it depends on what you're trying to do,

129
00:18:59,340 --> 00:19:09,809
but it's usually usually just set it set up first like a matrix of zeros and then fill it in later.

130
00:19:09,810 --> 00:19:18,870
So we wanted for the rows and the number of columns should be the number of elements of the list.

131
00:19:18,870 --> 00:19:25,440
So just two in row equals four and in call equals left.

132
00:19:25,950 --> 00:19:29,990
Basically the number of elements of the list just.

133
00:19:33,720 --> 00:19:39,210
Okay. So that takes care, but it sets out the storage for this part.

134
00:19:40,500 --> 00:19:44,920
Now we need to know. Fill in the numbers.

135
00:19:44,940 --> 00:19:55,800
Okay. So basically, if the key element of that list has like greater than four case columns should equal this kind of factor.

136
00:19:56,580 --> 00:20:03,420
And otherwise, it will equal a list of all zeros.

137
00:20:03,420 --> 00:20:10,170
So you can actually actually not necessarily have to be careful since I've already initialize it to zero.

138
00:20:10,240 --> 00:20:14,390
Maybe I'll just write it as in spite of.

139
00:20:14,970 --> 00:20:20,490
The first thing is the right kind of the form of the loop.

140
00:20:23,490 --> 00:20:29,070
I'm sorry. That was the length of X.

141
00:20:30,960 --> 00:20:39,720
So basically going to fill in, fill in, filling columns one at a time.

142
00:20:42,540 --> 00:20:45,570
So if the length.

143
00:20:48,000 --> 00:20:53,159
Of x k greater than four.

144
00:20:53,160 --> 00:20:59,400
You do something I actually don't necessarily need to else, but for the better.

145
00:21:01,080 --> 00:21:03,230
So basically what did it say?

146
00:21:03,240 --> 00:21:11,910
So if the k element of the list has length greater than four in the case column should have these kind of four words summary measures.

147
00:21:12,990 --> 00:21:16,200
So the way you would do that. So this is what I'm checking here.

148
00:21:16,200 --> 00:21:19,500
I'm checking it the length of the case element.

149
00:21:20,790 --> 00:21:26,670
So that's basically a back to take element of that list is X double bracket.

150
00:21:27,540 --> 00:21:41,460
Okay. So if that's greater than four, I'm going to say a return matched K is basically all of the other stuff I need to.

151
00:21:46,340 --> 00:21:54,280
Median. You can go on to another line.

152
00:21:54,790 --> 00:22:02,510
Some men in action will look back.

153
00:22:03,370 --> 00:22:06,520
And then else I'm just going to say a turn.

154
00:22:13,430 --> 00:22:15,890
It should just be for, I mean,

155
00:22:17,030 --> 00:22:27,230
a zero factor of length for and then return and return and actually don't need this else since it's kind of could just have

156
00:22:27,240 --> 00:22:38,950
the s since it automatically be zero since I initialize them just writing it this way as well as what also was mentioned.

157
00:22:40,950 --> 00:22:50,320
And if it looks as though we can test it, let's say X is equal to the list.

158
00:22:51,310 --> 00:23:04,540
I would say A 1 to 5 B is equal to six and two.

159
00:23:04,810 --> 00:23:09,879
So that's going to be the second component of the second column of the Matrix.

160
00:23:09,880 --> 00:23:14,170
Should be all zeros, right? Since the sentence length less than.

161
00:23:16,040 --> 00:23:24,710
Less than four months ago, someone could just take a look, and then you could just.

162
00:23:27,520 --> 00:23:33,970
Okay. We can see that you'll hopefully give out something that matches the way we want.

163
00:23:47,770 --> 00:23:53,349
Want me to run this. Okay, so it gives the looks pretty reasonable.

164
00:23:53,350 --> 00:24:04,329
So the first column should have the mean of 1 to 5 medium and 1 to 5, then the men in the max.

165
00:24:04,330 --> 00:24:06,790
And then the second one should be all zeros.

166
00:24:06,790 --> 00:24:21,680
And the third column should be the name of the factor of 20 to 32 million in 2013 and the minimum, which is 20 inches this.

167
00:24:26,660 --> 00:24:34,310
At least what I had in mind. So the description was 100% clear that this makes sense.

168
00:24:40,220 --> 00:24:47,110
Right? Yeah. I mean, I think the main purpose of this was just kind of a reminder of kind of all of the you know,

169
00:24:47,110 --> 00:24:52,780
there's a lot to know about the different art and structures.

170
00:24:52,840 --> 00:24:59,829
We have to make it clear the length of the list is actually the number of factors,

171
00:24:59,830 --> 00:25:06,969
not the length of human nature that they're trying to access kind of specific elements of the list with double brackets,

172
00:25:06,970 --> 00:25:11,670
you know, to fill in each column one at a time, things like that.

173
00:25:12,500 --> 00:25:19,780
It's, you know, I think it's still a little wrap up list for now.

174
00:25:21,190 --> 00:25:29,679
Okay. So the next big event type of structure in our is data frames,

175
00:25:29,680 --> 00:25:37,750
which is really the main thing in our that's going to be used to kind of store this real data sets.

176
00:25:39,340 --> 00:25:46,660
So data frames are the most common tool for storing, quote unquote, rectangular data sets.

177
00:25:47,710 --> 00:25:56,530
Sometimes that word is used just basically means data that is kind of organized in a table format where you have a certain number of rows and a

178
00:25:56,530 --> 00:26:05,610
certain number of columns of the kind of data organized in that format on data frames are going to be the the things you want to use in sense.

179
00:26:08,680 --> 00:26:12,700
So you can roughly think of a data frame is not a matrix.

180
00:26:13,270 --> 00:26:20,860
You can roughly think of a data and you basically think of a data frame and it's

181
00:26:20,860 --> 00:26:26,800
just basically a matrix where the columns are allowed to have different data types.

182
00:26:28,270 --> 00:26:36,349
Okay. So within a column, a single column, they all have to have the same type of action, but like different columns, kind of different types.

183
00:26:36,350 --> 00:26:43,960
So like the first column can be numeric, the second column didn't have all characters.

184
00:26:44,140 --> 00:26:55,570
Okay? So usually I guess in statistical language we would usually call the columns of different variables,

185
00:26:56,100 --> 00:27:04,270
the machine learning, all the features of your data set as well, hopefully column variables.

186
00:27:04,630 --> 00:27:13,120
So the columns are the variables of the data set and the rows are like different observations made on those variables.

187
00:27:13,240 --> 00:27:20,530
Okay. So yeah, I guess would just jump into it.

188
00:27:20,530 --> 00:27:33,200
So I guess just to see what a data frame looks like, I mean, you can directly convert a matrix into a data frame or vice versa.

189
00:27:33,230 --> 00:27:36,490
You can create, you can convert a data frame into a matrix.

190
00:27:36,490 --> 00:27:49,270
So kind of the the we start out with start out is to play with first create a data frame which just would actually create a dot frame.

191
00:27:49,930 --> 00:27:55,600
Okay. So this line of code is creating a data frame called data.

192
00:27:55,840 --> 00:28:07,660
So we're creating a data frame def. The way you create it is sort of similar to a list like you give the names like the name of this.

193
00:28:08,440 --> 00:28:12,070
The first component is X, the name of the second component is Y.

194
00:28:12,520 --> 00:28:18,640
So these are really the names of the variable. So you should think of X as being the name of the first variable,

195
00:28:19,090 --> 00:28:25,180
and this will be the first column in your page in your name, and why is the name of the second variable?

196
00:28:25,180 --> 00:28:33,309
And that's going to be the data associated with Y is going to be the second column of your data frame.

197
00:28:33,310 --> 00:28:49,010
So you can see that here. If you look at the F. X It is like kind of like the first is the first variable is the first column of data lines.

198
00:28:49,010 --> 00:28:53,210
The second variable, it's as it's in the second column of the data frame.

199
00:28:54,170 --> 00:29:06,020
And I just mentioned that you can convert well, in most cases, you can convert it directly back to the to a into a matrix.

200
00:29:06,020 --> 00:29:13,700
If there's a I guess the only way you couldn't convert it back into a matrix is there's not a way to.

201
00:29:16,670 --> 00:29:22,460
Sensible to automatically kind of convert everything back into the same tired.

202
00:29:24,290 --> 00:29:35,149
But the the matrix itself is kind of the same as the same format as the data frame.

203
00:29:35,150 --> 00:29:39,260
I guess the way it prints it out is slightly different. So it's printing these out.

204
00:29:39,260 --> 00:29:46,040
It's kind of like matrix rows, whereas a dataframe, if for instance, these numbers out here,

205
00:29:46,040 --> 00:29:52,099
it's I guess the way we usually think of these is observation numbers.

206
00:29:52,100 --> 00:29:58,130
So this would be the first observation, second observation, third observation of your of your data set.

207
00:29:58,740 --> 00:30:03,920
Okay. Okay.

208
00:30:03,920 --> 00:30:07,550
So you can also convert from a matrix to a data frame if you want to.

209
00:30:08,000 --> 00:30:17,240
So if you created a matrix data frame, so if you create a matrix called X first and then give it column names,

210
00:30:18,410 --> 00:30:30,200
if you just do as that data dot frame, that'll convert that into a data frame and that'll it'll convert the column names into the variable names.

211
00:30:30,560 --> 00:30:35,930
Okay. So you can see that here. The variable names in our data frame are are A and B.

212
00:30:38,690 --> 00:30:47,629
Okay. So yeah, I guess this is just showing kind of what you said before.

213
00:30:47,630 --> 00:30:56,030
This is kind of one of the key differences between a data frame and a the matrix so the data frame can have.

214
00:31:00,650 --> 00:31:03,950
Heterogeneous data types so we can add one column.

215
00:31:04,760 --> 00:31:08,020
It's all numeric and we can have one column.

216
00:31:08,030 --> 00:31:13,159
It's all character. So you can see that here. It doesn't. We could try to do this with a matrix.

217
00:31:13,160 --> 00:31:17,809
It would probably it would try to convert these numbers into characters.

218
00:31:17,810 --> 00:31:23,750
So it's really quotes inside equal, but that doesn't happen with the data frame.

219
00:31:23,760 --> 00:31:29,420
So you can have one column of all characters and one column with all numbers.

220
00:31:31,130 --> 00:31:40,640
You can't mix it within a column. So you can't have a column, half numbers, half characters, but the different columns can have different data.

221
00:31:40,910 --> 00:31:44,210
Data types. Okay.

222
00:31:46,340 --> 00:31:51,260
Okay. So here's actually, I think on the next slide, there's.

223
00:31:56,150 --> 00:32:03,840
We're just I just noticed this tentative just kind of a slight error in this and this slide.

224
00:32:04,040 --> 00:32:11,850
So I guess I'll just stay with the bullet points.

225
00:32:12,100 --> 00:32:19,600
So we're creating a data frame, ah, as the defaults convert character variables into a factor.

226
00:32:19,600 --> 00:32:23,470
So we'll talk about factors a little bit later today.

227
00:32:23,830 --> 00:32:34,390
So factors are basically just a guess if think of as a data type that are often uses for categorical variables.

228
00:32:36,220 --> 00:32:40,120
However, I just noticed that this is this is no longer true.

229
00:32:40,120 --> 00:32:47,830
So ah, periodically they change small features of the language.

230
00:32:48,400 --> 00:32:54,729
So they, they basically just change the default.

231
00:32:54,730 --> 00:33:06,190
I think in our work we have one of the early four points as a default convert characters to factors anymore.

232
00:33:06,190 --> 00:33:13,959
So I was changed in like the last movies in the last year or certainly within the last two years.

233
00:33:13,960 --> 00:33:19,120
So I didn't know that. So I just kind of found that out today.

234
00:33:19,120 --> 00:33:25,389
The reason why is if it did convert it into a factor, this will if you try to do this comparison,

235
00:33:25,390 --> 00:33:29,590
it would print out some kind of error message, but it didn't.

236
00:33:29,590 --> 00:33:41,190
So it kind of looked at the documentation and seemed like that's something that's been changed recently in the last year.

237
00:33:44,100 --> 00:33:45,410
So yeah, I was just yeah,

238
00:33:45,430 --> 00:33:56,559
I was just saying how to do to prevent what command you would have to do to prevent character variables from being converted into factors.

239
00:33:56,560 --> 00:34:00,580
And then for that you would have to do strings as factors equals false.

240
00:34:00,940 --> 00:34:09,550
So this is actually the default. Like two years ago the default was strings as factors equals true.

241
00:34:10,240 --> 00:34:19,450
So you had to kind of change this to to not have to, to not have it as a treated as a factor automatically.

242
00:34:19,900 --> 00:34:24,580
But it seems like they they change that like in the last year or two or something like that.

243
00:34:25,180 --> 00:34:31,900
So this is actually the default. So you don't necessarily have to input this yourself, I guess.

244
00:34:32,380 --> 00:34:40,780
I don't know, maybe a lot of people complained about are automatically converting characters into factors.

245
00:34:41,770 --> 00:34:50,430
So now, now this is actually the default notice this hour like a few hours ago.

246
00:34:50,440 --> 00:34:58,270
So I'll probably I'll fix this slide and upload that a new the new the new version later.

247
00:35:00,370 --> 00:35:05,859
Okay. All right. So just a few things about working on data frames.

248
00:35:05,860 --> 00:35:13,730
So oftentimes you want to add like a new variable to your data set.

249
00:35:15,220 --> 00:35:20,320
So the way to do that is just you just kind of do this type of syntax.

250
00:35:21,100 --> 00:35:32,410
So you can actually you can actually access the elements or I guess the individual variables of a data frame, kind of the same way you would a list.

251
00:35:33,490 --> 00:35:45,160
Actually, I mentioned this. I mean, a data frame is actually it's technically a list with with certain limitations on on kind of the

252
00:35:45,160 --> 00:35:50,770
components of the list so that all the components of the list have to have the same length.

253
00:35:51,550 --> 00:36:02,260
So that's why this, this kind of syntax works the way you access a variable.

254
00:36:04,240 --> 00:36:07,920
The variables from a data frame is with this dollar sign.

255
00:36:07,990 --> 00:36:13,600
So you can think of the data frame as a list where the, the variable names are like the list names.

256
00:36:13,600 --> 00:36:28,300
So you can kind of access individual variables by using like a dollar sign after the data frame and the name of that variable after the dollar time.

257
00:36:28,600 --> 00:36:33,790
But you can also create variables this way you can buy just in dollar sign Z and give it

258
00:36:33,790 --> 00:36:41,650
a value that's going to create a new variable in the data in the data for MDF called.

259
00:36:43,180 --> 00:36:48,160
So it'll create a new variable and it'll have the values that you assign.

260
00:36:48,250 --> 00:36:51,969
So if you look here, we print out the data frame.

261
00:36:51,970 --> 00:36:57,310
It now has this new variable called Z is it has these values.

262
00:36:59,740 --> 00:37:15,790
And you can also like you can kind of combine data frames using the kind of the same functions that you use for matrices like C by.

263
00:37:15,790 --> 00:37:28,779
And you can kind of join in two data frames and then resets horizontally basically the same way as you would with matrices.

264
00:37:28,780 --> 00:37:34,839
So if I have this other data frame here, so this is just a data frame with a single variable.

265
00:37:34,840 --> 00:37:36,729
So if you were to print it out,

266
00:37:36,730 --> 00:37:45,010
it basically looks like a one by or a three by one matrix or you have kind of the same structure as a three by one matrix,

267
00:37:45,660 --> 00:37:58,090
know what you see by width and these at two. It just kind of adds that in a extra column to the right and you can do R by and in kind of a similar

268
00:37:58,090 --> 00:38:07,030
way the R by and remember it kind of stacks with matrices that stacks matrix sees on top of each other.

269
00:38:07,480 --> 00:38:14,290
It's the same thing with data frames stacked two data frames on top of each other.

270
00:38:14,290 --> 00:38:22,329
So if I had this data frame here, so this is a data frame with three variables, but there's just one observation.

271
00:38:22,330 --> 00:38:30,069
So if you were if you were to print this out, it would look like a one by three matrix.

272
00:38:30,070 --> 00:38:41,830
And then if you are buying with the F in the three edges, kind of as this an extra row at the bottom of the original data frame.

273
00:38:41,830 --> 00:38:51,520
So it has four and a half and you have two as with matrices, you have to kind of when you're using C buying and are buying,

274
00:38:51,520 --> 00:38:58,600
you have to make sure that the the dimensions between the two things that you're joining,

275
00:38:59,950 --> 00:39:05,950
you have to make sure that the dimensions are compatible and that the dimensions have to match in the right way.

276
00:39:07,240 --> 00:39:13,270
Okay. So that's kind of joining different data frames.

277
00:39:13,270 --> 00:39:21,580
I guess the other thing that's that's useful, I think that's yeah,

278
00:39:21,790 --> 00:39:27,030
we'll probably mention some other things when we mentioned probably next week as well.

279
00:39:27,040 --> 00:39:30,990
And this is probably one of the other important things to note is some setting.

280
00:39:31,000 --> 00:39:37,780
It's often very useful that you just want to look at a certain subset of the data according to some criterion.

281
00:39:38,320 --> 00:39:50,560
And so you can use the subset function. So you can also plot next week or maybe even later this week about the loss of the results.

282
00:39:50,680 --> 00:39:57,700
There's also some functions for doing something in combination with other functions, but.

283
00:39:59,360 --> 00:40:06,080
I think just knowing that this how to use the subset function and base are as useful as so.

284
00:40:06,480 --> 00:40:11,960
So just to subset a data frame, you just use the the function subset.

285
00:40:12,080 --> 00:40:16,420
You give it the name of the data frame and then you give it some condition.

286
00:40:16,430 --> 00:40:35,030
So the way this works is that it's going to return a data frame only where the the value of X data frame,

287
00:40:35,030 --> 00:40:39,800
where the observations are such that this condition is satisfied.

288
00:40:40,370 --> 00:40:49,219
So, so you usually give a name, a variable name from the data frame d f here, so you don't have to repeat the name of the data frame.

289
00:40:49,220 --> 00:40:58,390
You just give it the name of the variable and you usually give some logical expression that shows how you want to do the subset.

290
00:40:58,520 --> 00:41:10,480
So here kind of this code here, this is going to return a data frame giving all the all the rows where the variable X and greater than one.

291
00:41:10,520 --> 00:41:20,290
So you can see that here X has the values one to the second and third observations must satisfy this condition.

292
00:41:20,300 --> 00:41:24,680
So it's going to return a data frame with the second and third observations.

293
00:41:25,030 --> 00:41:28,100
Okay, so that's how a subset works.

294
00:41:29,030 --> 00:41:33,979
If we have a more, you could give a more complicated, logical expression.

295
00:41:33,980 --> 00:41:39,680
So if we give it like X is greater than one and Y is equal to S,

296
00:41:39,690 --> 00:41:48,380
that's going to return the collection of observations where both of these things are true, where X is greater than one and lives in.

297
00:41:48,470 --> 00:41:52,250
You can see that the second row.

298
00:41:52,580 --> 00:41:57,110
So the second observation is the only it's only the only row where that's true.

299
00:41:57,260 --> 00:42:02,480
It's the only row where both X is greater than one and Y is equal.

300
00:42:02,780 --> 00:42:09,050
So it's going to return as a data frame containing data only from the second row.

301
00:42:15,480 --> 00:42:20,490
So let's talk a little bit more about data frames.

302
00:42:24,160 --> 00:42:31,870
You talk only next time. But I think those are the most important things to know about data frames.

303
00:42:32,620 --> 00:42:45,729
So I wanted to have a little bit of a separate section on factories just because kind of a lot

304
00:42:45,730 --> 00:42:53,080
of the statistical methods often convert certain variables into factors before analyzing them.

305
00:42:53,590 --> 00:43:04,750
So it's good to know at least a few of the. It's good to know kind of what factors are in and at least a few of their important features.

306
00:43:05,120 --> 00:43:12,550
Okay. So factors are basically kind of a separate it's not necessarily a tie, but it's kind of a separate,

307
00:43:13,510 --> 00:43:21,230
separate thing in our basically as a way to represent categorical variables as the purpose of factors.

308
00:43:21,250 --> 00:43:24,760
It's a way of representing categorical variables.

309
00:43:24,760 --> 00:43:42,730
So categorical variables are basically variables whose values kind of represent membership in some cat category rather than like a blood type,

310
00:43:44,230 --> 00:43:55,040
just like a few different blood types. And you know, it doesn't make sense to numerically compare it with strange things.

311
00:43:55,090 --> 00:43:56,649
Have a few categories of blood type.

312
00:43:56,650 --> 00:44:05,530
For example, the language spoken in this who make sense to assign those numerical values and compare them in most cases.

313
00:44:05,980 --> 00:44:10,780
And the treatment groups and treatment group A versus treatment group B is it

314
00:44:10,790 --> 00:44:18,790
really makes sense to give those those values numbers and compare them in any way?

315
00:44:19,570 --> 00:44:31,370
So those are examples of categorical variables. So I guess one feature of categorical variables at least one way are thinks about

316
00:44:31,370 --> 00:44:37,279
them is that they can only have one of kind of a finite collection of values.

317
00:44:37,280 --> 00:44:45,440
So if you have data on blood type, there's only a certain number of possible blood types.

318
00:44:46,130 --> 00:44:56,480
And so your categorical variable has to be one of those and it has to take one of the values from that collection.

319
00:44:56,480 --> 00:45:05,450
Okay. So there's kind of a set collection of possible values that you can have for that variable.

320
00:45:06,920 --> 00:45:13,730
So that's kind of one of the kind of the key features of categorical variables.

321
00:45:14,390 --> 00:45:25,130
You don't really have numerical comparisons between them, and we can only assume kind of one of a finite collection of possible values.

322
00:45:25,790 --> 00:45:33,989
Okay. So in fact, there's not really a completely different, I guess, data structure.

323
00:45:33,990 --> 00:45:42,980
It's it's really just a vector. There's kind of extra information about that vector of super over the details, but it's just a vector.

324
00:45:44,210 --> 00:45:49,910
It has some extra information stored as like metadata about that vector that tells it

325
00:45:50,900 --> 00:45:55,430
tells R that it's a factor and you should kind of treat it as a categorical variable.

326
00:45:56,390 --> 00:46:11,360
So kind of one certain extra piece of information stored about a vector is its act or their attributes and kind of.

327
00:46:16,080 --> 00:46:21,410
If a doctor has certain attributes that are well known and it's a factor there.

328
00:46:21,720 --> 00:46:26,860
Okay. So one kind of key attribute stored by a factor is are those levels.

329
00:46:26,880 --> 00:46:33,750
Okay. So the levels of a factor basically determine the set of allowable values.

330
00:46:33,960 --> 00:46:37,740
Okay. So if you're thinking of a categorical variable.

331
00:46:40,780 --> 00:46:51,070
Example of blood type when you if you internet into are in store as a factor you it would it would set up the levels.

332
00:46:54,690 --> 00:47:05,740
It would set up the levels for that variable, for that variable and store those levels as one of the vector attributes.

333
00:47:05,760 --> 00:47:13,520
Okay. So that's basically just telling our kind of what are this set of allowable values for elements in that vector.

334
00:47:13,560 --> 00:47:20,580
It's really kind of the main purpose of this. So it's kind of just a as an example of this,

335
00:47:20,580 --> 00:47:31,270
I use this this plant growth data set so actually are as a function of maybe not a bunch but a decent collection of kind of built in data set.

336
00:47:31,310 --> 00:47:32,910
So one of those is plant growth.

337
00:47:33,270 --> 00:47:44,610
I mean, you can access it yourself if you just type in data and plant growth inside of parentheses and it will load the plant growth data.

338
00:47:45,420 --> 00:47:49,170
So that's actually a plant growth should be a data frame.

339
00:47:49,230 --> 00:47:55,260
Okay. And then here, we're actually accessing a certain variable from that data frame.

340
00:47:55,940 --> 00:48:02,460
And so there's one variable in the plant growth data for income group attributed to the

341
00:48:03,720 --> 00:48:09,300
dollar sign group that all kind of print out the the values from the group variance.

342
00:48:09,480 --> 00:48:15,220
Okay. So if you do that, you'll see this thing printed up here.

343
00:48:15,910 --> 00:48:19,770
So it'll print out the values stored in this variable.

344
00:48:19,780 --> 00:48:24,530
I think there's. How many observations?

345
00:48:24,770 --> 00:48:31,430
1630 something. 33 observations.

346
00:48:32,000 --> 00:48:37,970
So these are the values stored in the group variable, but below that it prints this thing as well.

347
00:48:38,720 --> 00:48:43,820
So it says A levels control treatment one, treatment two.

348
00:48:44,420 --> 00:48:51,290
So when you see this type of thing, print it out. That's an indication that this is a factor.

349
00:48:51,380 --> 00:49:03,980
Okay. So it's a factor in these levels. So that means that the possible values for elements of this vector are C, TRL tree one and tree two.

350
00:49:04,160 --> 00:49:07,940
Those are the only possible values for elements of this factor.

351
00:49:08,120 --> 00:49:16,250
Okay. So if you see this levels thing printed out, that means that you're dealing with a factor.

352
00:49:16,410 --> 00:49:23,680
Okay. Okay. So I think in this in this type of case, it makes sense to treat this as a factor.

353
00:49:24,490 --> 00:49:28,990
I mean, these are like think these are just basically like different treatment conditions.

354
00:49:30,070 --> 00:49:36,820
So it makes sense to treat considering different treatment conditions as like categorical variables.

355
00:49:36,820 --> 00:49:47,320
There's only a finite possible number of treatments, at least for this study, and it doesn't really make sense to during the comparisons between.

356
00:49:53,000 --> 00:49:59,569
Okay. So one thing you may notice. I just thought I'd mention this because sometimes people run into this,

357
00:49:59,570 --> 00:50:05,530
and it's a little bit frustrating at first if you if you're not aware of factors.

358
00:50:06,320 --> 00:50:12,280
So let's say I wanted to do this type of assignment.

359
00:50:12,290 --> 00:50:19,580
Let's say I want to change the value of the fourth element of the root started a little bit treat or TR.

360
00:50:21,200 --> 00:50:29,990
So if you try to do this around something like an error message in a subcontinent.

361
00:50:30,230 --> 00:50:39,230
Okay, so sometimes people try to do this, we are beginning our and it's frustrating because why why can't I?

362
00:50:40,550 --> 00:50:46,760
Why can't I do this type of assignment? Okay. The reason for this is that this is since it's a factor,

363
00:50:46,760 --> 00:50:56,540
it doesn't consider this a one of the possible one of the possible values of that variable, since this is not one of the levels.

364
00:50:59,470 --> 00:51:01,820
If you try to do this, this works perfectly fine.

365
00:51:02,450 --> 00:51:13,700
I tried to do this assignment tr1 last perfectly fine, since tr one is already one of the levels in that factor.

366
00:51:14,000 --> 00:51:18,160
Okay. Okay.

367
00:51:19,170 --> 00:51:22,700
So if you have to know this,

368
00:51:22,820 --> 00:51:34,940
just if you wanted to know the way to check that something is a factor in this ATR and look at the class so that it will print out that it's a factor.

369
00:51:35,040 --> 00:51:44,179
Okay. So kind of one of the on the attributes that distinguishes factor is this class.

370
00:51:44,180 --> 00:51:46,010
It tells it is a factor.

371
00:51:46,370 --> 00:51:58,070
Basically, one of the things that that implies is that you can't do numerical comparisons between elements of something that has class factor.

372
00:51:58,430 --> 00:52:01,549
Okay. So if you try to do this type of comparison,

373
00:52:01,550 --> 00:52:14,570
let's say I want to compare of claim or the fifth element of plant of the group variable plant growth with the 15 element,

374
00:52:14,570 --> 00:52:19,430
let's say I just want to check which one is greater than the other. It'll return an error.

375
00:52:19,610 --> 00:52:28,849
Okay. Or it will return in. So you can't do this, you can't do these types of comparisons and you can't do addition or anything.

376
00:52:28,850 --> 00:52:41,270
You can't do basically can't do any kind of math with factors since it's saying that if this has a class factor is basically saying it's R,

377
00:52:41,270 --> 00:52:43,340
that this is a categorical variable.

378
00:52:43,850 --> 00:52:52,910
You can't do like marvelous elements of a categorical variable and you can't you shouldn't do any kind of numerical comparisons either.

379
00:52:53,090 --> 00:52:57,520
Okay. Okay.

380
00:52:57,640 --> 00:53:00,550
So I thought I'd add this in as well.

381
00:53:05,320 --> 00:53:16,390
Just to handle the previous case where I said you wanted to add in kind of a value that was not stored in one of the files.

382
00:53:16,840 --> 00:53:22,959
So you can do that. You just have to basically have to know how to do this.

383
00:53:22,960 --> 00:53:30,330
So you you basically first can assign new levels to your factor before you kind of add

384
00:53:30,340 --> 00:53:37,420
data to a factor vector that's that that's not already in one of the original categories.

385
00:53:38,050 --> 00:53:47,680
Okay. So like I said, as I said before, like if we create a factor vector, so let's look at this one here.

386
00:53:48,050 --> 00:53:53,860
And so this line is saying that we're creating a factor vector.

387
00:53:56,860 --> 00:54:01,150
It's basically containing the numbers one, one, two and three.

388
00:54:01,570 --> 00:54:05,320
It'll convert that into kind of a little treat. That is categorical.

389
00:54:07,900 --> 00:54:13,330
So when we run this, it basically treats the numbers one, two and three as categorical.

390
00:54:13,330 --> 00:54:17,050
So it's going to have levels one, two and three.

391
00:54:17,060 --> 00:54:21,310
So this is going to be a factor vector with levels one, two, three.

392
00:54:21,490 --> 00:54:28,830
Okay. Now on the next line, if we try to do this assignment, we're going to have a problem.

393
00:54:28,900 --> 00:54:32,850
Okay. So we're trying to assign the third element, the value four.

394
00:54:32,860 --> 00:54:38,890
So that's that's not going to work or at least it's not going to work maybe as we planned.

395
00:54:39,310 --> 00:54:49,840
So if we print out y, you can see that the third element is in a so it's basically kind of true if it basically turns

396
00:54:49,840 --> 00:54:55,180
into miss it's a good reason for that is that four is not in one of the original models.

397
00:54:55,840 --> 00:54:56,799
So you can see that here.

398
00:54:56,800 --> 00:55:05,470
The levels of the levels of the factor one, two and three, you can try to assign it a value which is not in one of the levels.

399
00:55:06,640 --> 00:55:10,640
So you can. So you can fix this.

400
00:55:10,660 --> 00:55:19,650
It's just you just have to change the levels first. One way of doing that is just assigning the levels of y a different set of values.

401
00:55:19,660 --> 00:55:24,110
If I assign a levels of Y values.

402
00:55:24,130 --> 00:55:27,850
One, two, three, four. Now the levels are one, two, three, four.

403
00:55:27,850 --> 00:55:33,070
And now this type of assignment, this kind of works as you would intend.

404
00:55:33,790 --> 00:55:37,100
So it kind of works in the way that you want, right?

405
00:55:38,710 --> 00:55:43,180
You can see that here. Print printed out at the bottom. The levels are one, two, three, four now.

406
00:55:45,420 --> 00:55:52,320
So this is just thought I'd just mention that just because. As I mentioned before, sometime I've seen.

407
00:55:57,390 --> 00:56:01,470
But people first starting our work with factors in it.

408
00:56:01,990 --> 00:56:06,069
They run into this control the frustration of what's going on.

409
00:56:06,070 --> 00:56:13,270
I can't do the simple assignment. So let's say you really need to do this type of assignment.

410
00:56:14,170 --> 00:56:20,710
How do you do that? So to do this is just to reassign or change the levels version.

411
00:56:23,180 --> 00:56:27,170
All right. I thought I just mentioned this as well.

412
00:56:27,830 --> 00:56:35,030
This is sometimes useful, at least like when you first load in a data set.

413
00:56:35,690 --> 00:56:40,759
I first load in a data set. Sometimes I just look at the first few observations.

414
00:56:40,760 --> 00:56:45,860
But also another thing I might look at is using this SDR function.

415
00:56:45,860 --> 00:56:49,380
So it basically gives you the structure of the data frame.

416
00:56:49,400 --> 00:56:55,230
I guess the key thing that it tells you is like the number of observations, the number of variables.

417
00:56:55,880 --> 00:57:02,880
And I think also the other important thing is it kind of tells you how it's storing each of the variables.

418
00:57:02,900 --> 00:57:10,250
So it's sometimes useful to know just to get a sense of kind of which variables are stored as which type.

419
00:57:10,260 --> 00:57:19,400
So if we look at a plant growth dataset, the plant growth dataset, it really only has two variables weight and group.

420
00:57:20,120 --> 00:57:26,360
And so if we just USTR, a plant group, is telling us that the weight variable is stored as numeric.

421
00:57:27,050 --> 00:57:36,470
Okay. And then the group variable is stored as a factor and also tell you it also tells you the number of levels, which is also health.

422
00:57:36,590 --> 00:57:40,760
So this time it's a factor with the three levels.

423
00:57:41,060 --> 00:57:45,440
Okay. SPR PR functions useful to know about.

424
00:57:46,850 --> 00:57:51,200
It just gives you kind of a rough structure of a data frame.

425
00:57:54,590 --> 00:58:00,500
Okay. So I just thought I'd mention this just because it's a useful ah function.

426
00:58:00,800 --> 00:58:04,770
So throw it in and it's often used in connection with factors.

427
00:58:04,790 --> 00:58:14,270
I mean you can use the table function for basically any variable, but usually you would use it in the case where you're dealing with categorical.

428
00:58:14,750 --> 00:58:23,239
So the table of function just basically counts the number of observations in each category or in

429
00:58:23,240 --> 00:58:29,870
our terms it counts the number of observations that are present at each level of the factor.

430
00:58:31,670 --> 00:58:41,420
And you can also use it for like combinations of to two variables so you can have it two by two or as how many levels there are.

431
00:58:41,420 --> 00:58:51,360
But you can have a cross tabulation of two or more factor variables are eight or three three.

432
00:58:52,420 --> 00:59:04,340
Usually a table with more than three variables at a time starts to become less useful, or at least as hard, less easy to interpret the output.

433
00:59:05,120 --> 00:59:12,559
And you can do it. Okay, so here is kind of the most direct application of table function.

434
00:59:12,560 --> 00:59:21,040
So let's say we want to check the number of observations that are in each of the treatment groups from the plant growth data frames.

435
00:59:21,040 --> 00:59:26,940
So the way to do that is just to put a table and then kind of the name of the the variable here.

436
00:59:26,960 --> 00:59:33,110
So if we just do table of plant growth dollar sign group,

437
00:59:33,770 --> 00:59:41,330
that's just going to give us a just going to count the number of observation at each level of that factor.

438
00:59:41,340 --> 00:59:50,690
So we have all the controls to operations and control and observations and treatment one and ten Observations and Treatment two.

439
00:59:51,020 --> 00:59:55,100
Okay. So there are actually 30 observations in this data frame.

440
00:59:55,970 --> 01:00:00,410
There's basically ten and each category for each treatment category.

441
01:00:03,830 --> 01:00:06,920
So we'll do another data set, I think.

442
01:00:07,340 --> 01:00:12,380
And since there is only one, there's only one kind of categorical variable.

443
01:00:12,890 --> 01:00:23,930
And the plant growth data is use another data frame just because there's more categorical variables that we can look at.

444
01:00:24,500 --> 01:00:30,780
So this is a data set from the mask package in A s s.

445
01:00:30,820 --> 01:00:39,200
So these are packages that you can install in our studio and these two locations, the library of mass.

446
01:00:39,950 --> 01:00:49,880
And so once you run Library of Mass to load into the dataset and do data, we can see the data and if we want to look at the structure.

447
01:00:50,540 --> 01:00:56,630
So this data frame as 137 observations with eight variables.

448
01:00:57,590 --> 01:01:08,210
So these are the variable names. So we have one to just five numeric variables and three factors.

449
01:01:10,280 --> 01:01:14,300
Okay. So that's kind of just stellar.

450
01:01:14,390 --> 01:01:20,800
Vague is is kind of a good overview of what what the.

451
01:01:22,660 --> 01:01:34,180
The components are the data frame. So you'll notice that the the treat the treat and the cell variables are both factor.

452
01:01:34,180 --> 01:01:38,740
So treat they just represents a treatment factor with two levels.

453
01:01:39,360 --> 01:01:44,890
Excel is something like a cell type, so this is a factor with poor levels.

454
01:01:48,610 --> 01:01:51,579
If you want to kind of cross tabulate these two factors,

455
01:01:51,580 --> 01:01:59,410
you can just put both of them into the table function and then separate them by commas or by a comma.

456
01:01:59,830 --> 01:02:10,120
So this will give us a table counting the number of observations in each possible combination of treatment and cell types,

457
01:02:10,130 --> 01:02:14,740
and eight possible combinations of treat in cell type.

458
01:02:15,340 --> 01:02:19,900
Now give us and present the results in two by four table.

459
01:02:20,710 --> 01:02:28,000
So you can see here there's 15 observations with Treatment one and cell type one.

460
01:02:28,960 --> 01:02:39,010
There's 30 observations with Treatment one and cell type two nine, observations treatment one, cell type three, etc., etc.

461
01:02:39,610 --> 01:02:51,310
Okay, so this is in the class and categorical data and the system used to call this said God, I call this a contingency table.

462
01:02:52,450 --> 01:02:55,840
So this is example of to my by four contingency table.

463
01:02:59,140 --> 01:03:02,180
Oh, I just point this out. You can also use these.

464
01:03:03,060 --> 01:03:07,780
So a lot of the matrix types of functions on tables as if it were a matrix.

465
01:03:07,780 --> 01:03:13,209
It's not exactly a matrix, but you can apply these functions as if it were a matrix.

466
01:03:13,210 --> 01:03:23,620
So if I wanted to just do the column sums of this table, I just didn't call some of that via the columns.

467
01:03:23,860 --> 01:03:28,960
So the first column has some 35/2 columns, some 48.

468
01:03:31,360 --> 01:03:37,660
You can even do kind of a cross tabulation of three variables.

469
01:03:37,670 --> 01:03:42,400
So the way this reads is that.

470
01:03:43,120 --> 01:03:48,370
So let's see if we look back at prior so prior as level zero and ten.

471
01:03:49,300 --> 01:04:01,860
So if you do kind of three categorical variables, it's going to print out kind of aa2 dimensional table for each level of the third factor.

472
01:04:01,870 --> 01:04:12,699
So basically this is this first table here is present is showing a kind of a contingency

473
01:04:12,700 --> 01:04:18,210
table of treatment and cell only for those observations where prior equals zero.

474
01:04:18,220 --> 01:04:33,730
So like this entry here, eight at number eight corresponds to the case where we have treatment one cell type one and prior equals zero.

475
01:04:34,450 --> 01:04:38,050
And very similarly like this ten here.

476
01:04:38,470 --> 01:04:44,500
And these are we have ten observations that treat with one cell type for prior equals zero.

477
01:04:44,710 --> 01:04:50,560
So that's kind of the way to read these things off where you have three

478
01:04:50,560 --> 01:04:55,210
categorical variables if you want to do a table of all of those at the same time.

479
01:04:59,500 --> 01:05:10,390
So let's basically just kind of print out a contingency table of two for each level of this this last factor variable.

480
01:05:11,320 --> 01:05:14,800
So let's say you can use table with more than two.

481
01:05:20,080 --> 01:05:25,660
More than two levels. Well mentioned raising briefly to apply an aggregate.

482
01:05:29,650 --> 01:05:36,400
There are ways to do this, which may you might find more convenient when we talk about deep fly art later on in the next lecture.

483
01:05:36,400 --> 01:05:48,070
But we thought I'd mention this because this is sometimes useful and you may see it in other people's continues to apply.

484
01:05:48,550 --> 01:05:51,580
And there's one other function I'll talk about, which is aggregate.

485
01:05:54,160 --> 01:05:56,860
So to apply is kind of like a table apply.

486
01:05:59,530 --> 01:06:10,359
So that's useful when you want to compute a certain summary statistic, maybe some numeric variable for each level of a factor variable.

487
01:06:10,360 --> 01:06:16,990
So I guess like a practical example of this is I want to know what.

488
01:06:17,350 --> 01:06:29,500
So we have, we have two treatment groups and the VA data and we also have a numeric variable being a numeric variable called age and VA data.

489
01:06:29,800 --> 01:06:36,280
So let's say you wanted to know what the average age was for each treatment.

490
01:06:36,610 --> 01:06:39,720
So we want to know the average age within each treatment group.

491
01:06:39,730 --> 01:06:42,890
So the way to do this is with a t apply.

492
01:06:42,910 --> 01:06:49,780
I just do the name of the numeric variable that I want to take the mean of first.

493
01:06:49,780 --> 01:06:59,890
And then the second argument is the factor that you kind of want to take the mean of for each level of that factor.

494
01:07:00,670 --> 01:07:06,850
And so this will output any factor with the same length as the number of levels of this factor.

495
01:07:07,210 --> 01:07:15,100
So basically what this is outputting is, is the mean of age for each level of treat.

496
01:07:15,100 --> 01:07:21,280
So the mean age for treatment group one is 57.5.

497
01:07:23,170 --> 01:07:32,510
One mean of the mean age within treatment group two mean age of people in treatment of two is 59.1.

498
01:07:34,390 --> 01:07:42,850
Similarly, if we wanted to do standard deviation, this is saying that the standard deviation age for those people is in treatment.

499
01:07:42,850 --> 01:07:54,370
Group one is 10.81. The standard deviation of age for those in treatment group two is 10.27.

500
01:07:54,940 --> 01:08:05,780
Okay, so this is kind of useful if you just want to take a quick summary statistic kind of for each level of a factor about kind of I mean,

501
01:08:05,780 --> 01:08:10,150
you can, you can write it out yourself by taking like a subset of each.

502
01:08:15,860 --> 01:08:20,299
A subset of this age variable, for example, computing.

503
01:08:20,300 --> 01:08:27,500
And I mean for each subset that you take for this, this is kind of just a convenient way of doing it in a, in a single line.

504
01:08:28,220 --> 01:08:35,330
So this is to apply, so to apply works for kind of one variable.

505
01:08:35,870 --> 01:08:41,000
Okay. So if I want to take a summary statistic of one variable to apply works,

506
01:08:41,600 --> 01:08:48,560
if you kind of want to do many at the same time, aggregate is kind of the type of thing you would want to do.

507
01:08:49,160 --> 01:08:56,090
So let's say I want to do with like a single line of our code.

508
01:08:56,090 --> 01:09:07,240
I want to take the mean of each of the numeric variables for each treatment.

509
01:09:07,730 --> 01:09:14,510
Okay. So you can't do all of that with t apply or at least within a single, single line of code.

510
01:09:14,750 --> 01:09:23,540
Okay. So aggregate is a way of doing this.

511
01:09:23,540 --> 01:09:34,429
So let's say the way you do it is you give it a dataframe with the give it a

512
01:09:34,430 --> 01:09:41,330
data frame with the kind of variables that you want to apply this function to.

513
01:09:41,540 --> 01:09:47,239
Okay. So the way I've done it here, so this is a data frame.

514
01:09:47,240 --> 01:09:58,160
So if I clearly said that you can, you can subset a data frame the exact same way as you would with the matrix.

515
01:09:58,670 --> 01:10:03,470
Okay. So this is code here.

516
01:10:04,100 --> 01:10:19,549
So if I have VA with bracket and then comma is this vector here that's it's taking a subset of VA kind of the exact same way you subset a matrix.

517
01:10:19,550 --> 01:10:28,250
So here all that is doing is taking the first, second, fourth, fifth and sixth columns of our data frame.

518
01:10:28,250 --> 01:10:36,409
V So the reason for doing that is that the first, second and fourth, fifth and sixth variables are all numeric.

519
01:10:36,410 --> 01:10:49,670
So this looks this kind of, this kind of extracts a data frame with only the first, second, fourth and fifth and sixth columns of V.

520
01:10:50,420 --> 01:11:01,370
And then the way you have to do in aggregate is this you just give it the factor variable that you call it.

521
01:11:01,730 --> 01:11:12,770
Stratifying by cell type basically means you could compute the mean for each level of the cell type and you have to this should be a factor,

522
01:11:12,770 --> 01:11:15,889
but you have to use the way aggregate works.

523
01:11:15,890 --> 01:11:19,510
You have to just put the guess to put it inside of the list command.

524
01:11:19,520 --> 01:11:25,460
So it should be a list with one component where.

525
01:11:27,790 --> 01:11:32,230
The first component is kind of a factor. Factor.

526
01:11:32,400 --> 01:11:36,490
Okay. Just kind of the syntax you have to do to make aggregate work.

527
01:11:37,240 --> 01:11:49,180
So what that does is just going to compute the mean for each variable that we have in this data frame according to each level of of this factor.

528
01:11:49,570 --> 01:11:53,170
So this is going to give us the cell had four levels, right?

529
01:11:53,180 --> 01:11:57,280
So these are on the left hand side. These are the four levels of cell.

530
01:11:58,060 --> 01:12:07,870
So this is like the so the mean of s time within the cell, type one is 200.2.

531
01:12:09,880 --> 01:12:14,500
The mean of status within cell type one is 0.885.

532
01:12:14,800 --> 01:12:25,090
Okay. And then the mean s time within for those observations with cell type four is one 66.1.

533
01:12:25,390 --> 01:12:29,980
So that's kind of the way of interpreting this. So aggregate is less useful.

534
01:12:29,980 --> 01:12:33,820
It kind of does it does all of this in kind of a single statement.

535
01:12:33,850 --> 01:12:43,030
You can kind of do this. You can kind of do t apply for multiple variables at the same time.

536
01:12:44,800 --> 01:12:52,300
And here kind of kind of has the same flexibility as all of our applied type functions.

537
01:12:52,840 --> 01:12:58,989
We could just get if we want to compute a different type of statistic, we can just get a different name of the function here.

538
01:12:58,990 --> 01:13:03,640
So if we wanted to compute the median rather than the mean, we just give it the name mean.

539
01:13:04,220 --> 01:13:14,200
Okay, so that's it for like table t apply in aggregate.

540
01:13:14,200 --> 01:13:19,220
So the real time. Okay, so just about that time, I don't know,

541
01:13:19,270 --> 01:13:31,630
there's not really a lot to say about reading in files or just kind of we can maybe do an example next time,

542
01:13:32,170 --> 01:13:37,600
but it's just kind of like the commands, the main commands that you would use to read in the titles.

543
01:13:37,620 --> 01:13:49,290
I was just saying that a file is a collection of data on your computer and kind of thing,

544
01:13:49,480 --> 01:13:54,920
at least in terms of reading in data into your ah studio for example,

545
01:13:54,920 --> 01:14:03,220
at least if you're loading and data load and you download it, the thing that you need to know about a file is inspired.

546
01:14:03,280 --> 01:14:12,149
Have right. You should know where it's located, basically kind of what folder it's located in in order to read it to.

547
01:14:12,150 --> 01:14:16,590
Ah. So there are many types of files.

548
01:14:16,590 --> 01:14:22,079
I mean we're, we're the oldest in this class.

549
01:14:22,080 --> 01:14:25,530
We're going to assume they're stored as text files.

550
01:14:25,920 --> 01:14:31,139
We're not going to be reading the raw binary files into tomorrow or anything.

551
01:14:31,140 --> 01:14:36,060
So we're going to be we're going to assume the data are stored as text file.

552
01:14:36,060 --> 01:14:42,450
So these are just files where when you open it up, it kind of looks reasonable.

553
01:14:42,450 --> 01:14:48,220
Everything is stored in letters, numbers, special characteristics like that.

554
01:14:48,330 --> 01:14:56,500
So these are going to be things like C, USB files, tab, separated files, things like that,

555
01:14:56,500 --> 01:15:01,980
and some things that when you open them up, you can kind of see kind of reading them.

556
01:15:02,220 --> 01:15:16,350
Okay. So as an example of this, maybe you can try it out or maybe we'll do it to start the next next lecture.

557
01:15:16,350 --> 01:15:25,020
But I put an example on the canvas site this got your data set so this is the name of this

558
01:15:25,020 --> 01:15:31,650
is reminder underscore for that CSP so this is under the files folders and data folder.

559
01:15:32,280 --> 01:15:40,650
So if you download it onto your local computer, you can, you should be able to load it into our studio.

560
01:15:41,160 --> 01:15:46,260
When you download it, just make sure you can know which folder it's downloading it into.

561
01:15:47,760 --> 01:15:58,709
So once you've done that, I mean, if you're uncertain about which folder it is,

562
01:15:58,710 --> 01:16:08,820
you can kind of see this thing you can do file that exists and you can check that the path path name is correct.

563
01:16:08,820 --> 01:16:16,890
So hopefully know where the kind of the path name to all of the work is found.

564
01:16:18,300 --> 01:16:21,540
So if you kind of run this command and it returns true,

565
01:16:21,570 --> 01:16:29,550
that means it's kind of it's located at the the file path and you put it and you put your list on the windows.

566
01:16:32,940 --> 01:16:40,440
So kind of where I like on my computer, it's kind of the folder that I downloaded it to.

567
01:16:40,440 --> 01:16:50,729
So this is the part of this folder and so I run this in our file exists with this pattern and it'll

568
01:16:50,730 --> 01:17:00,720
print true and so as a way to load and I see USB file is just to use the function read not see USB.

569
01:17:00,870 --> 01:17:08,040
It's kind of the key function that you need to know if you're dealing with C USB files, which are pretty, pretty common.

570
01:17:09,960 --> 01:17:20,340
So you just do it here. So I could have put it in, I could have done read that CSP and put it this entire thing here inside folders.

571
01:17:20,670 --> 01:17:23,129
I didn't do it since it ran out of space,

572
01:17:23,130 --> 01:17:32,960
but you can also assign the path name a character variable and just put the character variable as your argument.

573
01:17:33,060 --> 01:17:40,860
Read that CSP and this this when we do this assignment some variable to that.

574
01:17:41,330 --> 01:17:46,950
And so the object that's returned by reading CSP this should be a data frame when we run in this country.

575
01:17:48,790 --> 01:17:54,059
So after we want to run this code, that minder should be a it should be a data frame.

576
01:17:54,060 --> 01:18:02,910
So if we if we check the time class or calendar, it should be it should be anyone should be a data frame.

577
01:18:04,290 --> 01:18:12,569
So there's this command called head, there's this function called head really stands, I guess for header.

578
01:18:12,570 --> 01:18:21,930
It's kind of just when you when you run it, when you give it a data frame as an argument, it just prints out the first few rows.

579
01:18:21,930 --> 01:18:29,759
So just it's kind of useful just to as a way of just checking to see kind of what the what the dataset looks like.

580
01:18:29,760 --> 01:18:38,130
So that just gives you a kind of sense of the types of values that are in each of the variables, how many variables there are.

581
01:18:38,910 --> 01:18:45,660
And it gives you a way to check that it kind of read everything in reasonable in a reasonable

582
01:18:45,660 --> 01:18:54,450
way and kind of didn't mess up the data that was stored in some kind of weird way.

583
01:18:54,510 --> 01:18:58,260
Just text. It's a way of just checking that everything kind of worked correctly.

584
01:19:01,590 --> 01:19:03,990
Maybe we'll stop there, but maybe I'll just mention there is.

585
01:19:07,100 --> 01:19:15,380
Maybe an easier way if you don't know the exact words or the way upon viewing the data before you load it in.

586
01:19:16,010 --> 01:19:24,320
So if you had a kind of a CSP file that you want to load in and you're using our studio, you can just go to this.

587
01:19:27,320 --> 01:19:34,070
If you go to the kind of the environment tab and then look at this, it should be this import data set right underneath that.

588
01:19:34,580 --> 01:19:44,960
If you click on that, it'll allow you to kind of browse, browse your computer and you can look for the folder where it's stored.

589
01:19:44,970 --> 01:19:52,010
And then once you kind of click on that data set that you want to open, it will have it'll show something like this.

590
01:19:53,120 --> 01:20:01,309
So if you kind of see what your data sets going to look like before you actually load it into power.

591
01:20:01,310 --> 01:20:07,010
And so once everything looks good, you need to click import at the bottom here.

592
01:20:07,010 --> 01:20:12,660
And then that will also import the CSP file as a data frame into our.

593
01:20:12,740 --> 01:20:20,240
So this is kind of a little bit more of a point and click way of loading in your data into offer,

594
01:20:20,240 --> 01:20:28,030
but it does kind of the same and basically the same thing as redone CSP looks.

595
01:20:28,490 --> 01:20:37,430
Okay. So we have a few other comments about reading and data that we just finished

596
01:20:37,430 --> 01:20:52,220
that we can finish that next time for people who are not familiar with it.

