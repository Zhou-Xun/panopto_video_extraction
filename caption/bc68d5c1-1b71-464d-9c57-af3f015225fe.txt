1
00:00:05,320 --> 00:00:17,430
I want, you know, for whatever reasons.

2
00:00:26,590 --> 00:00:46,290
Go ahead and get started. Here is the big quiz on what is going on like a mouse.

3
00:00:46,300 --> 00:00:52,070
And that's what a cup of tea essentially covers up through.

4
00:00:52,080 --> 00:00:55,910
And that is without the power to reshape.

5
00:00:56,510 --> 00:01:15,300
I guess you just laid out everything up to this party after after we start talking about the shape of that is on the books.

6
00:01:16,710 --> 00:01:25,590
And then I just kind of, you know, data visualization stuff, not you just need that for the final assignment.

7
00:01:25,720 --> 00:01:43,970
So the first part of the lecture is how do we stop the material, the final assignment here?

8
00:01:44,760 --> 00:01:55,499
So if you want to, we just create an account load in the data that was released.

9
00:01:55,500 --> 00:02:04,980
Don't wait for the last minute. There's some issues with loading inflation, work for everybody.

10
00:02:07,110 --> 00:02:23,790
The questions, for instance, on Wednesday like today, basically just finish up some extra,

11
00:02:26,280 --> 00:02:30,120
extra things you can do with pandas data frames more or less.

12
00:02:30,260 --> 00:02:43,830
And yeah, part of that was talking about kind of reshaping the data that will be on the quiz and then we'll start talking about doing graphics.

13
00:02:44,130 --> 00:02:55,980
Basically, there's the map plot lib comes out with the main library for doing graphs in Python.

14
00:02:55,980 --> 00:03:01,440
All the others, there are a bunch of other libraries where that's probably feel if you just want to start,

15
00:03:02,070 --> 00:03:05,160
that's probably the most important thing about this.

16
00:03:05,670 --> 00:03:13,710
We'll start with that one. So yeah, so let's now let's go back into pandas again.

17
00:03:13,730 --> 00:03:20,760
So this is just kind of reminding us how to load the iris data set.

18
00:03:20,760 --> 00:03:24,270
So we are doing the iris data sent last time.

19
00:03:24,270 --> 00:03:36,060
So just start with that again. So you just want to lay out a little bit about Iris because that is from S K learn that data sets library.

20
00:03:36,690 --> 00:03:43,769
And so if you load iris with this as frame equals true that should load it in as a pandas data frame.

21
00:03:43,770 --> 00:03:55,530
So the computer this has iris, the F as I'm calling it so this you can print out the first five rows.

22
00:03:56,550 --> 00:04:03,650
This has four four variables 55455, four, four.

23
00:04:04,200 --> 00:04:14,790
The data set self has five variables which just what we work in the set as well.

24
00:04:16,350 --> 00:04:23,460
In this lecture, the only data that's on the it's on the canvas website and the data folder.

25
00:04:23,510 --> 00:04:33,210
Okay. So you said PANDAS is not going to be on the end of this, but if you say that PANDAS is not going to be created.

26
00:04:34,170 --> 00:04:40,230
Oh, I know pandas will be on the quiz. This is the PANDAS ratios.

27
00:04:40,800 --> 00:04:50,130
So basically start to erase everything before this is on is basically me.

28
00:04:55,730 --> 00:05:01,200
Okay. So. Okay. Okay.

29
00:05:01,820 --> 00:05:06,770
So this is the other data set will be working with us as the phone data set.

30
00:05:06,780 --> 00:05:12,229
So this is also on the Canada site data folder.

31
00:05:12,230 --> 00:05:24,110
So if you want to be in the CSP as a data friendly, I think the easiest way to do that read CSP so that others read it in as a data frame.

32
00:05:24,110 --> 00:05:33,379
So this is what the world looks like, or at least the first five rows of this data sets those four variables your own age.

33
00:05:33,380 --> 00:05:39,400
Gender. This can be in the. Okay.

34
00:05:39,440 --> 00:05:47,840
So I guess the yeah, we're just going to talk about some, just some useful commands that you can do when you're kind of manipulating a data frame.

35
00:05:48,530 --> 00:05:55,100
One of those things is just to sort the data off and want to sort the data within a certain variable, for example.

36
00:05:56,000 --> 00:05:59,300
The way to do that and PANDAS is just is just sort of values.

37
00:05:59,540 --> 00:06:10,279
Okay. So the way you do that, you can just use the name of the data frame itself and then dot sort values and then do it by equals,

38
00:06:10,280 --> 00:06:20,180
like the name of the variable. So if you want to sort of buy a particular variable from low to high, you just do it by the name of that.

39
00:06:23,450 --> 00:06:26,930
And so this will actually if you run this, this will kind of return.

40
00:06:27,920 --> 00:06:41,300
It's actually returns a different data frame, which is this data frame where the rows are sorted by the values of this very long.

41
00:06:41,770 --> 00:06:49,130
Okay. There's a way to do this sort of thing without returning a new data frame.

42
00:06:49,820 --> 00:06:53,630
And in the next slide or the next two slides.

43
00:06:54,260 --> 00:07:04,160
But if you run this type of command, it's returns kind of a new data frame where the rows are just sorted by this variable after that.

44
00:07:06,380 --> 00:07:13,760
So, yeah, I've done that here. If I, if I do this, both got sort of values and then I do find it to be empty.

45
00:07:13,760 --> 00:07:20,240
This will kind of return another data frame, assigning that to the sort of phone.

46
00:07:21,110 --> 00:07:26,090
So sorted barn will be new. This will be a new data frame,

47
00:07:26,960 --> 00:07:34,430
which is kind of what it looks like if you at least if you if you print out the first five rows, this is what it looks like.

48
00:07:35,600 --> 00:07:42,770
You can see here it's sorted from low to high according to this spindly variable.

49
00:07:42,770 --> 00:07:53,000
So the lowest and the smallest value of BMD is negative .060640.

50
00:07:54,590 --> 00:07:58,210
And then we have all of these or are larger than that.

51
00:07:58,220 --> 00:08:03,050
So this is now the second smallest value. This is the third smallest value and so on.

52
00:08:04,780 --> 00:08:08,450
And. Oh, yeah.

53
00:08:08,470 --> 00:08:16,240
So like I was saying before, like when you run this sort of values command, but if it is both that sort of values command by itself,

54
00:08:16,750 --> 00:08:22,590
it doesn't change the ordering of the rows in the in the data set itself right.

55
00:08:22,600 --> 00:08:31,750
So if we look at, if we print out the first five rows of bone, it's still it's still kind of in the same order that we had in the beginning.

56
00:08:33,240 --> 00:08:38,710
It's just sorted by ID number two is kind of the way we originally loaded in the data.

57
00:08:40,510 --> 00:08:52,420
So the way you can do it in like a single command that, that updates the ordering of the rows and your original data frame, you can do that.

58
00:08:53,230 --> 00:09:05,200
You just have to include this. This in place equals true basically kind of updates the ordering of the rows, things in place like if.

59
00:09:06,920 --> 00:09:10,730
Without having to reassign it to something later on.

60
00:09:10,760 --> 00:09:13,460
So I've kind of done that here.

61
00:09:13,970 --> 00:09:26,720
So if you run following that source values and still use by ESPN BMD, but if you add the extra arguments in place equals true,

62
00:09:27,320 --> 00:09:37,790
that will sort the I will actually kind of change the order of the rows in the bone data frame so that you can see that here.

63
00:09:37,790 --> 00:09:42,840
If I run this command, then I look at the first five rows of bonus.

64
00:09:43,490 --> 00:09:51,490
It's now time to order. I go to growing. The rows has changed, so the first row is as the smallest value of ESPN3 handy.

65
00:09:51,740 --> 00:10:00,050
Okay. And that's how you can kind of change the actual ordering of the rows and the dataframe that you're working with.

66
00:10:01,190 --> 00:10:11,659
Okay. So oh, so you often want to do you often don't want to do like just sort of by a single variable.

67
00:10:11,660 --> 00:10:16,879
So you are someone to sort by two variables.

68
00:10:16,880 --> 00:10:25,640
I mean, this often happens when you have like in this case you have one variable where there's a lot of duplicates,

69
00:10:26,240 --> 00:10:39,430
another variable whether it's maybe not. So you want to, you want to sort by the, like, this numeric variable, at least within it.

70
00:10:39,620 --> 00:10:42,109
You don't want to change like the ordering of the items,

71
00:10:42,110 --> 00:10:51,620
but like within be like for a fixed idea for like all the observations where you have ID equals one,

72
00:10:52,070 --> 00:10:56,570
you want things to be sorted according to spin BMD.

73
00:10:56,780 --> 00:11:01,309
Okay, you often want to do that. So I would say that's kind of your order.

74
00:11:01,310 --> 00:11:10,160
You're sorted by two variables and so I want everything first sorted by I need, but there are a lot of duplicate values of ID.

75
00:11:10,380 --> 00:11:17,850
So for the rows where we have the same ID value, we're going to sort by ESP and BMD empty.

76
00:11:21,440 --> 00:11:29,360
So you can just do that by giving it to variable. So let's you know, if you want to sort by ID and then spin BMD.

77
00:11:30,080 --> 00:11:36,500
So that kind of basically means you're giving the ID priority when you're doing the sorting.

78
00:11:36,680 --> 00:11:40,910
But for the same values of ID, you're sorting by SPV,

79
00:11:41,450 --> 00:11:48,649
you just give it to the name and you give make sure that that ID no name is

80
00:11:48,650 --> 00:11:55,790
first and then that as PNB and here again using in-place place equals true.

81
00:11:55,790 --> 00:12:00,950
So that'll kind of change the ordering of the rows within the bottom dataframe.

82
00:12:01,730 --> 00:12:09,049
Okay. So you can see here, if we print out, all I want is first,

83
00:12:09,050 --> 00:12:21,860
but within one it's it's sorted from lowest to highest for PNB in the case that's had a sort back like variables.

84
00:12:21,860 --> 00:12:28,969
I guess the only main other thing to know about sorting is how to do the sorting in the reverse order.

85
00:12:28,970 --> 00:12:39,110
So the default in python is to sort things from lowest to highest if you want to do list the lowest.

86
00:12:39,110 --> 00:12:46,130
So that's descending order. You just have to include the ascending equals false.

87
00:12:47,600 --> 00:12:51,770
So I guess the default is to have a send sending equals true.

88
00:12:51,770 --> 00:12:59,060
So if you just change that the sending equals false, that'll do it kind of in the reverse order.

89
00:12:59,180 --> 00:13:05,660
So if I saw this on DataFrame by SPV, I'm dealing with a sending impulse.

90
00:13:06,440 --> 00:13:14,960
Now we go from of largest to the smallest. So the largest volume as PubMed is 0.1.2199.

91
00:13:15,500 --> 00:13:35,240
Yeah it's it's really about sorting is the next thing I wanted to mention is at least kind of at least a few commands total.

92
00:13:35,950 --> 00:13:42,770
We work with kind of theta values that have a lot of duplicates.

93
00:13:44,810 --> 00:13:49,250
So that's pretty common to have some variables where there's a lot of duplicate values.

94
00:13:49,910 --> 00:13:54,410
So I mean, that's certainly the case in this and this bone data frame.

95
00:13:54,410 --> 00:14:01,639
So this, I would say IDM is an example of a variable that's a lot of duplicates.

96
00:14:01,640 --> 00:14:06,050
So we have idea number one is repeated.

97
00:14:06,140 --> 00:14:13,520
Three times 82 I think is the 32 of us were repeated three times, etc., etc.

98
00:14:13,520 --> 00:14:25,069
So there's a lot of kind of repeats. I'd know, for example, so often you want to be able to, depending on what you're trying to do,

99
00:14:25,070 --> 00:14:30,260
it's good to be able to kind of identify where the kids are.

100
00:14:33,650 --> 00:14:40,459
So the first I guess the first thing I wanted to mention was to like find out how many unique values there are.

101
00:14:40,460 --> 00:14:50,180
So like in this data set, you might like an ID number represents a different person, so you might just want to find out how many,

102
00:14:50,240 --> 00:14:55,100
how many people are represented in your data set so that the number of rows

103
00:14:55,100 --> 00:14:59,540
doesn't tell you that since you can have multiple rows for the same person.

104
00:14:59,540 --> 00:15:03,410
So to do that, you have to look at kind of the number of unique.

105
00:15:04,250 --> 00:15:11,720
Number of unique, I'd say, okay, so to do that, you can just do this, use this unique method.

106
00:15:13,820 --> 00:15:22,040
So yeah, you can just use it on you just use it on like a one on one variable from, from a data frame.

107
00:15:22,730 --> 00:15:33,680
So if I look at both announcements, basically that's the ID column from the data frame.

108
00:15:33,680 --> 00:15:47,899
If I just use this dot unique method on it, then I will just return it returns a numpy array with kind of containing only the unique ID number.

109
00:15:47,900 --> 00:15:58,700
So this it's going to return all of the IP numbers, but it's not going to have any it's not going to repeat them anywhere in the in the array.

110
00:16:00,320 --> 00:16:04,460
So this is just unique IDs. This is actually a not being array.

111
00:16:05,240 --> 00:16:13,250
Did you see that? If you look at the type to not be array and I don't know, maybe on the next line,

112
00:16:13,250 --> 00:16:19,520
if you look at the length of it, that will tell you how many unique people are in your data frame.

113
00:16:21,780 --> 00:16:25,110
But I just printed out the first five values here.

114
00:16:27,200 --> 00:16:28,890
Doesn't necessarily put them in order.

115
00:16:31,390 --> 00:16:38,100
But yeah, if you want to find out how many people are in your data, say you can just look at the blank, the length of that array.

116
00:16:38,460 --> 00:16:43,050
Since there's kind of no duplicates, every element is kind of like a separate idea.

117
00:16:43,770 --> 00:16:50,130
So in this case, this is telling the stuff. We have 261 people in this dataset.

118
00:16:52,340 --> 00:16:59,040
There's 201 261 different people represented in this dataset.

119
00:17:04,850 --> 00:17:14,850
So that's just. That's just how you. That's how you find the number of detainees or it's actually one way.

120
00:17:14,860 --> 00:17:22,030
What's another? Another is another way is to just do it.

121
00:17:22,360 --> 00:17:27,190
If you do the set of functioning people that you just assigned to.

122
00:17:27,460 --> 00:17:32,830
I take the set of this and should create a set.

123
00:17:37,180 --> 00:17:42,520
Insets have no duplicates. If you look at the length of that same issue, there's also another way to put it.

124
00:17:45,550 --> 00:17:52,460
Okay. So it's in addition to just finding the number of unique values you often want to kind of identify.

125
00:17:54,030 --> 00:17:57,780
Are you you also want to drop the duplicates, for example.

126
00:17:57,790 --> 00:18:04,920
So let's say. And it's pretty common to do this sort of thing.

127
00:18:04,930 --> 00:18:10,479
I mean, for example, if you just want to create a data set which has data from the first visit,

128
00:18:10,480 --> 00:18:18,370
so these these data are like observations from two consecutive hospital visits.

129
00:18:18,370 --> 00:18:27,520
For example, if I just want to collect data or get a data frame where you just have data from everybody's first visit.

130
00:18:29,470 --> 00:18:41,110
One way to do that is to drop kind of all the cases where we have duplicate I.D. So to do that and you could use this drop duplicate method.

131
00:18:41,470 --> 00:18:56,070
Okay. So the way driving duplicates works is that all you have to do is I'll show on the next the next slide exactly what it's doing.

132
00:18:56,070 --> 00:19:02,580
But what it's really kind of the purpose of it is we're kind of driving duplicate ID values.

133
00:19:02,580 --> 00:19:09,479
It only keeps for an I.D. It only keeps a row that I.D. first appears.

134
00:19:09,480 --> 00:19:12,629
So here the ID one first appears.

135
00:19:12,630 --> 00:19:17,100
So it keeps the first row, but it's going to drop the next two rows.

136
00:19:18,120 --> 00:19:22,079
And then for this row of index three.

137
00:19:22,080 --> 00:19:28,380
But this is like this fourth row. That's the first time I need to appear.

138
00:19:28,390 --> 00:19:34,710
So it keeps that row and then it'll drop all the other rows where, where I need to appear.

139
00:19:34,800 --> 00:19:37,830
So that's kind of how drop duplicates works.

140
00:19:38,790 --> 00:19:43,050
I think this shows like the exact way to use it.

141
00:19:44,790 --> 00:19:56,820
So if I so if I want to create another data frame that kind of only keeps the first appearance of an ID number,

142
00:19:57,240 --> 00:20:04,410
I can do it this way so I can say phone dot, dot, drop duplicates.

143
00:20:04,410 --> 00:20:14,460
And then I have to tell ID the variable that I want it to look for for duplicates that otherwise doesn't mix.

144
00:20:14,520 --> 00:20:17,910
And you have to pick a variable for that.

145
00:20:18,090 --> 00:20:23,340
And you're looking for duplicates of, okay, the way to do that is this kind of subset of time.

146
00:20:23,670 --> 00:20:30,570
So you subset equals the variable that you're looking for duplicates out.

147
00:20:31,800 --> 00:20:42,210
So this will return a data pandas data frame that only keeps the first appearance of an IP number.

148
00:20:46,110 --> 00:20:47,550
So you can see that here.

149
00:20:47,640 --> 00:20:58,200
Like if you look at the clone unique IDs, if you look at the first five rows of this, you can see every row has a new I.D. number.

150
00:20:58,200 --> 00:21:01,620
So we have ID. One, two, three, four, five.

151
00:21:06,140 --> 00:21:10,730
And this this should if you look at like the number of rows and columns,

152
00:21:11,300 --> 00:21:19,430
it should match up to what we had before, where we used the unique method to look at the number of unique.

153
00:21:19,850 --> 00:21:23,960
So if we look at the like the dimensions of bone unique IDs,

154
00:21:25,190 --> 00:21:37,450
you can do that using only indicating that that shape it tells you like the number of rows and columns and at the end is dataframe shape.

155
00:21:37,460 --> 00:21:47,790
So this is telling us that the unique shape of the indicated shape has 261 rows and four columns.

156
00:21:47,790 --> 00:21:54,200
So this matches what we put, what we had before, where we used the unique method.

157
00:21:54,260 --> 00:22:00,860
So there's 261 individuals in this dataset.

158
00:22:05,750 --> 00:22:14,300
I find that the duplicated method also pretty useful is sometimes the duplicated method.

159
00:22:15,290 --> 00:22:18,500
What that does, it basically returns a boolean vector.

160
00:22:22,190 --> 00:22:26,659
So basically the way to interpret the boolean vectors added that it returns.

161
00:22:26,660 --> 00:22:39,320
It returns true if that value has appeared previously in the array, otherwise it returns false.

162
00:22:40,160 --> 00:22:51,010
So if we look at this kind of the original format of the phone data, if I look at if I just do following a phone that I've done,

163
00:22:51,230 --> 00:23:03,260
let's look at another way to have an indirect or straightforward look at the ID variable from both.

164
00:23:03,890 --> 00:23:06,110
So if I do the duplicated method on that,

165
00:23:06,740 --> 00:23:19,700
that returns a that returns a boolean vector to return a boolean vector the same length as the number of components in it.

166
00:23:21,320 --> 00:23:29,090
And then here I'm just printing out like the first five, the first five rows, just so it kind of fits on the slide.

167
00:23:31,170 --> 00:23:45,230
So this is these are the first five rows of what duplicated returns which we're applying to the duplicated method on the 1984 returns.

168
00:23:47,690 --> 00:23:59,450
So the first element is false. Why is that? That's because for the first first element of I did not miss one.

169
00:24:00,110 --> 00:24:07,640
So one has never appeared before. This has to be the first row to pretty much always has to be false.

170
00:24:08,090 --> 00:24:11,330
So the number one has never appeared before. So that's why this is false.

171
00:24:12,170 --> 00:24:17,690
The next number is also one. So this has appeared before to appear in the first observation.

172
00:24:17,690 --> 00:24:24,110
So that's true. Also, the third element here is one that has also appeared before.

173
00:24:24,110 --> 00:24:33,320
So that's why the third element here is true. Now, if we got a two, this has that's kind of a new number that has not appeared before.

174
00:24:34,140 --> 00:24:44,840
So that's why we have false here. And then kind of the fifth element will be found here that has appeared before to appear right before.

175
00:24:44,870 --> 00:24:51,440
So that's what we had true here. So that's kind of what duplicate it does.

176
00:24:52,130 --> 00:25:00,520
So basically, actually, if you point out one way to think about one drop, if you think back to drop densities here,

177
00:25:01,500 --> 00:25:13,129
you drop duplicates is just to keep going to the rows where this is false properties for is like dropping

178
00:25:13,130 --> 00:25:21,400
where this is keeping with the first appearance of one is the first appearance of two etc. etc.

179
00:25:21,410 --> 00:25:26,210
So these are pretty closely related concepts.

180
00:25:34,690 --> 00:25:39,490
It's. He's.

181
00:25:40,870 --> 00:25:51,050
So I guess the other main thing you mention is the is in method that's useful if you just want to.

182
00:25:51,640 --> 00:26:06,670
I would say if you want to keep something in a data set, if it's if that value is in a is a member of kind of a larger set.

183
00:26:06,670 --> 00:26:10,280
So a larger set that has multiple. Okay.

184
00:26:11,860 --> 00:26:25,689
So where you don't want a subset based on whether or not something equals a certain value, but it's an element of some set that has multiple value.

185
00:26:25,690 --> 00:26:27,910
So as an example.

186
00:26:33,210 --> 00:26:46,000
I'm going to look at this this kind of small data frame that we were working with, I think last time, the state 77 data frame that has eight rows.

187
00:26:46,750 --> 00:26:50,890
Okay. So let's say, for example, I want a subset.

188
00:26:54,630 --> 00:27:05,240
I choose. I think I wanted a subset, whether the region is south and west or something like that of south or north central.

189
00:27:07,050 --> 00:27:10,110
So you could do that, that type of subset.

190
00:27:10,110 --> 00:27:16,380
And using any poor statement, you could say like region is equal to south or regions equal to north central.

191
00:27:16,800 --> 00:27:20,070
So that's fine when we're only looking at two possible cases.

192
00:27:20,070 --> 00:27:27,120
But if you wanted to subset based on whether or not if you had a bunch of regions and you wanted a subset,

193
00:27:27,120 --> 00:27:30,929
whether or not it equaled one of 100 possible regions.

194
00:27:30,930 --> 00:27:39,130
So kind of writing or for that is, is, you know, that's that's not easy to do.

195
00:27:39,240 --> 00:27:43,830
So that for that type of setup you usually want to use is in.

196
00:27:47,700 --> 00:28:04,220
Okay. So. I'll showed the exact same setting in a second, but it's probably just easier to see first what's returned if we use is in.

197
00:28:04,940 --> 00:28:11,190
So if I look at the region variable from the state data frame and use the kind of

198
00:28:11,190 --> 00:28:18,650
the is in method on that is in method where we're giving it south or north central.

199
00:28:19,640 --> 00:28:30,950
Either returns a boolean vector so it's in or turn a boolean vector which is the same length as this variable.

200
00:28:30,950 --> 00:28:33,209
So this variable has eight elements.

201
00:28:33,210 --> 00:28:47,000
So this array and return should have elements and it just basically returns true if it equals south or central easy to one, it doesn't matter.

202
00:28:47,000 --> 00:28:58,730
So you can see that here we have true, true in the first and fourth and the last two residents here, south, south and north central.

203
00:28:59,420 --> 00:29:13,550
Okay. So you can do that to create a subset of data from inside to remind you how to do a

204
00:29:14,720 --> 00:29:20,900
subset in a PANDAS data frame when you have a kind of a Boolean array that you're using.

205
00:29:23,660 --> 00:29:27,200
So you can do that by just giving it the Boolean array inside brackets.

206
00:29:28,430 --> 00:29:31,280
So that's one way to do it. I think that's the easiest way to do it.

207
00:29:33,470 --> 00:29:45,710
So if you just give it a boolean array in brackets, it's just going to keep the rows where that know where the elements of that boolean are rare.

208
00:29:45,720 --> 00:29:49,160
True. So you can see that here it returns a data frame.

209
00:29:50,030 --> 00:30:00,440
Just keeping the all of the rows in the original data frame are kind of corresponding to where elements of this boolean array are true.

210
00:30:01,400 --> 00:30:09,230
So here we're just keeping the regions of the rows where region is equal to south or north central.

211
00:30:11,000 --> 00:30:21,920
That's how you can use is n to kind of keep a subset of rows where, you know,

212
00:30:22,280 --> 00:30:31,310
it's really useful when you're looking at whether or not the value of a variable is kind of one one or kind of

213
00:30:31,580 --> 00:30:38,740
it takes at least one of the values in some kind of collection like this mean this is all going to pop up.

214
00:30:39,110 --> 00:30:48,460
This is like a collection with only two values, but it's it's useful if you have a much longer list than this list only has two elements, you know,

215
00:30:48,530 --> 00:30:58,640
loosely stored that has 200 elements this is using this is then is a lot more convenient and can have a lot of other a lot of other approaches.

216
00:31:01,240 --> 00:31:05,200
Right. Oh, this is just another example of is.

217
00:31:05,200 --> 00:31:12,460
And so let's say I wanted to create a subset of the phone data that only had a kind of a subset of people.

218
00:31:13,060 --> 00:31:21,520
So in this example, I, I'm creating a subset of people, you know, those with IDs three, four or five.

219
00:31:21,530 --> 00:31:33,260
So I just want to create a. Data set, which contains people with AIDS three or four or five, you just do that with IS in this way.

220
00:31:33,290 --> 00:31:41,170
I can just say that is in the last three, four or five years here this.

221
00:31:41,950 --> 00:31:47,120
This is the data frame that every time we have 80 numbers, three or four or five.

222
00:31:48,260 --> 00:32:02,930
Correct. Okay. So that's so I think that's kind of take a look at the questions about that so that it basically,

223
00:32:02,930 --> 00:32:08,480
I guess concludes the the stuff that's on the quiz on Wednesday.

224
00:32:09,380 --> 00:32:13,280
So everything after this is not basically nothing on the quiz.

225
00:32:15,320 --> 00:32:25,550
So I think some of the graphing stuff will probably be useful for the final assignment and the way to know it for the quiz.

226
00:32:32,740 --> 00:32:39,010
Lisa. The next topic is reshaping data frames. I just mentioned the basic commands and there's.

227
00:32:46,000 --> 00:32:54,280
It's kind of complicated, this reshaping, depending on exactly how many variables are reshaping and exactly how you're doing it.

228
00:32:54,910 --> 00:32:58,060
There's even this command pivot table, which I'm not going to talk about.

229
00:32:58,730 --> 00:33:02,380
Well, I'll just do like a little bit an introduction.

230
00:33:03,010 --> 00:33:05,440
So I guess I'm talking about Tiffin Belt.

231
00:33:06,580 --> 00:33:17,650
So at least you kind of know how to get started if you ever need to know how to do the do this type of reshaping of updated data frames.

232
00:33:19,150 --> 00:33:22,170
So let's look at the bone data set again.

233
00:33:22,180 --> 00:33:32,170
So this is basically at least the way the way it's stored is kind of an example of often called repeated measures.

234
00:33:32,950 --> 00:33:46,120
Basically in this setting, that that just means that we have kind of multiple multiple observations or multiple rows for the same person, basically.

235
00:33:47,370 --> 00:33:52,059
So calling each row is like a different observation.

236
00:33:52,060 --> 00:33:56,980
So we have multiple observations for the same person.

237
00:33:56,980 --> 00:34:00,610
So it's sometimes called repeated measures data.

238
00:34:02,800 --> 00:34:13,810
So this is one way to store this type of data. So you have or you have like one person that has a bunch of visits to the hospital, for example,

239
00:34:13,840 --> 00:34:20,470
you can have a separate row for each visit and then you just repeat the item number multiple times.

240
00:34:21,100 --> 00:34:24,870
That's definitely one way to store it there.

241
00:34:25,270 --> 00:34:33,390
The other kind of way, a main way to store it is kind of more of horizontally where you would have one row for each person.

242
00:34:33,440 --> 00:34:42,809
You kind of stacking the the information from each visit horizontally and then extra columns.

243
00:34:42,810 --> 00:34:46,660
So that's kind of another another way to store the data.

244
00:34:47,290 --> 00:35:00,730
The data set that you might see kind of depends on what you're doing, know which way to store it,

245
00:35:01,180 --> 00:35:06,380
kind of depends on what you're doing or who you're working with or something like that.

246
00:35:06,400 --> 00:35:10,270
But you often see both in both formats.

247
00:35:10,840 --> 00:35:20,740
So the original data, kind of the way this is stored, is often called tall or long format,

248
00:35:21,640 --> 00:35:25,780
often single words, and sometimes it's made in second stacked format.

249
00:35:26,410 --> 00:35:34,120
So that's kind of this format where we have a separate row for kind of like each observation of the person,

250
00:35:34,900 --> 00:35:41,530
you know, an alternative way of storing this is like this, this wide format.

251
00:35:42,160 --> 00:35:47,730
So something like this probably had one row for each separate ID,

252
00:35:48,550 --> 00:35:55,330
so you store it like this and then we kind of have multiple columns for that span BMD variable.

253
00:35:55,480 --> 00:36:02,020
This is like you spend BMD at the first visit, SBN being on the second visit, etc., etc.

254
00:36:02,090 --> 00:36:05,950
This is like age at the first visit. Age and the second visit.

255
00:36:06,280 --> 00:36:14,040
The third visit. So that's just an alternative way of storing pretty much the same data.

256
00:36:15,060 --> 00:36:26,730
So if you wanted to convert kind of the original stolen data frame to lower light format, you're basically going to create new variables.

257
00:36:27,660 --> 00:36:31,950
So the new variables you're going to have to create is,

258
00:36:34,350 --> 00:36:42,389
are the new variables that you have to create are s probably 1 to 2 as part of the

259
00:36:42,390 --> 00:36:49,290
MDR three and then age one age to age three to create those two new variables.

260
00:36:53,430 --> 00:36:58,830
Okay. So at least one way to do it is the following.

261
00:37:05,510 --> 00:37:09,070
So I first created this extra variable called Arms Numb.

262
00:37:11,240 --> 00:37:19,280
That's basically the observation number for that. So that arms numbers are really like this in numbers is like visit one, visit to visit three.

263
00:37:23,870 --> 00:37:30,470
You don't necessarily have to do it this way, but you have to have something that changes and isn't it.

264
00:37:31,040 --> 00:37:39,860
And this is going to be like a part of the column name in the transformed in then when we transform the data into wider format.

265
00:37:40,370 --> 00:37:44,290
So the vertical part of the new variable name.

266
00:37:44,300 --> 00:37:52,850
So if we want to kind of different variable names, you might want to label this differently.

267
00:37:52,850 --> 00:38:03,950
But if you want to label it like one, two, three, you want to do something like this, we need separate observation number for each visit.

268
00:38:09,290 --> 00:38:13,819
Okay. So once we actually added that extra column, now we can use the pivot method.

269
00:38:13,820 --> 00:38:21,260
So the pivot the pivot method is really kind of the main way for converting from long to wide format.

270
00:38:25,640 --> 00:38:29,750
So the main arguments are the index and the column arguments.

271
00:38:29,750 --> 00:38:39,350
There are a bunch of other arguments, but it's just and you can use that if you just want to if you kind of the only thing

272
00:38:39,350 --> 00:38:44,930
that you need to use to be able to use it is the index in the columns already.

273
00:38:46,700 --> 00:38:56,180
So the index is the name of the variable that kind of contains the unique individual identifier.

274
00:38:58,040 --> 00:38:59,630
So in this case, it's ideal.

275
00:39:02,270 --> 00:39:13,339
So that that would be the case if you have kind of long format where we're looking at data from individuals, but it could be something else.

276
00:39:13,340 --> 00:39:24,650
Like if we have data from countries where we have multiple observations in a country over time, the index or the country name.

277
00:39:25,490 --> 00:39:30,260
But if we're looking for a data set, can you give people an ID number?

278
00:39:30,710 --> 00:39:39,230
You want the index to be reliable and then the columns, basically,

279
00:39:39,230 --> 00:39:45,950
that's the variable name that depends kind of the ordering of the columns if you want to convert to wide format.

280
00:39:45,950 --> 00:39:51,410
So that's all that's saying is like this observation, we have jobs now.

281
00:39:52,880 --> 00:40:02,620
This is going to be linked to the first column and then this will be in the second column of the engine and 13.75 will be in the third column each.

282
00:40:05,590 --> 00:40:10,150
So that's kind of what the car loans argument is telling us.

283
00:40:11,080 --> 00:40:14,170
So this is, you know, this, yeah, I just run this.

284
00:40:14,170 --> 00:40:18,700
So I have run down that pivot and I give it those two arguments.

285
00:40:19,840 --> 00:40:25,030
It kind of returns a data frame here. I'm calling it bona fide, sort of bone wide.

286
00:40:25,150 --> 00:40:28,600
Now it has a bone.

287
00:40:28,600 --> 00:40:32,980
Why has 261 rows. So that should be expected.

288
00:40:34,030 --> 00:40:44,530
The wide format, the number of rows should equal the number of individuals in the dataset, since each row corresponds to a different person.

289
00:40:45,310 --> 00:40:49,900
So we should have 261 rows and we now have nine columns.

290
00:40:50,020 --> 00:40:54,130
So originally we had four. So now there's nine in the one.

291
00:40:57,540 --> 00:41:02,549
Okay. So. So here I am. Just print it out the at least part of it.

292
00:41:02,550 --> 00:41:09,990
So I turned it off the first five rows and I print out the first eight columns so that it fits on the slide basically.

293
00:41:09,990 --> 00:41:11,550
So I cut off the last column.

294
00:41:12,330 --> 00:41:25,890
So remember that this is a reminder from last lecture if you want to do this kind of access elements from an array of some elements from a data frame,

295
00:41:28,140 --> 00:41:33,840
kind of in the same way you would access elements from A to the nothing array or at

296
00:41:33,840 --> 00:41:41,010
least where you're explicitly explicitly giving it both a row and column indices.

297
00:41:41,010 --> 00:41:52,589
Use this that I look at so if you've got I love you can find a tree accessing components of a pandas data frame in the same

298
00:41:52,590 --> 00:42:00,900
way that you would do a we have to be B array we just done that here and kind of putting out the first five rows and columns.

299
00:42:01,350 --> 00:42:02,669
Okay. So that's what it looks like.

300
00:42:02,670 --> 00:42:16,740
So the others, we can kind of we can probably trim this, this gender variable later since we said this, data centers change over time.

301
00:42:23,570 --> 00:42:34,150
There's a way to do it, but not directly with just index and columns, but the age variables and as PubMed variables, these change over time.

302
00:42:34,160 --> 00:42:41,389
So here's the first. So we have age one age to an age three.

303
00:42:41,390 --> 00:42:45,110
So these are all separate columns and they wide format.

304
00:42:45,110 --> 00:42:51,590
And then we also have espnW BMD, Vonn, espnW BMD two, etc., etc.

305
00:42:54,340 --> 00:42:59,140
So this is just cut off the last column and the last column is not shown here.

306
00:43:03,920 --> 00:43:07,290
Right, Sue? Okay.

307
00:43:07,300 --> 00:43:12,050
So one thing. Yeah, it does print out the I.D. numbers.

308
00:43:12,490 --> 00:43:18,970
Actually, up here, it does print out the I.D. number where these are technically like the row names of the dataframe.

309
00:43:21,640 --> 00:43:34,870
So this is actually not a variable. So if you wanted to access if you wanted to try to access the variable here, the ID num variable from bond y,

310
00:43:34,900 --> 00:43:41,620
you could not like access that you could not access the I.D. number as a separate variable.

311
00:43:42,550 --> 00:43:52,210
So sometimes you don't want that if you want to keep the kind of the ID as a variable.

312
00:43:57,530 --> 00:44:01,950
Oh, yeah. You just have to. Yeah, I. Yeah.

313
00:44:02,300 --> 00:44:05,480
You have to use this reset dye reset index method.

314
00:44:06,310 --> 00:44:17,510
That's going to do that. So you can just you can just do it after actually after you've originally created this wide data set.

315
00:44:17,510 --> 00:44:23,990
If you just run reset index, it'll kind of put the index back in here.

316
00:44:24,650 --> 00:44:36,320
You have to use in place equals true if you want to kind of use that to I guess modify bone wide without returning a separate data frame.

317
00:44:37,070 --> 00:44:41,810
So it's kind of the same logic when we did sorting if I look in place equals true

318
00:44:42,380 --> 00:44:50,780
like kind of when we run this single line of code that modifies bone by itself,

319
00:44:50,780 --> 00:44:54,880
it doesn't like return a separate data frame separate from bone line.

320
00:44:54,950 --> 00:44:58,340
So that's why we have this in place equals true argument.

321
00:45:00,110 --> 00:45:08,330
Okay, so here I'll just print out the first five rows and first eight columns.

322
00:45:08,960 --> 00:45:14,900
So now this would actually have ten columns. So we have two extra spin BMD values in here.

323
00:45:18,380 --> 00:45:24,140
We have a column for hiding number. So this is just something to keep in mind.

324
00:45:24,140 --> 00:45:32,840
If you notice that it deleted your ID numbers on column, oh,

325
00:45:32,860 --> 00:45:47,960
you just make sure that before the number is the number of rows in the y dataframe should equal kind of the number of unique values,

326
00:45:48,800 --> 00:45:56,210
number of unique tiny values. So this is actually another way that there's multiple ways to find out the number of unique values.

327
00:45:58,730 --> 00:46:02,120
So if you just do not unique I don't know if we talked about this.

328
00:46:02,630 --> 00:46:10,790
We when we talked about. Discussing not being able to find a number to return.

329
00:46:11,290 --> 00:46:15,800
The unique values from a numpy array can just do import unique.

330
00:46:16,590 --> 00:46:20,180
So this also return kind of the collection of unique values.

331
00:46:20,180 --> 00:46:24,100
So if I look at the length of that, I should also give this to 61.

332
00:46:24,140 --> 00:46:33,890
So that's kind of this that's just an alternative way to find the number of unique values in a given array.

333
00:46:35,120 --> 00:46:39,650
So. Okay.

334
00:46:39,820 --> 00:46:48,370
So if you want to do a specific if you only want to reshape like a specific parameter, a specific variable,

335
00:46:48,970 --> 00:46:56,980
or you could even do a specific collection of variables, you can give it this values argument.

336
00:46:58,930 --> 00:47:05,589
Like here in the previous example, we kind of we converted kind of all of the variables in our data frame.

337
00:47:05,590 --> 00:47:16,570
We converted all of them into Y format. But if you just want to create a data frame in wide format where we only include the CPM, BMD values,

338
00:47:17,140 --> 00:47:22,900
how you can do it this way if I just include this extra argument values equals ESPN BMD.

339
00:47:23,350 --> 00:47:31,150
So this will create a data frame where we only have ESP and BMD.

340
00:47:32,470 --> 00:47:47,000
So these are the ESPN values. Here in these columns, the first one, second one there, and then here again.

341
00:47:47,640 --> 00:47:57,710
I've kept the idea early. So these are all just SPV values for the first visit, second visit, third visit of.

342
00:48:00,640 --> 00:48:10,370
The last thing I just wanted to mention was the. Now going back from, I guess, wired to how long?

343
00:48:11,030 --> 00:48:23,690
I think it's slightly easier. So in that case, I think about this, at least to me, it's easier to understand what's going on.

344
00:48:24,650 --> 00:48:32,690
So to convert to wide from wide format to back to long format, we can use melt and here.

345
00:48:36,610 --> 00:48:39,700
Well, at least if you have. Like I said, as long as you are.

346
00:48:44,000 --> 00:48:50,420
Yes. As long as your columns are labeled reasonably, it's fairly, fairly straightforward.

347
00:48:51,740 --> 00:48:55,130
But to use melody, you could just give it the name of the data frame.

348
00:48:55,610 --> 00:49:05,570
And then the, the I, the, the name of the variable, which kind of identifies the ID which which identifies the ID.

349
00:49:06,620 --> 00:49:15,710
Okay. And then it will just kind of automatically convert it like, oh, I see what happened.

350
00:49:22,680 --> 00:49:29,850
Yeah, it did convert it into like long format and just convert it back into a long format.

351
00:49:30,300 --> 00:49:34,050
It's no longer sorted by ID number. Okay.

352
00:49:34,740 --> 00:49:37,799
So it's sorted by something else. Exactly.

353
00:49:37,800 --> 00:49:47,760
And it's sorted. But if you re sorted it by ID, it should be it would show up as one one, one, two, two, two like we had originally.

354
00:49:48,490 --> 00:49:53,040
You can see that it should be a long format because it has a lot more rows.

355
00:49:53,040 --> 00:49:57,450
We now have 783 rows and three columns.

356
00:49:57,750 --> 00:50:05,310
Okay. Okay.

357
00:50:06,360 --> 00:50:09,420
So guess the other thing I'll point out.

358
00:50:10,790 --> 00:50:22,080
You have a bunch of missing values now. So that's something that happened that can happen when we go from, like long to wide and then back again.

359
00:50:22,590 --> 00:50:28,890
So this didn't this didn't originally have a missing values.

360
00:50:30,330 --> 00:50:37,920
I mean, you could check with this originally. The original bone data frame that we loaded in it did not have any missing values.

361
00:50:38,460 --> 00:50:41,820
So why is it have the same values now? So let's see.

362
00:50:43,050 --> 00:50:50,610
So. So the reason for this is that I don't think I printed it out.

363
00:50:50,610 --> 00:51:05,250
I should have print it out, like further down. The reason for this is that not every person has a shortcoming, right?

364
00:51:06,360 --> 00:51:12,450
Yeah. So not every person has. They're all three visits are actually a lot of people don't have all three visits.

365
00:51:12,450 --> 00:51:17,550
They only have two visits or sometimes even one visit always for a few people.

366
00:51:17,970 --> 00:51:25,710
So if I like further down the data set, so I like the first like 100 people or so they have,

367
00:51:26,370 --> 00:51:29,880
they have all three visits, but kind of a further down of the data set.

368
00:51:30,780 --> 00:51:37,500
A lot of them only have to one or two visits. So I show that here, if we print it out kind of further down the dataset.

369
00:51:38,610 --> 00:51:43,589
These only have like two observations.

370
00:51:43,590 --> 00:51:52,920
So like a person with ID 278 and only have two business observation one and two.

371
00:51:56,460 --> 00:52:04,800
So when you do this conversion into wide format, so what happens to somebody if they don't have all three visits?

372
00:52:04,800 --> 00:52:08,430
So let's say they just had two the first two visits,

373
00:52:08,940 --> 00:52:14,400
it would just fill in numbers for the first two visits and then they would have a missing value here.

374
00:52:14,910 --> 00:52:20,070
Okay. So if you if we were to turn out kind of the full data,

375
00:52:20,280 --> 00:52:32,339
you would have a lot of people that had kind of missing values to the third this column or even a decent amount this second.

376
00:52:32,340 --> 00:52:41,680
Come on. And then when it converts that to back to long format, it doesn't really it just keeps all kind of the data that we have out here.

377
00:52:41,680 --> 00:52:53,270
It doesn't delete missing entries. So that's kind of why that's why the those missing values kind of reappear when we both reappear,

378
00:52:53,290 --> 00:52:58,319
I guess magically appear when we convert it back to too long for that.

379
00:52:58,320 --> 00:53:07,860
So if we do want to wide and back to too long you can often see missing depending on kind of.

380
00:53:09,890 --> 00:53:17,600
Exactly what your long format looks like. Okay. So that's one penalties in a sense here.

381
00:53:22,280 --> 00:53:27,210
So that was basically the end of. Pandas.

382
00:53:32,880 --> 00:53:40,890
I guess the you know, basically, I you don't have that much time left, maybe like 30 minutes today and then 30 minutes or so on Wednesday,

383
00:53:42,180 --> 00:53:52,170
at least in kind of a little bit of an introduction of how to get started making the graphics, the pipe.

384
00:53:52,290 --> 00:54:00,899
And so people are mostly going to talk about Matlock live that originally wanted to be with the SEABOURNE,

385
00:54:00,900 --> 00:54:07,010
but I think Matlock live is of that the classic library for doing plotting in Python.

386
00:54:07,740 --> 00:54:16,230
I just mentioned some other kind of popular libraries for for for making graphs in Python.

387
00:54:17,430 --> 00:54:19,770
So start out with moth map plotlines.

388
00:54:23,040 --> 00:54:35,580
So that plot live is kind of a it's a library that you can put in data visualization, so you can work with pandas with map plot lines.

389
00:54:35,860 --> 00:54:48,389
It's also nice because you can work with kind of the built in data types if you want to listen to both those problems.

390
00:54:48,390 --> 00:54:53,129
I don't know what I put in here. I, I think it's probably the most widely used.

391
00:54:53,130 --> 00:54:58,800
It's, I guess it's more like the one that's been around the longest as well.

392
00:55:02,690 --> 00:55:11,219
But and then also a lot of the even a lot of the other kind of popular libraries thing they have,

393
00:55:11,220 --> 00:55:14,570
there's a lot of similarities between them and that sort of stuff.

394
00:55:14,580 --> 00:55:22,080
You know how to use that plot line. You can kind of use some of the other kind of popular libraries to write it.

395
00:55:22,080 --> 00:55:30,320
So the typical way to important and not one way that you would see things like the importance map on

396
00:55:30,390 --> 00:55:41,370
anything that pi plots as plotting in this kind of like the usual way of importing on that plot line.

397
00:55:41,850 --> 00:55:55,380
And then since we're doing it as the usual way, we use like many plot line functions, you're going to see like pretty dot something, okay?

398
00:55:57,150 --> 00:56:06,920
When you see plot dots something in Python code, it's usually they're using like the map plot line function or it's pretty librarians using.

399
00:56:06,930 --> 00:56:11,610
I kind of need some type of function from that point. Okay.

400
00:56:11,610 --> 00:56:19,110
So I just thought I'd start out with a, you know, a basic example just to show how to plot something.

401
00:56:19,530 --> 00:56:23,700
So let's just say, well, we want to plot the line Y equals two.

402
00:56:23,700 --> 00:56:26,850
X is kind of a first graph.

403
00:56:28,620 --> 00:56:38,430
So the way you can do that is you could just plot you just plot the coordinates or a collection of coordinates along,

404
00:56:38,750 --> 00:56:51,150
you know, kind of along the line Y equals to X and then you can plot zero, zero, one, two and then two, four, etc.

405
00:56:54,030 --> 00:56:58,380
So you could just give it kind of a collecting of a few points and then it'll kind of,

406
00:56:59,100 --> 00:57:02,910
it'll kind of connect those points with lines is kind of the way it works.

407
00:57:03,630 --> 00:57:07,560
So I've just done that here. I've done that with the to not be erased.

408
00:57:07,560 --> 00:57:10,920
So I've just created this, this X, not the array.

409
00:57:12,690 --> 00:57:21,839
It's just kind of a collection of points from zero one, two, three up to ten and then y is equal to two, two times x.

410
00:57:21,840 --> 00:57:25,680
So it's going to be the points like 0 to 4, etc., etc.

411
00:57:26,190 --> 00:57:37,590
So if I just didn't politics plot if effects those points and it just kind of draws a line through the points and and displays that, that plot.

412
00:57:38,580 --> 00:57:43,020
That's what I like shown here. It's just kind of a line through the points that we give in it.

413
00:57:43,020 --> 00:57:46,890
So this is kind of a line of the graph like this to X.

414
00:57:48,210 --> 00:57:58,460
So the plot function that just kind of works if you just want to create a quick plot for you've just given it kind of an array of,

415
00:57:59,400 --> 00:58:02,690
of, of two collections of points. Okay.

416
00:58:02,730 --> 00:58:09,120
So basically just draws a line through these points like zero lies, 02x in line.

417
00:58:10,170 --> 00:58:21,420
So we have to erase I have kind of in, I guess in this case with the plus one elements and it just kind of draws a line through those points.

418
00:58:22,350 --> 00:58:26,110
So. Oh, yeah.

419
00:58:28,060 --> 00:58:33,010
You can actually just give it a single array as well if you want to.

420
00:58:33,010 --> 00:58:40,350
In that case, it'll just do zero zero and up until like in X in one case.

421
00:58:40,990 --> 00:58:45,510
Okay. So if you just want to plot those Oh.

422
00:58:45,940 --> 00:58:52,930
A line through those points, if you you can do it. If you just give it should kind of like one array.

423
00:58:53,620 --> 00:59:01,180
So if you just give it a single array X and the plot still works and just it's just plotting these things by default.

424
00:59:05,400 --> 00:59:19,040
Okay. So here's just another example. Uh, not as simple as y equals to x, y equals sign of x equals.

425
00:59:20,710 --> 00:59:28,940
Gave it the wrong. Something happened where we did a little funny stuff.

426
00:59:29,840 --> 00:59:34,850
But anyway, this is these are the ones I wanted.

427
00:59:36,920 --> 00:59:40,280
I basically wanted to print not one array.

428
00:59:40,280 --> 00:59:48,710
I wanted to print the points from Ray at square X's going from zero up to two pi.

429
00:59:53,120 --> 00:59:56,590
So in this case, I'm not giving it one array, I'm giving it to array.

430
00:59:56,600 --> 01:00:08,240
So I'm going to give you X is just it's an array of points from zero to up to two pi or APR to pi 6.28.

431
01:00:10,730 --> 01:00:18,770
And it has a like of ten. So these are like equally spaced points from zero up to roughly two pi.

432
01:00:19,370 --> 01:00:28,339
And then I'm going to plot X and Y. So to get it, we have by the side of x you can just use MP dot sign.

433
01:00:28,340 --> 01:00:37,760
So an MP has a sign function that is implemented as you can just take in P that sign and that returns the sign of each element of the brain.

434
01:00:37,940 --> 01:00:45,530
So that's just going to plot lines through the it's basically plotting lines, connecting the dots basically.

435
01:00:46,100 --> 01:00:52,660
So the dots for X and sign of x and you've got one here.

436
01:00:52,680 --> 01:00:59,630
One year on, year on year communication. Another one year, one year, one year, one year.

437
01:01:00,410 --> 01:01:10,160
So basically, just draw the line and draw as a series of straight lines connecting, connecting kind of the points that you're given.

438
01:01:10,280 --> 01:01:19,940
That's basically how a plot works. And that one and I want that one didn't look super nice.

439
01:01:20,540 --> 01:01:23,270
This one's a little bit kind of bulky,

440
01:01:23,480 --> 01:01:31,190
at least compared to like the typical graph graph that you would see if you're plotting Y equals sign of X for those

441
01:01:31,190 --> 01:01:39,590
types of things that I you just do it more points in time x alright for in installs it'll just have a lot shorter lines.

442
01:01:40,640 --> 01:01:43,550
So kind of the overall appearance is a lot more smooth.

443
01:01:45,020 --> 01:01:53,770
So here, yeah, I just if I just give it a X factor that's had a lot more points, so I'd still go from 0 to 6.28.

444
01:01:54,260 --> 01:01:58,549
If you just give it a hundred instead of ten, it should look a lot smoother.

445
01:01:58,550 --> 01:02:08,090
So if I just plot actions and sign of X and y direction, everything kind of looks a lot nicer.

446
01:02:09,900 --> 01:02:15,879
All right. So that's how we can. Yeah, that's just kind of a basic example of how to create plots.

447
01:02:15,880 --> 01:02:21,370
So I think plots are this a useful way, if you want to kind of to.

448
01:02:26,010 --> 01:02:31,710
Two sets of points, and you just want to plot a kind of a curve connecting everything.

449
01:02:32,160 --> 01:02:37,860
You know, plot is kind of a just a quick way to to do that quickly.

450
01:02:39,450 --> 01:02:51,930
Okay. So we have so we have, uh, I think I just,

451
01:02:53,310 --> 01:03:02,160
I did an example basically just to show a lot of extra features of my plot line I thought was just kind of

452
01:03:02,160 --> 01:03:08,700
better just to kind of work through an example and see how to generate a little bit of a nicer looking plot,

453
01:03:08,700 --> 01:03:11,880
or at least or at least a somewhat nice looking plot.

454
01:03:12,460 --> 01:03:17,250
So this is an example where I've learned I'm using this as Y and data set.

455
01:03:17,260 --> 01:03:25,710
So this is also another data set that you can get from this scale and data sets library.

456
01:03:26,640 --> 01:03:34,590
So here you kind of load it in a similar way that you did for the iris data frame, loading it in.

457
01:03:35,070 --> 01:03:39,630
And so y and that should be a pandas data frame. We run this command.

458
01:03:40,290 --> 01:03:43,350
So here I'm just looking at the dimensions of the data.

459
01:03:43,860 --> 01:03:53,159
So this has 178 observations, one 178 rows, and then there's 14 columns.

460
01:03:53,160 --> 01:03:58,110
So at this data set has 14 kind of variables.

461
01:03:59,280 --> 01:04:05,610
All right. So I just wanted to do an example where we create a figure from this data set.

462
01:04:06,600 --> 01:04:16,350
So the figure that I had in mind is going to have like a scatterplot, which basically means we're plotting kind of the data has points.

463
01:04:20,660 --> 01:04:25,100
I'm a two dimensional figure and it's kind of plotting.

464
01:04:26,180 --> 01:04:29,420
The points represent the values of two different variables.

465
01:04:29,990 --> 01:04:36,290
So the plot during is this total phenols and flavonoids.

466
01:04:36,380 --> 01:04:39,670
So these are like two different variables in the wine dataset.

467
01:04:39,710 --> 01:04:50,300
These are just kind of two different features that they record for profit for these two glasses of wine or something like that.

468
01:04:51,200 --> 01:04:57,499
And so also in this figure, the colors of the points should be different for each wine type.

469
01:04:57,500 --> 01:05:04,310
So and this data set, as we'll see in a second, there's like I think there's like three main different wine types.

470
01:05:05,120 --> 01:05:12,590
Okay. So there might be a different kind of pattern for each for each wine type.

471
01:05:13,250 --> 01:05:21,530
So it's sometimes a good way to highlight that is to give us points, a separate color for each for each wine type.

472
01:05:22,770 --> 01:05:26,880
So. Makes things more clear, at least in theory.

473
01:05:27,300 --> 01:05:30,090
If there is a different pattern for each wine types.

474
01:05:30,810 --> 01:05:37,770
A nice way of visualizing that is just giving each of the points of the different wine types a different color.

475
01:05:38,520 --> 01:05:49,110
So we'll also do that. Then I also just want to add a line like a straight line through the through the points, kind of like the best fitting line.

476
01:05:49,110 --> 01:05:58,739
So that just that line just kind of gives us an idea of the relationship between these two variables of it and the slopes upwards of that,

477
01:05:58,740 --> 01:06:04,230
because there's kind of a a positive relationship between phenols and flavonoids.

478
01:06:05,760 --> 01:06:11,820
Okay. So the way I am, though,

479
01:06:12,570 --> 01:06:21,360
I guess one way to create a figure with my plot line is to just first create a

480
01:06:21,360 --> 01:06:30,470
figure like object and then you basically kind of add stuff to the figure as,

481
01:06:30,480 --> 01:06:39,930
as you can separate features to the figure. So the way you do that is to first kind of create a plotting figure object.

482
01:06:40,440 --> 01:06:56,280
So you can do that with I'm just creating a figure object called Fig saying the lady that is just plot that figure open close parentheses and then.

483
01:07:00,470 --> 01:07:12,750
We didn't. You basically add something else or in this case, we're just going to have a single board.

484
01:07:15,170 --> 01:07:21,059
And if you are, maybe we'll talk about it next time.

485
01:07:21,060 --> 01:07:32,040
If you want to have kind of multiple panels in a figure, like if you want to have four panels in a single figure, I'll put different arguments here.

486
01:07:32,060 --> 01:07:35,430
I like to add two of the four. Now everything is one.

487
01:07:35,760 --> 01:07:44,180
We just want kind of a single figure for kind of a single graph on our figure though.

488
01:07:44,370 --> 01:07:47,250
When we add that when we run this dot added subplot,

489
01:07:47,790 --> 01:07:59,760
this kind of empty plot should show up since we kind of haven't told it what to give up all the time.

490
01:08:00,180 --> 01:08:05,820
All this adds up subplot is doing is telling it to kind of generate an empty figure.

491
01:08:06,000 --> 01:08:10,020
Okay, but we're going to keep adding stuff to it.

492
01:08:11,550 --> 01:08:21,660
Okay. So I think well, the first thing okay, so the first thing, so as a default, it kind of does everything from 0 to 1.

493
01:08:22,980 --> 01:08:26,160
So it goes from 0 to 1, lies zero.

494
01:08:27,180 --> 01:08:30,420
That's kind of what it does by default if you don't tell us anything else,

495
01:08:31,230 --> 01:08:35,790
I'm kind of one of the first things you might want to do is to change that the the,

496
01:08:36,030 --> 01:08:43,440
the range of the X in the range of the Y axis so that it kind of matches what your what your data are.

497
01:08:46,080 --> 01:08:52,140
Okay. So at least in this case, we were plotting like like flavonoids and phenols.

498
01:08:53,010 --> 01:09:02,140
So if I want to create the range appropriately, you should look at like the, the range of those variables.

499
01:09:02,150 --> 01:09:06,780
So remember to describe method for a data frame.

500
01:09:07,740 --> 01:09:13,720
And it gives us a summary of numeric variables. If I look at Y that and I only look at kind of the,

501
01:09:14,460 --> 01:09:23,610
the subset of the subset of that data frame that only has the total phenols and flavonoids variables.

502
01:09:24,210 --> 01:09:30,840
That's what this does. I just do the described method that's going to give us kind of a summary of those two variables.

503
01:09:30,900 --> 01:09:43,050
That's what's done here. So if I look at the min in the max, so the minimum of total phenols is 0.98 and the maximum is 3.88.

504
01:09:43,860 --> 01:09:49,170
And then the minimum of total phenols I think is 0.99.

505
01:09:49,590 --> 01:09:58,410
And then the max is 5.08. So I kind of like the range of the X limit and the Y limit to be at least something like that.

506
01:10:00,480 --> 01:10:10,830
So I just did 0 to 5.5 for the x the X limit and then point five at 4.25.

507
01:10:10,830 --> 01:10:15,870
So it's a little bit bigger on either end of each of the variables.

508
01:10:17,370 --> 01:10:27,210
Okay. So it kind of sets up at least the rate at least kind of reasonable X limits for our figure and reasonable Y limits for A here.

509
01:10:30,080 --> 01:10:38,479
Okay. So so this may maybe the next thing you want to do is to actually plot the data itself so you

510
01:10:38,480 --> 01:10:46,400
can plot the data set is just to do kind of the you run the scatter method on the on the figure.

511
01:10:46,610 --> 01:10:53,840
Okay. Okay. So we've called like the figure itself, x x.

512
01:10:53,900 --> 01:11:00,920
So that's kind of the way you have to do it. And then you kind of have to add extra stuff on and on.

513
01:11:00,920 --> 01:11:05,480
The figure you just kind of do x x dot something.

514
01:11:06,240 --> 01:11:15,320
If I just do that scatter, give it to arrays, into arrays of numbers, it'll just do a scatter plot of response.

515
01:11:15,860 --> 01:11:28,060
So this should plot the phenols values of the phenols on the y axis and the values of the flavonoids on the y values of the flavonoids on the x axis.

516
01:11:28,070 --> 01:11:37,110
Okay, this was shown here. This is just a scatterplot case.

517
01:11:37,250 --> 01:11:45,500
So if we want to add that again and they usually want the names of the variables on the axes here,

518
01:11:45,500 --> 01:11:54,200
you know, we have the flavonoids in the y axis, sorry, phenols on the y axis and flavonoids on the x axis.

519
01:11:54,770 --> 01:12:01,819
And these are you just do set x set x label or set while label and it's kind of just give it the name you want.

520
01:12:01,820 --> 01:12:04,940
It quotes, you want to change the font size.

521
01:12:04,940 --> 01:12:08,420
You can use font size if you want to make it bigger or smaller.

522
01:12:08,990 --> 01:12:16,700
That's how you do that. Okay. So the other main thing we wanted to do was like a different color for each type of wine.

523
01:12:19,800 --> 01:12:34,330
So I didn't mention it. But the variable that stores the wine type is wine dot dot wine that targets the target variable that stores the wine type.

524
01:12:34,380 --> 01:12:39,120
So I think that there are three wine types and I think this is just a number.

525
01:12:39,120 --> 01:12:43,150
It stores it as type zero, type one and type two addresses.

526
01:12:43,800 --> 01:12:46,890
It's just a numeric variable. So that's how it is stored.

527
01:12:47,970 --> 01:12:58,580
Way to create a scatterplot where we have a different color for each type is to just use the C argument.

528
01:12:58,590 --> 01:13:07,890
So like we have the argument invite argument for determining how we plot Y versus X to determine the color.

529
01:13:08,280 --> 01:13:20,399
We have a C argument. So a C argument is going to give us a different color for each different number in this array.

530
01:13:20,400 --> 01:13:25,590
So this is actually an array within that target mind that target.

531
01:13:26,070 --> 01:13:34,230
It's an all right. It's the same length as this as flavonoids are phenols, but there's only there's only three unique values here.

532
01:13:34,710 --> 01:13:39,300
So we're only going to have three different colors and it's going to have it.

533
01:13:42,570 --> 01:14:00,510
And the colors should kind of match up with the the corresponding flavonoids and phenols here, just so you can see that here,

534
01:14:00,510 --> 01:14:07,770
if we just do it, this is basically the same code that we had before where I just always been this different.

535
01:14:07,770 --> 01:14:12,150
I've included a C of the C argument C equal find that.

536
01:14:13,350 --> 01:14:17,580
So that'll give us a different color for each wine type.

537
01:14:18,450 --> 01:14:22,379
So there is a way to kind of pick it yourself.

538
01:14:22,380 --> 01:14:31,140
If you look at the documentation, it looks like this is kind of it shows as a default at least for these numbers that we gave it.

539
01:14:33,510 --> 01:14:37,560
So we kind of have to remember if this is zero one or two,

540
01:14:37,740 --> 01:14:46,080
that one of the types is in kind of yellowish color and then this is kind of a greenish color.

541
01:14:46,080 --> 01:14:50,159
And then out here, it's kind of dark purplish color.

542
01:14:50,160 --> 01:14:53,370
Yes. Okay. So we have three different wine types.

543
01:14:53,370 --> 01:15:03,390
So here I can actually see there is there definitely does seem to be a different difference in the distribution for each wine type kind of the

544
01:15:04,050 --> 01:15:13,440
yellow types are kind of concentrated here and the greenish types are in the middle and then that particular types around to the to the top.

545
01:15:13,440 --> 01:15:21,240
Right. Okay. So I think the kind of the plotting by different colors really kind of illustrates that feature.

546
01:15:27,500 --> 01:15:32,580
Okay. So this is just a default that might not be like the colors that you want.

547
01:15:34,620 --> 01:15:46,170
So let's say we wanted to have a red colored four type, zero line, one line, and then a gray color for type two.

548
01:15:47,370 --> 01:15:54,629
So the way you could do that is, well, multiple ways to do it.

549
01:15:54,630 --> 01:15:58,620
But I guess a direct way to do this is just to do a loop, for example,

550
01:15:58,620 --> 01:16:04,530
where we plot a scatterplot of each subtype of line and each time we go inside the loop.

551
01:16:05,310 --> 01:16:09,360
Let's say I have this color list. I'm just colored called list.

552
01:16:09,360 --> 01:16:14,520
This is a a list of names of three colors.

553
01:16:15,030 --> 01:16:18,390
And so I just have a loop here each time I go inside the loop.

554
01:16:19,350 --> 01:16:23,489
I only do a scatterplot for that subtype.

555
01:16:23,490 --> 01:16:29,900
Some type of wine. So for example, the first time we go inside the loop, Luke Cage zero.

556
01:16:30,350 --> 01:16:36,319
So this creates this is just going to generate a scatterplot with only type zero

557
01:16:36,320 --> 01:16:44,020
one and it's going to use that color of zero with the zero with the colorless.

558
01:16:44,030 --> 01:16:55,820
So it'll be red the first time you go inside the loop, friends, it'll generate a little add a scatterplot of points for a type zero line.

559
01:16:56,330 --> 01:17:03,290
They'll all be in red. And the second time we go inside the loop, it'll do the scatterplot of points for the time.

560
01:17:03,290 --> 01:17:10,160
One line and all of those points we will be doing. This is kind of one way of doing what we what we wanted over here.

561
01:17:13,070 --> 01:17:18,200
So, yeah, you can see here, this is actually this is actually what would be plotted.

562
01:17:18,200 --> 01:17:22,430
So we have a gray is type zero with type one.

563
01:17:26,150 --> 01:17:31,010
Type zero is red. This is type zero. This is type one race.

564
01:17:31,010 --> 01:17:38,030
Type two with you know, maybe one other thing.

565
01:17:40,370 --> 01:17:46,040
Probably always I just mentioned these last two last two slides.

566
01:17:46,040 --> 01:17:52,249
So click on the previous example, let the tick labels.

567
01:17:52,250 --> 01:17:59,540
I would say look a little small at least that's not at least in my opinion, I like them slightly larger like this.

568
01:17:59,540 --> 01:18:04,430
One, two, three, four, five. All these up here and this is a little bit bigger.

569
01:18:05,300 --> 01:18:15,080
So the way you can do that is you just set extra labels, set Y in sync label and you change the false.

570
01:18:16,130 --> 01:18:19,190
And here you're telling them what the label should be.

571
01:18:19,790 --> 01:18:27,410
So if I give it the well here, the extra x or y text I'm telling is where the location of the tick should be.

572
01:18:28,070 --> 01:18:31,469
The ticks are just these little tick marks here. I'm telling it should be.

573
01:18:31,470 --> 01:18:36,170
It should be at one one, two, three, four, five on the X label, X-axis.

574
01:18:36,770 --> 01:18:43,770
And here I'm telling it what the labels you want to set, tick labels reset acoustically.

575
01:18:44,150 --> 01:18:50,090
And then if I increase the font size, it kind of makes those particular labels larger.

576
01:18:53,060 --> 01:18:57,139
Yeah, maybe I'll just stop here. But now you can see. You can see here.

577
01:18:57,140 --> 01:19:03,490
And these are a lot greater, particularly a lot bigger in different conditions.

578
01:19:06,170 --> 01:19:14,560
Yeah, I'll just stop there. All right.

579
01:19:17,790 --> 01:19:25,360
Now. I'll just finish up that example next time. But I.

