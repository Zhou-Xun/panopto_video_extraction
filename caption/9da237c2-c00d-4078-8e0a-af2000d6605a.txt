1
00:00:07,510 --> 00:00:15,340
All right. It's 9:00. How's everybody doing today?

2
00:00:17,290 --> 00:00:20,980
Good. Really? Learn some more fast. Yeah. You're all excited for that, right?

3
00:00:23,320 --> 00:00:27,400
All right. No. Why not?

4
00:00:28,720 --> 00:00:36,550
You're going to learn a lot today. You'll learn a lot. All right, so last week, we learned some really good stuff.

5
00:00:36,560 --> 00:00:42,460
We learned how to find means and frequencies and. And create your own formats and things like that.

6
00:00:42,910 --> 00:00:46,870
There was a lot there. Does anyone have any questions before we get started today?

7
00:00:55,160 --> 00:00:58,640
No. All right.

8
00:00:59,150 --> 00:01:14,600
Well, a couple of words about homeworks. Do make sure that you're turning in a copy of your word document with all your answers and your SAS code.

9
00:01:15,230 --> 00:01:19,940
So make sure you're submitting two files every time you submit your homework.

10
00:01:20,600 --> 00:01:25,220
Okay. So please make sure you're attaching your your SAS code as well.

11
00:01:26,150 --> 00:01:34,250
Otherwise. You may forfeit some partial credit that you could get if you had your code there.

12
00:01:35,090 --> 00:01:41,600
Right. Because if if there's some question about, well, maybe maybe this answer works.

13
00:01:41,600 --> 00:01:45,740
But I'm not it's not how we intended for you to do it, but it might work.

14
00:01:46,040 --> 00:01:54,080
But I'm not sure. So our our GSEs might want to run that code to see if it does work.

15
00:01:55,500 --> 00:01:59,790
But if we can't do that, then you might not be able to get the credit for that.

16
00:02:00,300 --> 00:02:04,230
So that makes sense. So make sure you're attaching your sash code as well.

17
00:02:08,520 --> 00:02:17,040
See. We certainly are okay with you working together on those homeworks as well as labs.

18
00:02:17,520 --> 00:02:20,280
But make sure that you're turning in your own copies.

19
00:02:20,790 --> 00:02:28,590
Make sure you're you're doing the work in your own words and make sure your your code is is your own.

20
00:02:28,920 --> 00:02:33,840
Okay, that's all. But you're certainly work you're welcome to work on them together.

21
00:02:36,250 --> 00:02:41,070
Does it make sense? So Homework three is released today.

22
00:02:42,550 --> 00:02:50,110
You have a week from today to finish it. So as usual, it will be due at 9:00 next Friday.

23
00:02:53,540 --> 00:02:57,710
Same as usual. Sound good?

24
00:03:00,920 --> 00:03:06,750
All right. Well, today we got lots more good stuff for you.

25
00:03:12,120 --> 00:03:16,040
And again, I do want to emphasize again that if you're having trouble, we know it's hard.

26
00:03:16,670 --> 00:03:19,760
If you're having trouble leasing out help desk.

27
00:03:20,000 --> 00:03:26,750
We've got office hours. We all hang around class after class, too.

28
00:03:27,260 --> 00:03:32,570
If you just want to ask a quick question, you're welcome to make an appointment with me, if you like.

29
00:03:33,230 --> 00:03:39,320
You can always ask questions by email and things like that to. So lots of opportunities to get help if you need it.

30
00:03:40,270 --> 00:03:51,680
Right. So use that. It's going to be, you know, coding is is something that it takes a little bit to get the hang of.

31
00:03:51,690 --> 00:03:55,770
But after a while, you'll start to to get the idea.

32
00:03:56,130 --> 00:04:03,930
So you just have to keep practicing and it'll come. So one of the things we're going to talk about today is sub setting.

33
00:04:06,310 --> 00:04:09,560
So when I say sub setting, that could mean one of two things.

34
00:04:09,580 --> 00:04:15,280
It could mean, well, I've got this data set and I really only want some of the variables in it.

35
00:04:16,710 --> 00:04:23,540
So I might just want to select some of the variables. I also may just want to select some of the observations.

36
00:04:25,590 --> 00:04:31,230
So we're going to learn how to deal with that today. And we're going to do this by using logic.

37
00:04:32,940 --> 00:04:38,040
Logic can be tricky if you're not used to it. So try not to be like this penguin here.

38
00:04:38,670 --> 00:04:47,880
We want to use some sound logic. Use your partner if, if, if you've got one to make sure the logic makes sense.

39
00:04:50,590 --> 00:04:54,989
And think it through. So our learning objectives.

40
00:04:54,990 --> 00:05:01,950
For this first part, we want to restrict datasets to only some variables using the keep or drop statements.

41
00:05:03,750 --> 00:05:07,620
We also want to be able to rename variables with the rename statement.

42
00:05:09,950 --> 00:05:14,660
We want to understand the importance of how of where we place these statements in our code.

43
00:05:16,740 --> 00:05:21,000
And we'd also like to select certain observations using logical statements.

44
00:05:24,260 --> 00:05:31,810
So first of all, keep and drop. This is when we want all observations, but only some of the variables.

45
00:05:35,660 --> 00:05:40,970
So in this dataset here, in this example, we've got a bunch of variables.

46
00:05:42,440 --> 00:05:50,990
Now suppose I only wanted those first three, the date of birth, the ID number and the stop mens variable there.

47
00:05:52,380 --> 00:05:56,820
Well, in my data step, I could use a keep statement.

48
00:05:58,170 --> 00:06:02,160
And simply list the three variables that I'm on after the keep.

49
00:06:05,000 --> 00:06:11,660
All right. Equivalently, I could drop all the other ones and that would do exactly the same thing.

50
00:06:12,350 --> 00:06:15,710
So I could drop each stop all the way through.

51
00:06:16,580 --> 00:06:19,820
Educator. And I would do the same thing.

52
00:06:22,810 --> 00:06:26,140
A couple of nice tricks. If you've got a bunch of them to list.

53
00:06:27,110 --> 00:06:34,220
If they're in contiguous order, meaning in your dataset, the way they're ordered you can use this double dash.

54
00:06:34,970 --> 00:06:39,980
Indicate all the variables starting from age, stop to education.

55
00:06:41,510 --> 00:06:44,510
Okay. So that'll include all these other ones in between them.

56
00:06:44,690 --> 00:06:46,180
In between those two as well.

57
00:06:48,420 --> 00:06:57,420
If your variables happen to be numbered, like var one, var two or three, var for you can also use a single dash and accomplish the same thing.

58
00:07:00,140 --> 00:07:03,950
But they do have to be numbered like that. For that to work.

59
00:07:06,760 --> 00:07:13,490
Okay. Now, where are you going to put these statements to keep or drop?

60
00:07:14,760 --> 00:07:23,100
Is going to be pretty important. You can actually put them as kind of a sub option in your data statement.

61
00:07:24,720 --> 00:07:29,940
You can put them as a sub option, your set statement, or they can be their own statements.

62
00:07:31,360 --> 00:07:34,870
Within the data step. Okay.

63
00:07:35,620 --> 00:07:40,200
And where you place him is going to change how how they work.

64
00:07:40,210 --> 00:07:44,050
Exactly. So if you put them in the data statement.

65
00:07:45,160 --> 00:07:51,270
Or as their own statement. This is going to subset your data upon writing.

66
00:07:53,050 --> 00:08:00,600
Okay. So when it writes, when it sees the data, it's going to subset at that point.

67
00:08:02,600 --> 00:08:08,810
Where if you put it in the set statement, it's going to subset it upon bringing the data in.

68
00:08:11,970 --> 00:08:19,560
Remember, the set statement is kind of where you're reading in a an existing SAS data file.

69
00:08:19,590 --> 00:08:23,250
Right. So if you put it in that statement,

70
00:08:23,490 --> 00:08:32,100
it's going to subset that incoming data first and then you can manipulate it from there with in the rest of the data step.

71
00:08:34,420 --> 00:08:41,540
So that's the big difference. Upon writing and upon bringing in.

72
00:08:44,600 --> 00:08:49,660
Okay. So what are the implications of this?

73
00:08:51,460 --> 00:08:56,770
Why might that matter? Any ideas?

74
00:09:10,190 --> 00:09:19,650
Someone had an idea. Well, what happens if I drop a variable when I'm reading it in?

75
00:09:22,090 --> 00:09:27,990
But then I wanted to. Create some new variable from that from that old one.

76
00:09:30,180 --> 00:09:33,270
It wouldn't work, right? Because it doesn't exist anymore.

77
00:09:33,280 --> 00:09:39,540
We dropped it. So if you're going to manipulate a variable in some way.

78
00:09:42,290 --> 00:09:47,389
You'd better. You'd better not drop it until you're two.

79
00:09:47,390 --> 00:09:51,050
You're writing your data. Okay.

80
00:09:55,160 --> 00:09:58,440
Is that clear? Yes.

81
00:10:07,960 --> 00:10:14,140
Well, it's permanent, but you could always reread the data back in.

82
00:10:14,680 --> 00:10:19,230
Yeah. Right. Yeah.

83
00:10:19,540 --> 00:10:23,890
Remember, it also depends a lot on how you're naming your new data set, right?

84
00:10:24,370 --> 00:10:29,459
If your data name up there. Is worked out.

85
00:10:29,460 --> 00:10:34,140
It's it's in the permanent or in the in the work the temporary work folder.

86
00:10:34,560 --> 00:10:37,680
But if it's on location, that name, it's going to be saved somewhere permanently.

87
00:10:38,130 --> 00:10:47,310
You can always overwrite that later. But if you drop a variable out, it's going to be dropped out or whatever your your saved version is.

88
00:10:48,800 --> 00:10:53,270
Okay. All right.

89
00:10:55,370 --> 00:11:02,060
So here's another example. So in this one, I'm creating a dataset called BMI.

90
00:11:02,740 --> 00:11:11,980
It's going to live in the work folder and it's starting from an existing SAS data in the work folder called for height weight.

91
00:11:12,100 --> 00:11:18,400
Yes. All right. So in this data step, I'm converting height.

92
00:11:20,130 --> 00:11:25,530
Into hiding meters and converting weight into weight in kilograms.

93
00:11:28,610 --> 00:11:32,570
So this can happen in my data step creating two new variables.

94
00:11:32,750 --> 00:11:40,230
I m and wait cg. And at the bottom here, I'm going to just drop the the original ones.

95
00:11:44,250 --> 00:11:49,370
Okay. So the implication here is. I start with the top.

96
00:11:51,110 --> 00:11:59,020
And I end with this bottom data set here. Okay.

97
00:12:01,420 --> 00:12:09,720
Now what? And so yeah, I could have the drop statement by itself like I did here.

98
00:12:10,500 --> 00:12:16,410
I can also equivalently use the drop in the data statement itself like this.

99
00:12:18,120 --> 00:12:23,140
And that would do the same thing. However.

100
00:12:24,550 --> 00:12:32,460
If I put the drop statement in the sex statement. And then try to manipulate those two variables.

101
00:12:33,550 --> 00:12:43,550
I'd end up with an empty dataset like this. So since height and weight didn't get read in.

102
00:12:46,280 --> 00:12:52,550
SAS is going to see these two math statements here and think you're trying to create four new variables.

103
00:12:54,440 --> 00:13:00,280
Since they didn't exist already. And since it didn't exist before then, it's entirely blank.

104
00:13:00,300 --> 00:13:04,590
So if you multiply blank by some number, it's still going to be blank.

105
00:13:04,720 --> 00:13:08,070
And so you just got this whole big empty nonsense.

106
00:13:10,200 --> 00:13:14,250
So this is why it matters where you put your drop or your keep statements.

107
00:13:16,300 --> 00:13:20,230
Yes, it is always. But they are not in the.

108
00:13:22,490 --> 00:13:27,970
Not in the set's statement, you mean? Yes.

109
00:13:32,280 --> 00:13:37,890
That would be the safer option. Yes, it's the less efficient option, however.

110
00:13:38,610 --> 00:13:44,550
Like so if you if you drop them, if you don't need them, it makes sense to drop them right away.

111
00:13:44,760 --> 00:13:49,690
So then you're not saving a bunch of stuff that you don't need. Does that make sense?

112
00:13:54,670 --> 00:14:13,819
Any other questions about that? So it's making sense. Yes. I think what you're getting at is, is there some kind of conversion function?

113
00:14:13,820 --> 00:14:21,760
Maybe it's. No, there's really not that I can think of.

114
00:14:22,000 --> 00:14:25,989
There may be some functions for certain things, but not something like.

115
00:14:25,990 --> 00:14:32,440
Like this. This conversion. All right.

116
00:14:33,040 --> 00:14:39,670
You just have to. You have to do the math. All right.

117
00:14:42,070 --> 00:14:51,810
Renaming variables works very similarly to keep and drop so you can put them in all three of the same locations as you did Trapper Keeper statements.

118
00:14:53,440 --> 00:14:59,530
And the implications are also the same. So it's going to depend where you put them.

119
00:15:01,980 --> 00:15:04,290
When the variable is renamed.

120
00:15:04,560 --> 00:15:12,360
So it's either going to get renamed upon reading it in, if you do it in the set statement or it's going to rename it upon writing the data,

121
00:15:12,660 --> 00:15:16,440
if you put it in the data statement or as its own standalone statement.

122
00:15:21,030 --> 00:15:26,760
Okay. So that's what I was just saying here.

123
00:15:28,710 --> 00:15:35,250
It's own statement or in the data statement, it's going to rename it when it writes the data.

124
00:15:38,200 --> 00:15:42,330
So what is it really doing? Well. Instead of.

125
00:15:43,930 --> 00:15:50,470
Creating new variables is actually just going to change the name of the variable.

126
00:15:51,560 --> 00:15:58,220
So you can actually accomplish the same thing if you want it by creating new variables and then dropping the old ones.

127
00:15:58,700 --> 00:16:04,880
So that's what this second thing does here. I create a new variable called new, which is the same as old.

128
00:16:05,840 --> 00:16:14,030
Newton, which is the same, is old, too. And then if I drop old in old too, I'll actually accomplish the same thing.

129
00:16:16,890 --> 00:16:20,100
Okay. As renaming it like in the first part there.

130
00:16:25,370 --> 00:16:32,950
However. In the first part if you rename rename with the rename option here.

131
00:16:35,530 --> 00:16:44,540
The variables will be in the same order. If you do it like the second part where you create new variables and then drop the old ones,

132
00:16:45,110 --> 00:16:49,909
your new variables will get tacked on to the end of your dataset, which is generally fine.

133
00:16:49,910 --> 00:16:54,020
It doesn't matter where the variables are located, but if for some reason that matters to you,

134
00:16:54,470 --> 00:16:57,620
then this would be would be a difference between the two.

135
00:16:59,820 --> 00:17:04,800
All right. So key takeaways in that section.

136
00:17:06,890 --> 00:17:10,940
You can restrict your data sets to only some variables you can keep or drop statements.

137
00:17:12,970 --> 00:17:22,340
You can change variable names with rename. If you're adding commands to the data line or in the body of the data,

138
00:17:22,430 --> 00:17:27,620
so it's own statement, this is going to execute the sub setting upon writing the data.

139
00:17:29,290 --> 00:17:35,440
But if you put it in the set statement, it will execute that sub setting when reading in the data.

140
00:17:38,400 --> 00:17:45,060
So that means that the placement can have important implications for manipulating your data in your data step.

141
00:17:49,280 --> 00:17:54,380
Okay. All right.

142
00:17:54,620 --> 00:18:04,070
Well, what if we want to select certain observations? Well, in this case, we're going to use either if or where statements.

143
00:18:05,670 --> 00:18:12,720
We want to understand the timing of the removal of those records. And we're going to want to use logic to select select those records.

144
00:18:16,170 --> 00:18:23,950
So. You can use their logic to either select or delete.

145
00:18:25,530 --> 00:18:36,150
With if or where statements. So if I only wanted certain observations that met some criteria, I can do that without too much trouble.

146
00:18:37,280 --> 00:18:44,270
So let's think about logic here. So suppose I have a data set, which is this crowd of people, right?

147
00:18:44,870 --> 00:18:55,930
It's some football game. Well, the way a computer thinks is in terms of choosing false ones and zeros.

148
00:18:56,510 --> 00:19:06,709
So computers think including SAS. So if I had some statements like Waring Maze, well, that would select everybody.

149
00:19:06,710 --> 00:19:13,900
Waring Maze. Right. If we're looking at these three people, that means Waring Mays It's true.

150
00:19:16,380 --> 00:19:22,560
Wolverines near Wolverines it's true. Spartans, no offense, can sing.

151
00:19:22,560 --> 00:19:26,850
The victory is true. It looks like they're singing. Maybe you're wearing hats.

152
00:19:26,880 --> 00:19:29,970
Yes, true. Are they older than 65?

153
00:19:30,000 --> 00:19:35,630
No, that's false. They look younger than that. And they're certainly younger than 80.

154
00:19:36,200 --> 00:19:42,020
So that's true. So this is kind of how sass is going to think and choose and false.

155
00:19:42,710 --> 00:19:50,640
So if I had a dataset called Crowd. And I wanted to create a subset of Wolverine's.

156
00:19:52,160 --> 00:19:55,190
I might just say if Mays equals one.

157
00:19:58,270 --> 00:20:03,310
So that will select all the observations where maize equals one.

158
00:20:07,750 --> 00:20:12,760
Equivalently I could use where instead of this in this would accomplish the same thing.

159
00:20:15,990 --> 00:20:22,550
Okay. There's subtle differences between if and where, but in general, they will work the same.

160
00:20:24,430 --> 00:20:30,200
We'll talk about those subtle differences momentarily. Because one is true.

161
00:20:31,890 --> 00:20:39,870
In SAS you can also just use if means so I can just leave out the equals one and two now would actually accomplish the same thing.

162
00:20:40,170 --> 00:20:47,910
As long as my variable was coded as one or zero, it will assume ones are true and zeros are false.

163
00:20:49,660 --> 00:20:57,140
Okay. So if Maze would work equivalently. Right.

164
00:20:58,040 --> 00:21:02,420
We can use. Connecting words as well.

165
00:21:03,700 --> 00:21:08,440
So we might say if Mayes equal, one or no song equals one.

166
00:21:08,800 --> 00:21:12,460
So if either of those are true, the observation will be selected.

167
00:21:15,250 --> 00:21:20,180
I could also use and. Between logical statements.

168
00:21:21,110 --> 00:21:25,250
So in the second part where May's equals one and no song equals one.

169
00:21:25,910 --> 00:21:30,320
Both of those things have to be true for the observation to be selected.

170
00:21:34,510 --> 00:21:42,690
Okay. So.

171
00:21:45,310 --> 00:21:50,590
Here's another example where I start with a dataset called Play Whoa!

172
00:21:51,100 --> 00:21:58,350
And I'm creating and these are called men's and I'm subsiding to stop men's equal one.

173
00:21:58,360 --> 00:22:02,350
So if that's true that men's equals one, then it's going to select the data.

174
00:22:02,600 --> 00:22:11,620
It's like the observation. Now, if we did a frequency table on that variable, we'd see that there were 305 ones.

175
00:22:12,720 --> 00:22:17,710
And 59 nos. Or two's.

176
00:22:20,310 --> 00:22:26,370
So if I look at my log, which I should be checking my log every time I run something right, should definitely be doing that.

177
00:22:26,790 --> 00:22:34,440
You'll see that there are 365 observations were read in and now I have 305 observations and three variables.

178
00:22:35,540 --> 00:22:40,270
And that three and or five matches how many we expected. Okay.

179
00:22:41,210 --> 00:22:44,240
So this is a good thing to check. Check your logs.

180
00:22:44,300 --> 00:22:49,090
See if it makes sense. Here's another.

181
00:22:50,650 --> 00:23:02,660
Alternative. So we could say instead of if statement equals one, we could say If that means not equal one, then delete.

182
00:23:07,750 --> 00:23:10,930
And from their log, we can see that it actually accomplishes the same thing.

183
00:23:16,390 --> 00:23:20,700
So if you just have the if. Statment equals one.

184
00:23:21,030 --> 00:23:27,270
It's selecting if that statement's true. But in this case, if the statement is true, then it deletes it.

185
00:23:29,920 --> 00:23:36,620
Right. So you can use these as long as your logic.

186
00:23:36,890 --> 00:23:46,710
Logic is correct. You could use these equivalently. There's lots of other logical operators that you can use and SAS.

187
00:23:48,080 --> 00:23:53,120
So you can use equals, which we've seen already. IQ is just a pseudonym for equals.

188
00:23:53,990 --> 00:24:02,240
So in SAS, you can. You can either use the mathematical symbol or you can use a letter equivalent to it.

189
00:24:03,130 --> 00:24:12,070
So equals our IQ greater than or greater than or equal to or g less than or less than or equal to.

190
00:24:12,070 --> 00:24:15,280
And so on. There's also a not equals.

191
00:24:17,390 --> 00:24:21,090
Or carrot equals would be equivalent or any. That's also excellent.

192
00:24:21,110 --> 00:24:25,270
So all three of those are the same. Okay.

193
00:24:26,740 --> 00:24:30,970
There's also an interesting operator called the Inn Operator, which would.

194
00:24:32,200 --> 00:24:36,070
Look for any of the values in the set that you that you list.

195
00:24:39,310 --> 00:24:47,970
All right. So let's think about some other operators in this one.

196
00:24:49,230 --> 00:24:56,540
We're so upsetting to. Where we're using where statement where stop mens is greater than one.

197
00:24:59,000 --> 00:25:08,510
We look at our. We look at our log here, it says 60 observations where statement is greater than one.

198
00:25:10,460 --> 00:25:14,470
But if you recall. Up here.

199
00:25:15,430 --> 00:25:18,670
We only expected 59 no's, right?

200
00:25:20,620 --> 00:25:30,040
So. So what happened if I just ran stepmom's stepmom's equals to I would get the 59.

201
00:25:32,100 --> 00:25:35,160
So what do you suppose happened here? Why is there one more observation?

202
00:25:36,180 --> 00:25:41,800
With greater than one compared to. Equal to. Yes.

203
00:25:42,080 --> 00:25:51,560
Is there a missing observation? Yeah. There's probably some kind of missing observation, which is coded as something greater than two.

204
00:25:51,590 --> 00:26:02,360
Greater than one. Right. So in in Heinz, a lot you'll see a lot of seven sevens or nine, nine, nine, nine, nine and so on as the missing code.

205
00:26:03,810 --> 00:26:08,970
That's probably what happened here. And if we were to run a product freak on that variable.

206
00:26:09,360 --> 00:26:12,530
Oh, yeah, there was a nine. That showed up here.

207
00:26:13,130 --> 00:26:18,620
And if we checked our codebook, that would be the coded value for missing.

208
00:26:21,280 --> 00:26:25,740
So again, your code book is very important. You need to know what that name means.

209
00:26:28,550 --> 00:26:28,880
Okay.

210
00:26:29,970 --> 00:26:37,800
So you need to really use caution when you're using greater than or less than a particular lesson, which we'll see an example of here in a minute.

211
00:26:39,350 --> 00:26:44,690
Because the normal sass missing, which is a dot a period.

212
00:26:46,990 --> 00:26:51,430
SAS. Thinks of that as minus infinity.

213
00:26:54,180 --> 00:26:57,810
So if you use less than without a lower bound.

214
00:27:00,000 --> 00:27:04,620
Any of those dots, those missing are going to be included in there.

215
00:27:07,690 --> 00:27:11,130
Maybe you want that, but probably not. Okay.

216
00:27:11,400 --> 00:27:16,530
So you need to be very careful with lesson and greater than as we saw in the last example.

217
00:27:19,200 --> 00:27:25,380
There's also character logical statements so you can use the N operator.

218
00:27:27,810 --> 00:27:35,120
To list all the values you want. Character values are always in parentheses.

219
00:27:37,230 --> 00:27:43,350
Numeric or not, character values are always in parentheses when you're referring to them in SAS.

220
00:27:43,890 --> 00:27:47,190
Otherwise SAS will think it's a variable name or some other.

221
00:27:48,240 --> 00:27:53,870
Thing. Some other object. Certainly you can use equals with character as well.

222
00:27:54,740 --> 00:27:58,410
You can use this equal colon, which is very interesting.

223
00:27:58,430 --> 00:28:07,130
I mean, starts with. So this this third one, this third bullet equals colon.

224
00:28:07,340 --> 00:28:10,400
M will select all the observations.

225
00:28:12,140 --> 00:28:16,030
Let's start with them. Okay.

226
00:28:18,260 --> 00:28:29,000
You can also use in colon. So that's kind of a combination where you can select anything, starting with Am I or ammo?

227
00:28:33,480 --> 00:28:38,460
There's also an equal star operator, which is sounds like.

228
00:28:40,110 --> 00:28:44,040
That now one's a little tricky. I'd be a little wary of that one.

229
00:28:44,580 --> 00:28:53,520
I'm not exactly sure how the sass logic works there. You could test it out and see what happens, but I'd be a little cautious with that one.

230
00:28:55,040 --> 00:28:58,800
But theoretically it could work. Okay.

231
00:29:00,340 --> 00:29:03,590
And you can see if I did this. It would select.

232
00:29:06,350 --> 00:29:10,340
In this case, I'm using the in-app reader in Washington, Oregon.

233
00:29:10,610 --> 00:29:14,690
Just going to select the two observations with those state names.

234
00:29:20,290 --> 00:29:26,510
That makes sense. All right.

235
00:29:29,160 --> 00:29:38,760
If statements can also be used for outputting. So. Here's an interesting example where I'm using a data step to actually create two.

236
00:29:40,710 --> 00:29:49,240
Data sets at the same time. So I start with my data statement, which has men's and no men's.

237
00:29:49,720 --> 00:29:57,030
So that's two data. Data sets that I'm creating.

238
00:29:59,140 --> 00:30:03,790
And I'm starting with the original Play-Doh set.

239
00:30:04,950 --> 00:30:12,480
And here I'm using. If statement equals one, then output two no names.

240
00:30:13,770 --> 00:30:26,860
And if stamina equals to an output to men's. And what we'll see from our log is that it created a dataset called Menz in the work folder.

241
00:30:27,830 --> 00:30:33,290
Which has 59 observations that we expect and no man has 305, which we expect.

242
00:30:35,030 --> 00:30:40,210
I can create both at once. Nice and efficient.

243
00:30:41,530 --> 00:30:44,830
Of course, you could have used two separate data steps if you wanted.

244
00:30:45,010 --> 00:30:51,550
That would have been fine. This is kind of a slightly more efficient way to to create those things, if you want.

245
00:30:55,720 --> 00:30:58,970
All right. A note here.

246
00:30:59,350 --> 00:31:03,190
The output statement takes effect at the point in the data step where it's placed.

247
00:31:03,910 --> 00:31:12,040
So what I mean by that is the way SAS executes things is line by line, observation by observation.

248
00:31:14,460 --> 00:31:22,410
So. It's going to try to execute this first if statement first and observation one.

249
00:31:23,610 --> 00:31:27,780
Right. And then line two and observation one.

250
00:31:28,500 --> 00:31:33,740
And then it. Outputs observation one, the new one.

251
00:31:34,340 --> 00:31:38,210
Right. And then it'll go to the next observation and do the same thing.

252
00:31:39,400 --> 00:31:47,400
Okay. So that's kind of. Could potentially make a difference and how you order your your code.

253
00:31:48,310 --> 00:31:51,880
So it's just something to keep in mind that this is the way Sass executes things.

254
00:31:53,700 --> 00:32:03,890
Usually it's not that that important. Now I promise that we talk about the difference between if and where.

255
00:32:05,610 --> 00:32:12,189
Where happens at the opening of a data set. So if you use where?

256
00:32:12,190 --> 00:32:16,250
Here. Two subset statements.

257
00:32:16,710 --> 00:32:22,910
Less than two. And I checked my log.

258
00:32:24,450 --> 00:32:29,790
I'll see that there are 305 observations read from the data set.

259
00:32:32,850 --> 00:32:36,840
And 305 observations in the new men's dataset.

260
00:32:39,730 --> 00:32:42,910
So from that, you can kind of see that.

261
00:32:44,380 --> 00:32:52,720
If you use where. It's unique in that it actually does that upsetting as it's reading in the data.

262
00:32:54,920 --> 00:33:00,690
Whereas if you use if. Sort of an example here.

263
00:33:00,690 --> 00:33:05,580
But if you use if it's going to subset on the rating.

264
00:33:06,680 --> 00:33:10,830
Of the data. Okay.

265
00:33:14,800 --> 00:33:24,970
So that very much like the position of the drop and keep this might matter if you're trying to manipulate a particular variable right.

266
00:33:27,480 --> 00:33:35,490
So if you have to, which would you have to use then if you were trying to subset a variable that was newly created?

267
00:33:47,700 --> 00:33:54,210
It's got to exist to be able to manipulate it. Right. So that means you're going to have to use it.

268
00:33:56,760 --> 00:34:02,590
If you use where. You've already subsided upon reading in that data.

269
00:34:03,190 --> 00:34:10,000
And so you won't be able to to manipulate manipulate anything that you subset it out.

270
00:34:12,520 --> 00:34:16,490
Okay. Right.

271
00:34:18,720 --> 00:34:25,670
You can also subset for procedures. But if you're going to subset for a procedure, you do have to have to use where?

272
00:34:27,710 --> 00:34:34,650
So in this example, we're doing a proc means. And we're using aware age greater than 50.

273
00:34:36,180 --> 00:34:46,600
So this is going to run the. The default statistics that broadening usually does for the variable systolic BP.

274
00:34:47,820 --> 00:34:55,270
But it's only going to do it for everyone greater than 50 years old. Okay.

275
00:34:56,670 --> 00:35:02,240
Does that make sense? If you check your log, it will actually say that.

276
00:35:06,150 --> 00:35:12,990
There is only so many observations in that that were read in and it will give you the number that were greater than 50.

277
00:35:14,630 --> 00:35:19,090
Okay. So this is nice.

278
00:35:19,540 --> 00:35:25,660
If you're you don't really want to change your dataset, but you want statistics on a certain group of people.

279
00:35:27,770 --> 00:35:33,790
Our particular group of observations. All right.

280
00:35:36,990 --> 00:35:43,260
Key takeaways in this section. We can restrict to only some observations using everywhere.

281
00:35:45,440 --> 00:35:49,700
Our logical statements can help select those variables when conditions are true.

282
00:35:51,820 --> 00:35:58,180
And if statements are executed in the order of the code where statements are executed and the opening of the data.

283
00:36:00,760 --> 00:36:06,630
So that's really the big difference between if and where. In general, though, they will work the same.

284
00:36:08,230 --> 00:36:15,340
In most cases. Now, a couple other interesting things that we can do.

285
00:36:16,910 --> 00:36:24,350
We can remove duplicate records. And we can restrict data that's only first or last observations for repeated measures.

286
00:36:27,740 --> 00:36:34,740
So. A lot of times we do have data which has multiple records per.

287
00:36:35,940 --> 00:36:39,660
Per person. This might be some kind of longitudinal data.

288
00:36:42,890 --> 00:36:49,950
So we may have to deal with that. It might be because.

289
00:36:51,920 --> 00:37:01,340
Informations comes from various sources. It might be that you've got repeated information over time, so it's some kind of longitudinal data.

290
00:37:02,120 --> 00:37:09,530
It might be that the files get merged multiple times. You might have double entry or other mistakes that might happen.

291
00:37:10,650 --> 00:37:16,110
So if you do have duplicates that are undesired, you can just select them.

292
00:37:17,690 --> 00:37:22,880
So proc sword is going to be your friend for this type of situation.

293
00:37:28,820 --> 00:37:35,080
So here's a general, simple example of practice where you invoke the procedure with practice sought.

294
00:37:35,080 --> 00:37:39,350
You tell the data you want to sort and use a buy statement to tell it.

295
00:37:40,730 --> 00:37:43,970
What variable you want to sort. Sorted by.

296
00:37:45,240 --> 00:37:49,980
Okay. So in this case, we're sorting play well play well by wait.

297
00:37:51,610 --> 00:37:57,740
You can see if we were to open up the data set. The observations are all ordered in terms of weight.

298
00:38:00,000 --> 00:38:06,910
It does put the missing as a top. Well, that's because there's things missing minus infinity.

299
00:38:07,580 --> 00:38:15,010
Okay. So those are the smallest. Okay.

300
00:38:17,470 --> 00:38:22,170
So one way to get rid of duplicates. Is to sort them.

301
00:38:23,140 --> 00:38:30,240
And use the no dukey option. This will.

302
00:38:31,670 --> 00:38:38,480
Simply sort them by the variable you you say in the buy statement and select the first one.

303
00:38:40,690 --> 00:38:44,079
With that by with the set of my variables.

304
00:38:44,080 --> 00:38:50,370
I knew that you state there. So if you've got multiple IDs and dates.

305
00:38:51,590 --> 00:38:55,670
It's going to take the first one for each combination of it and.

306
00:39:01,840 --> 00:39:07,960
Okay. So really what that means in this case is they're taking the earliest date.

307
00:39:09,420 --> 00:39:17,170
For each person. You also notice we have an out equals option there.

308
00:39:18,520 --> 00:39:24,190
By default. If you just saw it without that option, it's going to.

309
00:39:25,210 --> 00:39:28,660
Overwrite the original data set.

310
00:39:28,870 --> 00:39:35,770
The ENCODE model writers in this case will get overwritten with a sorted version of itself.

311
00:39:38,670 --> 00:39:45,780
Which may be fine. But if you want to maintain the original sorting, whatever that might have been,

312
00:39:46,590 --> 00:39:50,820
you can use this out equals option to create a new name for it for the sorted version.

313
00:39:56,620 --> 00:40:06,030
Okay. Yeah.

314
00:40:06,120 --> 00:40:09,540
That's exactly what I just said. Right, right here.

315
00:40:09,550 --> 00:40:17,970
So if you don't use that as an option, it's going to overwrite the original with the sorted version where otherwise,

316
00:40:18,270 --> 00:40:22,230
if you do use the article option, it's just going to create a new one with that name that you specify.

317
00:40:24,390 --> 00:40:29,800
All right. Sorting is going to be critical for many procedures.

318
00:40:31,780 --> 00:40:39,190
Any time you use a buy statement in any way in a procedure, you're going to have to sort it by that by variable first.

319
00:40:42,900 --> 00:40:48,210
So in this case where we are interested in running a proc means by statements.

320
00:40:48,390 --> 00:40:57,000
So that really means that we want to break down the statistics that PROC means produces by each level of statements.

321
00:40:57,630 --> 00:41:02,040
Stop means. Okay. So in this case,

322
00:41:02,040 --> 00:41:08,009
you'll see it gives the default stats for statement equals one and then it gives

323
00:41:08,010 --> 00:41:12,750
a nice table for stat men's equals two and it gives one for women's equals nine.

324
00:41:13,720 --> 00:41:18,460
So all levels of SAP means it gives our default stats.

325
00:41:20,200 --> 00:41:23,980
But in order to get that to work in SAS, you would have to sort.

326
00:41:25,000 --> 00:41:32,720
Buy that variable first. Okay.

327
00:41:33,950 --> 00:41:44,950
Now you could have accomplished. The similar set of stats using a class statement which we've seen previously for PRAC means.

328
00:41:45,700 --> 00:41:52,499
And that would work and it would not require sorting. So that makes it a little bit more efficient.

329
00:41:52,500 --> 00:41:56,160
So if you can use a class statement, it makes sense to do so.

330
00:41:56,880 --> 00:42:05,480
There are situations where. You wouldn't want to use that if you really wanted these things separate and you wanted to output them separately.

331
00:42:05,480 --> 00:42:07,490
For example, you would have to do it this way.

332
00:42:07,940 --> 00:42:11,960
But if you're just interested in these numbers, you could get these same numbers with the class statement.

333
00:42:15,150 --> 00:42:21,460
Okay. Ray.

334
00:42:23,100 --> 00:42:27,610
Another interesting thing we can do. A select first and last observations.

335
00:42:31,850 --> 00:42:38,810
This will require sorting again because it's going to use a buy statement this time to buy statements in a data step.

336
00:42:42,840 --> 00:42:49,290
So in this example, we start with, you know, model writers and creating a new baseline.

337
00:42:50,880 --> 00:42:55,280
We've already sorted it by. Subject I.D. and date.

338
00:42:56,880 --> 00:43:03,709
The practice soared above. So we can then do a buy statement in my data.

339
00:43:03,710 --> 00:43:06,780
Step here and buy. Subject ID.

340
00:43:09,840 --> 00:43:17,820
And once I have that statement, I can then use the first stock or the last that operators on that variable.

341
00:43:21,380 --> 00:43:26,260
So if I said for if first that. Subject ID equals one.

342
00:43:29,530 --> 00:43:38,430
Then it's going to select. All the first observations for each person.

343
00:43:44,150 --> 00:43:50,020
Okay. I could also use last that subject ID.

344
00:43:51,390 --> 00:43:55,800
So if I said if last, that subject would select the last observation.

345
00:43:57,510 --> 00:44:02,250
Four for each person. So just use that.

346
00:44:05,880 --> 00:44:10,200
Right. So, yeah, you're not creating any variables here in this case.

347
00:44:10,200 --> 00:44:13,440
You're just selecting certain observations, either the first.

348
00:44:14,670 --> 00:44:20,320
Or the last one. Could you do the second one?

349
00:44:23,420 --> 00:44:26,750
Sure you could, but not not not with these operators.

350
00:44:30,400 --> 00:44:35,060
You could. Well, you'd have to get a little creative there.

351
00:44:35,080 --> 00:44:40,720
You might delete the first observation first and then use this for that operator.

352
00:44:42,300 --> 00:44:46,630
Right? Something like that. Might take you a couple days of steps to do it.

353
00:44:47,080 --> 00:44:52,740
Yes. We use the power for use as well. Could use out.

354
00:44:53,270 --> 00:44:57,150
Yeah, a great. Um.

355
00:45:02,870 --> 00:45:07,190
In your well. Where do you want to put that out?

356
00:45:11,780 --> 00:45:16,720
Would it be all right? So remember.

357
00:45:16,960 --> 00:45:22,720
So out is an option which is going to create a new dataset for, for a procedure basically.

358
00:45:23,170 --> 00:45:30,430
So like proxy sort if you use out equals in the proxy sort is going to create a new dataset with the sorted version.

359
00:45:31,280 --> 00:45:35,390
But a data step is creating a data set in itself.

360
00:45:35,570 --> 00:45:39,800
That's what a data step does. Right. So it's creating a data dataset.

361
00:45:40,280 --> 00:45:46,430
It's called baseline. So that kind of takes the place of of the out, I think that you're thinking of.

362
00:45:47,680 --> 00:45:53,890
So you're. So your your logic is all happening in that data step.

363
00:45:55,070 --> 00:46:00,140
And you're out putting in a new day to set of baseline in this case.

364
00:46:02,990 --> 00:46:11,610
Okay. Any other questions on this?

365
00:46:11,940 --> 00:46:16,950
Yes. If there's a time.

366
00:46:18,450 --> 00:46:23,439
Um. There's a tie.

367
00:46:23,440 --> 00:46:33,910
So let's think about that. If if this first observation that's highlighted there, if there was another one for that person on the same date.

368
00:46:37,540 --> 00:46:41,230
It's just going to select whichever one happens to show up first when it sort.

369
00:46:44,060 --> 00:46:52,490
If it's a different date. Well then it's where sorting remember by subject idea and date.

370
00:46:53,450 --> 00:46:58,970
Right. So if all the dates are different like they are here, it's going to select the first.

371
00:47:00,620 --> 00:47:05,020
The first one. So the earliest date in this case. Yeah.

372
00:47:05,830 --> 00:47:10,110
If there happens to be more than one with the same date. Well, then.

373
00:47:12,200 --> 00:47:15,080
Whichever one happened to be at the top is the one that's going to choose.

374
00:47:15,890 --> 00:47:19,790
Now that which one's at the top is going to depend on how it was ordered in the original data set.

375
00:47:22,870 --> 00:47:29,230
So if you needed to distinguish those two, somehow, you probably have to look at some other third name.

376
00:47:30,500 --> 00:47:36,620
Maybe a time. If there was a timestamp, you could sort it by ID date and time.

377
00:47:37,980 --> 00:47:41,440
First. Okay.

378
00:47:46,030 --> 00:47:52,780
And the other questions. All right.

379
00:47:52,880 --> 00:47:58,980
So the key takeaways. Source available valuable for removing duplicate records and.

380
00:48:00,880 --> 00:48:09,880
You must first identify which variables are not to be repeated. Practice is useful before processing data with bi statements and then.

381
00:48:13,860 --> 00:48:22,050
And you can use the first and last observation, the first and last operators to select observations for the first and last.

382
00:48:24,780 --> 00:48:33,099
Observations for each person. Okay. Right now.

383
00:48:33,100 --> 00:48:37,120
Questions? All right.

384
00:48:37,120 --> 00:48:45,670
Well, good luck on your lab today. I think you'll have have fun figuring out the stuff here.

