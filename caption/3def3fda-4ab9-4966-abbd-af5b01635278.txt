1
00:00:00,960 --> 00:00:19,830
I think this you know, it's going to be Star Trek, which is the homework, you know, tomorrow morning.

2
00:00:20,820 --> 00:00:25,149
The quiz was a while ago. British quiz posted a while ago.

3
00:00:25,150 --> 00:00:28,920
And that's when I was the second one.

4
00:00:29,970 --> 00:00:41,400
Let's do this is next. So next week, probably the third homework of the whole data options should be posting that very soon.

5
00:00:42,060 --> 00:00:46,360
Three. If you.

6
00:00:50,870 --> 00:01:02,260
Now hopefully that's clear. Answer some questions about the [INAUDIBLE] or it's slow motion.

7
00:01:02,330 --> 00:01:10,270
That's basically a reminder of the things that are due to the perception that are coming.

8
00:01:10,850 --> 00:01:16,210
So I guess today, basically a lot of the references and pointers, I guess we're doing it.

9
00:01:16,680 --> 00:01:28,700
So that's the first main topic I guess we're doing and we're doing the related topics, talking well, calling by reference versus calling by value.

10
00:01:28,700 --> 00:01:32,210
So there's we use a function, C++,

11
00:01:32,980 --> 00:01:47,480
which kind of the distinction between calling by a value versus calling by reference and we'll talk about how to do it and when it's useful.

12
00:01:48,350 --> 00:01:56,450
So I guess a reference or a reference variable is something called alias, which is just basically an alternative.

13
00:01:57,290 --> 00:02:01,160
Some subsets, it's just an alternative demand for the same at the same thing.

14
00:02:02,240 --> 00:02:08,300
So it's just an alternative alternative name for an already existing variable,

15
00:02:09,050 --> 00:02:19,970
which just if you think of a variable name is like a label label that you use that kind of corresponds to a particular location in memory

16
00:02:19,970 --> 00:02:30,890
that stores something that's kind of a reference variable is just not another label that refers to the same kind of location of memory.

17
00:02:35,320 --> 00:02:41,750
See, basically we have kind of two different labels that refer to the same location in memory.

18
00:02:42,260 --> 00:02:45,350
That's kind of what you're doing when you're creating a reference variable.

19
00:02:46,280 --> 00:02:51,890
So that's basically the definition of a reference variable.

20
00:02:52,810 --> 00:02:56,330
You know, probably hopefully be more clear.

21
00:02:56,900 --> 00:03:02,820
I only just see a few examples, but I think it's just good to keep the definition in mind of reference variables.

22
00:03:02,910 --> 00:03:06,469
Just is a different name for the same thing almost.

23
00:03:06,470 --> 00:03:11,660
Or at least the same kind of the same memory location at least.

24
00:03:12,320 --> 00:03:18,229
Okay, so this is how you create into our reference variables and C++.

25
00:03:18,230 --> 00:03:30,050
So basically use this the kind of the ampersand and the symbol in front of the, the variable that create that creates a reference variable.

26
00:03:30,740 --> 00:03:38,899
So let's say this is an example of creating an integer variable X and creating a reference for that.

27
00:03:38,900 --> 00:03:45,260
So this creates. So here we're declaring an integer terrible x value two.

28
00:03:46,400 --> 00:03:59,810
And then this is the code you would use to create a reference variable because the reference variable has to refer to something.

29
00:04:03,590 --> 00:04:13,640
So you can't just create a reference variable like ampersand x ref without kind of giving it a variable that it refers to.

30
00:04:15,530 --> 00:04:22,730
So you have to have an E equal to some other has to kind of refer to some other variable.

31
00:04:24,660 --> 00:04:33,820
Okay. So once you've created this, like after this kind of declaration, you can basically treat express as if it were X,

32
00:04:33,830 --> 00:04:42,590
basically when you're doing any type of computation and vice versa and you can treat axes X, Raffy, they're basically interchangeable.

33
00:04:42,590 --> 00:04:46,460
So they're basically just two different names for the exact same thing.

34
00:04:47,280 --> 00:04:51,049
One way that we could see that with this example, you know,

35
00:04:51,050 --> 00:05:08,780
after doing this declaration that we have above this Fernando Valley, they both have the value to express the same value as X.

36
00:05:09,230 --> 00:05:16,040
And then look here on like 99, we, we have the statement X equals four.

37
00:05:16,940 --> 00:05:25,760
And then just by running this, this kind of updates the value of X and X graph both.

38
00:05:26,720 --> 00:05:36,740
All right. So if we print out X and express that both for even though we didn't really I mean, you didn't explicitly change the value of X RAF,

39
00:05:36,760 --> 00:05:44,989
but since we change the value of X, they kind of change the value in that and the memory location of four.

40
00:05:44,990 --> 00:05:49,070
So that that also kind of changes.

41
00:05:49,100 --> 00:05:56,300
The value of x graph since x is really just a name for that, the values stored in that memory location.

42
00:05:57,950 --> 00:06:03,439
That's kind of just a small example just to show that, you know,

43
00:06:03,440 --> 00:06:12,820
when you create a reference for a variable like we have here x ref for x, kind of updating x update the value of X forever or vice versa.

44
00:06:12,830 --> 00:06:17,600
So if we change express, that also changes X at the same time.

45
00:06:19,520 --> 00:06:26,690
Okay. So here's probably a slightly longer example, hopefully to better illustrate these points.

46
00:06:26,700 --> 00:06:31,819
So here we have in this example,

47
00:06:31,820 --> 00:06:40,820
I guess in the first two lines I'm creating and declaring an integer variable I it has the value one and then we're just creating a reference to I.

48
00:06:40,910 --> 00:06:51,920
So we have a reference variable right now refers to I and then I'm also creating a pointer to I remember that's the last time.

49
00:06:51,920 --> 00:07:10,370
So pointer p I so I basically just stores the address of I basically address that store's value one of I so that some pointer has an address value.

50
00:07:11,090 --> 00:07:16,940
So that's what we're doing and kind of the first three lines of main and then what are we doing here.

51
00:07:19,610 --> 00:07:27,290
We're setting VII equals I think we can if I explicitly set this in an earlier lecture

52
00:07:27,290 --> 00:07:33,080
and kind of assume this when you're when you do this type of assignment like say,

53
00:07:33,980 --> 00:07:39,920
VII equals some other variable, you're really creating, creating a copy of.

54
00:07:40,020 --> 00:07:51,169
I mean, it just means there's kind of a separate memory location that's, that's opened up, right?

55
00:07:51,170 --> 00:08:02,660
So. VI so when we run this, there's a V is assigned a kind of a separate memory location that's different than I am.

56
00:08:02,750 --> 00:08:07,490
And then the initial value of VI is going to be one in this case.

57
00:08:08,120 --> 00:08:15,820
So that's all that means it VII gets a new memory location and its initial value is above the value currently stored by.

58
00:08:15,980 --> 00:08:18,980
But these are kind of two separately memory locations.

59
00:08:18,980 --> 00:08:24,320
So if you Update VII, it doesn't affect II and vice versa.

60
00:08:24,320 --> 00:08:27,530
If you update, I mean later on in your code,

61
00:08:27,530 --> 00:08:35,149
it doesn't affect the VI just that's what it's meant by companies are kind of even

62
00:08:35,150 --> 00:08:41,299
though VII will have the initial value that's stored by after this kind of assignment,

63
00:08:41,300 --> 00:08:50,270
these are two separate experiments. Then after that we're just increasing the value by okay.

64
00:08:50,270 --> 00:08:56,839
So that's kind of what's done in this first chunk in main in after hours printing I over also

65
00:08:56,840 --> 00:09:01,850
printing the address of II and then we're turning out our eye and the address of our eyes.

66
00:09:01,850 --> 00:09:11,690
So these well so here's kind of at least for reference variables this is know these two first print statements are the important thing to look at.

67
00:09:11,690 --> 00:09:14,150
They should they should print out the exact same thing.

68
00:09:15,080 --> 00:09:27,860
So, you know, I and I should have the exact same values and they should have the exact same addresses as well, even though we only update it.

69
00:09:27,860 --> 00:09:32,930
I at least you know, we only know at least in terms of writing, not an expression.

70
00:09:33,560 --> 00:09:37,640
The only updated line but that also affects our off of.

71
00:09:39,290 --> 00:09:45,410
And I guess in the last two lines we're putting out the reference point to pie.

72
00:09:45,500 --> 00:09:51,440
So that kind of prints the value at the address stored by PI.

73
00:09:51,530 --> 00:09:58,849
So that should also point out to an API, which is an address.

74
00:09:58,850 --> 00:10:06,380
And then this is the address of the address, I guess, which is which is different than the address stored by API.

75
00:10:07,520 --> 00:10:14,179
And we're turning out, I guess the last line is to show that kind of VI is different than I write

76
00:10:14,180 --> 00:10:20,740
sense VI is like a copy of I kind of when you update I it doesn't affect VI.

77
00:10:20,750 --> 00:10:27,680
So the last print statement should print out one since VI is still one.

78
00:10:28,340 --> 00:10:37,300
We didn't update the value of VI and then the address of the VI, which should be different than I think these two addresses should be the same.

79
00:10:38,060 --> 00:10:51,350
I All right. And then the address of VI should be different than that I and II since it's, it's a copy of I guess that's was shown here.

80
00:10:51,350 --> 00:10:57,860
So you can see in the first two things that are printed out, they're basically doing the exact same thing.

81
00:10:57,860 --> 00:11:10,490
They print out two and the same addresses and then the reference pointer also prints out too, since that's the D referenced value at that address.

82
00:11:11,660 --> 00:11:15,620
So the value at that address has been changed to.

83
00:11:15,620 --> 00:11:24,170
So on the reference ID, you should be too. And then the value of the pointer should be the same as the memory of I and our I.

84
00:11:25,100 --> 00:11:30,049
And then just this last address is like the address of the address.

85
00:11:30,050 --> 00:11:35,629
And since like the address and storage at the stores, the value of the pointer.

86
00:11:35,630 --> 00:11:39,800
And that's that's actually different than the value of the pointer itself.

87
00:11:40,700 --> 00:11:48,440
And then in the last print statement, we can see yesterday for the visit copy, it still has the value one.

88
00:11:48,950 --> 00:11:52,780
And then the address. The address is different than I.

89
00:11:53,270 --> 00:11:57,920
Okay. So the address is different than I and I has a slightly different address.

90
00:11:58,160 --> 00:12:08,810
Okay. So that's what I take for it illustrates the reference is working just illustrates that.

91
00:12:09,890 --> 00:12:21,680
And by default when we do this type of assignment, a copy is created rather than us, rather than it being a case where they refer to the same thing.

92
00:12:24,020 --> 00:12:33,440
Okay. I think this was just I just had a little bit of a breakdown of the steps.

93
00:12:33,470 --> 00:12:39,440
I mean, I think we walked through it a little bit. So I just got through it one more time.

94
00:12:39,440 --> 00:12:43,700
So I guess I'm just walking kind of through the steps of the previous example.

95
00:12:44,090 --> 00:12:48,020
So I guess the first thing we did was we just declared integer variable.

96
00:12:48,020 --> 00:12:56,419
I already know how to do this. And then guess after that we created this a reference variable.

97
00:12:56,420 --> 00:13:04,300
All right. So this is a reference to I basically treats an alias of I, I basically doesn't create, you know,

98
00:13:04,370 --> 00:13:13,180
consume any extra memory space since it's it's just a variable that refers to the same memory location.

99
00:13:13,550 --> 00:13:25,220
So it really just it's really not creating an extra any extra memory space when we do this, this type of creation of a reference variable.

100
00:13:27,000 --> 00:13:32,090
Okay. And then if we then the next thing we did was create a pointer.

101
00:13:32,090 --> 00:13:38,430
So this is a pointer to the address of the stores of value by.

102
00:13:38,450 --> 00:13:48,109
So this actually does create additional memory space since there's really there's actual the value

103
00:13:48,110 --> 00:13:59,270
of drastically an actual additional memory location that stores the value of that address to note.

104
00:14:02,450 --> 00:14:07,729
And then then the kind of the next thing we did was we created a copy variable of I, so this creates a copy.

105
00:14:07,730 --> 00:14:15,860
So this also consumes additional memory spaces, including additional memory location that stores the value one.

106
00:14:15,920 --> 00:14:19,040
In this case we declare it.

107
00:14:20,690 --> 00:14:29,720
And then I guess the last thing to note is that when we do this, we update I, we increase it by one value.

108
00:14:29,930 --> 00:14:33,380
You know, our I and P are also affected.

109
00:14:35,270 --> 00:14:44,630
I guess it not directly affects its stores and address, but if you d reference that address, other kind of value will be changed.

110
00:14:45,470 --> 00:14:48,930
Um, I guess the important thing to note when you,

111
00:14:49,210 --> 00:14:57,350
when you create a copy is that when you do this type of updating kind of VI is not affected in any way by this, this type of updating.

112
00:14:58,100 --> 00:15:07,490
Okay. Okay. So let's just I just walked another walk through like the main kind of the main points of of the first examples which.

113
00:15:14,600 --> 00:15:20,259
The main points are that this is another example.

114
00:15:20,260 --> 00:15:28,630
I guess it's did a lot of the same thing I just read differently here.

115
00:15:31,450 --> 00:15:40,720
I guess I just I guess I just did a few slightly different things, like just checking if you can kind of reassign.

116
00:15:41,320 --> 00:15:48,520
All right. After, after it's been treated. So let's let's walk through this is kind of a similar example, which is slightly different.

117
00:15:48,520 --> 00:15:57,610
So here I think the first four lines of main are exactly the same as in the previous where we created a reference variable.

118
00:15:57,910 --> 00:16:02,950
I am going to point to API and then this copy VII.

119
00:16:02,950 --> 00:16:06,460
So that's that's the exact same as the previous example.

120
00:16:08,230 --> 00:16:15,400
I guess the only thing different is that I do are I plus plus in this case the previous example we did I plus plus.

121
00:16:17,260 --> 00:16:28,959
So that's the only difference, although I think the effect is pretty much the same when we update our I mean that affects both I and I as you know,

122
00:16:28,960 --> 00:16:32,560
in the same way that updating I would do.

123
00:16:33,040 --> 00:16:38,670
Okay. So the effect of this is pretty much the same as doing nine plus plus one.

124
00:16:39,700 --> 00:16:47,529
Okay. So I guess so when we print out this first print statement, it prints out I r I d reference to pi and then vi.

125
00:16:47,530 --> 00:16:54,370
So I think it should print out which or print option print out one point.

126
00:16:54,370 --> 00:17:00,190
Sorry, started to print out to 2 to 1.

127
00:17:00,550 --> 00:17:09,010
Okay. That's what the first statement should be since I and our eyes should both be updated to two.

128
00:17:10,060 --> 00:17:15,730
Since PI is a pointer that points to I I won't be d reference it.

129
00:17:15,730 --> 00:17:19,570
It should also be two and then v should be one since it's a copy.

130
00:17:20,510 --> 00:17:30,010
Okay. So that's what the first print statement should be. Then we do our I equals VII, so it does that.

131
00:17:32,380 --> 00:17:41,260
So I think that that's just going to mean that the value stored by VI will now be stock stored by our I and I.

132
00:17:41,890 --> 00:17:52,420
Okay. So I think, I mean, we should still be, at least in this case, we will be pointing out, you know, one, one, one, one, one.

133
00:17:56,740 --> 00:17:59,979
And then we're going to try to, I guess,

134
00:17:59,980 --> 00:18:09,280
change the or actually and change the value of the pointer to the address stored by VI are the address that stores the value of VI.

135
00:18:10,870 --> 00:18:14,800
So that's going to change the value of PII.

136
00:18:14,950 --> 00:18:24,400
Okay. So I think that's going to be shown here. This doesn't really change the addresses of I or II.

137
00:18:24,940 --> 00:18:28,730
It's just going to change the value of PI. Okay.

138
00:18:29,500 --> 00:18:36,250
Then I guess in the last step we're going to increase VI our I and VII.

139
00:18:37,060 --> 00:18:48,280
Okay, I think. Yeah, I, I and VI are still distinct.

140
00:18:48,640 --> 00:18:52,420
I mean, I think different from VI. Okay.

141
00:18:53,620 --> 00:18:57,760
So yeah, it's hard to say.

142
00:18:58,390 --> 00:19:13,810
Maybe we can just look at the print out in a second. So yeah, the I and I are still distant from VI like this when we do this type of assignments,

143
00:19:20,320 --> 00:19:26,389
you know, Ari and I are still they still have different memory locations from VI.

144
00:19:26,390 --> 00:19:32,420
It just doesn't really change that, that all this does is just change the value stored by all right.

145
00:19:32,950 --> 00:19:36,220
They're still like different memory locations,

146
00:19:36,880 --> 00:19:47,500
but the only way they can just doing this kind of assignment doesn't really change where variables are stored in any way.

147
00:19:47,800 --> 00:19:51,730
Okay. So that's kind of, I guess the main things I want to say here.

148
00:19:52,900 --> 00:20:00,040
These are still our items are still stored in different memory locations.

149
00:20:00,700 --> 00:20:06,040
Okay. So I could just plot through it again.

150
00:20:06,040 --> 00:20:09,160
So let's see what print it. Print it out. Like it, like I said before.

151
00:20:10,120 --> 00:20:19,510
The first thing that's going to be printed out is two, 2 to 1. That's because I write aliases for the same thing.

152
00:20:21,250 --> 00:20:29,250
And then the reference pointer should also be two since it points to the address of I and I.

153
00:20:29,920 --> 00:20:33,159
And then VI is different because it's a copy. Okay.

154
00:20:33,160 --> 00:20:36,720
So I think that's basically what we had in the previous example.

155
00:20:36,760 --> 00:20:41,260
Now let's see what happens. We have our I equals VI.

156
00:20:41,290 --> 00:20:46,990
So in this case, it's going to print out one one, one, one.

157
00:20:48,340 --> 00:20:49,990
Okay. So that's.

158
00:20:52,510 --> 00:21:04,160
So the reason reason for that is we've just assigned the value I'm sorry, this this line here, you just assign the value of VI that's stored in VI.

159
00:21:04,180 --> 00:21:07,900
So that's it. All right.

160
00:21:07,910 --> 00:21:14,440
And I kind of I slash our I and VI are still distinct.

161
00:21:14,980 --> 00:21:18,370
You're just storing the same the same value in this case.

162
00:21:18,370 --> 00:21:22,360
So you can think I could see that in the next print out.

163
00:21:25,540 --> 00:21:31,719
So here we're pointing out the first the addresses of I and our I was the first to address.

164
00:21:31,720 --> 00:21:36,460
As you can see, that's different than the address of VII, which is the last.

165
00:21:37,570 --> 00:21:43,130
And then I actually now has the same address as VI.

166
00:21:43,150 --> 00:21:49,350
So that's that's what's done here. So only two pieces equal to the address of VI.

167
00:21:49,360 --> 00:21:57,960
That just means the at the end, the address stored by the pointer is the address of the.

168
00:21:58,210 --> 00:22:02,170
So the value of the pointer is the same as the address of the UI.

169
00:22:05,010 --> 00:22:11,820
Okay. So now we increase our eye by two so our eye and I should be three.

170
00:22:13,350 --> 00:22:17,550
And the way increase VII by four that should now be fired.

171
00:22:18,750 --> 00:22:25,590
Store by VII should now be five and then the value stored by both I and our eyes three.

172
00:22:25,590 --> 00:22:36,510
So you can see that here on pronoun I are. I know which ones are both three and then the d referenced value of pi is not phi since pi.

173
00:22:36,510 --> 00:22:39,750
The value of pi is the address of VII.

174
00:22:40,750 --> 00:22:49,350
So then VII is now five. So I our eyes and the eyes still distinct.

175
00:22:52,800 --> 00:22:57,300
The pointer is somewhat distinct in the sense that it's stored at a separate memory location,

176
00:22:57,300 --> 00:23:02,740
but that the value at the separate memory is location is now the address of VII.

177
00:23:03,420 --> 00:23:08,190
And that's in that sense, the PI and VI are now kind of linked,

178
00:23:08,190 --> 00:23:14,820
at least in the sense that when you reference PI should, you should go to the value stored by VII.

179
00:23:19,710 --> 00:23:29,760
Let's see, this is kind of a similar walk through to the previous example.

180
00:23:29,760 --> 00:23:38,920
When we are I it affects I well an API at least in the sense that you do reference API type,

181
00:23:39,000 --> 00:23:46,650
you'll get a different value and then V is not affected since it's a copy of when you.

182
00:23:47,130 --> 00:23:52,470
So now this part. So this part was something that was a little different than from example one.

183
00:23:53,340 --> 00:24:02,040
So basically when we do this assignment, we're not reassigning it.

184
00:24:02,250 --> 00:24:09,300
At least I guess what I meant by this is you're not assigning it to a different a different memory location.

185
00:24:09,570 --> 00:24:16,380
Okay. Ari and I are still connected there, still refer to the same memory location.

186
00:24:17,460 --> 00:24:20,130
So you can't change that at least with this statement.

187
00:24:23,490 --> 00:24:30,930
All you can do is basically all this is doing is just changing the value stored at the shared memory location.

188
00:24:31,830 --> 00:24:38,900
I in our basic knowledge, doing this is actually the same thing as doing as a statement.

189
00:24:38,940 --> 00:24:42,090
I equals VM, basically.

190
00:24:47,400 --> 00:24:54,680
That's all. Yeah, that's another way. The statement here is the same as the statement I equals VI.

191
00:24:55,350 --> 00:25:02,110
So the value stored by these items can be copied to I slash are basically the point.

192
00:25:03,000 --> 00:25:09,290
The value stored at that. The shared memory location of an array of.

193
00:25:11,220 --> 00:25:19,590
Okay. I guess the last major thing we did was we missed we changed the value of the coin.

194
00:25:20,310 --> 00:25:25,620
So this changes the value of the pointer, right?

195
00:25:28,350 --> 00:25:33,840
So I don't know if I would call it a reassign, but it's I only do that in a sense that,

196
00:25:34,610 --> 00:25:41,219
you know, it didn't it it changes the the variable that it points to.

197
00:25:41,220 --> 00:25:53,550
In essence, it didn't change the memory location where PI is stored, but it changes the value, the value of pi.

198
00:25:55,110 --> 00:26:03,360
So in that sense, it, it points to another variable just in the sense that we d reference this pointer.

199
00:26:03,360 --> 00:26:08,760
It should go to the the value stored by VI rather than I irr.

200
00:26:09,180 --> 00:26:13,020
That's really what I meant by reassign in quotes.

201
00:26:14,880 --> 00:26:23,910
Okay. It's a copy and paste error, so on.

202
00:26:25,730 --> 00:26:33,860
So yeah, this was just the last kind of thing when our eyes updated and updates both eye and our eye.

203
00:26:34,400 --> 00:26:37,910
And then when VI is updated, it updates VI, of course.

204
00:26:37,910 --> 00:26:43,040
And then it also will change the value of the DX reference pointer.

205
00:26:43,160 --> 00:26:47,840
I think that's kind of the point of the last the last print state.

206
00:26:48,710 --> 00:26:53,870
Okay. So hopefully, I mean, I guess we could have done, for example, I think.

207
00:26:56,210 --> 00:26:59,960
More examples, but I guess. But that hopefully got the man.

208
00:27:01,580 --> 00:27:08,120
I guess the key points about trading reference variables, you know,

209
00:27:08,120 --> 00:27:26,599
the distinction between creating a reference variable and creating a copy of a variable and changing the value of the pointer kind of relates to.

210
00:27:26,600 --> 00:27:35,450
Oh, go ahead. I was just wondering what are the advantages of creating the reference variable instead of creating another new variable?

211
00:27:37,510 --> 00:27:47,590
So I think memory basically memory, I guess it consumes extra memory, for instance.

212
00:27:48,230 --> 00:27:53,990
So the main at least the main way I will talk about it is the way.

213
00:27:54,650 --> 00:28:02,540
The main way I use it is in terms of passing by a reference which is a second to a function.

214
00:28:03,710 --> 00:28:12,500
So I guess the we didn't talk about in detail before, but when I when you I guess call a function,

215
00:28:12,500 --> 00:28:19,100
there's really like a local copy of the of the variable that you give it that's created inside of the function.

216
00:28:19,850 --> 00:28:23,690
And that's fine.

217
00:28:23,690 --> 00:28:26,270
In a lot of cases if it's in, it's kind of a small variable.

218
00:28:27,950 --> 00:28:33,859
But if you're passing kind of a large object, it has to be kind of copied every time you call the function.

219
00:28:33,860 --> 00:28:37,640
So that can create, but it can consume a lot of resources.

220
00:28:38,570 --> 00:28:55,280
So if you pass it a a reference, in some sense you can change the value of the original variable inside the function.

221
00:28:57,020 --> 00:29:01,399
So that's one thing. But that doesn't, it doesn't create an additional copy.

222
00:29:01,400 --> 00:29:06,980
So it's kind of a lot more efficient. That's really the main.

223
00:29:11,150 --> 00:29:17,959
Yeah. I think at least here there's a few other advantages in some cases, but effort in the way I use it.

224
00:29:17,960 --> 00:29:25,840
I think using a reference name, reason for using a reference is that you're.

225
00:29:25,970 --> 00:29:36,720
You're not. Using additional memory if you don't have to respond to this question.

226
00:29:38,070 --> 00:29:41,220
Oh yeah.

227
00:29:41,230 --> 00:29:50,520
It's definitely related to passing by when you're calling a function passing by reference versus passing by value.

228
00:29:50,520 --> 00:30:07,020
So basically we're going to talk about that now. The other questions are not yeah I think this is the I don't know fool and the

229
00:30:07,020 --> 00:30:12,420
whole time today but I think just passing by a value versus passing my references.

230
00:30:12,430 --> 00:30:17,159
So just the second main thing that I wanted to talk about today.

231
00:30:17,160 --> 00:30:25,049
So this is well, this is just an example that I think will show the advantages of passing by reference.

232
00:30:25,050 --> 00:30:30,570
So this is this is an example of a function.

233
00:30:30,570 --> 00:30:34,469
This is actually why we're calling this function.

234
00:30:34,470 --> 00:30:39,150
We're passing by values, which will I guess we'll talk about that in a second.

235
00:30:39,540 --> 00:30:42,750
So this is a so what is this function?

236
00:30:43,020 --> 00:30:48,450
We have a function called get. So what does that do? So I think it's a pretty straightforward function.

237
00:30:48,450 --> 00:30:55,559
So as an input argument, which is an integer vector and then just an integer by itself.

238
00:30:55,560 --> 00:30:59,840
So all it does is just it just returns X at this index.

239
00:30:59,860 --> 00:31:03,239
So you can think of the second argument as just an index.

240
00:31:03,240 --> 00:31:07,470
So if, if this is ten, it just returns exit ten.

241
00:31:08,190 --> 00:31:11,519
So it's probably I don't think it's actually really a useful function.

242
00:31:11,520 --> 00:31:18,870
You can always you just do accept ten. But this is just kind of an example to illustrate the benefits of passing by reference.

243
00:31:19,560 --> 00:31:24,990
So let's look at what we're doing in May.

244
00:31:24,990 --> 00:31:29,880
And so in main, we're just I guess we're just filling up the vector here.

245
00:31:30,480 --> 00:31:33,990
So this vector has length 100,000.

246
00:31:34,530 --> 00:31:40,919
So there's 100,000 elements and we're just in the first part of main, we're just filling it in with integers.

247
00:31:40,920 --> 00:31:51,840
And then the second part of Main, we're just computing the sum of all of the elements in the vector, and we're kind of doing it in an efficient way.

248
00:31:52,530 --> 00:31:56,909
So we're just, we're using the get function basically.

249
00:31:56,910 --> 00:32:04,110
So initialize some to zero when we just add in kind of the ith iteration of the loop,

250
00:32:04,110 --> 00:32:12,420
we just add the sum, the kind of the IV, the IV element of V is basically what we're doing here.

251
00:32:12,900 --> 00:32:18,840
So we're getting the kind of value of V Index II and adding it to sum.

252
00:32:18,840 --> 00:32:25,770
So this is basically the same thing as writing sum as plus equal to being Rocky II most recently,

253
00:32:26,610 --> 00:32:35,780
the exact same thing is just an inefficient way of doing it since we we're using the function that we've read, okay?

254
00:32:37,590 --> 00:32:45,240
So you can run this and so it'll just print out the values of the sum of all the elements in the vector.

255
00:32:46,050 --> 00:32:54,360
You can also time kind of how long, but actually sure, the way it's decomposing these different aspects,

256
00:32:54,360 --> 00:33:08,310
but you can time how long it takes your C++ program to run if you just do time before you do that dot slash name, for example.

257
00:33:08,760 --> 00:33:16,979
Okay. So that's something maybe useful to know about if you're trying to time your program.

258
00:33:16,980 --> 00:33:20,970
So here it's like B C would be three.

259
00:33:21,960 --> 00:33:27,000
It's three and a half seconds, actually have to look at the documentation, how to compute this.

260
00:33:27,000 --> 00:33:31,830
But, you know, it's it's a noticeable amount of time, I guess.

261
00:33:32,520 --> 00:33:38,669
It's not like instantaneous. It's been a little bit of a lag when you run this.

262
00:33:38,670 --> 00:33:41,640
It's a few things, like a few seconds to run. Okay.

263
00:33:42,930 --> 00:33:50,370
So even as this is kind of a simple program, there's still all this, you know, it takes a noticeably long term.

264
00:33:51,480 --> 00:33:58,980
So here is an a an alternative. So here is actually what you'll notice here.

265
00:33:58,980 --> 00:34:07,260
We actually didn't change that much. The only thing that's different in this example from the previous example is that we have an ampersand.

266
00:34:07,920 --> 00:34:13,080
Let's see. That's the only difference that. All right, that's it.

267
00:34:13,950 --> 00:34:23,010
Otherwise, it's the exact same. This is the exact same code as the previous on the previous slide.

268
00:34:23,070 --> 00:34:29,120
We just added this ampersand here. So now let's look what happens when we when we run it.

269
00:34:29,130 --> 00:34:32,580
So it's, you know, how we get the same thing.

270
00:34:32,760 --> 00:34:40,499
And it's essentially instantaneous. It's like measured in thousandths of a second.

271
00:34:40,500 --> 00:34:46,380
So it's probably like a thousand times or 10,000 times faster or something.

272
00:34:47,460 --> 00:34:52,680
Okay, so this is way, way, much, much, much faster.

273
00:34:52,720 --> 00:35:03,930
Okay. I don't want to say it that way. I would say the reason for that I to say more on the following slide.

274
00:35:03,930 --> 00:35:11,040
The reason is really this this for the previous example, this for loop is really time consuming.

275
00:35:11,520 --> 00:35:19,950
Reason for that is every time we do this get function where we're copying a factor of size 100,000.

276
00:35:21,120 --> 00:35:25,500
So we're doing a loop with 100,000 iterations of the loop.

277
00:35:25,590 --> 00:35:30,149
Every iteration of the loop, you're copying something with like 100,000.

278
00:35:30,150 --> 00:35:34,299
So that's really takes super long.

279
00:35:34,300 --> 00:35:38,610
But I mean, compared to this, it really it really takes a lot of time.

280
00:35:39,110 --> 00:35:42,540
Okay. And then we'll see in a minute.

281
00:35:42,540 --> 00:35:47,309
Kind of like passing by reference, kind of you really don't do any copying.

282
00:35:47,310 --> 00:35:53,790
So that's why this this this program is essentially instantaneous.

283
00:35:54,600 --> 00:36:04,410
Okay. Oh, I guess that was just kind of showing why my passing by reference is important.

284
00:36:04,980 --> 00:36:09,750
So maybe we'll just do another example just to show kind of how it works.

285
00:36:09,760 --> 00:36:22,760
So here we have like three. There's three different examples, I guess, that we have our three different functions.

286
00:36:22,940 --> 00:36:25,909
So in the first one here,

287
00:36:25,910 --> 00:36:35,180
we're kind of writing a function and kind of this the same way that we did when we first talked about function than like lecture three.

288
00:36:36,140 --> 00:36:44,720
So kind of that basic way of, of writing C++ functions that's really passing by value by a kind of by default.

289
00:36:45,320 --> 00:37:00,500
Okay. So that I will call this function food is when we call this, it's going to do pass by this bar function.

290
00:37:00,500 --> 00:37:04,010
This is going to be referred to as passing by a reference.

291
00:37:05,510 --> 00:37:11,299
Okay. So this this is really the same function as the other one.

292
00:37:11,300 --> 00:37:17,960
And just it's just we just the only thing we've added is this ampersand.

293
00:37:19,190 --> 00:37:23,780
And the third one is actually here. We're calling it using a pointer actually point.

294
00:37:23,780 --> 00:37:32,239
Using a pointer is also a call. The way it works is it's also calling by reference in a sense,

295
00:37:32,240 --> 00:37:43,460
because it's calling by reference in the sense that it's really only giving the the function an address rather than kind of copying a full value.

296
00:37:44,120 --> 00:37:51,760
I guess that the difference between using this pointer and this ampersand is kind of the way the way you have to work with X is different.

297
00:37:51,770 --> 00:38:00,830
So what we want to we'll see in a second when we want to access the value of X, we have to do this D referencing thing.

298
00:38:01,580 --> 00:38:08,290
Okay. Whereas if we use this ampersand x, we can just treat x it.

299
00:38:08,380 --> 00:38:15,770
Just treat x as if it were x as as if it's kind of storing about the value of x.

300
00:38:15,800 --> 00:38:22,840
Okay. Okay. So so what's going to be turning out?

301
00:38:22,870 --> 00:38:27,280
So here we have is equal to one. Oh, I think.

302
00:38:30,860 --> 00:38:39,240
I don't think I did any updating. Oh, yes.

303
00:38:39,280 --> 00:38:43,600
Otherwise, we could just walk through it here.

304
00:38:43,620 --> 00:38:49,580
So, uh, in that, I guess the first print statement that just prints out I and it's address.

305
00:38:50,160 --> 00:38:55,890
Okay. Yeah, I forgot. Yeah. This is also something I wanted to mention as well.

306
00:38:57,150 --> 00:39:06,120
So the first print statement we have, I is one and it's addresses this this kind of this address that ends in 28.

307
00:39:06,960 --> 00:39:10,950
And the second thing that's printed is the print when we call food.

308
00:39:12,150 --> 00:39:21,070
So when we call food, it prints out this thing. So it prints out X and the address of of X.

309
00:39:22,890 --> 00:39:32,590
So what does that mean? So the value that we're passing, so we call full of I, we're passing it the value stored by.

310
00:39:32,610 --> 00:39:38,460
So that's one. So it should print out one. The second thing that is pointing out is the address of X.

311
00:39:39,810 --> 00:39:51,600
So that's not the address. So I think what this is really pointing out is the address of like the the local copy of X inside of the function.

312
00:39:51,790 --> 00:39:54,899
Okay. So you can think of there when you're running this function,

313
00:39:54,900 --> 00:40:01,320
there's kind of a local copy of X that that that, that it's working with inside of the function.

314
00:40:01,830 --> 00:40:08,909
So when you pass it exits, it's giving it the value of X or Y in this case that it's it main.

315
00:40:08,910 --> 00:40:14,700
But when you run the function, there's kind of a separate memory that stores that value.

316
00:40:15,090 --> 00:40:26,220
Okay. So when we're inside of this function, there's kind of a new memory of location that's opened up and that stores the value one.

317
00:40:26,760 --> 00:40:30,540
So you can see that here. This is that kind of a new memory location.

318
00:40:32,760 --> 00:40:35,480
So that's that's that's what happens when you run food.

319
00:40:35,490 --> 00:40:43,890
It's kind of a new memory location that that's that opens up that works with the value of X inside of the function.

320
00:40:44,680 --> 00:40:50,830
Okay. So now what happens when we call the function bar?

321
00:40:51,480 --> 00:40:56,760
So here we're still just giving it the inside of the parentheses.

322
00:40:56,760 --> 00:41:00,809
We're still just giving it the value. But the way it works is slightly different.

323
00:41:00,810 --> 00:41:05,850
So when we look at this print statement, when we prints access, that's still one.

324
00:41:05,850 --> 00:41:15,899
So I mean, X is still getting the value of one. However, when we print out the the value of X inside of the function, look here.

325
00:41:15,900 --> 00:41:21,060
So here it has its the address ending in like C 28.

326
00:41:21,750 --> 00:41:29,970
So the address of X is actually the, the same address as the address of I in main.

327
00:41:30,270 --> 00:41:30,660
Okay.

328
00:41:31,500 --> 00:41:44,940
So the X so you can think of inside of this function X is basically like a reference variable to inside of me, basically how you can think of it.

329
00:41:45,660 --> 00:42:01,530
So it's, it's has the same it's yeah, the name of X is kind of associated with the same memory location as I inside of the main function.

330
00:42:01,530 --> 00:42:08,030
So that's that's kind of how it works. Okay. So you didn't really.

331
00:42:09,560 --> 00:42:14,030
There's no real new memory locations that had been created inside the function.

332
00:42:15,710 --> 00:42:19,070
Now, I guess the last thing we did is we're giving it a pointer.

333
00:42:19,670 --> 00:42:27,320
So here we call basically you have to give it the pointer variables.

334
00:42:28,940 --> 00:42:30,650
We have to do that. Is ampersand of.

335
00:42:31,730 --> 00:42:40,310
And so when you use X inside of that, if you want to use the value stored by X inside of this function, you have to kind of D reference it.

336
00:42:43,250 --> 00:42:52,220
But X itself is the same as the same memory location as inside of me.

337
00:42:53,210 --> 00:43:00,380
So in some sense, there's no real extra memory that's being created.

338
00:43:03,670 --> 00:43:14,860
Since you're still kind of working with the same memory location store I inside of Main because there's extra memory location for the pointer,

339
00:43:14,860 --> 00:43:22,660
but it's already kind of been created inside and there's no kind of extra memory location for a copy inside of me.

340
00:43:24,190 --> 00:43:31,510
So kind of passing something a pointer or using it using a pointer argument also kind of has.

341
00:43:36,010 --> 00:43:42,559
And I guess it's still kind of the same similar thing as as passing by reference

342
00:43:42,560 --> 00:43:47,630
in the sense that you're not creating an extra copy of for X in this case.

343
00:43:49,490 --> 00:43:55,340
It's just kind of that I think the syntax of working with the pointer is a little bit slightly

344
00:43:55,340 --> 00:44:03,440
more awkward than just using the reference notation where the argument is ampersand of of x.

345
00:44:04,730 --> 00:44:15,590
Okay. So I guess this was just walking through again, I guess, you know, just walk through it and it doesn't hurt to walk through as quickly again.

346
00:44:16,190 --> 00:44:24,470
So here yeah, here is just showing what was going on when we defined each of the various quantities.

347
00:44:24,480 --> 00:44:31,640
So here we had, I guess the first thing we just defined I and print it out and it's memory location.

348
00:44:31,820 --> 00:44:35,030
Okay. So that's the basically the first thing that we did.

349
00:44:35,420 --> 00:44:42,770
The second thing we did was we called the function so that when we call the function food,

350
00:44:44,390 --> 00:44:51,640
there's kind of a there's a local there's a, you know, inside of the function access.

351
00:44:51,980 --> 00:44:55,580
You can think of it as a copy of and kind of inside of a function.

352
00:44:56,330 --> 00:45:00,410
So at some sense inside of the function, there's like a duplicate of the variable.

353
00:45:02,300 --> 00:45:13,350
So I think there's nothing wrong with doing this and especially this type of example where you're passing a function like a single integer.

354
00:45:13,370 --> 00:45:16,129
There's actually I don't think there's anything wrong with that.

355
00:45:16,130 --> 00:45:27,830
There's really no advantage necessarily to passing by reference, since it's just such a small it's just such a small object that you're passing it.

356
00:45:28,220 --> 00:45:36,350
But it could be slow, as we saw in the previous example, if it was variable looking for passing vectors of size 100,000.

357
00:45:36,920 --> 00:45:44,510
Okay. So that's really where there's kind of a noticeable distinction between passing by value and passing by reference.

358
00:45:45,380 --> 00:45:49,010
Okay. So now in the next case,

359
00:45:49,310 --> 00:46:01,340
when we basically when we call the function bar and you think of the variable X inside of the function bar as like a basically an alias,

360
00:46:01,340 --> 00:46:07,100
am I it's just that it's a different name for the same variable, for the same memory location.

361
00:46:08,210 --> 00:46:17,900
Inside a bar X is just an alternative name for the same memory location that I uses inside of the main function.

362
00:46:18,440 --> 00:46:23,060
So there's, there's no copying of the original variable going.

363
00:46:30,720 --> 00:46:39,650
Each variable is cut ten years.

364
00:46:42,190 --> 00:46:55,629
Actually, I'm not sure that the variable X points to the actually I'm not sure what I meant by

365
00:46:55,630 --> 00:47:00,670
the last statement that when calling the function so that X kind of points to the,

366
00:47:01,600 --> 00:47:05,260
to the address of the variables. Okay.

367
00:47:10,340 --> 00:47:14,570
So it's to us.

368
00:47:16,100 --> 00:47:22,940
So if you saw it here, that was the address of I want to see 28.

369
00:47:23,720 --> 00:47:28,400
And here the address of X is also C 28.

370
00:47:34,140 --> 00:47:39,050
So we call this function be a Z variable x points to the address.

371
00:47:39,710 --> 00:47:48,950
So it's two values stored by X inside of main is is the value is the it is the

372
00:47:48,950 --> 00:47:57,830
address above the signs that this is x the value of the pointer is copied,

373
00:47:57,950 --> 00:48:09,870
I guess is what I meant. So there's only kind of a copy of the pointer, but that doesn't really consume that much extra memory space.

374
00:48:10,790 --> 00:48:24,680
Okay. So the the the address of the pointer is kind of is it's is kind of the only new thing that's created.

375
00:48:27,930 --> 00:48:31,900
But that pointers themselves are not large objects to be single interest.

376
00:48:31,920 --> 00:48:41,220
So that also usually kind of a pointer doesn't really assume that much extra memory is so here.

377
00:48:43,830 --> 00:48:50,100
Yeah. I guess here is just a summary of kind of the difference between passing by value and passing by reference.

378
00:48:51,390 --> 00:49:03,810
So if we pass by value this so when the functions execute it, basically when you call the function of the argument they would give, it is copy.

379
00:49:03,810 --> 00:49:13,290
And that's what happens when you can call the function. So if you kind of update the value of the argument inside of the function.

380
00:49:14,340 --> 00:49:18,569
So the examples that we have here, we can really do that.

381
00:49:18,570 --> 00:49:29,520
But like in this example, if you like I say X is equal to two for example, that it doesn't affect has no effect on the value of pi inside of me.

382
00:49:30,120 --> 00:49:35,160
So it's, it's a copy. Okay. So that's kind of what I meant here.

383
00:49:35,670 --> 00:49:44,910
So if we update the argument inside of the function, that doesn't affect the variable that we that we used to call the function.

384
00:49:44,970 --> 00:49:52,950
Those are kind of two separate variables. You know, this so this works perfectly fine and is perfectly okay.

385
00:49:52,950 --> 00:49:57,779
And so sometimes it's preferable if that is the argument that you give it as small,

386
00:49:57,780 --> 00:50:05,880
if it's just a single number, for example, there's many disadvantages of passing by value.

387
00:50:08,040 --> 00:50:18,449
However, this is can lead to kind of slower than necessary performance if if you're kind of repeatedly

388
00:50:18,450 --> 00:50:23,370
calling a function with where the argument of the function is that a kind of a large object,

389
00:50:23,500 --> 00:50:29,340
like a very large vector, a very large map or something like that.

390
00:50:30,440 --> 00:50:39,870
So that's kind of one of the main problem problems you might want to consider if you're passing to passing large objects by them.

391
00:50:42,000 --> 00:50:50,819
So the other way of, of kind of calling a function or in C++ is passing by reference.

392
00:50:50,820 --> 00:50:58,170
So you pass kind of a reference or a pointer of an up to an argument when the function is executed.

393
00:50:59,100 --> 00:51:07,170
So, so there's not an additional copy that's made when you pass by reference.

394
00:51:08,170 --> 00:51:12,150
The only thing to be careful about when you're passing by reference is that

395
00:51:12,990 --> 00:51:17,070
if you're doing any kind of updating of the argument inside of the function,

396
00:51:17,850 --> 00:51:25,380
that also kind of updates the original copy like the original, the original variable inside of Main, for example.

397
00:51:26,970 --> 00:51:31,140
That's definitely the main thing to just to be careful about.

398
00:51:32,190 --> 00:51:40,919
So this the advantage of this is that, you know, it's more efficient, especially if you're calling a function with large arguments,

399
00:51:40,920 --> 00:51:45,540
since you're not creating any additional copies, you're just in a sense,

400
00:51:46,560 --> 00:51:53,340
kind of giving it an address of the that of the argument that you're working with inside of me.

401
00:51:54,060 --> 00:52:03,950
So the last point is just it's just e you're changing the values of the argument inside of your function.

402
00:52:03,960 --> 00:52:13,620
Just be careful that it's doing it in a way you want to of that will also change kind of the value inside of the inside of the main function.

403
00:52:15,960 --> 00:52:21,750
Okay. So here's some examples where we're actually changing the value of something inside of the function.

404
00:52:22,320 --> 00:52:28,080
So here we again have three functions. Few are and spans, I guess.

405
00:52:29,190 --> 00:52:33,510
So each of these functions in subs that they just increase the value of X by one.

406
00:52:35,990 --> 00:52:40,620
When we call these functions and main kind of what exactly what they do is slightly different.

407
00:52:41,460 --> 00:52:48,690
So let's look inside a bit. So we have we first declare three integer variables that are all equal to one.

408
00:52:49,590 --> 00:53:01,739
How do we when we run food. So when we call food F, that is going to well it doesn't print out anything,

409
00:53:01,740 --> 00:53:12,569
I guess so it actually really does nothing today inside of Main since there really what this is

410
00:53:12,570 --> 00:53:20,280
doing is updating the value of a kind of a local copy of the of the argument that you give it.

411
00:53:20,520 --> 00:53:26,100
So it really has no effect on me inside of me. And so when we print out a at the bottom.

412
00:53:26,270 --> 00:53:30,379
It should still have the value of one kind of running.

413
00:53:30,380 --> 00:53:34,120
This has no effect on the value of a inside of main.

414
00:53:34,890 --> 00:53:39,850
We run this one bar of B, what is that?

415
00:53:39,860 --> 00:53:43,939
So that R of B has a reference thing.

416
00:53:43,940 --> 00:53:53,990
So this actually since inside of bar you could think of X is essentially just an alias for B inside main.

417
00:53:54,530 --> 00:53:57,770
This actually updates the value of B inside of me.

418
00:53:58,580 --> 00:54:09,049
So my in front this out this should have the value to the last one is as a function so that what does that do.

419
00:54:09,050 --> 00:54:32,540
So this is a pointer to a pointer to the to the address that stores the value of C.

420
00:54:32,690 --> 00:54:42,020
Okay. And then here we're incrementing by incrementing the value of X.

421
00:54:42,530 --> 00:54:48,109
So I guess the de reference pointer inside of inside of the function.

422
00:54:48,110 --> 00:54:56,230
So that should also assume you also kind of affect C inside of right.

423
00:54:57,740 --> 00:55:02,270
I mean because the reason for that is I guess I can think of it this way.

424
00:55:02,270 --> 00:55:18,200
So x x x is like an address and here where we're looking at the value stored in that address and we're just increasing the value stored in that case.

425
00:55:18,410 --> 00:55:25,549
Okay. So here, this is the address that stores the value of C and then in this case,

426
00:55:25,550 --> 00:55:35,990
we're increasing the value stored and we're basically increasing the value of C inside of me.

427
00:55:36,470 --> 00:55:49,870
Okay. And I sense hopefully that we're examples where hopefully this example makes kind of using pointers inside of functions a little bit more clear.

428
00:55:51,970 --> 00:55:59,110
So here you have you can see that we print out A, B and C, it's only the first example that's that has no change.

429
00:55:59,830 --> 00:56:06,100
So this food, when we do it, we run food of a that has no effect on inside of main.

430
00:56:06,580 --> 00:56:12,490
But the other two cases those kind of change the values of B and C inside of me.

431
00:56:12,640 --> 00:56:20,800
Okay. Even though kind of the only, only kind of increment operations were were performed inside of these functions.

432
00:56:21,160 --> 00:56:24,820
Okay. Yeah.

433
00:56:24,850 --> 00:56:34,630
So we can, I think like off of both functions, I can just do something called P,

434
00:56:35,500 --> 00:56:47,530
so just copy the original, I mean, just copy the value, but just store as a different address.

435
00:56:48,640 --> 00:56:57,390
So it means like for a, the value of the A doesn't change here.

436
00:56:57,670 --> 00:57:13,300
So it's a still be the launch. And for reference and for pointer, it will change the value of the T of B and C so we can return to it.

437
00:57:17,470 --> 00:57:21,930
Yeah. Yes, roughly. I think so. Yeah.

438
00:57:22,090 --> 00:57:33,390
So a yeah. So it doesn't change anything since this is like a for this thing, it's well yeah, this is a,

439
00:57:33,430 --> 00:57:39,520
it's working on kind of a different variable with a different memory location

440
00:57:40,330 --> 00:57:46,719
inside of a function for these these functions actually don't return anything.

441
00:57:46,720 --> 00:57:53,290
These are, these are void. And remember, if they're type void, they don't have a specific return value.

442
00:57:53,290 --> 00:58:10,989
But it doesn't it doesn't matter for this this because we're we're using kind of the same memory memory location as in this case B inside of main.

443
00:58:10,990 --> 00:58:18,729
It's still kind of updates that the same it updates the value of the that's stored

444
00:58:18,730 --> 00:58:32,510
in the memory of of be that values know the memory location of B I guess that helps

445
00:58:33,810 --> 00:58:43,990
that slightly still maybe still slightly confusing I think it's sweet or is passing

446
00:58:43,990 --> 00:58:50,890
my references slightly confusing at least if you have if you haven't seen it before.

447
00:58:51,690 --> 00:59:03,610
Okay. And depending on depending on which languages you've done before, you may or may not have seen it before.

448
00:59:03,610 --> 00:59:08,230
And you kind of totally use to passing by a value.

449
00:59:09,910 --> 00:59:18,850
I mean that's kind of the case in ah basically everything is passed by value and use functions and ah that's, it's just not the case here.

450
00:59:19,090 --> 00:59:23,100
There is an option to pass by reference.

451
00:59:23,230 --> 00:59:29,850
It's slightly confusing. We call this function to change the, the variables that have,

452
00:59:30,160 --> 00:59:37,180
that have entered in that have kind of were involved in the function in any way but this.

453
00:59:39,420 --> 00:59:41,360
Hopefully it will some clearer.

454
00:59:44,220 --> 00:59:52,500
So, I mean, maybe it's just helpful to think of X as when we're when we're running this like inside of this function X,

455
00:59:52,500 --> 01:00:01,350
it's kind of just a different name for the same memory associated with beings, is maybe it?

456
01:00:02,550 --> 01:00:08,310
Hopefully that's a helpful way to think about time.

457
01:00:10,210 --> 01:00:16,890
Okay. Oh, I guess the this is probably the last thing I wanted to mention.

458
01:00:17,340 --> 01:00:25,830
So I think when we talked about arrays, I showed how to use an array as a function, as an argument and a function.

459
01:00:26,250 --> 01:00:30,150
But I don't think we really got into detail of kind of how it works.

460
01:00:33,930 --> 01:00:39,930
So when we're using an array as a function argument, you could really think of it as you're passing a pointer.

461
01:00:40,290 --> 01:00:48,659
So that functions almost like a pointer. I think it's kind of talked about before the one you use, like the name of an array itself.

462
01:00:48,660 --> 01:00:55,110
You should think of it as like a pointer variable to the first pointer variable to

463
01:00:55,110 --> 01:01:04,530
like the to the first element of the array basically is it is kind of think of it so.

464
01:01:06,450 --> 01:01:09,000
So that's kind of an advantage of working with that, right,

465
01:01:09,030 --> 01:01:21,390
is at least in terms of computational efficiency because if you use arrays in a like in a function, there's really no local copy that's made of it.

466
01:01:21,870 --> 01:01:26,580
Made in a, in a, in an array. Are made of an array.

467
01:01:27,180 --> 01:01:32,820
Okay. So I guess that's an advantage.

468
01:01:33,150 --> 01:01:38,250
I guess it's just the thing to worry about if you're writing functions with array

469
01:01:38,250 --> 01:01:46,820
arguments is that if you kind of change the value of the name of elements inside of the

470
01:01:47,700 --> 01:01:52,889
is the variable representing the array inside of the function that will also change

471
01:01:52,890 --> 01:01:57,570
the elements of the the array kind of outside of the function kind of inside of main.

472
01:01:58,450 --> 01:02:06,660
That's kind of just the thing to be cautious about. Here is an example of an array as a function argument.

473
01:02:06,670 --> 01:02:16,860
So here I have I have a an array as a function argument and here's an example or I'm actually returning a value.

474
01:02:17,640 --> 01:02:30,180
So here I'm a returning a double number. So here the the argument is an array, it's an X.

475
01:02:30,600 --> 01:02:42,930
So basically all I'm doing inside of the function is I'm just turning out X the D reference value of X and then X's zero.

476
01:02:44,700 --> 01:02:51,210
Okay. So this is basically going to be the first thing that is going to print out is a is really a pointer.

477
01:02:51,380 --> 01:02:59,340
It's like an address if it's going to print out, I guess the the value at zero, I guess zero again.

478
01:02:59,820 --> 01:03:05,250
So remember when we do that a D referencing of an array that's really the same thing as doing X of zero.

479
01:03:06,420 --> 01:03:12,930
Then I'm going to change x of one inside of the function.

480
01:03:12,930 --> 01:03:19,530
So I'm saying x one equals 3.0 and then I just say y is equal to zero plus x.

481
01:03:20,430 --> 01:03:36,659
Now I return y. Okay, so when we do this, it changes the value of the array outside of the function that's really being cautious about to do this.

482
01:03:36,660 --> 01:03:45,180
X 13.0 that's really well changing both kind of x inside of the function and outside of the function.

483
01:03:47,070 --> 01:03:53,229
Okay. So. Let's see what happens when we run this.

484
01:03:53,230 --> 01:03:58,900
So here, in this example, I'm just defining an array with two elements just one and two,

485
01:03:59,740 --> 01:04:04,690
and then I'll set the first print statement out just before calling the function.

486
01:04:05,470 --> 01:04:14,140
These are the elements of the array. So I'm just printing out x zero and x one and then I call the function on this line at two.

487
01:04:14,710 --> 01:04:19,900
So that's going to print out, I think, these values of X inside the function.

488
01:04:25,690 --> 01:04:32,650
And then it's going to print out the values, out the values of X outside of the function.

489
01:04:33,400 --> 01:04:37,930
All right. I'm not going to say outside, I guess, after calling the function.

490
01:04:38,410 --> 01:04:43,120
So I guess the thing to watch out for years that that X one is going to be different.

491
01:04:43,120 --> 01:04:46,629
That's really the main thing I want to say.

492
01:04:46,630 --> 01:04:51,190
So we do this out here, we print out both elements of the array.

493
01:04:52,240 --> 01:04:58,750
Then I call the function that's actually going to change the kind of the elements of the array.

494
01:04:59,290 --> 01:05:06,879
So this is what's printed out after this function call is going to be different and then before it gets really the same,

495
01:05:06,880 --> 01:05:17,050
the main thing is to say, okay, so you can see that here we do print out before calling the function x0 is equal to one, x one is equal to two.

496
01:05:17,530 --> 01:05:26,650
And then after calling the function like 001 and x one is equal to three, I'm sorry, that's kind of the same thing.

497
01:05:27,070 --> 01:05:30,639
So doing this type of we change the value of X one,

498
01:05:30,640 --> 01:05:39,420
that's really changes in the value of x one outside of outside of this function because you can think of it,

499
01:05:39,890 --> 01:05:44,350
you think of X itself is essentially a pointer or at least the name of X is essentially a pointer.

500
01:05:44,950 --> 01:06:03,729
And then when you do x, one is really what is your D referencing your D referencing the address of the address next to the x zero.

501
01:06:03,730 --> 01:06:12,130
I guess since I can think of an array as like a block of memory, it's like that memory right next to x0.

502
01:06:12,640 --> 01:06:17,950
So here you're saying kind of a D reference to value X.

503
01:06:18,130 --> 01:06:23,890
It now has the value 3.0. So the memory location, which stores.

504
01:06:28,380 --> 01:06:31,740
X1 now has the value 3.0. Okay.

505
01:06:32,520 --> 01:06:42,599
Kind of weird to interpret that. And I guess the only other thing I'll mention, so we had this also had this print statement inside the function.

506
01:06:42,600 --> 01:06:50,579
So inside the function we're turning it out at least before we change the value of X, we're printing out tags.

507
01:06:50,580 --> 01:06:56,670
So that should be an address. So you can think of when you're using the name of an address in an array.

508
01:06:57,330 --> 01:07:00,510
It's really like basically you can treat it as a pointer.

509
01:07:01,050 --> 01:07:03,870
So it should be an address, actually an address.

510
01:07:04,530 --> 01:07:11,250
And we do Star of X that's like a you're basically D referencing a pointer or it's a pointer to the first element of the array.

511
01:07:11,760 --> 01:07:17,720
So it should have the value x zero. And then zero.

512
01:07:17,740 --> 01:07:20,160
Yeah. So yeah. So just printing it out twice.

513
01:07:20,160 --> 01:07:29,880
These are just really two alternative ways of kind of referencing like zero eight in these cases as both one.

514
01:07:30,640 --> 01:07:42,920
So that's hopefully that that's working using a res locally three or so you can think of arrays as when you use when you use them as an

515
01:07:42,930 --> 01:07:53,550
inside of the call function is essentially like using a pointer or a pointer to the first element of the Iraqi's to be more specific.

516
01:07:54,840 --> 01:08:00,990
Okay. Oh yeah. So here is actually this is I think this is useful to mention as well.

517
01:08:02,550 --> 01:08:12,660
So here I think it's often recommended practice to when you, uh, when you're writing a function that you expect to be called by reference.

518
01:08:12,660 --> 01:08:24,750
So in many cases the, the kind of the argument that you give the function when you're passing by reference, you don't want,

519
01:08:25,380 --> 01:08:34,890
you don't want to change it, you don't want you don't want any of the values inside of that kind of the object that you pass to to be changed.

520
01:08:35,520 --> 01:08:39,780
You're just kind of passing it because it's a lot more efficient to pass by reference.

521
01:08:40,830 --> 01:08:47,640
In that case, I think it's often recommended to do this is cost to add this const keyword.

522
01:08:48,570 --> 01:08:56,640
So if I write this function here, this basically does the same thing as the previous function.

523
01:08:56,960 --> 01:09:01,800
All right. It's it's meant to do the same thing as the previous function.

524
01:09:02,610 --> 01:09:10,320
However, the only thing that's different here is that you're not allowed to change the the elements of X.

525
01:09:12,180 --> 01:09:15,240
Okay? So for this case, it's a vector.

526
01:09:16,950 --> 01:09:22,430
So you are you're not allowed to you're basically not allowed to change in the elements of X.

527
01:09:22,440 --> 01:09:28,740
So in this case, we're passing by reference, if we change the value of X doing this X push back,

528
01:09:29,700 --> 01:09:32,580
that would change the value of kind of X outside of main.

529
01:09:33,720 --> 01:09:41,220
However, in many cases when you pass by reference, you really only want to kind of use the values of X, but you don't want to change the values.

530
01:09:41,760 --> 01:09:46,890
So just to be extra cautious that you didn't like accidentally change the values of X,

531
01:09:47,310 --> 01:09:50,070
you could add this constant keyword, so that kind of prevents it.

532
01:09:50,790 --> 01:10:04,260
So here I think if you if you try to run this out, which should create an error of some kind, I think if you tried to run this through actually.

533
01:10:05,160 --> 01:10:08,729
Yeah, yeah. I think yeah. That's why I didn't have a screenshot.

534
01:10:08,730 --> 01:10:16,770
If you tried to run this, it should create an error or sometime we should pronounce pronounced some error message.

535
01:10:17,280 --> 01:10:24,749
That's because when you have this constant, that just means that you're not allowed to change kind of any of the elements inside of X.

536
01:10:24,750 --> 01:10:28,470
So I try to run this line of code.

537
01:10:28,950 --> 01:10:36,090
It should generate an error. I think cost is fully cost is often recommended.

538
01:10:36,630 --> 01:10:48,780
You want to you want to pass something by reference, but you really you don't want to change any of the values of the object that you give it.

539
01:10:49,530 --> 01:10:56,759
You kind of just want to use the tiny elements inside of X in some kind of way.

540
01:10:56,760 --> 01:11:12,190
But you don't want to change any of the values. But we it long enough that's is just more or less just a wrap up of what we talked about.

541
01:11:12,190 --> 01:11:18,139
So that's basically calling by value versus calling my reference.

542
01:11:18,140 --> 01:11:31,990
So out of the main the main thing to know about calling by value is that these are kind of a copy of the variable that's made inside of the function.

543
01:11:31,990 --> 01:11:36,280
In some sense. There's a, there's a separate copy that that's being worked on.

544
01:11:39,040 --> 01:11:41,410
So that's, that's, that's what's done by default.

545
01:11:41,620 --> 01:11:51,250
Like if you don't add any kind of ampersand or, or a pointer notation, kind of the default of C++ is to do pass by value.

546
01:11:53,590 --> 01:12:00,280
I guess an advantage of this is that when you do a kind of updating inside of the function, you're basically just working with a copy.

547
01:12:00,280 --> 01:12:05,469
So it doesn't affect the original variable that you and you used when you call the function.

548
01:12:05,470 --> 01:12:11,080
So that's kind of the main advantage. Okay.

549
01:12:11,350 --> 01:12:14,470
So when you do call in by reference, when you use this ampersand,

550
01:12:15,100 --> 01:12:20,830
it's really you're making kind of a reference to a variable is really what you're doing.

551
01:12:23,770 --> 01:12:33,070
So you can think of kind of the the variable inside of the function is basically just a reference to the,

552
01:12:33,520 --> 01:12:37,660
the same variable that's that you used to call the function.

553
01:12:37,840 --> 01:12:41,110
Okay. So the variable that's, that's inside of making usually.

554
01:12:41,620 --> 01:12:56,650
Okay. So the key thing to keep in mind about this is that updates, any updates that use kind of inside the function on the reference variable,

555
01:12:57,010 --> 01:13:09,220
it affects the kind of the original variable inside of your after function definition.

556
01:13:10,390 --> 01:13:25,480
I just meant. What I meant by this is kind of the syntax for working with the reference is

557
01:13:25,480 --> 01:13:30,790
basically you can treat it as if it's kind of a you don't have to do any reference,

558
01:13:31,210 --> 01:13:44,320
deep referencing or anything. You can kind of just treat the variable X as the same way inside of the function as if it were a kind of the same X.

559
01:13:44,320 --> 01:13:50,800
There was no special syntax you have to do to to work with X inside of the function.

560
01:13:51,310 --> 01:13:56,950
If you're passing by a reference image, I can clarify this a little bit better.

561
01:13:58,920 --> 01:14:05,290
Okay. And this is also, I think, something useful to keep in mind when you're passing by reference.

562
01:14:06,850 --> 01:14:14,860
If you use cards to constitute a word, that's just kind of an extra protection against an unwanted update.

563
01:14:14,870 --> 01:14:26,859
So many cases you don't want to update the variable that you used and the argument you want to update that in other places in your program.

564
01:14:26,860 --> 01:14:29,860
So doing cards is kind of a protection against that.

565
01:14:34,320 --> 01:14:43,590
Using pointers. I guess when you call a function, you can use this before the variable that gives you can use it to pull the pointer of that variable.

566
01:14:43,650 --> 01:14:50,070
If you want to use that, that's attached to the function. This we mentioned this before.

567
01:14:50,760 --> 01:14:55,980
Usually this inside of a function. I did reference it as with Star.

568
01:14:59,350 --> 01:15:01,590
I guess passing a pointer doesn't.

569
01:15:02,820 --> 01:15:13,370
So it's basically kind of the same thing as passing by reference in the sense that you're not creating a copy of the argument that you do.

570
01:15:13,380 --> 01:15:20,540
But I guess it's slightly more complicated since you're creating a copy of the pointer in a sense.

571
01:15:20,550 --> 01:15:26,780
But that doesn't. It doesn't really create so much extra memory space.

572
01:15:26,800 --> 01:15:30,129
And so you can think it is essentially the same thing.

573
01:15:30,130 --> 01:15:37,690
It's passing by reference with the ampersand, which just, you know, the syntax is, is a little bit different.

574
01:15:37,690 --> 01:15:45,399
So you have to be just careful about remembering what a pointer is.

575
01:15:45,400 --> 01:15:50,799
It's a it's an address and what you're doing when you're de referencing.

576
01:15:50,800 --> 01:15:58,150
It's, I think kind of doing I personally think kind of passing by reference with this ampersand is a lot easier.

577
01:15:59,910 --> 01:16:07,360
It's kind of a little bit easier, at least the syntax is a little bit easier to work with when you're writing function.

578
01:16:10,840 --> 01:16:15,370
So that's basically it for today.

579
01:16:15,370 --> 01:16:27,159
So that's really the main things I wanted to talk about is reference variables and pointers and passing by reference versus passing.

580
01:16:27,160 --> 01:16:39,370
But that's it for today. So just remember to to morrow quizzes Wednesday I'll be I'll be posting homework

581
01:16:39,370 --> 01:16:45,940
three person show and I'll probably be due next next week Wednesday April.

582
01:16:49,160 --> 01:16:55,910
It's a. There are other concerns.

