1
00:00:02,790 --> 00:00:36,600
It will be an emergency which got to go ahead and get started because it will start as soon as I miss the first homeworks due tonight.

2
00:00:40,650 --> 00:00:47,090
I have submitted it to the government and so it rejection.

3
00:00:48,540 --> 00:00:58,210
Just as long as you have the function, the function itself and something that shows the output when you run it in our economy,

4
00:00:59,400 --> 00:01:09,240
we would put it in the same file and set out a separate text file as you can read this function.

5
00:01:10,860 --> 00:01:18,750
I guess the first quiz is due tomorrow. Tomorrow is the day and it just post the second quiz.

6
00:01:20,950 --> 00:01:25,559
That's not going to like it. It's not due until the 26th.

7
00:01:25,560 --> 00:01:32,370
So I think that's a little bit less than two weeks.

8
00:01:33,990 --> 00:01:40,740
I think the immediate things that are due today, we'll talk mostly about matrices probably.

9
00:01:42,540 --> 00:01:46,080
I think we just started a little bit about matrices last time.

10
00:01:46,950 --> 00:01:57,090
So do a lot of matrices today and then probably hopefully, I think a little time to start to start talking about this a little bit.

11
00:01:58,080 --> 00:02:05,040
So lists are like the next big data structure and ah, so for matrices,

12
00:02:05,040 --> 00:02:22,290
I think the slide we had last time you are using matrices is like two dimensional vector and it's kind of one of the same features as vector.

13
00:02:23,430 --> 00:02:29,460
So one of the main things is that all of the elements of a vector have to have the same type, so same thing.

14
00:02:32,400 --> 00:02:35,700
That's a similarity between actors and matrices.

15
00:02:36,720 --> 00:02:39,750
So this was basically how you create a matrix.

16
00:02:39,750 --> 00:02:46,470
The matrix function is probably the best way to do it all.

17
00:02:48,930 --> 00:02:55,469
So it's kind of the second argument is the number of rows, and the third argument is the number of columns.

18
00:02:55,470 --> 00:02:59,520
And this just creates a matrix with two rows and three columns.

19
00:03:00,510 --> 00:03:04,270
You can even do kind of a you can give it a vector of, of,

20
00:03:04,300 --> 00:03:14,400
of entries and it'll kind of fill in the vector of the elements of the matrix from the elements of this vector.

21
00:03:14,400 --> 00:03:19,530
And then I think, as we mentioned before, it kind of fills in one column at a time.

22
00:03:19,530 --> 00:03:32,370
It fills in everything in the first column, and it moves on to the second couple of solutions by road in an alternative,

23
00:03:32,370 --> 00:03:38,370
if you fill it in, fill it in five through the first rather than the second segment.

24
00:03:38,460 --> 00:03:43,200
So if we mentioned this,

25
00:03:43,200 --> 00:03:56,549
this is a beautiful to access certain certain columns in a matrix like this example here you want to access the second column of matrix.

26
00:03:56,550 --> 00:04:12,210
You just read the kind of first order inside of the bracket, and it's just kind of nothing easier than comma two, but you can access columns that way,

27
00:04:12,220 --> 00:04:22,980
or alternatively rows if you want to access the second row by itself, it would just be a bracket two and comma, then nothing after the column.

28
00:04:23,760 --> 00:04:33,870
And that we're not mention this last time but the in row and call functions just

29
00:04:33,870 --> 00:04:38,459
telling you tells you the number of rows at number of columns of your matrix.

30
00:04:38,460 --> 00:04:45,330
Sometimes it's useful to know that information. If you want to know both, you could just do down the I Am of the Matrix.

31
00:04:45,930 --> 00:04:49,470
So that basically tells you the dimensions is the first.

32
00:04:49,860 --> 00:04:54,090
The first number is the number of rows. Second number is the number of columns.

33
00:04:55,020 --> 00:04:58,500
Okay. So yeah, I don't think we mentioned this.

34
00:05:00,900 --> 00:05:03,300
Last time. So you.

35
00:05:04,110 --> 00:05:15,510
So I guess the the usual way of accessing elements of a matrix is with like the two numbers, like a pair of numbers, like a two comma one.

36
00:05:16,430 --> 00:05:21,420
I that that's kind of the intuitive way of accessing elements of the matrix.

37
00:05:24,330 --> 00:05:32,520
Ah. Does have the option to access elements of a matrix as as you would with a vector.

38
00:05:33,570 --> 00:05:43,400
Basically if it kind of a single number inside brackets, I think in some cases it's useful to city to use that feature,

39
00:05:43,410 --> 00:05:49,500
but I wouldn't say I use it that much, but I think in some cases it's it's useful to know about that feature.

40
00:05:50,160 --> 00:05:56,190
So like so let's say for example, if you have a matrix A with three rows,

41
00:05:59,930 --> 00:06:07,410
I see if you just do a one by itself, that'll actually return a number that works.

42
00:06:07,780 --> 00:06:14,280
So that's just any one one. It's the same thing if you just do a two by itself, it's a21.

43
00:06:14,280 --> 00:06:19,259
Like the second row of the first column, a three would be a31.

44
00:06:19,260 --> 00:06:26,970
And then after that, you sort of move on to the next column after you finish the first column.

45
00:06:28,170 --> 00:06:32,340
This would be like the first entry of the second column. So the A1 two.

46
00:06:32,970 --> 00:06:34,970
So you can actually just give it a single number.

47
00:06:34,980 --> 00:06:46,530
That's actually a valid way to access elements of matrices and ah, although I don't think it's the normal way of doing it.

48
00:06:47,070 --> 00:06:56,680
It's sometimes useful to know about this, especially if you're doing like logical, some setting, like easier to write something like this one.

49
00:07:00,600 --> 00:07:05,370
You only want to extract the elements of any that are greater than three.

50
00:07:06,980 --> 00:07:15,930
You can use something like this. And so in that case, that kind of single without using kind of a double number notation can be useful.

51
00:07:16,210 --> 00:07:25,740
Okay, I can see that here in this example, I have a two by three matrix and then if I do a subset of just the entries,

52
00:07:25,740 --> 00:07:31,410
four and five like that for the fourth and fifth element of the matrix that's

53
00:07:31,410 --> 00:07:38,760
invalid all all it is going to do is going to give us these is five and the three.

54
00:07:39,590 --> 00:07:44,280
So this is the first element. This is the second element.

55
00:07:45,060 --> 00:07:50,270
Two is the third element. Five is the fourth element. And then three is like the film elements.

56
00:07:50,270 --> 00:07:53,860
So that's the way you kind of if you're using a single number indexing,

57
00:07:53,860 --> 00:08:00,030
that's kind of the way to read it because you go down columns and then you switch

58
00:08:00,030 --> 00:08:06,390
columns once you kind of know once you've finished going through the column.

59
00:08:06,480 --> 00:08:10,980
Okay. So, yeah, this is, I think what I just said.

60
00:08:10,980 --> 00:08:21,480
Like if you do this kind of subset of the A which is greater than three that I'll return and I'll return it to Vector.

61
00:08:21,690 --> 00:08:28,950
Okay. So this is just returns all the elements of A that are greater than three.

62
00:08:28,950 --> 00:08:33,209
So that's I think in this case, it's just of just four or five six.

63
00:08:33,210 --> 00:08:38,130
The only elements that greater than three are four, five and six.

64
00:08:40,980 --> 00:08:52,470
Okay. So just a few things about working with those matrix like diagonals of the matrix and the diagonal matrix is come up a lot.

65
00:08:52,690 --> 00:08:59,330
The identity matrix is a diagonal matrix, but there's also other uses of diagonal matrix.

66
00:08:59,400 --> 00:09:06,510
So this kind of special functions just to make working with diagonal matrix easier.

67
00:09:07,680 --> 00:09:17,700
So a diagonal matrix is just basically any kind of matrix where the like the non diagonal elements are zero, right?

68
00:09:17,700 --> 00:09:27,359
So the diagonal matrix elements are the elements where the row index equals column index and then it's a diagonal matrix.

69
00:09:27,360 --> 00:09:35,220
If all the nine diagonals are zero to create a diagonal matrix and ah you could just use this

70
00:09:35,610 --> 00:09:48,120
diag function di ag and basically the way it works is you give it a vector as kind of the input,

71
00:09:49,410 --> 00:09:55,740
give it a vector and it creates a diagonal matrix like a square diagonal matrix.

72
00:10:00,380 --> 00:10:08,000
With the number of rows and columns equal to the length of this vector so that this is the vector, we get it.

73
00:10:08,000 --> 00:10:11,060
Here is the vector. One, two, three, four.

74
00:10:11,800 --> 00:10:18,540
This is like four. So it's going to create a four by four matrix with just this vector along that.

75
00:10:18,740 --> 00:10:23,920
And also you can see here that long that I have one, two, three, four.

76
00:10:23,930 --> 00:10:31,670
So that's, that's a useful function to know about. Just sometimes it's useful to just be able to easily create a diagonal matrix.

77
00:10:36,200 --> 00:10:43,730
You can also use dynamic in multiple ways.

78
00:10:44,630 --> 00:10:47,720
It basically depends on the argument, the type of argument you give it.

79
00:10:48,380 --> 00:10:55,940
So if you give it a vector, it creates a it creates a diagonal matrix, as we just saw.

80
00:10:56,750 --> 00:11:01,970
It does something different if you give it a matrix. So you can give it a matrix as an input argument.

81
00:11:03,680 --> 00:11:13,370
However, what it does when you get it, a matrix input argument, it just returns the the diagonals of that matrix.

82
00:11:13,610 --> 00:11:18,019
So it's pretty useful in that way. So it doesn't create anything.

83
00:11:18,020 --> 00:11:27,499
It just returns kind of the diagonal matrix of the diagonals of the matrix that if it is see here this matrix and it has diagonal entries,

84
00:11:27,500 --> 00:11:35,340
one, five and nine. If you just do diag entry, it just returns that those diagonals as a factor of one five.

85
00:11:36,770 --> 00:11:44,540
So it's sometimes useful to use it to be able to extract with the diagonal elements of a certain matrix.

86
00:11:44,540 --> 00:11:48,190
Ah, I included this.

87
00:11:48,200 --> 00:11:53,780
I don't. Is it?

88
00:11:53,840 --> 00:12:06,399
Sometimes it's it depends what type of problem you're working on. Sometimes used for this upper try and low worked try basically allows you to

89
00:12:06,400 --> 00:12:12,910
reassign an upper triangular portion or the lower triangular portion of a matrix.

90
00:12:13,810 --> 00:12:20,380
So if I create this matrix, it's as numbers of 1293 rows, three columns.

91
00:12:21,070 --> 00:12:30,790
And I aside, basically, this works. You think of this as it's when we do this notation, it's like a logical sub something.

92
00:12:30,790 --> 00:12:43,780
So basically when we do assignment, an assignment, we're assigning to zero those elements of X that are on the upper triangular portion.

93
00:12:43,850 --> 00:12:49,840
That's the way to think about it. So I'm just assigning the upper triangular portion of X to value zero.

94
00:12:49,850 --> 00:13:04,120
So you can see that here. The upper triangular is things to the top, to the to the right and above the diagonal elements.

95
00:13:04,120 --> 00:13:08,560
Right. You could do the same thing with lower tri. I do 10 to 15.

96
00:13:09,790 --> 00:13:12,159
It would do the lower triangular, although I did.

97
00:13:12,160 --> 00:13:21,400
And this is another example of an argument with a default value that the diag initials false by default.

98
00:13:21,970 --> 00:13:29,170
But if we do a true as the lower triangular portion, including the diagonal elements here,

99
00:13:29,170 --> 00:13:35,300
we change the lower triangular coercion, plus the diagonal happens.

100
00:13:35,380 --> 00:13:39,070
So it shows an end with the values. 10 to 15.

101
00:13:43,170 --> 00:13:52,840
So. It's sometimes, you know, sometimes useful as the dialog or at least.

102
00:13:53,380 --> 00:14:02,030
I mean, personally, I think I used the dialog function more than I forget to try or not try, but it's sometimes useful to know about.

103
00:14:03,540 --> 00:14:18,860
Okay, so I just wanted to maybe talk about a few things to think about, like when you're using a matrix as an input argument and certain functions,

104
00:14:20,300 --> 00:14:33,890
so you can use a matrix as an input argument into a lot of the not just well known built in functions in r like some the mean SD you know,

105
00:14:33,890 --> 00:14:40,880
things like that. You could, you could just input a matrix directly and it works fine.

106
00:14:41,300 --> 00:14:50,030
It's just good to be aware of what it's doing. So when you take it, when you do it, when you have a matrix and you do some of a, some function,

107
00:14:50,030 --> 00:14:58,790
assuming what it's really doing is it's just computing the sum of kind of all the elements of the matrix.

108
00:14:59,660 --> 00:15:07,430
Okay? It's, it's not computing like the sum of certain columns or certain rows.

109
00:15:07,430 --> 00:15:10,850
It's that it's just all of the numbers in the matrix.

110
00:15:10,850 --> 00:15:14,570
It just sums all of those up and returns it as a single number.

111
00:15:15,950 --> 00:15:21,170
We'll talk about doing column sums and rows, sometimes a little later.

112
00:15:22,130 --> 00:15:32,180
It's kind of the same thing with a mean. It just kind of takes all the elements in the matrix and then computes the mean of all of those numbers.

113
00:15:33,110 --> 00:15:44,780
Same thing with the the standard deviation of just groups, all of the numbers together and compute the standard deviation of those numbers.

114
00:15:44,780 --> 00:15:53,810
Okay. So it's good to be aware of that. Let's see, maybe the only one or two other things that it is useful.

115
00:15:54,320 --> 00:16:02,629
So the transpose of a matrix ellipse basically just switch the rows and columns of the matrix to do the transpose.

116
00:16:02,630 --> 00:16:15,320
You just do it just to see and then kind of as an input argument so that you can see here this is the transpose of eight.

117
00:16:15,320 --> 00:16:25,160
So now it's a three by two so as non factor of an eight so that you can convert to a vector,

118
00:16:25,370 --> 00:16:31,700
so you can convert a matrix to a vector directly, you're just using as a vector.

119
00:16:32,540 --> 00:16:45,919
So here with a yes, it returns, it has a vector of like six again by default kind of switching between vectors and matrices.

120
00:16:45,920 --> 00:16:49,670
Everything is done by columns in that order.

121
00:16:49,670 --> 00:16:57,920
So it goes in the vector, it returns, it goes one, two, then three, four and five, six.

122
00:17:00,590 --> 00:17:08,329
Okay. So let's just keep that in mind. Whenever you're pretty much any type of conversion between vectors and matrices,

123
00:17:08,330 --> 00:17:17,150
it's going to kind of do the order that it does things by the column spacing, but I think in every case by default.

124
00:17:18,080 --> 00:17:18,889
So you can see that here.

125
00:17:18,890 --> 00:17:28,360
If we do that, if we convert the transpose of a to a vector, returns the vector one, three, five and then two, four, six and.

126
00:17:30,760 --> 00:17:41,879
She? Look. Oh, here's something also which is useful to know about, especially when you're thinking about multiplication.

127
00:17:41,880 --> 00:17:53,250
So for the addition of subtraction, multiplication and division, all of them,

128
00:17:53,790 --> 00:18:00,210
it does element by element type of addition or subtraction or multiplication divisions.

129
00:18:00,660 --> 00:18:08,549
So if we have two matrices with the same dimension here, these are two by three matrices we do X plus Y.

130
00:18:08,550 --> 00:18:17,340
The matrix that is returns is like individual elements or just either element of what it returns is just X plus five.

131
00:18:18,270 --> 00:18:25,919
Same thing with X minus Y I think is expected.

132
00:18:25,920 --> 00:18:33,020
This is kind of the same thing that you would Oh what does the bio mean here?

133
00:18:33,040 --> 00:18:39,959
Vitacost That's I didn't print out the matrix itself.

134
00:18:39,960 --> 00:18:44,430
It just means the way it fills in the numbers 1 to 6.

135
00:18:45,210 --> 00:18:52,700
So this matrices Y is actually going to be in the first row, it's going to be one, two.

136
00:18:52,860 --> 00:18:57,510
So the first row is one, two, three was in the second rows, four or five, six.

137
00:18:58,230 --> 00:19:03,870
So I'm going to say four by default. It will do this by column.

138
00:19:03,880 --> 00:19:12,060
So if we did not have this here in the X and Y would be the matrix,

139
00:19:13,380 --> 00:19:24,060
it would be the third row and the first row of the one with three five instead of one, two, three.

140
00:19:28,450 --> 00:19:32,350
So this is the matrix that's going to be the matrix.

141
00:19:32,410 --> 00:19:36,280
One, two, three, four, five, six.

142
00:19:37,720 --> 00:19:45,850
If we didn't do that, it would be 1 to 2, three, five, six.

143
00:19:46,000 --> 00:19:49,270
So this is five rows. That's true.

144
00:19:54,310 --> 00:20:02,440
Like interpreting it makes it that matrix. If you didn't include that, it would mean, yeah, that's kind of a default that would make that matrix.

145
00:20:04,510 --> 00:20:08,560
So it's just one I mean, it's not really necessary for this.

146
00:20:08,740 --> 00:20:13,270
It's just kind of just an example. I could I could have created it the other way.

147
00:20:20,380 --> 00:20:26,070
Questions. Not.

148
00:20:26,130 --> 00:20:34,740
Yeah. So it's just. Yeah. So addition and subtraction is kind of like and matches like the linear algebra definition.

149
00:20:35,400 --> 00:20:43,979
This multiplication symbol doesn't, it doesn't do kind of true quote unquote matrix multiplication.

150
00:20:43,980 --> 00:20:48,000
So that's just something to be aware of. It does the the the element by element.

151
00:20:49,800 --> 00:21:02,310
So like what this returns like the i j element of this matrix is excited j times y i j Look, that's just something to be aware of.

152
00:21:06,150 --> 00:21:17,310
So the way you do do the, like, the true matrix multiplication for linear algebra is you use this notation,

153
00:21:17,880 --> 00:21:24,780
you can put a percent sign before and after the multiplication symbol.

154
00:21:25,470 --> 00:21:33,990
So this is like, yeah, this is x multiplied by the transpose in my right.

155
00:21:35,610 --> 00:21:40,620
So it's just something where you want to do kind of true matrix multiplication.

156
00:21:40,620 --> 00:21:45,120
You have to use this symbol. It's not just it's not just the regular multiplication symbol.

157
00:21:48,280 --> 00:21:55,719
Okay. So the next thing to know about is changing the rows or columns.

158
00:21:55,720 --> 00:22:00,700
Sometimes it's useful to have row names or column names in your matrix.

159
00:22:03,040 --> 00:22:12,759
So here's an example of the Matrix X. If you don't give it row names or column names, it just kind of puts it in this format.

160
00:22:12,760 --> 00:22:21,220
There's no specific names. It just looks like a one next to the first row or two next to the second row.

161
00:22:21,670 --> 00:22:32,980
But you can give them names. If I do row names of X and then assign it kind of a vector of names, then they'll have row names.

162
00:22:33,400 --> 00:22:36,910
So this vector should match the number of rows in the matrix.

163
00:22:38,920 --> 00:22:46,120
So here I'm giving it a vector of names. So the way you do vector of names is just a vector of character variables.

164
00:22:46,930 --> 00:22:52,690
So this is just C of the first element of these actors.

165
00:22:52,750 --> 00:22:58,780
The character in the second column is the character B So you can see that here on the printed out.

166
00:23:00,310 --> 00:23:06,360
These are the row names for the Matrix now. Okay.

167
00:23:06,550 --> 00:23:12,790
So you can actually yeah, it's just mentioning I don't use this that much, but yeah,

168
00:23:12,790 --> 00:23:20,350
in some cases it's useful the you can access like rows or columns using the names of those rows or columns.

169
00:23:21,010 --> 00:23:28,950
So if we have this so I mean this is the way we discussed before about accessing the first row, you see,

170
00:23:28,960 --> 00:23:40,120
using the kind of thing you want to access row one, you just access if you just use the number one and then nothing after the comma.

171
00:23:41,020 --> 00:23:51,730
Alternatively, if, if you're the matrix has names, you can just use the name itself for the row that does the same thing.

172
00:23:52,780 --> 00:23:58,360
Then that's just an alternative for accessing rows or columns in a matrix.

173
00:24:02,020 --> 00:24:08,740
So the way you do column names is pretty similar. Just you just use call names instead of row names.

174
00:24:09,250 --> 00:24:17,889
So if I want to give a column names, I just do call names of X is equal to some vector of names.

175
00:24:17,890 --> 00:24:27,040
And here, since this is a two by three matrix, this vector should have length three.

176
00:24:27,040 --> 00:24:33,550
So that three names here. So you can see here. Now the R column names are C one, C two and C three.

177
00:24:35,050 --> 00:24:43,480
And then here if I look at the other suggested example of this, accessing everything by name.

178
00:24:43,480 --> 00:24:55,389
So if we access things by the index number, if we look at O two and columns, two and three, 85 and six.

179
00:24:55,390 --> 00:24:59,170
But alternatively, if we wanted to use names, you could do it this way.

180
00:24:59,170 --> 00:25:09,940
Simply access the row with row named B and the columns with column names C two and C three.

181
00:25:10,540 --> 00:25:17,170
So that would give us the same thing. So that's, that's the row with Ruby and V and then the column names C,

182
00:25:18,160 --> 00:25:28,780
C two and C three because it's just illustrating the access things with row leaves and column names.

183
00:25:30,860 --> 00:25:39,790
I would say this, these are probably more useful C by an an, R by and I probably should have put more examples.

184
00:25:42,800 --> 00:25:46,880
Some examples for next time. So this is quite useful.

185
00:25:47,790 --> 00:25:59,270
These see mine in our binder if you want to kind of join, if you want to call it that way or stack matrices together, you can do see mine are mine.

186
00:26:02,420 --> 00:26:07,879
So these are like vertical or horizontal things like joining matrices.

187
00:26:07,880 --> 00:26:15,050
So see, mine is basically you have two matrices and you kind of want to create a bigger matrix with like

188
00:26:15,560 --> 00:26:21,350
stacking on this way or like putting them side by side and more or less the way to think of it,

189
00:26:22,550 --> 00:26:28,370
you want to add one matrix to the right of a matrix that's C bind.

190
00:26:30,110 --> 00:26:36,439
If you want to stack two matrices on top of each other and kind of return a single matrix, that's our bind.

191
00:26:36,440 --> 00:26:45,800
So that stands for Row Bind. So I'd actually say it's kind of our bind are very useful when you're working with matrices.

192
00:26:46,400 --> 00:26:50,930
So you can see that here we have two matrices, an X and Y.

193
00:26:51,860 --> 00:26:55,309
So Y is actually a square and type of thing.

194
00:26:55,310 --> 00:27:05,930
This just squares every element of X. So you can see here these first three, you see kind of X and Y, the first three columns are from X.

195
00:27:07,400 --> 00:27:16,290
So that's the x matrix. And then the last three columns are four Y, these three columns in the line insurance.

196
00:27:16,400 --> 00:27:26,000
And so and you can see by the kind of just a wider matrix you are and you just create a taller,

197
00:27:26,180 --> 00:27:30,460
taller matrix, at least from the individual matrix matrices.

198
00:27:30,470 --> 00:27:42,200
So when I look at our line, the first two rows are four x plus x matrix and then the Y matrix are the last two rows.

199
00:27:42,470 --> 00:27:46,370
Okay. So that's, that's how our line works, I think.

200
00:27:48,610 --> 00:27:57,670
See find is making the matrices wider and then our binds making matrices taller.

201
00:27:58,360 --> 00:28:08,290
That helps to think of it that way. And again, kind of the the dimensions of the matrix have to match at least in a certain way.

202
00:28:08,290 --> 00:28:17,530
Like if you're doing C behind the number of rows and X and Y have to match, otherwise it will get an error of some kind.

203
00:28:21,020 --> 00:28:26,200
Pretty sure there's an error or some kind or. I'm sure.

204
00:28:27,970 --> 00:28:32,650
Just to double check so if I do sequel to.

205
00:28:36,220 --> 00:28:54,410
Matrix 023 and shrinks if the number of covers is different 3D printing and recycling.

206
00:29:01,610 --> 00:29:05,050
Okay, so that's you trying to do that.

207
00:29:05,770 --> 00:29:15,580
They'll get in error if the if you try to do a C bind where the number of rows is different, you'll get an error.

208
00:29:20,860 --> 00:29:27,339
Although the number of colleagues don't have to be the same, there's not a reason why the number of columns acting in the same kind of a similar thing

209
00:29:27,340 --> 00:29:32,410
with our mine is the number of columns are different and X and Y should give an average.

210
00:29:32,950 --> 00:29:37,810
So the number of rows can be different in the matrices x and y.

211
00:29:44,640 --> 00:29:48,870
All right. Okay.

212
00:29:48,870 --> 00:29:52,440
So really, I didn't label this correctly.

213
00:29:52,680 --> 00:30:01,319
I guess this section is really more concerned with doing functions on matrices where

214
00:30:01,320 --> 00:30:08,670
where we want to apply the function to each row separately or each column separately.

215
00:30:09,240 --> 00:30:16,530
Like I said before, like if you just use the sum function by itself for a matrix, it just takes a sum of all of the elements.

216
00:30:17,100 --> 00:30:22,740
But in many cases you want to, for example, take the sum of each column or the sum of each row.

217
00:30:23,370 --> 00:30:27,540
So that's really what we're talking about in this section.

218
00:30:29,100 --> 00:30:32,700
So let's look at this example again, where we have this matrix.

219
00:30:32,700 --> 00:30:39,120
A There are built in functions that can do row sums and column sums.

220
00:30:39,720 --> 00:30:46,900
So the function row sums will take the sum of some of the personalities one plus three,

221
00:30:46,930 --> 00:30:54,509
four, five, nine, and then the second row is two plus four plus six, which is 12.

222
00:30:54,510 --> 00:30:56,280
So I can return to that as a fact.

223
00:30:57,840 --> 00:31:07,950
So this is nine and 12 is just a vector is linked to a similar thing with call sums of six to the sum of each column and

224
00:31:07,950 --> 00:31:18,570
returns it as a vector where the number of components returns by call sums is the same as the number of columns in our matrix.

225
00:31:19,010 --> 00:31:23,310
And there's also functions like row means and column needs as well.

226
00:31:23,760 --> 00:31:31,860
So row needs just takes the median of each row and returns that as a vector.

227
00:31:33,480 --> 00:31:40,560
So those that these functions look perfectly fine.

228
00:31:41,340 --> 00:31:46,530
But I wanted to talk about how you would implement your own kind of rows sums

229
00:31:46,560 --> 00:31:56,370
function just kind of as a way of introducing your life to apply type functions.

230
00:31:57,120 --> 00:32:04,800
So if you wanted to write your own kind of row sums, function separately, different ways of doing it.

231
00:32:05,790 --> 00:32:10,050
One way of doing it is with a single loop.

232
00:32:12,570 --> 00:32:16,260
So here is the way I wrote this function.

233
00:32:16,710 --> 00:32:23,940
I first kind of initialize a vector with length equal to the number of rows of x.

234
00:32:24,810 --> 00:32:33,960
Okay. So since the thing you want to return should be a vector with the number of components equal to the number of rows of x.

235
00:32:35,400 --> 00:32:39,030
And then I'm just going to go through a little bit, fill in each entry one at a time.

236
00:32:39,030 --> 00:32:44,640
So the number of iterations of the loop is equal to the number of rows of X.

237
00:32:45,360 --> 00:32:49,649
So that's what I've done here for I am one for the number of rows of X and in

238
00:32:49,650 --> 00:32:59,550
each iteration I fill in the entry for right with the sum of the the I throw x.

239
00:33:00,090 --> 00:33:08,850
So this year this this sum of x I comment is just the sum of the the I throw of x, right?

240
00:33:09,660 --> 00:33:17,490
That's all it is. And then I just return this right at the end and then this should run perfectly fine.

241
00:33:18,420 --> 00:33:29,639
Just decide as an example if we can row something and then compare it with my row sums of Oh, what is the comma and right tax bracket?

242
00:33:29,640 --> 00:33:37,290
I call that just means it's sum setting it as a a vector.

243
00:33:38,100 --> 00:33:47,340
So is it x i comma will return like the ice row the entire high for all of x.

244
00:33:48,660 --> 00:33:59,040
That said, I want more time. So this x i comma returns the entire I throw of x.

245
00:33:59,370 --> 00:34:03,750
Okay, so what will happen if you don't have the power of x?

246
00:34:03,760 --> 00:34:07,080
I will finish the sum of excited.

247
00:34:07,560 --> 00:34:11,250
Yeah. Oh so you add each.

248
00:34:12,130 --> 00:34:18,570
I don't do something intellectually, intellectually run but it won't, I won't return.

249
00:34:18,570 --> 00:34:19,649
What you want it to return.

250
00:34:19,650 --> 00:34:34,170
So I'll say this is X and then as I said before sum x one is just a single number, so x I guess x and this example x one is what we had before.

251
00:34:35,700 --> 00:34:42,780
So what I'm using is one, two, this would be like that vector one, two, three, and then x.

252
00:34:42,900 --> 00:34:44,570
One is actually just the first element.

253
00:34:46,010 --> 00:34:52,309
So actually, just when you think this summer will just be the number itself, so it would be computing something,

254
00:34:52,310 --> 00:35:02,650
but it's not like a Rose song and I think it would just retire and just go just because this is like x2.

255
00:35:02,660 --> 00:35:05,510
It would just actually I think it would actually just turn the page.

256
00:35:05,600 --> 00:35:14,490
Like the first column itself is actually what happened before of Oh, you're interested.

257
00:35:14,750 --> 00:35:24,040
So x one, x comma one. Yeah. So that would be that would be the one for.

258
00:35:24,050 --> 00:35:28,950
Okay, now just the first column. Okay.

259
00:35:31,490 --> 00:35:40,370
So this is just for the X I come to take the AI through.

260
00:35:41,210 --> 00:35:50,350
Okay. So these are. Yeah, these are just basically comments.

261
00:35:50,360 --> 00:35:58,750
So yeah, I think like I said before, like writing of this type of function, you know, it works perfectly fine.

262
00:35:58,800 --> 00:36:04,720
I think it's a little bit it's a little bit extra effort than you and you

263
00:36:04,720 --> 00:36:12,300
would like you would like to have whenever you want to compute a like column.

264
00:36:12,550 --> 00:36:17,290
Like I'm calling it like column specific or row specific summary statistics.

265
00:36:17,290 --> 00:36:30,590
So it's pretty common. Pretty common goal is to compute certain summary statistics for each, each row or each column like nairobians and column.

266
00:36:30,610 --> 00:36:41,590
These are probably the most well known. But you I mean, there's many others like you might want to compute a median for each row of each column.

267
00:36:42,160 --> 00:36:47,500
I don't even think there's a built, so I don't think there's a built in column medians or cut.

268
00:36:47,500 --> 00:36:51,970
All are row medians in all. So when you want to do something like that,

269
00:36:52,600 --> 00:37:03,549
you don't want to have to write your own function every time you want to compute some type of some summary statistic for each column number.

270
00:37:03,550 --> 00:37:09,730
So there's kind of a useful family functions that allow you to do this.

271
00:37:10,390 --> 00:37:13,670
So basically these are the applied functions.

272
00:37:13,670 --> 00:37:18,970
So these allow you to like for each row or column of a matrix,

273
00:37:19,720 --> 00:37:29,049
it kind of allows you to have a function that kind of takes each row or column as input and then kind of

274
00:37:29,050 --> 00:37:35,980
applies that function to each column or or row and then kind of returns everything as a single vector.

275
00:37:35,980 --> 00:37:39,520
And that's really what apply does.

276
00:37:43,530 --> 00:37:51,660
Hopefully it's so hopefully the examples make it a little bit more clear what the kind of apply does.

277
00:37:52,140 --> 00:37:56,760
So like you can do apply to do the same thing at zero sums or column sums.

278
00:37:57,750 --> 00:38:05,910
So if you wanted to use apply to compute the columns or the row sums of a matrix you would have applied.

279
00:38:07,440 --> 00:38:17,850
I mean, you can use row sums, but then to do the same thing, you can do it like apply a comma, one comma, sum.

280
00:38:18,710 --> 00:38:23,880
That's, that's another way of computing neuroscience for call sums.

281
00:38:24,390 --> 00:38:30,870
The way you do that and apply, it's just you do apply a comma to comma sound.

282
00:38:32,490 --> 00:38:44,160
So this kind of second argument of apply, that just means you're any equal one or 211 just means you're applying it across rows.

283
00:38:44,160 --> 00:38:49,080
And then two is like across conferences to try to make you think about apply.

284
00:38:50,010 --> 00:38:53,850
So here's kind of the general formula for a plot.

285
00:38:55,110 --> 00:39:03,590
So the way applied works come the first argument for apply is a matrix like we have here which read a matrix.

286
00:39:03,620 --> 00:39:11,399
And the second parameter of our argument is the dimension that you're interested in looking at.

287
00:39:11,400 --> 00:39:17,460
It's basically just rows or columns. One is for rows, two is for columns of the second.

288
00:39:19,140 --> 00:39:23,640
And the second argument in apply that you should have should equal one or two.

289
00:39:24,750 --> 00:39:33,900
The third parameter or argument is the name of a function that you want to apply for each row or each column.

290
00:39:34,740 --> 00:39:41,730
So the way to kind of interpret this is you have to apply a one and then the function sum.

291
00:39:42,570 --> 00:39:49,500
That means that we're kind of we're using the sum function on each row of a list,

292
00:39:50,220 --> 00:40:04,710
but it's going to return as a vector with the same number of rows as if it's if we have apply a comma to cover some,

293
00:40:05,130 --> 00:40:11,280
it's going to return a vector with the same number of columns as a. Okay.

294
00:40:12,930 --> 00:40:23,100
Yeah. So you can see that here we've applied a to mean that's that's the same thing as called means.

295
00:40:23,580 --> 00:40:32,220
So here's an example or it's actually useful if you want to find the maximum of each column,

296
00:40:32,910 --> 00:40:40,889
the maximum number in each column you can do apply a comma to common max so that returns the maximum of each column.

297
00:40:40,890 --> 00:40:49,320
So you can see that here, the max first columns to the max to the second column is for Max, and the third column is six.

298
00:40:50,130 --> 00:40:54,090
So here's one case where it's useful, since I don't think, at least not in my face.

299
00:40:54,090 --> 00:41:01,560
Ah, there is not a, there's not a built in function that computes the maximum for each column.

300
00:41:02,040 --> 00:41:07,050
So that's kind of where I apply comes in handy.

301
00:41:07,560 --> 00:41:17,700
You can kind of easily compute the maximum maximum for each column.

302
00:41:17,700 --> 00:41:21,770
So what is this example? So let's see our by.

303
00:41:21,780 --> 00:41:25,720
Okay, so we have this example are buy and right.

304
00:41:28,960 --> 00:41:35,310
Also X is just going to be X is going to have two rows, right?

305
00:41:35,320 --> 00:41:39,940
Since we're just our binding two vectors, that's what our line does.

306
00:41:43,360 --> 00:41:48,820
And then these are going to have a length 12, right?

307
00:41:49,840 --> 00:41:55,870
And then we can write it out. So for this example, x.

308
00:42:00,010 --> 00:42:04,390
Belief in myself and see x would be.

309
00:42:09,760 --> 00:42:13,870
What was each one? No, no.

310
00:42:13,870 --> 00:42:17,740
Sorry. Sorry. These are not 12. These are six.

311
00:42:17,950 --> 00:42:21,489
Sorry. I was reading that as one column.

312
00:42:21,490 --> 00:42:29,320
41114441114241.

313
00:42:35,110 --> 00:42:41,190
And then six I think since.

314
00:42:47,410 --> 00:42:57,430
That's what it looks like. So it's RBI and it's stacks kind of the two factors on top of each other.

315
00:42:58,510 --> 00:43:03,110
And then if we do apply the sun, so that does the columns.

316
00:43:04,090 --> 00:43:08,740
So that should be like actually had a dimension six, right.

317
00:43:10,240 --> 00:43:30,040
So I to it was just the sum of the top is just nine and it's like nine, nine, nine, ten, ten, ten.

318
00:43:34,270 --> 00:43:38,180
All right. So then we just look at the second component of this.

319
00:43:45,250 --> 00:43:48,570
That's mine. That's.

320
00:43:48,820 --> 00:43:54,880
I can see. The summary of the state.

321
00:43:55,600 --> 00:44:00,489
That's the answer to this question.

322
00:44:00,490 --> 00:44:04,190
So, yeah, I don't know if I mentioned it, you know.

323
00:44:04,210 --> 00:44:16,720
So yeah, if you do r bind with vectors, basically experience is going to stack the two vectors on top of each other and create a matrix with two rows.

324
00:44:17,080 --> 00:44:25,210
If you did see by and with two vectors, it's going to just put them side by side and it'll create a matrix with two columns.

325
00:44:27,130 --> 00:44:38,860
Okay. Okay. So here's an example of how to use apply if if there's like a, a function that does not exist at least in kind of place.

326
00:44:38,860 --> 00:44:44,440
Ah so in this example we're using a function that exists in max, the max function.

327
00:44:48,250 --> 00:44:52,300
So when that's the case, you can just use the name of the function that's already there.

328
00:44:52,720 --> 00:45:01,660
In some cases you kind of want to want to use your own function that you've written to a and apply that to each column of a matrix.

329
00:45:01,660 --> 00:45:05,410
So you can certainly do that.

330
00:45:05,410 --> 00:45:10,090
So I, I just did that try to illustrate that with this example.

331
00:45:10,630 --> 00:45:16,270
So no, I don't think there's a built in R function that computes the sum of squares of a vector.

332
00:45:17,080 --> 00:45:26,140
Okay. So let's say we wanted to compute the sum of squares of each row our column.

333
00:45:26,620 --> 00:45:37,760
How could we do that using apply? So I did that here with this example and I think it really shows how apply gives you a lot of flexibility.

334
00:45:37,780 --> 00:45:44,350
You can kind of use your own functions I have written and apply them to compute

335
00:45:45,860 --> 00:45:52,060
and you can apply them to find column wise or row wise summary measures.

336
00:45:53,020 --> 00:45:56,410
Okay, so I just first define my own function here.

337
00:45:57,070 --> 00:46:02,650
Excuse sum, it's a function of x where I'm thinking of x is just a vector.

338
00:46:03,730 --> 00:46:06,970
So I think they should think of x as a numeric vector here.

339
00:46:07,360 --> 00:46:13,780
And I'm just returning the sum of squares, the sum of the elements squared.

340
00:46:13,780 --> 00:46:22,689
So this x times x is a vector where each element is just the square of the corresponding element of x.

341
00:46:22,690 --> 00:46:24,610
And I'm just summing all of that. Okay?

342
00:46:24,740 --> 00:46:33,229
This is just the sum of the squares, of the elements of that vector, and then we can use it directly on different matrices.

343
00:46:33,230 --> 00:46:39,880
So if I just do apply a one excuse sum that's going to return.

344
00:46:45,070 --> 00:46:48,309
The sum of squares for each row.

345
00:46:48,310 --> 00:46:52,300
So we look back in a row as it was one.

346
00:46:53,920 --> 00:47:02,010
It was this type of thing. So the sum of squares of the first row is one plus nine plus 25, right?

347
00:47:02,020 --> 00:47:17,640
Since 35. And then the second one it's four plus 16 plus 36, which is six return.

348
00:47:18,850 --> 00:47:28,210
Yeah. So it's 35 and 56. So it's, it's just giving the sum of squares of each row.

349
00:47:28,750 --> 00:47:34,300
Okay. So this is something that can be very useful once you've kind of written this little function,

350
00:47:34,750 --> 00:47:44,229
you can compute this summer squares for each row or for each column.

351
00:47:44,230 --> 00:47:47,950
We could use it for any matrix that you want.

352
00:47:49,030 --> 00:47:57,909
Okay. So another option is you can actually you actually don't necessarily have to write the functions kind of separately.

353
00:47:57,910 --> 00:48:02,500
You can define the function within kind of the applied function.

354
00:48:03,140 --> 00:48:18,650
And I think that's really only useful for. If the function is not super complicated, then you want to compute.

355
00:48:19,350 --> 00:48:26,480
Okay, so in this case, it wasn't super complicated. It's just a return of the sum of x squared.

356
00:48:27,800 --> 00:48:30,680
But if you want to do that with applied,

357
00:48:31,040 --> 00:48:38,749
all you have to do is do a function of X and then just what you want it to return in kind of inside of these curly braces.

358
00:48:38,750 --> 00:48:43,100
So this kind of just defines the function within the apply statement itself.

359
00:48:43,110 --> 00:48:45,410
So then actually it actually works.

360
00:48:46,110 --> 00:48:55,610
It's probably not a good idea, kind of like a fairly complicated function where you have multiple lines of code inside of the body of the function.

361
00:48:55,610 --> 00:49:00,560
But if you have something that's just like a single line, this is pretty convenient.

362
00:49:01,970 --> 00:49:05,960
Okay, so this does the exact same thing as we had before.

363
00:49:08,270 --> 00:49:11,990
Or you don't? Yeah. You don't necessarily have to have the parentheses, actually.

364
00:49:12,680 --> 00:49:16,399
I'm sorry. The curly braces is a single line function.

365
00:49:16,400 --> 00:49:23,150
So I think since it's a single line function, you have to have that because you can actually write it this way.

366
00:49:23,870 --> 00:49:29,570
This is kind of probably the simplest way to try to write it that apply function.

367
00:49:32,180 --> 00:49:48,140
Okay. So your function, I would say in most cases, the function that you use with applied returns a single number, but it doesn't have to.

368
00:49:50,150 --> 00:49:54,709
Although there are some limits on what types of things it can return,

369
00:49:54,710 --> 00:50:02,780
but you can have it return like a vector if you define this function here that returns the minimum and the maximum.

370
00:50:03,290 --> 00:50:10,129
So this function is like returning a length to a vector in that case applies in the return of matrix.

371
00:50:10,130 --> 00:50:27,080
So. And so I mean, so in a way, we look at the men in the backs of the women of this row as one in the backs as five.

372
00:50:27,830 --> 00:50:36,530
So the order it uses, it kind of does it, you know, by rote kind of this way.

373
00:50:36,560 --> 00:50:41,870
So this is one is the minimum of the first column.

374
00:50:42,350 --> 00:50:51,200
Five is also the maximum of the first column. Two is the minimum, the second column and six is the maximum of the second column.

375
00:50:52,820 --> 00:51:02,150
So you can use you can return kind of a amount of a vector as your function and then use that and apply statement.

376
00:51:02,480 --> 00:51:10,700
In that case, the when you run apply is going to return it's going to return a matrix rather than kind of a single vector.

377
00:51:15,560 --> 00:51:21,500
Okay. So that's one I'd say it's a little bit more common to have a function that returns a single number.

378
00:51:22,070 --> 00:51:26,390
But you could definitely this is this is certainly not a valid option.

379
00:51:27,470 --> 00:51:31,490
Okay. So how much time do we have?

380
00:51:35,510 --> 00:51:40,130
Let's let's let's run through this fairly quickly.

381
00:51:40,140 --> 00:51:53,990
So this is just maybe just to make sure we're comfortable with up with all of the the and the syntax for matrices, basically.

382
00:51:54,740 --> 00:51:59,540
So let's say we have a want to write a function has two arguments and B those are both matrices.

383
00:52:00,230 --> 00:52:09,440
So they have the same dimension. I mean, we'll just assume that and it's going to return a matrix D of the same the same dimension.

384
00:52:09,450 --> 00:52:22,010
So the IJA element of D should equal AJ if A is AJ is less than B and then kind of vijay otherwise.

385
00:52:22,910 --> 00:52:27,049
So I guess you could write this multiple ways.

386
00:52:27,050 --> 00:52:32,710
I guess a nested for loop is one way you can do logical kind of sub setting.

387
00:52:32,720 --> 00:52:41,830
Although I don't know if. The logical talked enough about logical assumption for matrices,

388
00:52:41,830 --> 00:53:02,760
but for the for loop way I would do it is just so I would say okay, let's call it doing matrix is a function function of A and B.

389
00:53:07,420 --> 00:53:12,850
And so you wanted it away? Probably I would do it as you just say.

390
00:53:12,850 --> 00:53:22,329
D is assigned D the value F and then you replace those values when necessary.

391
00:53:22,330 --> 00:53:27,600
So you only need to replace the values.

392
00:53:27,850 --> 00:53:33,459
If D starts out with the equal to A, then you only need to replace it.

393
00:53:33,460 --> 00:53:44,020
If for the case when J is greater than or equal to the IJA, when the case AJ is less than big,

394
00:53:44,020 --> 00:53:53,020
you don't really need to do anything since it's kind of, you know, the already j r equals AJ.

395
00:53:55,370 --> 00:54:04,339
So I want to say so what do we want to do? We only need to replace things when AIG is greater than or equal to be AIG.

396
00:54:04,340 --> 00:54:15,890
So I'll just put it. I'll be keep forgetting if AIG is greater than or equal to be AIG.

397
00:54:22,520 --> 00:54:27,229
That's the condition. Okay, let's just remind.

398
00:54:27,230 --> 00:54:30,770
I do. It's probably better to put the loot first.

399
00:54:31,340 --> 00:54:35,120
So if we do a nested for loop, you want to loop.

400
00:54:36,020 --> 00:54:45,190
When you want to loop over the all of the elements of the matrix, you have to do like a for I and A for one for J.

401
00:54:46,990 --> 00:54:51,620
And from there I just put the statement first and set it up.

402
00:54:52,670 --> 00:54:55,670
Forget about which condition we need.

403
00:55:11,790 --> 00:55:19,080
Okay so I'm have a nested for loop for I loop over the number of columns, the number of row,

404
00:55:19,110 --> 00:55:34,300
all of the rows of a and all the columns of A and then I only change di j and when I get is greater than or equal to what's behind.

405
00:55:35,880 --> 00:55:40,470
So no. And it's H.J.

406
00:55:44,120 --> 00:55:51,080
Sorry, Vijay. Then return the.

407
00:55:57,060 --> 00:56:01,310
So did Matrix. So that should run.

408
00:56:02,840 --> 00:56:14,329
Then you can run. Let me try to be defined to use two.

409
00:56:14,330 --> 00:56:17,920
Arm three.

410
00:56:21,850 --> 00:56:28,540
From. Excuse me, sir.

411
00:56:32,510 --> 00:56:39,720
That's dangerous. This is just something he set an example around.

412
00:56:46,910 --> 00:56:50,840
Okay. So this is kind of what it should look like.

413
00:56:54,980 --> 00:57:01,700
There's an alternative, maybe. I think that's probably the right thing.

414
00:57:02,240 --> 00:57:06,830
There's an alternative way to do it if you do.

415
00:57:09,620 --> 00:57:24,340
If you do a logical sub setting. I mean, I write another function called let's say D matrix two actually, which is probably easier.

416
00:57:24,350 --> 00:57:31,190
You can probably, let's say D is a and then we d d I could do it this way.

417
00:57:31,190 --> 00:57:44,570
A d a b is greater than or equal to the it's a sign the value of B is greater than or equal to E.

418
00:57:47,000 --> 00:57:57,410
So I don't know if I actually talked a lot about logical sub setting of matrices in this way that you can do it this way.

419
00:58:01,520 --> 00:58:08,850
You should get the same thing in the same office.

420
00:58:16,760 --> 00:58:22,220
Yeah. These are these are the same. Either way, we're getting the same result.

421
00:58:22,910 --> 00:58:33,469
So this is you can with matrices, you can do this kind of logical sub setting and replacement, basically the same notation as with vectors.

422
00:58:33,470 --> 00:58:36,710
So if you were doing like if I was doing,

423
00:58:37,820 --> 00:58:52,309
I wanted to subset a vector according to a certain logical condition and then replace those elements with a certain vector of the same length.

424
00:58:52,310 --> 00:59:03,680
You would use this notation if you were thinking of De and B as vectors, or you can actually use the exact same syntax for four matrices and it works.

425
00:59:04,790 --> 00:59:09,260
So this actually does the same thing as the the nested for loop above.

426
00:59:09,920 --> 00:59:19,670
So just replace I first kind of initialize D as equal to A and then here I look at the this is basically looking at

427
00:59:19,670 --> 00:59:31,340
the subset of D where elements of A are greater than or equal to B and then replacing those elements of D with the B,

428
00:59:31,340 --> 00:59:41,600
so b at least B where on the same subset basically replacing the elements of B using that on the same subset.

429
00:59:41,600 --> 00:59:50,780
So that kind of matches up. Correct. This is and also this is a lot faster way of doing it, but these two functions do the same thing.

430
00:59:59,960 --> 01:00:06,440
So that was the exercise.

431
01:00:09,080 --> 01:00:15,070
So yeah, I think maybe any questions before I move on to the to list.

432
01:00:15,080 --> 01:00:18,530
I think that that wraps up matrices for now.

433
01:00:22,720 --> 01:00:30,340
If not, let's just keep moving on the list solicited literally the next big data structure

434
01:00:30,340 --> 01:00:36,280
and are so let's see this is kind of a table showing how I would say kind

435
01:00:36,280 --> 01:00:42,940
of the four main data structures in our fit together and there's a lot more

436
01:00:42,960 --> 01:00:48,760
details involved and these are kind of a broad view of how they're purpose and.

437
01:00:48,760 --> 01:00:59,960
All right, so the atomic factor, earliest factor that we talked about first in a matrix is really just kind of a two dimensional version of fact.

438
01:00:59,980 --> 01:01:03,910
Your next thing is blast. So it's kind of like a vector.

439
01:01:03,910 --> 01:01:07,270
It's kind of single dimensional in a sense.

440
01:01:07,270 --> 01:01:12,910
But it can be the distinction between a list and the kind of irregular vectors that it can have.

441
01:01:13,510 --> 01:01:21,870
You have different types of data, so a list can have numbers on certain components, characters and other components.

442
01:01:21,870 --> 01:01:25,690
So that's kind of the main the main distinction there.

443
01:01:26,230 --> 01:01:28,209
I guess data frames is the last thing here.

444
01:01:28,210 --> 01:01:37,900
It's kind of like a it's a list in the sense that it's you can have different types of data, but it has kind of the same structure as a matrix.

445
01:01:37,900 --> 01:01:45,130
So a data frame is can have has a certain number of rows and a certain number of columns.

446
01:01:47,330 --> 01:01:54,350
Okay. So here is just kind of an example of a case where you might want to use a list.

447
01:01:55,040 --> 01:02:01,340
So in many cases, you have a data that has a certain thing.

448
01:02:02,180 --> 01:02:13,549
That's where kind of there's different components that have that should have different data types.

449
01:02:13,550 --> 01:02:24,150
So I had an example here where I have a single very variable which has I can go that is like employee info one.

450
01:02:24,230 --> 01:02:30,390
I would probably want to store that as a single variable, but there's kind of different types of data that you have to store.

451
01:02:30,420 --> 01:02:37,400
So you have a number which is like maybe an ID number, the character variable that you have to store,

452
01:02:37,970 --> 01:02:42,650
and there might be some logical variables that you also want to store.

453
01:02:42,650 --> 01:02:47,750
So you can store all of that in a list. And this is kind of the syntax that you use.

454
01:02:47,750 --> 01:02:58,520
You used it as a function list and then kind of components of the list are separated by commas, kind of the same way you you create vectors.

455
01:03:01,670 --> 01:03:10,100
You can give the components of the list different names and you don't absolutely have to, but it's common to do so.

456
01:03:10,100 --> 01:03:15,770
And it's, it's an option. So here you can give the each component of the list name.

457
01:03:15,780 --> 01:03:24,140
So like the first time it's the name of the first component of this list is is name I guess.

458
01:03:24,710 --> 01:03:32,120
And then there's the name of the second component is utility and then the name of the third component is faculty.

459
01:03:32,890 --> 01:03:36,440
Okay? So you can name the components of your list.

460
01:03:37,110 --> 01:03:42,889
It's common to do so, but you don't have to. You can't have you have unnamed list.

461
01:03:42,890 --> 01:03:48,740
So I can just put the these values here without the name first.

462
01:03:49,250 --> 01:03:50,390
That's perfectly fine.

463
01:03:52,890 --> 01:04:04,400
You and so when you print out this list the way it outputs it, it puts the name of each component kind of after these dollar signs.

464
01:04:05,900 --> 01:04:10,970
So this dollar sign name means that the first component is named name.

465
01:04:11,720 --> 01:04:17,840
And then right below that, that gives kind of the value in the in the first component.

466
01:04:18,200 --> 01:04:22,120
Okay. The value that started the first component, same thing here.

467
01:04:22,210 --> 01:04:28,970
The second component has a name utility and this is the value still attached.

468
01:04:29,020 --> 01:04:38,540
It's a number. So that's that's kind of the way to read the list output, at least when you're when you print things out to the screen.

469
01:04:38,690 --> 01:04:42,680
Okay. And then you can access at least one. It's a named list.

470
01:04:43,220 --> 01:04:52,370
You can access the individual components by just doing the dollar sign and kind of the name of the component that you want to look at.

471
01:04:52,370 --> 01:05:00,890
So if I want, I have this list amp underscore info and I want to look at what's stored in the the name component of that list.

472
01:05:01,370 --> 01:05:12,140
I just do dollar sign name. So one way to if this works, if it's a named list, some of the components are name.

473
01:05:12,620 --> 01:05:21,680
We could use this kind of dollar sign notation to access things here.

474
01:05:21,690 --> 01:05:31,100
Just another example, just to make sure we're clear on list. This is also a list that has numeric, logical and character components.

475
01:05:31,730 --> 01:05:38,180
This is also a named list. So this has the names of the components are A, B and C.

476
01:05:38,750 --> 01:05:49,280
So this list is here. The first components named A, it's a factor of like three.

477
01:05:49,280 --> 01:05:55,549
And then the second components are vector of like two. Then the last one is a single logical.

478
01:05:55,550 --> 01:06:08,240
So I guess I wanted to include this point is that the so here these are in this example like the components were kind of like a single value thing.

479
01:06:08,240 --> 01:06:13,010
They said this is just a character vector of length one, this is a numeric vector of length.

480
01:06:13,010 --> 01:06:19,340
One of the individual components of a list can be vectors themselves.

481
01:06:23,420 --> 01:06:28,639
So yeah, you can see that here.

482
01:06:28,640 --> 01:06:37,280
I would say the way I would state this is that the first component of this list is a vector of length three.

483
01:06:37,940 --> 01:06:45,890
So actually this list here, this list here is really the length of the list is three, but some of.

484
01:06:45,940 --> 01:06:50,550
But I like the individual components of the list can actually be longer than that.

485
01:06:50,860 --> 01:06:58,600
So the first component of this list is a factor.

486
01:06:58,930 --> 01:07:02,469
Okay. We've been looking at a total length of the list is three.

487
01:07:02,470 --> 01:07:08,080
But the individual components can certainly be factors they don't have or they can even be matrices.

488
01:07:08,080 --> 01:07:24,700
They don't have to be kind of single numbers. So like I said before, the first two examples, those are examples of creating named lists.

489
01:07:25,330 --> 01:07:31,920
So each component has a name associated with it, but you don't have to create lists that way.

490
01:07:31,930 --> 01:07:40,810
You can create unnamed lists. So there's no, you know, the components don't have kind of names for the labels.

491
01:07:42,190 --> 01:07:49,209
The way you access kind of individual elements of a list is this kind of double bracket type of syntax.

492
01:07:49,210 --> 01:07:58,810
So if you want to access the case element of a list, you do kind of double bracket with K inside that two brackets.

493
01:07:59,800 --> 01:08:08,350
So this I had an example here where I create a list of why the list has like three.

494
01:08:09,190 --> 01:08:12,100
The first component is the spectrum of one, two, three.

495
01:08:12,940 --> 01:08:20,760
So if I want to access that first component, since it doesn't have a name, I can just do why a double bracket one not.

496
01:08:20,770 --> 01:08:24,070
I'll return on this first component factor. One, two, three.

497
01:08:26,620 --> 01:08:34,300
You want to access. The second component would just be y fellow bracket two and it would retain this character vector.

498
01:08:39,610 --> 01:08:47,629
If it's a named list, you can access it really either way, actually can access it by a name or using the the actual number index.

499
01:08:47,630 --> 01:08:52,840
So if I had this factor, sorry, this list X, it's a named list.

500
01:08:52,840 --> 01:09:04,900
I can access the first component by name, do a dollar sign a or you can access it by looking at the number using this double bracket notation.

501
01:09:05,890 --> 01:09:15,820
So if it's a named list, you can basically take either option to access the elements and access it by the

502
01:09:15,820 --> 01:09:21,610
name of the component after the dollar sign or the actual numeric component itself.

503
01:09:23,830 --> 01:09:36,370
Okay. Yeah, that's basically just what we cover so far as creating list with the list function and then how to access individual elements.

504
01:09:37,870 --> 01:09:46,439
I just listed a few extra. Useful things to know about when we're working on lists sometimes are.

505
01:09:46,440 --> 01:09:55,649
A lot of times it's useful to know kind of what's in the list, or at least the names that are the main things that are in the list.

506
01:09:55,650 --> 01:10:07,470
And if the if kind of the names are labeled in a helpful way, just looking at all the names in the lists can sometimes be helpful.

507
01:10:08,430 --> 01:10:15,899
So if we have a list called X, I just want to see the names of the components of this list.

508
01:10:15,900 --> 01:10:19,620
I can just do names of X. So I think that was the previous example.

509
01:10:19,620 --> 01:10:28,050
So this is X to the names of the components are A, B and D, if you just want to see what those are, just do names of X.

510
01:10:28,560 --> 01:10:30,920
So there's our return, A-B and D.

511
01:10:32,490 --> 01:10:39,650
If you want to find the length of the list, you can just use the length function as you would with a if with a vector.

512
01:10:40,440 --> 01:10:46,980
Just the thing to be careful about is that the length of the list is the number of components of the list.

513
01:10:49,770 --> 01:11:00,059
So like I said before, the length of this list is three and it really doesn't matter how big these individual components are.

514
01:11:00,060 --> 01:11:05,790
You could have the first element. You could have a matrix with a million rows.

515
01:11:05,790 --> 01:11:12,429
And it doesn't matter that. The length of the list would still be three.

516
01:11:12,430 --> 01:11:20,020
So it's really just the number of the components here that we've separated by commas that determine the length of the list.

517
01:11:21,520 --> 01:11:25,170
So you can see here, here, the length of the list is three.

518
01:11:27,340 --> 01:11:38,920
Okay, so here's ADD. So I'm not not adding in terms of the numerical additions, but adding extra components to an existing list.

519
01:11:39,640 --> 01:11:44,020
Okay. So let's say we have this this list X, it has three components.

520
01:11:44,530 --> 01:11:47,530
Let's say if I want to add additional component components.

521
01:11:47,530 --> 01:11:51,430
So I want to add a fourth element of the list and a fifth element of the list.

522
01:11:54,040 --> 01:11:57,219
It's pretty easy. You can just add it directly.

523
01:11:57,220 --> 01:12:02,170
You can don't have to use it. You don't have to use the C function or anything.

524
01:12:02,170 --> 01:12:09,790
You just have to do assignment and it will kind of expand the size of the list and add an additional component to the list.

525
01:12:10,570 --> 01:12:18,420
So if I just want to add a fourth element to the to the list, I can do it by a numerical index.

526
01:12:18,420 --> 01:12:21,790
So X of four is assigned the value four.

527
01:12:21,790 --> 01:12:29,650
So after running this code, it'll be the list of four components.

528
01:12:32,080 --> 01:12:42,010
And then if I run this next line of code X dollars 99 assigning the value five, the list will now have five five elements.

529
01:12:42,010 --> 01:12:47,560
And then we can select the last element of the list of all five.

530
01:12:48,220 --> 01:12:58,780
So you can see that here I've just outlined. So before we, we added these extra elements, X was just these first three elements, A-B.

531
01:12:59,350 --> 01:13:06,640
But then when we ran the last chunk of code, we added the fourth element to four and the fifth element equal to five.

532
01:13:07,300 --> 01:13:17,740
And you can see here, you can actually have you actually have a list that's mixed between named and unnamed.

533
01:13:20,020 --> 01:13:28,210
So you can have lists where every component is named or you can have a list where none of the components have name names,

534
01:13:28,240 --> 01:13:33,910
or you can have a list where some of the components have names and some of them don't.

535
01:13:34,420 --> 01:13:41,650
So you can see this here. This is an example of that. So the first three components have names assigned to them.

536
01:13:42,310 --> 01:13:47,650
The fourth component is not there's no name associated with the fourth element of this list.

537
01:13:48,220 --> 01:13:58,810
And then the fifth element has the name. So you can have, you know, all they don't have to be a strictly named or a named list if you don't want to.

538
01:13:58,900 --> 01:14:08,320
Although I'd say it's it's more typical to have if you're going to create a list to have it either all have names or all

539
01:14:08,500 --> 01:14:15,670
don't have names but it's it's definitely not a it's this it's not an across requirement when you're working with lists.

540
01:14:18,260 --> 01:14:22,580
Okay. Just one or two more slides.

541
01:14:24,380 --> 01:14:33,430
Okay. So this is just. I'm just trying to illustrate why you would want to use lists.

542
01:14:35,380 --> 01:14:41,200
So there's I guess there's there's multiple reasons why you would want to use list, I would say.

543
01:14:42,650 --> 01:14:51,970
You know, one example that's common is, is when you have functions that are that return different types of output.

544
01:14:52,930 --> 01:15:03,040
So a lot of it's it's common for a lot of the well-known functions in order to return to a bunch of

545
01:15:03,040 --> 01:15:09,790
different types of output rather than a single number or a single vector or something like that.

546
01:15:10,960 --> 01:15:15,940
In those cases, what you'll see is that it's, it's usually what is returning is a list.

547
01:15:16,390 --> 01:15:20,799
Okay. So this is an example of that or at least for a function that I wrote myself.

548
01:15:20,800 --> 01:15:27,129
So I wrote a function called Matrix One. So it'll, it'll return several things.

549
01:15:27,130 --> 01:15:34,570
So it returns the row sums, it returns the column sums and it returns kind of the total sum.

550
01:15:34,570 --> 01:15:39,820
So those are like three different things.

551
01:15:39,820 --> 01:15:48,639
I mean, one option is to kind of put them all in a single vector and try to remember

552
01:15:48,640 --> 01:15:52,510
kind of which order you're supposed to put the row sums or the column sums.

553
01:15:52,510 --> 01:15:59,950
But I think a better option is to return these three components as components in a list and give each component a name.

554
01:16:00,820 --> 01:16:04,149
Okay. I think that makes the output a lot easier to interpret.

555
01:16:04,150 --> 01:16:11,290
So that's kind of a common use of a list, and it makes the returned output a lot easier to interpret.

556
01:16:11,290 --> 01:16:18,460
So when I run this function here on this matrix, so I run matrix some.

557
01:16:18,940 --> 01:16:22,659
So the returns three, it returns three components.

558
01:16:22,660 --> 01:16:29,200
And since we can add names to it, it kind of makes the output a little bit easier to interpret.

559
01:16:29,860 --> 01:16:31,809
So we have one component named row.

560
01:16:31,810 --> 01:16:41,860
So I think that's easier to notice that that those are the rows some today we have another point in the list called the call.

561
01:16:41,860 --> 01:16:45,339
So it's easier to know that those are the columns of the day.

562
01:16:45,340 --> 01:16:48,790
And then we have the last component of the list.

563
01:16:48,790 --> 01:16:53,829
It's called All. So that's that's kind of the overall sum of the matrix.

564
01:16:53,830 --> 01:17:01,360
So, you know, this this type of output is, I think, a lot easier to interpret than other types of output.

565
01:17:01,370 --> 01:17:11,290
So this is kind of a common, common use of the list when you're kind of returning kind of different types of output from a function.

566
01:17:16,210 --> 01:17:22,510
It's just a this is a bit of idea perfectly.

567
01:17:23,980 --> 01:17:32,860
I think this just kind of says the same thing is on the similar thing to the last, last slide,

568
01:17:33,310 --> 01:17:38,980
although that was for a function is that basically you want to return something for a function or if you

569
01:17:39,310 --> 01:17:47,680
want to store it either variable where you want to store different things in kind of a single area.

570
01:17:50,290 --> 01:17:57,099
So like we saw that in the first example, we had a list that is story or information.

571
01:17:57,100 --> 01:18:05,770
If you want to store kind of different types of information under the name of a single variable list are kind of useful for that.

572
01:18:05,770 --> 01:18:19,809
So if you have let's say you have a data maybe for one individual or several individuals for kind of for each individual,

573
01:18:19,810 --> 01:18:26,320
you have different types of data. Maybe one part of the data stored in as a vector, something else is a matrix.

574
01:18:26,830 --> 01:18:31,030
Something else is like a character matrix. Another components, a data frame.

575
01:18:31,420 --> 01:18:37,720
You can kind of collect all of those things together and store them as a as a single.

576
01:18:38,350 --> 01:18:47,440
That's really kind of the main context for the most useful things.

577
01:18:48,070 --> 01:18:54,190
Yeah, that seemed to be my slides, so we'll just finish there for today.

578
01:18:54,190 --> 01:19:03,310
So everybody, the next week seems to be about the whole.

