1
00:00:05,280 --> 00:00:06,720
Ready to go? More or less.

2
00:00:29,070 --> 00:00:46,260
Right to go ahead and get started of the United States and look forward to the United States on Monday to post the first online quiz relatively soon.

3
00:00:47,340 --> 00:01:00,750
So probably the next thing we look out for. So yeah, I guess today we're going to be talking about basically different features,

4
00:01:00,780 --> 00:01:07,229
I guess just different things that are available like the standard template library is a standard template library,

5
00:01:07,230 --> 00:01:20,010
which is kind of this useful library of things I guess different just different functions, different data classes.

6
00:01:20,010 --> 00:01:32,579
You would say it's kind of made available out of yesterday, built in C++, but it's kind of used to always include these extra data classes.

7
00:01:32,580 --> 00:01:38,790
So I mean we've already used a little bit of some of them is going to be more formal.

8
00:01:39,960 --> 00:01:52,170
So I guess the standard template library has illustrated that we'll talk about kind of there's another part of the standard

9
00:01:52,170 --> 00:02:04,770
template library allows you to read in files and infectious sense and maps and we'll talk about strings a little bit more as well.

10
00:02:05,220 --> 00:02:16,200
So strings are also kind of with the additional kind of data structure made available by the standard template library.

11
00:02:16,200 --> 00:02:21,660
I mean, we already did a few examples of this for kind of discussing more formally.

12
00:02:22,350 --> 00:02:31,920
So it still is just basically like, um, just basically like a library of a bunch of stuff I guess to,

13
00:02:32,220 --> 00:02:40,100
I guess to, to use them these different features of the library, you have to use some type of include headers.

14
00:02:40,110 --> 00:02:45,269
I guess the for example like the stream string library you have to do include strings.

15
00:02:45,270 --> 00:02:58,410
So that allows you to access I guess a sub library or a subset of the kind of the utilities made available from the standard template library.

16
00:03:00,780 --> 00:03:05,220
So this is kind of standard template library, something that's pretty standard.

17
00:03:06,960 --> 00:03:09,930
You can use it with basically all C++ compilers,

18
00:03:09,930 --> 00:03:22,980
so you should be able to use it without a problem regardless of exactly where you're doing C++ programing.

19
00:03:23,970 --> 00:03:27,480
Okay. So I guess we talked about IO stream already.

20
00:03:28,260 --> 00:03:33,479
So it has like C outside in. I guess we'll talk about F stream today.

21
00:03:33,480 --> 00:03:37,950
So we have talked about before and we talked a little bit about strings.

22
00:03:37,950 --> 00:03:43,770
So String is kind of another feature of the standard template library.

23
00:03:44,460 --> 00:03:53,990
And then I guess these are kind of totally. New types of features of the Standard Temple Library that we're going to talk about today.

24
00:03:53,990 --> 00:03:59,660
Some factors, sets and maps, and these are basically often called containers.

25
00:03:59,660 --> 00:04:06,350
So these are things that just the whole of kind of a collection of items and then iterator,

26
00:04:06,350 --> 00:04:13,870
these are basically things that allow you to this is a separate type that allows you to access the output,

27
00:04:14,000 --> 00:04:19,579
certain elements of containers basically size, which is the way to think of this.

28
00:04:19,580 --> 00:04:30,590
So this is just yeah, I guess I'll just mention these and you can always memorize this.

29
00:04:30,590 --> 00:04:37,790
We can always refer to this. These are just different methods that come along with kind of the string, the string type.

30
00:04:38,720 --> 00:04:50,660
So a string is kind of a specific guess class or I think of it as a type that's available from the standard template library.

31
00:04:51,260 --> 00:04:55,010
It's basically you can think of it as a collection of characters.

32
00:04:55,010 --> 00:05:04,760
And then there's for the string type, there's kind of extra nice methods you can use with with strings as well.

33
00:05:04,760 --> 00:05:09,560
So access the case element of a string, you just use this kind of bracket.

34
00:05:10,490 --> 00:05:13,760
K Things of the brackets zero is the first element.

35
00:05:15,500 --> 00:05:24,409
C string is convert seed into this file string if you want to use an S length that tells

36
00:05:24,410 --> 00:05:30,080
you the length of a strange how many kind of characters are your string substring.

37
00:05:32,160 --> 00:05:35,420
You basically just extract a substring from a string.

38
00:05:36,140 --> 00:05:46,220
So you have the character starting from the index place and then however many characters after that.

39
00:05:47,510 --> 00:05:57,600
This is three. It's kind of that don't extract a substring of like three starting from a position place if you want to contaminate two strings,

40
00:05:57,630 --> 00:06:01,370
so put one right after the other. Just do you just add them.

41
00:06:01,460 --> 00:06:05,600
That will create another string, just kind of cabinets, the two strings.

42
00:06:06,740 --> 00:06:10,700
And then if you want to find an index of a match, just do not find.

43
00:06:11,540 --> 00:06:15,109
So the way you use all of these is just the name of the string, not something.

44
00:06:15,110 --> 00:06:26,470
So the name of your string is as if you wanted to use, find to use as that find that the character that you want to find the match for.

45
00:06:26,510 --> 00:06:34,060
So if you want to find index has a character see for example you would do that.

46
00:06:41,320 --> 00:06:58,969
This is just. You want to compare to Strange to compare and not to clear all of the characters in your story.

47
00:06:58,970 --> 00:07:01,400
You could just do less clear, for example.

48
00:07:04,880 --> 00:07:15,650
And then if you want to just check whether or not your string is empty or not, like if it has no characters in it could just do stuff.

49
00:07:16,460 --> 00:07:21,470
So these are just kind of just useful methods to know about.

50
00:07:22,810 --> 00:07:26,270
You know, you don't really need to memorize the syntax for all of them.

51
00:07:26,270 --> 00:07:34,250
And it's good just to be aware of some of the, just some of the useful methods that are available when you're working with strings.

52
00:07:34,970 --> 00:07:41,299
Okay. So this is just an example of an example run of showing some useful methods.

53
00:07:41,300 --> 00:07:48,920
So kind of as well, if you want to use string variables, you have to do this include string.

54
00:07:49,310 --> 00:07:54,220
You always have to include that header. So in this example, we first declare a string.

55
00:07:55,010 --> 00:08:02,450
It's just a string containing these characters a little bit.

56
00:08:02,510 --> 00:08:11,880
So this is declaring a string variable. So we have to do steady double colon string if we're not using using namespace.

57
00:08:12,020 --> 00:08:17,060
So first thing we do, I'm just printing it out the length.

58
00:08:17,270 --> 00:08:24,589
So this is s as Don Link gives us the and then extracts basically the length of the string.

59
00:08:24,590 --> 00:08:27,080
It should be five in this case.

60
00:08:27,770 --> 00:08:38,600
And so we're using this percent z you just because the length, the length is actually not an integer, it's like a, it's a separate type like size.

61
00:08:39,110 --> 00:08:42,530
C I think. And then you have to use this percent.

62
00:08:42,700 --> 00:08:56,000
Z you, if you're using this C style print, the next thing which is we're extracting substring here.

63
00:08:57,020 --> 00:09:03,170
So from here, from position three position files on the previous slide, we made a mistake.

64
00:09:04,100 --> 00:09:10,249
So it shouldn't should be. You should be sorry.

65
00:09:10,250 --> 00:09:24,660
That's a typo. It was. I think it should be up to position when number blinks, starting at position use and going up to index.

66
00:09:27,830 --> 00:09:33,770
This word about its substrate starting at the going up to.

67
00:09:37,970 --> 00:09:52,400
That's what we got here for now I'll tell the zero not out on the next cannabis print is just going to be the cat nation of hello

68
00:09:52,400 --> 00:10:10,520
and elbow and then let's see we're just going to find where the index or you have to see which you really shouldn't be any match.

69
00:10:11,330 --> 00:10:16,160
And then we're going to compare t.

70
00:10:22,050 --> 00:10:28,390
You just go to the next one. So. Okay, so.

71
00:10:30,760 --> 00:10:34,629
So does everything we said before.

72
00:10:34,630 --> 00:10:42,400
So this find thing is going to return some kind of nonsense index if it doesn't find a match.

73
00:10:42,630 --> 00:10:45,790
That big number.

74
00:10:45,790 --> 00:10:57,730
I forget the exact rules for determining this, but yeah, it doesn't return a proper index if we try to find a character that's not there.

75
00:11:02,280 --> 00:11:07,710
Also you can check if you do clear it clear here.

76
00:11:08,340 --> 00:11:14,160
And it basically empties the string as it kind of makes it a string of length zero, basically.

77
00:11:14,580 --> 00:11:19,290
So there's nothing contained in there. And then you say if that empty.

78
00:11:22,260 --> 00:11:26,160
That just returns true if there's kind of nothing inside the string.

79
00:11:26,180 --> 00:11:29,780
So you can see here, we printed out the message since that's that empty.

80
00:11:29,790 --> 00:11:33,890
It's true. Okay. Okay.

81
00:11:33,900 --> 00:11:41,940
So that's basically I just wanted to mention kind of all the useful methods that are available for string.

82
00:11:42,300 --> 00:11:46,910
We went through all of them before. So I think that's about it.

83
00:11:46,920 --> 00:11:51,630
I wanted to say for sure, strings. Okay.

84
00:11:52,320 --> 00:11:56,580
So input and output, I guess the main things are io stream and f stream.

85
00:11:57,120 --> 00:12:05,220
So IO stream is basically like input output to the from the keyboard or to the screen, for example.

86
00:12:06,240 --> 00:12:09,240
So that that's IO stream. So you don't need this back.

87
00:12:09,240 --> 00:12:16,860
That's a typo. You don't need this backslash here. We've already done a number of examples with C and in Seattle.

88
00:12:17,700 --> 00:12:24,280
So it's just like input via the keyboard and outputs of the string to the screen.

89
00:12:24,300 --> 00:12:31,320
So that's like what IO stream handles for doing like input and output with files.

90
00:12:31,320 --> 00:12:37,140
So reading and the contents of a file or writing out certain results to a file

91
00:12:37,740 --> 00:12:41,610
and f stream is the kind of the standard header that you need to include.

92
00:12:42,450 --> 00:12:55,620
So F stream, I guess the main kind of functions from f stream or I f stream or f stream and o f stream upstream I guess.

93
00:12:56,370 --> 00:13:07,350
So that I have stream is just for reading and the contents of the file and then of stream is just for writing certain numbers or or text to a file.

94
00:13:07,440 --> 00:13:11,570
Okay. So that's really kind of the main.

95
00:13:14,780 --> 00:13:18,680
I think those are the only functions that I'm going to cover from upstream.

96
00:13:19,820 --> 00:13:26,959
Okay. So I thought, I want to see how it works. I think it just I just wanted to go through an example probably more clear.

97
00:13:26,960 --> 00:13:32,270
So let's say we wanted to write a program that opens some text files.

98
00:13:32,270 --> 00:13:38,270
So we have some text file saved somewhere. So it opens the file, it reads in each word.

99
00:13:40,790 --> 00:13:43,759
It counts the total number of words in the text file.

100
00:13:43,760 --> 00:13:51,470
So this is just a text file that has a bunch of words in it, and then it records the length of the the longest word.

101
00:13:51,650 --> 00:13:54,770
Okay. So basically the word with the most characters in it.

102
00:13:55,340 --> 00:14:00,650
And then at the end it's going to print the total number of words and then the length of the longest word.

103
00:14:00,890 --> 00:14:04,200
Okay. So that's kind of what the program is going to do. Okay.

104
00:14:04,220 --> 00:14:14,120
So the way you do this is not the entire program itself, but this is kind of the syntax for reading in like the contents of a text file.

105
00:14:14,930 --> 00:14:20,390
Okay. So the way it works usually is you kind of read in one word at a time.

106
00:14:21,560 --> 00:14:27,910
So if you want to read in each word one at a time, you can kind of use the following volume.

107
00:14:27,980 --> 00:14:46,350
So first. You kind of open the file using I have stream and you kind of declare a variable

108
00:14:47,400 --> 00:14:52,680
containing the roughly thing that is containing the contents of the text file.

109
00:14:53,400 --> 00:14:59,100
And then you can kind of with this operator, I kind of read in the contents one by one.

110
00:14:59,670 --> 00:15:12,270
So if you do this while loop and then IFRS double greater than sign, it's not to read in the words one by some kind of in each iteration of the loop.

111
00:15:13,710 --> 00:15:21,030
So I have nothing inside the loop right now, but if you think about it as each iteration or like each time we go inside the loop,

112
00:15:21,030 --> 00:15:29,550
s takes the value of a different word in the in the text file.

113
00:15:29,560 --> 00:15:39,330
So if you had, like, if you had C out s here and you were to run this, it would just print out each word from the text file one by one.

114
00:15:39,840 --> 00:15:48,540
So kind of in each iteration, s has a takes on the value of kind of the next word in the text file.

115
00:15:49,440 --> 00:15:57,750
Okay. Okay. So this is that was just kind of the syntax for for reading in a text file, one by one word at a time.

116
00:15:58,960 --> 00:16:03,030
Okay. So here's kind of an example of where we put everything together.

117
00:16:04,140 --> 00:16:12,480
Okay. So here I want to include string, since we're going to treat each word as a string that we read in.

118
00:16:13,260 --> 00:16:20,670
So you have to include that. You have to include f string. Since that we've had to use extreme.

119
00:16:21,810 --> 00:16:27,120
And then I guess I did C studio because I want to use an F at the end.

120
00:16:29,220 --> 00:16:33,710
Okay. So what is that? Well, you have to declare everything.

121
00:16:33,720 --> 00:16:42,660
So we have to declare a string type s that's basically going to hold the value of each word from I f string.

122
00:16:42,680 --> 00:16:52,140
And then we're going to have two integers, none words that's going to compute the number of words in the text file and then maxlength,

123
00:16:52,890 --> 00:16:59,030
which is going to be the length of the max, the kind of the longest word in the in the document.

124
00:16:59,040 --> 00:17:08,790
Okay. Okay. And then we just did what we did before on kind of the previous slide, the way to kind of open a file is to do this.

125
00:17:09,150 --> 00:17:14,270
I have string and then I have to assign the file to some name.

126
00:17:14,730 --> 00:17:17,970
So I'm just calling that variable name ifs.

127
00:17:18,690 --> 00:17:29,190
So I'm using this lower run, it's text. So I actually put this on canvas and then the data file data folder probably finds kind of a common text.

128
00:17:29,850 --> 00:17:40,770
You can probably find it elsewhere. But in this on canvas, it's just kind of a short a text file and then it's a kind of read in one word at a time.

129
00:17:40,770 --> 00:17:50,520
We use this wild loop. So this violence kind of each time we go inside the loop s takes on the value of one of the words in the document.

130
00:17:51,600 --> 00:17:55,679
And so to count the number of words, we just have to do number words plus, plus.

131
00:17:55,680 --> 00:18:04,739
Every time, every time you go inside the loop, you increase not enough words by one so that I'll count the number of words in the document.

132
00:18:04,740 --> 00:18:13,190
So that's pretty straightforward. The other thing is how to keep track of the maximum length.

133
00:18:13,200 --> 00:18:19,109
So to do that, we just set the initial value of max length to zero.

134
00:18:19,110 --> 00:18:26,430
And then we say if. So if the length of each time you go inside the loop,

135
00:18:26,440 --> 00:18:36,010
like if the length of the current word is greater than maxlength, that becomes the DU the new maximum length, right?

136
00:18:36,820 --> 00:18:42,390
So kind of the current word is greater than the current maximum length.

137
00:18:43,890 --> 00:18:47,520
The length of the current word becomes a single maximum of length.

138
00:18:47,730 --> 00:18:50,850
Okay. Otherwise, you don't you don't really have to change it.

139
00:18:51,090 --> 00:18:54,780
Okay. So that's what's done here. So we do have this.

140
00:18:57,490 --> 00:18:58,710
This is called casting.

141
00:18:58,720 --> 00:19:08,590
This is really like changing the type of the star length because remember, it's that length is not an integer, it's guys type, size, size.

142
00:19:09,820 --> 00:19:19,330
So if you want to do this, if you want to assign it an integer value, you do have to do this kind of changing the time.

143
00:19:19,330 --> 00:19:28,750
So you change the type, you do this. And in parentheses, like I say, kind of converts the type from size T to two integer.

144
00:19:28,870 --> 00:19:36,950
Okay. And then you'll absolutely have to close the file.

145
00:19:37,010 --> 00:19:43,040
I should kind of close it at the end of the program, but I think it's it's usually good.

146
00:19:43,360 --> 00:19:47,860
I think it's good practice to close the file right after you use it.

147
00:19:47,860 --> 00:19:50,740
So that's that's what that's what this does.

148
00:19:50,770 --> 00:20:00,970
If I start close, that kind of closes the file and then the last two statements are just turning out the results.

149
00:20:01,410 --> 00:20:07,180
Okay. Okay. So here's an example of Yeah.

150
00:20:07,240 --> 00:20:14,740
Just running it. So this went through, it shows that this is just an example run.

151
00:20:14,740 --> 00:20:18,639
So this this a text document is pretty short.

152
00:20:18,640 --> 00:20:23,950
It only has 69 words and then the longest word has 13 characters.

153
00:20:25,240 --> 00:20:29,530
So it's, it's basically the results of of.

154
00:20:32,010 --> 00:20:39,389
I've run into this. So, okay, so here is how you he's off stream.

155
00:20:39,390 --> 00:20:44,000
So it's kind of a simple example just to show how to use it.

156
00:20:44,010 --> 00:20:56,820
So it's sort of similar to I have stream, it's just kind of use the opposite lesser than or equal to symbols.

157
00:20:57,540 --> 00:21:06,900
So but like I have stream, you have to kind of declare a variable representing the file that you're going to write to.

158
00:21:07,440 --> 00:21:11,700
So basically we're trying to write certain contents to a text file.

159
00:21:12,270 --> 00:21:19,770
So basically these three lines, I want those to be I want to write those to a text file.

160
00:21:20,970 --> 00:21:26,340
So I do I want the name of the text file to be test output, that text.

161
00:21:26,880 --> 00:21:28,560
Okay. So that's what this does.

162
00:21:29,460 --> 00:21:37,740
And so I'm going to just here, I'm just declaring the variables that I'm going to write to the different lines of the text file.

163
00:21:37,750 --> 00:21:41,310
So this is declaring a string which says Hello World.

164
00:21:42,240 --> 00:21:48,490
And these are going to have a double, which is 3.1 for an integer equal to 42.

165
00:21:48,510 --> 00:21:58,650
Okay. So the way you would do this, if you want to write it kind of one word at a time or one kind of block at a time,

166
00:21:59,370 --> 00:22:07,710
you use this office ten to double, lesser than or equal to or lesser than symbol.

167
00:22:08,370 --> 00:22:14,399
Okay. So here I'm just writing the contents of S to the file text test output.

168
00:22:14,400 --> 00:22:18,690
That text. Here I'm writing the D, here I'm writing.

169
00:22:20,910 --> 00:22:26,180
You don't have to put them on separate lines. You can have them kind of next to each other on the same line.

170
00:22:26,190 --> 00:22:31,230
In that case, you wouldn't use this. But here, if I close the end l it should be.

171
00:22:31,950 --> 00:22:36,000
Each one of these things should be on a separate line in the text file.

172
00:22:38,190 --> 00:22:41,700
So this is what it looks like if you open it up.

173
00:22:42,250 --> 00:22:47,790
Yeah, we just have Hello World first line 3.14 and then then 42.

174
00:22:51,940 --> 00:22:57,340
Okay. So that's how you can write. You can write things to a text.

175
00:22:59,290 --> 00:23:02,439
Okay. So here is just maybe just another example.

176
00:23:02,440 --> 00:23:08,770
Just see, this is kind of, I guess.

177
00:23:14,810 --> 00:23:19,650
Yeah. I guess I could have used this with the string closer to the string content.

178
00:23:19,660 --> 00:23:25,120
So this is just maybe a, just an example to remind us how to write functions basically,

179
00:23:25,120 --> 00:23:34,480
and then how to use certain features of the string that the string kind of the string library.

180
00:23:35,080 --> 00:23:40,920
Okay. So yeah, this doesn't have any in file input or output,

181
00:23:40,930 --> 00:23:49,350
but this is just kind of another example of writing functions and using kind of the features of, of strings and C++.

182
00:23:49,360 --> 00:23:53,019
So this is an example of a function.

183
00:23:53,020 --> 00:23:57,970
It takes a while to go back here.

184
00:23:59,200 --> 00:24:09,219
It takes it basically the input is like a single string variable and then the output is basically just the it's an integer,

185
00:24:09,220 --> 00:24:13,480
it's just the number of vowels in that word. And this involves just a letter.

186
00:24:13,990 --> 00:24:25,090
It's either idle or you. So that is basically the purpose of the function.

187
00:24:25,090 --> 00:24:30,430
So here I'm calling the name of the function count vowels.

188
00:24:30,550 --> 00:24:36,310
So remember, we need to declare the type when you're declaring a function.

189
00:24:36,790 --> 00:24:45,820
So since this returns an integer variable, we have to say it before count vowels and then we also have to declare each argument.

190
00:24:45,830 --> 00:24:51,370
So the input argument is a string. So I'm just going to say string word.

191
00:24:51,950 --> 00:24:55,060
Okay. So that's correct. Function, that declaration.

192
00:24:56,200 --> 00:25:06,910
Okay. And so the way to do this, I just initialize kind of a variable, an integer variable called non vowels that equals zero.

193
00:25:07,660 --> 00:25:15,400
And I'm just going to use a loop over the kind of the data, the characters inside of the string.

194
00:25:15,590 --> 00:25:19,900
Right. So I'm using a loop. So here is actually an example.

195
00:25:20,140 --> 00:25:26,110
The looping elements actually don't necessarily have to be integers.

196
00:25:26,770 --> 00:25:40,900
So here is an example where I'm using a size, size T type size TS, you have to be non-negative, but then we have that in this case.

197
00:25:41,830 --> 00:25:55,960
So I'm defining a size t type variable. I goes from zero up to word length or length of the word less than the word length to pi plus plus.

198
00:25:56,740 --> 00:26:05,880
And then each time inside the loop, I just I just increase the vowel, increase the number of vowels by one.

199
00:26:05,890 --> 00:26:14,770
If, if the ice, if the I've character is one of these one of the vowels basically.

200
00:26:14,770 --> 00:26:19,240
So a it's either ai0 or you.

201
00:26:22,520 --> 00:26:29,429
I said, remember, if you want to test whether or not an individual component of a string equals a character,

202
00:26:29,430 --> 00:26:39,470
you have to put the characters in single quotes, kind of characters in C++, or you can put input inside a single source of it.

203
00:26:40,500 --> 00:26:43,890
So this is this is how you would implement this function.

204
00:26:49,530 --> 00:26:54,300
All right. So this is how you would combine a campaign, for example.

205
00:26:55,470 --> 00:27:01,110
So let's here is main here. So here I just initialize a string.

206
00:27:03,510 --> 00:27:10,380
I'm declaring an integer variable variable in vowels that I call the function count vowels.

207
00:27:11,130 --> 00:27:15,450
So that should return an integer and I sign that in vowels.

208
00:27:15,450 --> 00:27:23,280
And then I just print out the vowels. Print out the value of in vowels.

209
00:27:23,530 --> 00:27:25,490
Okay. So it's pretty,

210
00:27:25,660 --> 00:27:35,370
a pretty short name and you have to declare a variable integer variable and then kind of call the function in assignment to that variable.

211
00:27:36,120 --> 00:27:40,290
It's really all you have to do in Maine and then Maine.

212
00:27:40,770 --> 00:27:52,800
Calculations are done inside of this function. This she turns out turns out to since it's implicit, this example is correct.

213
00:27:52,830 --> 00:28:00,630
So that's. Which that's it for like strings and ideastream.

214
00:28:01,610 --> 00:28:07,570
So the next sort of thing, we did not talk about this before.

215
00:28:07,580 --> 00:28:11,330
So this is kind of the next, I guess.

216
00:28:17,170 --> 00:28:22,899
The next type of feature of steel that we're going to talk about.

217
00:28:22,900 --> 00:28:32,350
So these are these are vectors. So to use vectors, you have to include you have to put this header.

218
00:28:32,500 --> 00:28:44,140
So including vector basically. So vectors are what they're they are a type of kind of container basically meaning they just

219
00:28:44,350 --> 00:28:50,560
they're used for containing kind of a collection of objects under the name of a single variable.

220
00:28:51,010 --> 00:28:56,890
And I guess in this case they would, I mean, they're usually referred to as a quarter container.

221
00:28:57,610 --> 00:29:05,319
So that just means like the there's a, there's a first element of the vector, there's a second element of the vector.

222
00:29:05,320 --> 00:29:07,330
There's a third element of the vector. Okay?

223
00:29:08,380 --> 00:29:19,600
That's what the order in refers to as a nice feature of vectors, at least compared with it's nice depending on what you're trying to do,

224
00:29:19,600 --> 00:29:29,469
but often nice feature of vectors is that you can kind of you can change the size.

225
00:29:29,470 --> 00:29:33,130
Basically, you can change the number of elements in your vector.

226
00:29:33,400 --> 00:29:38,290
Okay, so it's not the case with arrays. So I think we'll talk about arrays soon.

227
00:29:38,830 --> 00:29:50,020
So for arrays, you have to kind of declare the size of the array and you can't make the array bigger or smaller or things like that.

228
00:29:50,020 --> 00:29:51,310
There's kind of a fixed size.

229
00:29:51,940 --> 00:30:00,910
So that's not the case with with vectors, you can add new components to a vector or you can delete components from a vector.

230
00:30:01,270 --> 00:30:04,810
So that's kind of one of the nice features of still vectors.

231
00:30:05,950 --> 00:30:13,120
So the way you declare, I'll show an example in a second that this ti thing is the is the type of the vector.

232
00:30:13,120 --> 00:30:22,750
So you can have vectors of different types. So that just basically refers to the types of the components of the vector.

233
00:30:23,380 --> 00:30:25,450
So you can have a vector with all integers.

234
00:30:26,080 --> 00:30:32,710
So in that case the T would be put into, for example, you can have a vector where all of the components are doubles.

235
00:30:33,280 --> 00:30:40,540
So you would put like double here when you declare it. So that's what this kind of general T notation means.

236
00:30:41,950 --> 00:30:48,670
So it fits the have factors which can the components are different types.

237
00:30:49,210 --> 00:30:53,920
So here's a more formal way of showing that.

238
00:30:53,920 --> 00:31:01,780
So we can have a if we're declaring this, this just means the vector should I mean,

239
00:31:01,780 --> 00:31:05,200
the vector can have multiple things in it, but they should all be integers.

240
00:31:05,200 --> 00:31:09,940
Okay, so this means they're to all integer values.

241
00:31:12,760 --> 00:31:19,390
You can have a vector of strings. So each element of this vector would have would be a string.

242
00:31:19,480 --> 00:31:27,760
So to do that, you would do esti d double call vector, and then inside of these arrows you would have to double colored string.

243
00:31:28,780 --> 00:31:35,170
I can have a vector of all doubles and I guess the last one, if you want to have you can have this like nested vector.

244
00:31:35,180 --> 00:31:42,280
So you'd have a basically a vector of factors that certainly allowed you to do this type of thing.

245
00:31:42,280 --> 00:31:53,440
You have STD, double colon vector, and then inside of these arrows you would have a you basically declare another vector type.

246
00:31:54,040 --> 00:31:58,089
So here we're declaring a vector of doubles.

247
00:31:58,090 --> 00:32:06,250
So that just means that each vector in this vector in vector should be should have double type.

248
00:32:08,830 --> 00:32:12,970
Of this might often be referred to like a nested container.

249
00:32:13,780 --> 00:32:18,810
This is a factor of factors. Okay.

250
00:32:21,630 --> 00:32:25,640
So let's start with the first one is slightly weaker.

251
00:32:25,680 --> 00:32:36,540
That was maybe that's not so clear. So the way to put it on the board, the way you could declare factors and different ways.

252
00:32:37,740 --> 00:32:49,510
So this would be. You can actually declare the whole like this would be the best TV.

253
00:32:52,220 --> 00:33:01,280
Actor. I'd say, and the rest would be same.

254
00:33:05,720 --> 00:33:10,070
So I guess this is empty factory. Empty factory.

255
00:33:15,820 --> 00:33:28,020
Because if you did as a TV actor. And so this would be five.

256
00:33:28,170 --> 00:33:32,790
So this would be five integers.

257
00:33:33,000 --> 00:33:43,350
So. This is basically a vector of five zeros, I guess five zero is.

258
00:33:44,780 --> 00:33:48,910
I mean that's kind of the way it. That's slightly confusing.

259
00:33:49,120 --> 00:33:52,920
So me you can also combine. Yeah.

260
00:33:52,930 --> 00:33:57,610
So this would be you can have two things in the parentheses.

261
00:33:58,720 --> 00:34:03,160
So if you did this. V.

262
00:34:04,340 --> 00:34:13,400
I. One. So this would be a factor of size one.

263
00:34:14,300 --> 00:34:19,040
Asset size. Size five of all ones.

264
00:34:19,130 --> 00:34:23,250
I guess. I guess that's kind of what I meant to say.

265
00:34:23,780 --> 00:34:26,879
So that's a factor of size five.

266
00:34:26,880 --> 00:34:30,570
That's the first component of the in the parentheses is five.

267
00:34:30,750 --> 00:34:37,799
All the ones you can even if you use the curly braces.

268
00:34:37,800 --> 00:34:44,040
I think I have an example later if you want to look at the actual individual elements one at a time.

269
00:34:44,700 --> 00:34:49,599
So if I did this type of thing. The.

270
00:34:49,600 --> 00:34:54,710
One, two, three. So this is.

271
00:34:55,580 --> 00:34:58,970
Yes. Factor of like three.

272
00:35:02,280 --> 00:35:09,720
That's kind of how you can use. With components.

273
00:35:14,510 --> 00:35:17,910
Yeah. Basically. One, two, three. Okay.

274
00:35:18,610 --> 00:35:24,820
So you can also do the curly braces when you're declaring a factor.

275
00:35:24,920 --> 00:35:28,990
Okay. I went through all of those different cases.

276
00:35:36,410 --> 00:35:45,319
All right. So, yeah, that was the. So I probably shouldn't lose that on the slides next time.

277
00:35:45,320 --> 00:35:54,920
So this is how you can kind of initial ah declare a vector and here and it's kind of different ways of if you want to give it a,

278
00:35:55,190 --> 00:36:09,559
an initial value or an initial value for the components in a certain way, the size is basically the total number of elements in your vector.

279
00:36:09,560 --> 00:36:17,629
If you want to resize your vector, basically you want to give it a new size.

280
00:36:17,630 --> 00:36:26,720
You can do resize. If you want to access individual components of your vector, it's basically the same wave as you do with strings.

281
00:36:26,960 --> 00:36:34,790
With this kind of bracket notation vs bracket zero is the first component of the vector.

282
00:36:35,510 --> 00:36:42,829
If you want to insert an element kind of at the end of your vector, you can do push back.

283
00:36:42,830 --> 00:36:47,990
If you want to remove an element, you can pop back front.

284
00:36:49,850 --> 00:36:55,000
And on the front is that news. And it's basically the first it's like a.

285
00:36:58,940 --> 00:37:06,139
Return to the first element. I guess you can always do brackets zero for that and feedback gives you the returns.

286
00:37:06,140 --> 00:37:09,200
The last element v dot again.

287
00:37:13,120 --> 00:37:26,440
Yes it gives you the most that's useful for vectors is you can create an iterator.

288
00:37:26,500 --> 00:37:34,810
We'll talk about generators later to the first element and then you could also erase certain components of your vector.

289
00:37:35,890 --> 00:37:43,990
So if you want to erase at a given location here, if you just want to remove that element from your vector engines, do feed on arrays.

290
00:37:44,260 --> 00:37:54,309
Okay. So these are just kind of a list of some of the useful methods for vectors and then your other categories are okay.

291
00:37:54,310 --> 00:37:59,920
So here's just an example of us using these features of vectors.

292
00:37:59,920 --> 00:38:04,730
So this is an example that creates a vector of size to us.

293
00:38:04,770 --> 00:38:11,830
It's really an integer vector. So this creates a factor of size too.

294
00:38:12,800 --> 00:38:18,580
We do this by default. This should be like the components of the vectors or zeros.

295
00:38:18,580 --> 00:38:25,210
So this is after running this line, it's just a factor of length to the both of the components are zero.

296
00:38:26,590 --> 00:38:33,010
And then here we're assigning the first element, what about period value 42?

297
00:38:33,550 --> 00:38:42,730
And then here we're assigning the value of kind of the second component 1024 and then on this line where we're doing push back,

298
00:38:42,730 --> 00:38:48,550
we're basically increasing the size of the vector.

299
00:38:48,970 --> 00:38:53,830
So you're basically just adding another element kind of to the end of the vector.

300
00:38:55,030 --> 00:39:02,530
So after running this, the vector should have like three and then the third component should be six.

301
00:39:06,340 --> 00:39:11,530
So that's yeah. And then I guess I'm just putting the results using a four loop at the end.

302
00:39:12,970 --> 00:39:22,270
So let's switch done here. Yeah. So as expected the zeroth element is 42 first.

303
00:39:22,630 --> 00:39:33,070
I guess I could have that, my first element is 1024 and then the second second element is six.

304
00:39:36,790 --> 00:39:40,260
Okay. So here's here's another example. There's a network.

305
00:39:40,990 --> 00:39:47,180
There's an example where we're declaring an inventor in a slightly different way.

306
00:39:47,200 --> 00:39:51,820
So we want to create an integer vector with the components one, two and three,

307
00:39:53,020 --> 00:39:57,340
and then print the size of the vector and then remove the second vector.

308
00:39:58,390 --> 00:40:02,560
So here I'm kind of using this as the syntax here.

309
00:40:03,130 --> 00:40:09,870
So this, this just creates a vector of like three where the components are one, two and three.

310
00:40:09,910 --> 00:40:20,020
So that's what this curly braces syntax means for declaring a vector using that rather than parentheses.

311
00:40:20,620 --> 00:40:24,340
So this is going to declare a vector with two components one, two and three,

312
00:40:26,380 --> 00:40:32,530
and we're going to print out the length of V kind of using vector size so that returns the size of the vector.

313
00:40:33,250 --> 00:40:38,200
So that should be three in this case. And then I'm going to erase the second element.

314
00:40:38,500 --> 00:40:47,980
Okay, so doing vector race and then V type again should be zero.

315
00:40:48,900 --> 00:40:57,820
And so for vectors codes, we kind of know that the first element is zero, but you can use it in this way.

316
00:40:57,820 --> 00:41:07,240
So this should return. It should erase the second element of V and then we're going to print out kind of this size of V and then

317
00:41:07,240 --> 00:41:13,840
then the two components of the of the vector and then I guess we're just going to empty the vector.

318
00:41:14,590 --> 00:41:23,890
So this is kind of the same thing you can do with strings if you can clear it, you just remove all of the elements in your vector.

319
00:41:24,490 --> 00:41:30,430
Okay, here, just watch what happens when we run it.

320
00:41:31,260 --> 00:41:40,060
So here's the various printing messages that come out. So first out prints out the little length of V is three as expected.

321
00:41:41,290 --> 00:41:46,360
Then we run after running a race of.

322
00:41:50,200 --> 00:41:54,160
Oh yeah, after running a race it deleted the second element.

323
00:41:54,790 --> 00:42:00,100
So we're printing out the size, which is two and then the first and then the second element.

324
00:42:01,050 --> 00:42:11,020
So the second element is now three because we, we deleted like the middle we deleted the middle component.

325
00:42:11,800 --> 00:42:15,430
So it kind of collapses to the vector one three.

326
00:42:15,430 --> 00:42:22,720
So the second component is now, now three and then the size is now two.

327
00:42:23,590 --> 00:42:31,210
And then we did clear we got clear that basically V still exists, but it's like an empty vector.

328
00:42:31,450 --> 00:42:34,719
Okay, so if we print out the size, it has size zero.

329
00:42:34,720 --> 00:42:38,080
So it's like it wants to run clear. It's like an empty vector.

330
00:42:38,080 --> 00:42:43,060
There's, there's nothing inside of it. And it, you know, it has size zero.

331
00:42:43,420 --> 00:42:53,709
Okay. All right. So let's say we want it to do a example and we read in the file.

332
00:42:53,710 --> 00:43:02,920
So we're going to do use extreme again. So we're going to use the same text file or if some and I want to make a vector of vectors.

333
00:43:03,760 --> 00:43:07,419
Okay, so each of the vectors inside of that big vector.

334
00:43:07,420 --> 00:43:16,230
So I guess you can think of. In this example, we have one big factor and then a lot of smaller vectors inside of that vector.

335
00:43:18,360 --> 00:43:27,540
So inside of our big vector, each of the vectors should be contain a collection of words, basically.

336
00:43:27,990 --> 00:43:31,740
So each vector contains a vector of a word.

337
00:43:32,570 --> 00:43:40,080
Sorry. Each vector contains a collection of words, and all of the words in that vector should have the same length.

338
00:43:40,650 --> 00:43:48,800
Okay, so like one of the vectors, if it has, if it represents the, the words with length three,

339
00:43:48,810 --> 00:43:53,100
for example, all of the words in that vector should have like three.

340
00:43:55,260 --> 00:44:00,360
And then we want to output kind of how many words we have for, for each length.

341
00:44:00,570 --> 00:44:08,370
Okay. So if we found like ten words that all had three letters, we want to output that result.

342
00:44:08,700 --> 00:44:10,370
Okay. Okay.

343
00:44:10,380 --> 00:44:21,270
So the way we can do this, like we said before, declaring as vector and vectors, you just have to put this vector and then like vector inside.

344
00:44:21,510 --> 00:44:30,989
So this is if we're declaring a vector of vectors and then the vectors, the smaller vectors contain strings.

345
00:44:30,990 --> 00:44:36,300
We would do this vector inside of the arrows to vector string.

346
00:44:36,330 --> 00:44:39,780
Okay. So that's how we were we're going to do this.

347
00:44:41,040 --> 00:44:49,200
So each, each kind of, each component of V, so v to think of this as like a big vector, each element of V is a vector.

348
00:44:49,950 --> 00:44:54,810
So like if you do V bracket K, that's actually a vector.

349
00:44:54,940 --> 00:45:01,040
Okay. So V bracket k, that's not like a single number or word or anything.

350
00:45:01,050 --> 00:45:04,060
This V bracket k is actually a vector. Okay.

351
00:45:04,530 --> 00:45:08,910
So that's how you can do nested vectors. Okay. So here's how it would work.

352
00:45:09,520 --> 00:45:13,290
There's the code of how it would work.

353
00:45:13,300 --> 00:45:21,960
I would put this inside of a main function. So we're going to use extreme again for the last time.

354
00:45:21,970 --> 00:45:35,220
So basically the same thing ifs we have a string, we declare a string type s and so each time we kind of go inside the loop.

355
00:45:37,620 --> 00:45:41,639
S takes on the value of a word from this.

356
00:45:41,640 --> 00:45:44,730
Lorem get some text documents. Okay.

357
00:45:46,560 --> 00:45:56,220
So how is this going to work? So we're going to say, you know, each time we go inside the loop and I declare integer K, right?

358
00:45:56,820 --> 00:46:05,840
So the K equals the end equals the length of S, it's basically the length, the current word.

359
00:46:05,850 --> 00:46:11,190
So how many letters are in the kind of the current word for the, the current iteration of the loop.

360
00:46:12,090 --> 00:46:18,010
Okay. And then we say if K so what does this mean?

361
00:46:18,030 --> 00:46:21,059
So if K is greater than V does size,

362
00:46:21,060 --> 00:46:34,470
basically what that is saying is if the length of K is greater than or equal to the the number of vectors already contained in V,

363
00:46:34,890 --> 00:46:38,250
we need to do we need we need another vector. Right.

364
00:46:38,850 --> 00:46:50,170
So the way to think about that is V. V contains a series of vectors.

365
00:46:50,830 --> 00:46:58,330
So we're going to have a like you can think of like the first vector contains the words with one character,

366
00:46:58,990 --> 00:47:03,940
like the words a by itself or by by itself.

367
00:47:04,540 --> 00:47:11,020
The second component of V is a factor which contains the word the length of a word.

368
00:47:12,520 --> 00:47:19,000
What does it like to see? Or something like on or something like that and so forth and so forth.

369
00:47:19,660 --> 00:47:25,390
So what this is saying is that if if the current word length, it is,

370
00:47:25,570 --> 00:47:32,830
if that's bigger than the number of vectors and v we need to create kind of another vector inside of V.

371
00:47:33,250 --> 00:47:38,320
Okay. Since we don't have a vector representing that category of words yet.

372
00:47:41,690 --> 00:47:47,120
So if that happens, all we have to do is increase the size of the vector.

373
00:47:47,360 --> 00:47:53,329
So we have to make sure that the size of the V is K plus one.

374
00:47:53,330 --> 00:47:58,760
So we have to have. So why do that in ten plus one?

375
00:47:58,760 --> 00:48:03,260
So k. So I actually.

376
00:48:06,140 --> 00:48:20,380
You could argue that you don't need to. But I think it is more straightforward if we do it this way.

377
00:48:21,970 --> 00:48:26,850
So I guess you could argue that you don't need a blanket zero cap agreement.

378
00:48:27,490 --> 00:48:30,850
The way I did it kind of did that. Okay.

379
00:48:32,720 --> 00:48:37,840
But anyway, so that's probably going to be empty. So V0 is should be empty.

380
00:48:38,020 --> 00:48:47,980
There's no words with zero length. But what this does, it says, okay, so v you can think of v bracket k is a vector.

381
00:48:48,040 --> 00:48:53,949
Okay. V bracket k select v v of one.

382
00:48:53,950 --> 00:48:56,980
It contains the words of length one.

383
00:48:59,670 --> 00:49:09,450
So if if the length of X happens to be one, we're going to add s to VK.

384
00:49:09,870 --> 00:49:21,120
So if S happens to be like the the word AI or A by itself, we would add that to v1v of one.

385
00:49:21,240 --> 00:49:29,760
Okay. So Fields one is like a vector which contains many, many words.

386
00:49:30,180 --> 00:49:36,130
If S has like like four for example, that would be added to V bracket four.

387
00:49:36,150 --> 00:49:41,940
So V bracket four is a vector as well.

388
00:49:42,210 --> 00:49:45,330
Right. All right. So here's.

389
00:49:45,570 --> 00:49:50,590
Here's kind of what it looks like when we put it all together in main.

390
00:49:51,300 --> 00:50:01,650
So here. Yeah. Just a reminder to include the correct headers with a vector header, string header, etc.

391
00:50:01,650 --> 00:50:05,490
And then I think this is kind of what we've had before.

392
00:50:05,610 --> 00:50:10,510
Everything is just I'm just putting it inside of Main and I'm putting out the result.

393
00:50:10,540 --> 00:50:14,879
So what I'm going to print out is, all right, so what are we going to print out?

394
00:50:14,880 --> 00:50:29,100
So I also notice you can compare it even though I did size T before in the loop, you can compare integers just with size t types that still work.

395
00:50:29,110 --> 00:50:38,280
So even though V that size is not an integer, you can do this type of it's you can do these types of comparisons between integers and size types.

396
00:50:38,280 --> 00:50:42,270
That's okay. Okay. So what we're going to print out is blank.

397
00:50:45,660 --> 00:51:02,120
Okay. So I. So we're looking at the so Z, you here represents the number of words that were found.

398
00:51:03,290 --> 00:51:07,840
So like and then this percent d represents kind of mechanical reserve.

399
00:51:08,480 --> 00:51:16,140
And the first case where we're going to print out is like once you bird recently.

400
00:51:16,220 --> 00:51:21,500
So that's how many birds of length one we found.

401
00:51:21,920 --> 00:51:26,720
And then the next iteration of the loop, how many words of like two were found?

402
00:51:27,100 --> 00:51:31,880
Okay, so that's kind of what's going to be printed out. So this VII, that size.

403
00:51:32,630 --> 00:51:40,550
So for example, if I has three VII dot size prints out how many words at length three were found.

404
00:51:44,110 --> 00:51:55,770
So yeah, I could probably remove the zero words category, but I think it's, I think it just makes the code a little bit longer than it needs to be.

405
00:51:56,550 --> 00:52:09,150
So I think, um, obviously there's zero words with zero letters in them, but otherwise I think the other categories make sense.

406
00:52:09,150 --> 00:52:13,410
So there's actually there are no words with one letter.

407
00:52:14,460 --> 00:52:18,390
There are 13 words that have had two letters.

408
00:52:19,470 --> 00:52:26,100
There were five words with three letters that were nine words with four letters, etc., etc.

409
00:52:26,740 --> 00:52:33,930
Okay. And then the I guess you already knew this from the previous example.

410
00:52:33,930 --> 00:52:39,380
That was the longest word, had 13 letters. So this is kind of confirms that as well.

411
00:52:39,500 --> 00:52:49,050
It's just another way of showing that. So there's one word with 13, 13 letters, number two.

412
00:52:49,980 --> 00:52:58,740
Okay. So that's factors. That's. So that's clear.

413
00:52:58,760 --> 00:53:09,890
So I think probably the for C++, one of the main advantages vector is I can sense you couldn't be kind of resized on these.

414
00:53:10,130 --> 00:53:20,390
That's probably one of the biggest advantages and it's probably has some additional kind of functionality which is, you know,

415
00:53:20,670 --> 00:53:33,050
more similar to, you know, at least if you took our kind of R factors or Python or at least not be arrays in Python.

416
00:53:33,560 --> 00:53:40,920
So the kind of some of the methods allow you to do some of the same things you would do in Python.

417
00:53:40,940 --> 00:53:45,500
So that's probably the main advantages of using C++ factors.

418
00:53:46,340 --> 00:53:59,600
All right. So the next kind of useful data type or data class made available from the Library R sets.

419
00:54:00,290 --> 00:54:12,290
Okay. So sets are actually kind of tell me if, you know, if you did type python, it's kind of similar to the concepts of sets in Python.

420
00:54:14,860 --> 00:54:22,240
Okay. Like we said before, vectors are an example of order container.

421
00:54:22,250 --> 00:54:31,790
So I guess one of the main differences between sets and vectors sets are should be thought of more as as unordered containers.

422
00:54:32,330 --> 00:54:43,150
Okay. So like when you define a vector with elements, one, two, three, that really means the first element is one.

423
00:54:43,180 --> 00:54:46,600
The second element is two. The third element is three.

424
00:54:47,250 --> 00:54:51,010
That's kind of the way to interpret a vector.

425
00:54:51,970 --> 00:54:55,480
However, like a set, you shouldn't really think of it that way.

426
00:54:56,140 --> 00:54:59,530
It's kind of there's there's no ordering.

427
00:54:59,530 --> 00:55:08,259
Like if, if you try to create a set with elements one, two, three, it doesn't really matter how you enter it.

428
00:55:08,260 --> 00:55:13,630
If you enter the numbers as one, two, three, four, three, two, one is still the same set.

429
00:55:13,860 --> 00:55:19,270
Okay. And all that matters is kind of the the collection of items that are contained in the set.

430
00:55:20,320 --> 00:55:23,750
The position at which they're at doesn't really matter. Okay.

431
00:55:24,950 --> 00:55:30,470
It's really to the main difference between a set and an A vector.

432
00:55:33,590 --> 00:55:37,220
Okay. So the way you declare sense is kind of similar to vectors.

433
00:55:37,700 --> 00:55:40,970
You just use the word set instead of vector. That's really the main difference.

434
00:55:41,930 --> 00:55:45,950
You do have to use this includes set pattern in order to use it.

435
00:55:47,450 --> 00:55:50,510
Okay. And then like vectors they all have like.

436
00:55:51,110 --> 00:55:57,290
I mean, you can declare and set any type, but once you've declared the type of a set,

437
00:55:57,290 --> 00:56:00,800
like all the all the elements at the set have to have the same type.

438
00:56:01,370 --> 00:56:09,860
Okay. So if I do declare a set with this I.R.A. that just meets all of the elements of that set has to be integers.

439
00:56:10,250 --> 00:56:20,090
Okay. Or this example, if I do set estimate, double strain, that means that all of the elements of the set have to be strings.

440
00:56:21,770 --> 00:56:27,560
Another similarity between sets and vectors is that you can you can kind of resize them

441
00:56:28,730 --> 00:56:39,710
as you go along to basically add add new elements or delete elements from us a set.

442
00:56:39,830 --> 00:56:49,729
That's not a problem, I would say. So the other main difference between vectors and sets besides like the ordering aspect is that

443
00:56:49,730 --> 00:57:00,440
the I guess it it kind of automatically removes duplicates in a sense or so sets automatically.

444
00:57:02,150 --> 00:57:07,650
So you, you can certainly have a vector that has repeats.

445
00:57:07,650 --> 00:57:12,860
So you could declare a vector that has elements one, two and three, and then three.

446
00:57:12,860 --> 00:57:16,240
Again, that's not a problem. What you can't do that was set.

447
00:57:16,260 --> 00:57:23,930
So kind of elements that are redundancies, that means they already exist in a set.

448
00:57:25,110 --> 00:57:35,350
You can't kind of add that it doesn't really make sense. It's kind of a collection of unique items is the purpose of a of a set in C++.

449
00:57:37,920 --> 00:57:46,730
Okay. So these are just some of the useful features of our useful methods that you can use with sense.

450
00:57:47,410 --> 00:57:50,510
I think they're pretty similar to what we talked about before.

451
00:57:55,140 --> 00:58:03,300
So the declaration of similar size tells you the total number of elements empty tells you whether or not it's an empty set or not.

452
00:58:04,980 --> 00:58:09,690
So you can insert certain elements or trace elements.

453
00:58:10,560 --> 00:58:17,850
Okay. So here you have to give it like the actual element, not give it like a position that you want it to leave.

454
00:58:17,890 --> 00:58:22,800
You want to put the actual kind of value that you want to add or erase.

455
00:58:27,270 --> 00:58:31,090
So then so that.

456
00:58:31,110 --> 00:58:34,440
Yeah, that's how insert or race works. So I think find.

457
00:58:35,160 --> 00:58:44,370
So fine. This might be kind of confusing. So like, like we said before that there's no ordering so it doesn't return an exact it doesn't

458
00:58:44,370 --> 00:58:51,540
return like an index in the same sense that you would return an index for a vector.

459
00:58:52,080 --> 00:58:54,600
So it returns something called iterator.

460
00:58:55,220 --> 00:59:05,790
So iterator is a separate type that basically allows you to access components of a set kind of a it's a type that kind of.

461
00:59:08,440 --> 00:59:16,020
Yeah. Basically the main purpose is to access certain elements of a set, even though sets are unordered.

462
00:59:16,170 --> 00:59:19,319
So iterations are often useful.

463
00:59:19,320 --> 00:59:21,870
So let's say if you want to print out the contents of a set,

464
00:59:22,500 --> 00:59:40,710
we can declare an iterator and that an iterator for that set and you could that allows you to basically access or print out each element of a set.

465
00:59:42,480 --> 00:59:51,370
I think I'll show some examples of that a little bit later on, hopefully that I'll clear up a little bit the concept of an iterator.

466
00:59:51,960 --> 00:59:55,170
And I think we'll also talk about that a little bit later on.

467
00:59:55,170 --> 00:59:58,830
So so VB can begin.

468
01:00:02,280 --> 01:00:05,519
Yeah. So it's an iterator to the first element.

469
01:00:05,520 --> 01:00:10,679
So if you want to. So there's really no quote unquote first element.

470
01:00:10,680 --> 01:00:23,669
But if you want to, I guess like if you're doing a loop, if you want to start somewhere you want to, this is useful.

471
01:00:23,670 --> 01:00:31,510
If you want to just print out the way that the iterator is treating the first person

472
01:00:31,980 --> 01:00:36,360
and the element that the iterator is considered to be the the first element of that.

473
01:00:36,360 --> 01:00:40,680
So you can do that. The. So I think.

474
01:00:43,390 --> 01:00:52,530
So this is a typo. So this is. This is not an iterator, the first element.

475
01:00:52,530 --> 01:01:07,520
So this is an iterator. This is what we called the card after the last plus one in some sense, so that it's like an empty element.

476
01:01:07,530 --> 01:01:14,520
Basically, it's like the index of the the thing that would come after the last element.

477
01:01:14,550 --> 01:01:19,080
It's like if you add in elements, this is kind of like the end plus one element.

478
01:01:19,770 --> 01:01:29,880
So it should be empty. But the purpose of this is like if find is so, if there's no match for find, it'll return this.

479
01:01:30,120 --> 01:01:34,390
Okay, so that's kind of telling you that it didn't find it.

480
01:01:34,440 --> 01:01:37,760
So it's kind of like the the last element plus one.

481
01:01:37,770 --> 01:01:42,540
So if it returns, that basically means that it found no match.

482
01:01:44,960 --> 01:01:48,020
All right. So let's see.

483
01:01:49,280 --> 01:01:55,669
There's just some examples, I think. So, you know, in this example, I'm just showing time how sex works.

484
01:01:55,670 --> 01:02:00,560
So we're basically declaring a set of strings.

485
01:02:01,850 --> 01:02:06,230
So first off, we declare a set which is empty.

486
01:02:06,800 --> 01:02:11,640
I mean, it has type string, but it's when you run this, it's basically an empty string.

487
01:02:11,770 --> 01:02:15,410
Okay. There's no there's no size to it. There's no elements in it.

488
01:02:16,190 --> 01:02:19,880
And then we could basically just add stuff to it by using insert.

489
01:02:19,900 --> 01:02:24,830
So when I run this, I'm inserting the string ABC.

490
01:02:25,370 --> 01:02:30,740
So after you run this line of code, it should have one size should be one.

491
01:02:35,870 --> 01:02:41,450
Okay, then I'm turning that out and then I'm adding the string BCD.

492
01:02:41,630 --> 01:02:50,960
So after this, it should have two elements. And then we're basically adding, well, we're at least attempting to add ABC and again.

493
01:02:52,100 --> 01:02:55,670
So you'll see you'll see what happens when we when we run this.

494
01:02:56,750 --> 01:03:00,440
So here you'll notice that we already have the string ABC.

495
01:03:01,310 --> 01:03:07,310
If we attempt to add it again, it basically I think it just ignores it more or less.

496
01:03:08,330 --> 01:03:15,440
Right, since it doesn't allow for duplicates in the set. So it should ignore that kind of last insert.

497
01:03:16,070 --> 01:03:22,600
So you can see that here. Kind of the first thing that's printed out is the size of the of the set.

498
01:03:22,610 --> 01:03:26,900
So you can see here, after we run the first insert, it has size one.

499
01:03:27,530 --> 01:03:34,939
After we run the second, insert has size two. After you run the third insert, it has size.

500
01:03:34,940 --> 01:03:42,589
It still has size two. It's just because ABC already existed.

501
01:03:42,590 --> 01:03:53,270
So since ABC already existed in our set base, there's nothing that much that is allowed for duplicate since it just still has size two.

502
01:03:54,350 --> 01:03:58,740
So it's just kind of an example of declaring a string and just showing the

503
01:03:59,180 --> 01:04:02,990
feature of the string that there are no kind of duplicates allowed in a string.

504
01:04:04,910 --> 01:04:08,530
All right. Here is an example of using fine in a race.

505
01:04:08,540 --> 01:04:24,890
So this is going to say, I'm declaring a string here and then I'm just inserting the strings, ABC, NBC, and I'm saying if find ABC does not equal to.

506
01:04:26,030 --> 01:04:35,090
So this is like the this is this is basically how you see if something exists in your set or not.

507
01:04:35,780 --> 01:04:43,670
It, as defined, does not return the kind of iterator to the last plus one element.

508
01:04:44,470 --> 01:04:48,260
And that means that that it's found there is a match.

509
01:04:48,290 --> 01:04:55,609
Okay. So if there's no match found, this find would return the value equal to DOT.

510
01:04:55,610 --> 01:04:58,720
And that's kind of the way this works. Okay.

511
01:05:00,050 --> 01:05:06,500
All right. So here so I think in this case, it should print this out since ABC does exist in our set.

512
01:05:07,280 --> 01:05:11,330
Okay, now, now what are we doing in this line? We were just racing ABC.

513
01:05:11,930 --> 01:05:18,140
And so I think after racing it, it shouldn't, you know, it should not be found.

514
01:05:18,150 --> 01:05:23,630
So if we do this test, we're find we test whether it's equal to end.

515
01:05:24,740 --> 01:05:27,950
So that should be true since ABC is no longer in the set.

516
01:05:28,520 --> 01:05:31,910
So it should print out this message. I think it should print out both messages.

517
01:05:34,850 --> 01:05:45,979
Yeah. If you run this, it prints out both messages. So this is just an example of how you can test whether or not a certain thing exists in your set.

518
01:05:45,980 --> 01:05:51,110
You just basically look at what the the fine method returns.

519
01:05:51,710 --> 01:05:56,330
So the fine method returns the iterator to the last plus one element.

520
01:05:57,170 --> 01:06:08,479
I mean, that means there's new there's no match if it returns the last plus the iterator to the last plus one element like we did here,

521
01:06:08,480 --> 01:06:13,400
that means there there was no match found. All right.

522
01:06:14,690 --> 01:06:21,440
So all I wanted to say about sense, so I think that's important first.

523
01:06:21,710 --> 01:06:28,640
So I think that's it for sets. So again, the assets are pretty similar.

524
01:06:28,640 --> 01:06:33,410
The vectors are still vectors. Yeah, main differences.

525
01:06:33,410 --> 01:06:44,450
There's no duplicates. And then there's really it's not an ordered container the way this vectors are.

526
01:06:44,450 --> 01:06:53,060
So you can't when you're dealing with sets, you can't necessarily access the components you can,

527
01:06:53,180 --> 01:06:57,469
but you can't access them in kind of the straightforward way that you do with vectors.

528
01:06:57,470 --> 01:07:05,030
You can't look at the component with index zero or index one, for example.

529
01:07:07,110 --> 01:07:12,830
All right, so I think we'll just do maps and that'll be it for today. So I think maps are actually based.

530
01:07:13,020 --> 01:07:16,170
I mean, you didn't have to take Python, but it didn't take Python.

531
01:07:18,280 --> 01:07:24,780
It would it might be helpful to think of maps as similar to Python dictionaries.

532
01:07:24,960 --> 01:07:35,160
Okay. So C++ sets are actually kind of similar to Python sets and C++ maps are pretty similar to Python dictionaries.

533
01:07:36,830 --> 01:07:42,750
Okay. No, I didn't put anything else on this slide.

534
01:07:42,750 --> 01:07:45,780
So this is actually kind of how you declare maps.

535
01:07:46,440 --> 01:07:54,540
They're also from the if you didn't use street names using namespace history, you have to use this city double colon.

536
01:07:55,890 --> 01:08:00,210
And then with maps, there's basically two types associated with a map.

537
01:08:00,300 --> 01:08:06,090
So there's a map has key values, basically like a collection of key value pairs.

538
01:08:06,090 --> 01:08:12,060
So there's a type associated with the keys and a type associated with the value.

539
01:08:12,840 --> 01:08:15,899
Right. So that's you have to declare that type.

540
01:08:15,900 --> 01:08:29,520
So kind of this t one didn't ask the it's the type associated with the keys of the map and then T2 is the type associated with the values of the map.

541
01:08:30,220 --> 01:08:38,430
So I think there's let's see some examples of that. But that's kind of what this t one common T2 is is supposed to represent.

542
01:08:39,120 --> 01:08:42,630
Okay. All right. So I think.

543
01:08:44,460 --> 01:08:49,950
A lot of these are pretty similar to the other stuff, but one or two things are different.

544
01:08:51,000 --> 01:08:58,890
Okay, so the way you declare a map is kind of similar, but we just have to have two types.

545
01:08:59,790 --> 01:09:07,530
So we have to have a keyword map. And then in contrast to vectors over cents, we have to have two types.

546
01:09:08,250 --> 01:09:13,650
So the T one is the type of the key and then the T two is the type of the value.

547
01:09:15,900 --> 01:09:19,620
Okay. So there's also you can also get the size of a map.

548
01:09:20,130 --> 01:09:25,970
So just keep in mind that what the size is returning is the number of key value papers.

549
01:09:26,010 --> 01:09:34,110
It's not the size of the individual user values, it's just the total number of pairs.

550
01:09:36,630 --> 01:09:43,410
V empty. That's kind of similar to what we had before that just says whether or not it's empty or not.

551
01:09:44,520 --> 01:09:52,470
The way you can access kind of individual components of your map is you use the you access it by key.

552
01:09:53,340 --> 01:10:03,560
It's not really so it's not really ordered in the same way a vector is like the first or second component, but you can access the component by key.

553
01:10:03,570 --> 01:10:13,410
So if you do V and kind of the name of a search key, it should return to the value associated with that key.

554
01:10:14,250 --> 01:10:18,870
Okay. All right.

555
01:10:19,210 --> 01:10:25,930
So you can erase a key using a race scan.

556
01:10:25,930 --> 01:10:31,389
Find. So find kind of works the same way as with sense.

557
01:10:31,390 --> 01:10:36,970
It returns. Well. Yeah.

558
01:10:37,210 --> 01:10:40,820
It returns basically an iterator.

559
01:10:40,820 --> 01:10:54,560
It doesn't it doesn't return nicely interpretable index it returns kind of an iterator to that to that kind of key value pair.

560
01:10:54,620 --> 01:10:58,030
Okay. All right.

561
01:10:58,040 --> 01:11:00,770
So I think it did the same type of here so.

562
01:11:01,730 --> 01:11:09,890
So beat up again returns in iterator to the first element this is VDOT and return to the iterator to the last plus one element.

563
01:11:10,910 --> 01:11:16,430
So I need to fix this in the slides and then kind of the same thing as was said,

564
01:11:16,490 --> 01:11:26,569
if fine doesn't find any match, it'll return of this iterator at this last plus one iterator.

565
01:11:26,570 --> 01:11:34,790
So that's kind of an indication that there's no match if that's if that's where that find returns.

566
01:11:35,930 --> 01:11:40,820
Okay, so maybe this was too much to put it once.

567
01:11:41,120 --> 01:11:45,139
So this is just walk through a few of the examples.

568
01:11:45,140 --> 01:11:52,250
So these are just examples of declaring a map and kind of how you can work with maps.

569
01:11:53,180 --> 01:11:53,479
All right.

570
01:11:53,480 --> 01:12:04,790
So if you want to use maps, you know, as with kind of the other examples from the steel library, you have to include the time, the appropriate header.

571
01:12:05,390 --> 01:12:12,170
So you have to include this map header, right? So tend to include the map at the top, right?

572
01:12:12,170 --> 01:12:16,160
So the way you declare a map. So I'm going to just declare a map called an S.

573
01:12:16,700 --> 01:12:25,160
So this is going to be a map where the kind of the keys of the map are strings and then the values are the map integers.

574
01:12:25,790 --> 01:12:29,060
So that's what I'm doing here around I use this line six or so.

575
01:12:30,020 --> 01:12:37,520
So this is a map with string keys and integer values.

576
01:12:37,820 --> 01:12:43,399
All right. That's what we're doing here. So way to make this declaration.

577
01:12:43,400 --> 01:12:47,540
It's basically an empty map. Okay, so there's nothing inside of it.

578
01:12:47,540 --> 01:12:52,400
So after that, we can add stuff to the map.

579
01:12:52,970 --> 01:13:00,340
So in this first thing after declaration, if I do IM's quotes A, B, C is equal to one.

580
01:13:00,830 --> 01:13:04,610
What does that do? That creates a single key value pair.

581
01:13:05,060 --> 01:13:11,540
The key is A, B, C, and then the value associated with ABC is one.

582
01:13:14,030 --> 01:13:19,370
So after running this line of code, MSA is now a map with size one.

583
01:13:20,430 --> 01:13:25,070
The single key value pair inside the map is ABC comma one.

584
01:13:28,000 --> 01:13:31,510
And then you can you can you can modify the values.

585
01:13:32,560 --> 01:13:38,290
So you can't really modify the keys, but you can modify the values directly.

586
01:13:39,850 --> 01:13:46,870
So I want to modify the value associated with ABC.

587
01:13:47,260 --> 01:13:57,950
I can do it this way. So if I do comes ABC, I can do this increment operator and that's going to increase the value associated with ABC to two.

588
01:13:58,620 --> 01:14:02,259
Yes. Thank you for that. And then in the next slide,

589
01:14:02,260 --> 01:14:14,800
I'm just printing the value associated with the end of this value associated with the key ABC inside the map and what's going on here.

590
01:14:18,760 --> 01:14:22,430
Oh, yeah, yeah. Like I said before. So you can.

591
01:14:24,970 --> 01:14:33,250
I say that. Oh, yeah.

592
01:14:34,930 --> 01:14:43,750
So like I said, like we said before, X, if you do this VCE so that kind of accesses the value associated with that key.

593
01:14:44,200 --> 01:14:54,490
If key doesn't exist, it basically creates basically creates that key and a value associated with that key automatically.

594
01:14:55,510 --> 01:15:06,400
So that's what's going on here. So even though the key doesn't exist, like BCD doesn't exist, this creates a key BCD in MSS.

595
01:15:07,090 --> 01:15:15,950
And if the values are integers by default, it just assigns a value of zero by default.

596
01:15:15,970 --> 01:15:23,650
If you don't give it anything, I could have assigned it a value if I said MBS, b, c, d is equal to something.

597
01:15:24,280 --> 01:15:30,340
It would give it that value. But if you don't give it anything, it kind of assigns zero by default.

598
01:15:30,890 --> 01:15:34,600
Then if we do an incremental on that, that should incremented to one.

599
01:15:34,600 --> 01:15:41,650
So maybe the BCD key should have a value of one after running this line of code.

600
01:15:41,850 --> 01:15:45,330
Okay. Okay.

601
01:15:45,550 --> 01:15:50,740
So let's see. So that's what's going to be printed out.

602
01:15:51,190 --> 01:15:58,360
So here we're doing fine. So this this should not equal to the end since ABC exists.

603
01:15:58,960 --> 01:16:06,040
So we should see this message output it. ABC was found, and then we erase it.

604
01:16:06,040 --> 01:16:11,710
And then we also check this to find equals and iterator.

605
01:16:12,070 --> 01:16:16,809
And that should also be true since ABC no longer exists. So this should also be printed out.

606
01:16:16,810 --> 01:16:22,360
So we should expect this message and the message to be printed out.

607
01:16:25,360 --> 01:16:29,760
Probability and time and again. This is really dry and material which.

608
01:16:32,810 --> 01:16:39,120
Yeah. So this prints out one first by my side prints out to first.

609
01:16:39,980 --> 01:16:46,010
Right. Since they keep the the value associated with ABC is to this at this point

610
01:16:46,010 --> 01:16:51,799
in the code we said before and then when we print out this it should be one,

611
01:16:51,800 --> 01:16:58,100
right since we said it must be CD when we run that that's like creates a value of zero.

612
01:16:58,790 --> 01:17:01,550
And then we did an increment on that. So it should print out one.

613
01:17:02,270 --> 01:17:11,660
And then like I said before this, both of these messages should be printed out since ABC exists here.

614
01:17:11,780 --> 01:17:15,169
And then after running a race, ABC does not exist.

615
01:17:15,170 --> 01:17:18,749
There is kind of the reasoning for that. All right.

616
01:17:18,750 --> 01:17:22,380
So how much do we have? Well.

617
01:17:27,770 --> 01:17:33,589
Okay. I think we just have to say what innovators are, and then we have a little example of how to use them.

618
01:17:33,590 --> 01:17:45,600
And then I think that'll be. So innovators are basically ways of accessing elements and steel containers.

619
01:17:46,170 --> 01:17:51,840
I think for for like for order containers like vectors and strings, it's pretty straightforward.

620
01:17:52,170 --> 01:17:56,030
You just use the numeric indices like a01 or two.

621
01:17:56,670 --> 01:18:03,299
So zero for a vector that accesses like the first component, etc., etc. for sets and maps.

622
01:18:03,300 --> 01:18:08,850
However, like they're for unordered containers. You can't really use this directly.

623
01:18:09,150 --> 01:18:12,660
Okay, you have to use this.

624
01:18:12,840 --> 01:18:21,810
It's actually a different type. So an iterator is actually a variable that has a special type for it.

625
01:18:22,380 --> 01:18:31,890
So the the based the the type is, I guess, the, the type that it's referring to.

626
01:18:32,340 --> 01:18:36,030
Double Colon Iterator is actually kind of a separate type.

627
01:18:36,040 --> 01:18:42,900
So let's say we had a map like we had before with string cheese and integer values.

628
01:18:46,230 --> 01:18:53,030
The iterator associated with that would have the type map string int double colon iterator.

629
01:18:53,040 --> 01:19:03,359
So it's like a iterator are almost like a separate type. The way to start an iteration from, I guess the quote unquote beginning,

630
01:19:03,360 --> 01:19:07,830
or at least the way the iterator, the thing the iterator is treating as the beginning.

631
01:19:08,400 --> 01:19:14,040
You use the dot begin method and then to access the end use that.

632
01:19:14,940 --> 01:19:22,740
Okay. For a map. Yeah. So maps have kind of a special thing that you have to use with them.

633
01:19:23,610 --> 01:19:33,399
So our map iterator, since there's kind of two components for that, I guess there's yeah, there's two components for each component of a map.

634
01:19:33,400 --> 01:19:37,440
Right. There's like a key part in a value part.

635
01:19:39,000 --> 01:19:51,180
Okay. So if we're looking at a certain value of the iterator, so something that you can think of is like the third index, three of your iterator.

636
01:19:52,020 --> 01:20:01,500
If you want to access the key part of that, you have to use this at least to extract it and you have to use this arrow first.

637
01:20:02,220 --> 01:20:10,500
So that kind of like extracts the, the key of that, of that part of the kind of the current value of the iterator.

638
01:20:10,920 --> 01:20:19,620
And then you do this inner arrow second to kind of extract the value part of that, that inner iterator.

639
01:20:22,630 --> 01:20:29,440
I have an exam. Hopefully it's probably not 100% clear from this description, but using this,

640
01:20:30,070 --> 01:20:37,570
I guess the key thing to keep in mind is this these arrows allow you to kind of separate the key and the value

641
01:20:37,570 --> 01:20:49,210
part of the of the of your map when you're accessing kind of individual components of your map using an iterator.

642
01:20:49,400 --> 01:20:52,940
Okay. So hopefully this makes it a little more clear.

643
01:20:52,960 --> 01:20:58,450
So here's just a little example where I have a map with a string of value pairs.

644
01:20:59,050 --> 01:21:08,890
So yeah, this is how you are. Sorry, this is now this actually has this is flip, this has integer keys and string value.

645
01:21:08,900 --> 01:21:23,059
So this is how you declare a. Or how you can create a map and in C++, at least directly without inserting everything.

646
01:21:23,060 --> 01:21:38,030
So you do everything inside of curly braces and then you kind of separate kind of keys and values with with with commas.

647
01:21:38,960 --> 01:21:50,600
So I guess the point here is that the keys for this for this map is one, two, three and four, and then the values are these kind of fruit names.

648
01:21:50,660 --> 01:21:56,150
Okay. All right. So to access that kind of the components of this map.

649
01:22:00,580 --> 01:22:09,570
The way you can do it is the following. So if you were to if you wanted to loop over the elements of this map, I can use a for loop.

650
01:22:09,720 --> 01:22:14,790
And then the first thing I would do, I would say, you have to declare this special iterator type.

651
01:22:15,420 --> 01:22:19,020
So ITER is the name of a variable with this special iterator type.

652
01:22:20,370 --> 01:22:30,840
It's going to start from the beginning index, I guess, of this map and then it's going to go up to all the way up to.

653
01:22:34,070 --> 01:22:37,490
Something not equal to the end.

654
01:22:37,820 --> 01:22:43,430
Okay, so once it equals the last element, it's going to terminate the loop.

655
01:22:44,000 --> 01:22:48,920
And then you can also you can also use an increment on your iterator.

656
01:22:48,920 --> 01:22:59,630
It doesn't necessarily add one and the sense of integers, but it goes to the next position in the map.

657
01:23:00,200 --> 01:23:08,170
It's kind of what the if you apply this increment operator to the iterator, basically every time you evaluate this tool,

658
01:23:08,360 --> 01:23:13,070
the interpretation is that it it's going to go to the next element in your map.

659
01:23:15,620 --> 01:23:24,649
And then what are we going to print out here? So enter. So you could think of this as kind of each time we go inside the loop inner contains the

660
01:23:24,650 --> 01:23:35,930
contents of the kind of the next part that they give me like the current currency value pair.

661
01:23:36,470 --> 01:23:41,540
And the way an iterator is set up is that it should iterate through all of the elements of the map.

662
01:23:43,520 --> 01:23:50,510
All right. And so when we do this arrow notation, what it's going to print out is the the key first.

663
01:23:50,520 --> 01:23:56,180
So this will print out the key for the kind of the current key value pair, the end of the map.

664
01:23:56,870 --> 01:24:03,950
And then we're going to have kind of a white space. And then after that, it's going to print out the value associated with that key.

665
01:24:04,280 --> 01:24:09,919
Okay. So when we run, this should this should print out all the key value pairs and then the keys in the

666
01:24:09,920 --> 01:24:15,110
value should be separated by a single amount of whitespace that we have here.

667
01:24:16,520 --> 01:24:28,160
Each one. Yeah. This is another way of just kind of skipping our ending the line because you could could do it as well as just an alternative.

668
01:24:28,640 --> 01:24:33,230
Okay, so this is. Yeah, like I said before, this is just what it would print out if you.

669
01:24:35,360 --> 01:24:41,870
If you just running the show, it'll print out. Yeah, just print out the keys, which is one, two, three and four.

670
01:24:41,870 --> 01:24:50,350
And the associated values, which are these fruit names. And then we have a single whitespace in between the keys in the value.

671
01:24:50,360 --> 01:24:56,390
So that's how it works. So these innovators are useful for.

672
01:24:56,760 --> 01:25:00,950
Yeah. I mean, I think this is kind of a classic use of the iterator.

673
01:25:01,370 --> 01:25:08,060
It's a way of iterating through all of the the elements of a map, even though we don't really have.

674
01:25:08,990 --> 01:25:15,140
Even though maps are not really ordered, there's no kind of first element or second element of a map.

675
01:25:23,600 --> 01:25:33,690
Just checking. None of this is too complicated to go through just quickly and we can review it quickly as well next time.

676
01:25:33,690 --> 01:25:42,750
So this is basically an example of of using a map and kind of iterating through a map as well.

677
01:25:43,320 --> 01:25:47,770
Let's say we have this text file which has a bunch of words.

678
01:25:48,270 --> 01:25:58,469
I also put this on canvas science, that text. And basically when we want to count the number of times each word appears and then report when I

679
01:25:58,470 --> 01:26:04,440
report each word in the text file and we want to report the number of occurrences of that word.

680
01:26:05,160 --> 01:26:09,150
So I'm thinking of each word as being like a G in a map.

681
01:26:09,780 --> 01:26:14,220
And then a value is the number of times that word appeared in the map.

682
01:26:14,610 --> 01:26:24,200
So that's kind of what we're trying to do, is to have a map where each word represents a key and the map and then the value is.

683
01:26:30,640 --> 01:26:38,080
And the number of contacts. Okay. So let's see, basically.

684
01:26:38,080 --> 01:26:41,230
Okay. I mean, we've already been through reading in a file.

685
01:26:41,740 --> 01:26:51,820
So basically the way it's going to work is I create this map for strange and integer values within the word count.

686
01:26:53,140 --> 01:27:05,650
And so for each for each word that we're reading in front, the document, the word counts basically says that we're going to hear that key.

687
01:27:05,650 --> 01:27:13,510
So S represents a key. So since it's a word, we're going to increase that, the value associated with that key.

688
01:27:13,750 --> 01:27:18,350
Okay. So that's how it's going to work.

689
01:27:20,840 --> 01:27:28,310
Right. And then if that word already exists, it it just increases the value associated with that cheat.

690
01:27:28,700 --> 01:27:35,330
If it doesn't exist, like we said before, it kind of automatically creates a cheat and the value is zero.

691
01:27:35,840 --> 01:27:38,480
And so we run this. It should be one after that.

692
01:27:39,230 --> 01:27:50,120
So that's actually this is kind of neat, this kind of kind of basically one line of code it to create this map of key value pairs,

693
01:27:50,630 --> 01:28:03,700
which is kind of stores everything we want it to store. And then down here, I'm just I'm just kind of doing the same procedure, using the iterator.

694
01:28:04,060 --> 01:28:06,459
And here we can print out all of the key value pairs.

695
01:28:06,460 --> 01:28:12,850
So there's all the key value pairs are just the number of words and the values are just the number of times it appears.

696
01:28:13,630 --> 01:28:21,750
Okay. So I think I oh, I think I only printed it out if the, if the value was greater than 500.

697
01:28:21,760 --> 01:28:26,530
Otherwise it's kind of too long. Okay. So this is just an example of, of running it.

698
01:28:26,530 --> 01:28:31,380
So this is what we get for that if you run it on this solid start text file.

699
01:28:31,390 --> 01:28:43,330
So this files in canvas and tiers appears 636 or at least the capital is the word a appears 851 times.

700
01:28:43,480 --> 01:28:52,629
So that's that's kind of just the output of this. Yeah, I think next time as well.

701
01:28:52,630 --> 01:28:56,950
But I think we'll just stop there for today.

702
01:28:56,950 --> 01:29:07,350
So. Anything your age.

703
01:29:09,430 --> 01:29:16,919
A little late. Yeah, that's it for today.

704
01:29:16,920 --> 01:29:21,030
So I'll see you on Monday. Yeah.

705
01:29:21,030 --> 01:29:25,440
Just remember that. The homework to do and on.

