1
00:00:00,870 --> 00:00:16,510
It just seems to me that the first steps that we are doing all about doing such a radio show and the show depended on the show.

2
00:00:16,710 --> 00:00:22,880
She is wonderful, this wonderful humor on every show.

3
00:00:22,890 --> 00:00:27,040
This is very much this is great, but this isn't show.

4
00:00:27,350 --> 00:00:31,500
That's what makes sense. It's something that we follow.

5
00:00:31,690 --> 00:00:40,679
We gave an answer, the whole ceremony, what it was first stilted and relativist since she she's never seen again.

6
00:00:40,680 --> 00:00:45,660
You should see the both. The quiz is due on Thursday.

7
00:00:45,730 --> 00:01:02,790
My homework is right around here, so just keep that in mind.

8
00:01:05,340 --> 00:01:15,750
So let's see. Okay. So I think today is a lot of now being basically extra details.

9
00:01:16,750 --> 00:01:22,770
I started a little bit last time, actually just the last thing you can do with the materials.

10
00:01:23,580 --> 00:01:27,870
And I also do kind of sample with the real data set.

11
00:01:29,720 --> 00:01:34,330
Kind of like looking at different summary statistics.

12
00:01:34,410 --> 00:01:40,410
You compute if you saw kind of a data set as a number theory and this and if we have time,

13
00:01:40,410 --> 00:01:57,300
we'll do a little bit more on the transition between the arrays and pandas, basically the pandas next time on Wednesday.

14
00:01:58,780 --> 00:02:04,230
Okay. So let's go back to none of you said this last time.

15
00:02:04,530 --> 00:02:11,880
It's just that basically the library here in America computing with Python,

16
00:02:12,150 --> 00:02:23,100
etc. and the main reason for using NumPy is basically it has kind of vector matrix type data structures.

17
00:02:23,190 --> 00:02:40,550
So the main purpose is in your algebra type operations or it's also so often also useful to kind of store data senses and factory variables,

18
00:02:40,560 --> 00:02:53,000
factors or matrices and manipulate factor matrices basically not being timed because

19
00:02:53,040 --> 00:02:58,479
everything in it is like a one dimensional array that is vector if you prefer,

20
00:02:58,480 --> 00:03:11,280
or in a two dimensional or any one. Beatrice So forget it.

21
00:03:11,280 --> 00:03:15,389
As she was just saying, if you're doing a lot of statistical analysis, I mean,

22
00:03:15,390 --> 00:03:20,860
I would say usually I'm the one to store your data center is either kind of a to the number,

23
00:03:20,900 --> 00:03:25,650
not the array for a pandas data frame, which we'll talk about next time.

24
00:03:27,750 --> 00:03:38,040
What we mentioned last time, yeah, I think we've mentioned this as well last time just before you you start using not be in a python session,

25
00:03:38,040 --> 00:03:44,460
you had to import it and it's not part of built in Python.

26
00:03:44,940 --> 00:03:56,579
So the way you usually do that as in in I mean you don't have to record as MP but that's just kind of a usual the convention,

27
00:03:56,580 --> 00:04:00,570
I would say most people work as an MP and then once you've done that,

28
00:04:01,610 --> 00:04:13,530
the way you run different functions, for example, from nothing, New Zealand has sort of named the kind of the name of the function in that.

29
00:04:15,360 --> 00:04:19,110
Okay, so that's kind of how you run everything from up here.

30
00:04:19,110 --> 00:04:24,210
You see something like MP got something easier using from something from nothing.

31
00:04:25,190 --> 00:04:34,709
You said this last time as well as the kind of the main kind of data structure and it's made available by an

32
00:04:34,710 --> 00:04:45,450
obviously in the array stands for dimensional array most in most cases this is a one array or a 2D array.

33
00:04:45,450 --> 00:04:51,570
So I was wondering, is this list of numbers more or less?

34
00:04:53,210 --> 00:04:59,880
It's a think of it as a vector, if you prefer to look at it that way to do.

35
00:04:59,970 --> 00:05:06,940
National showed is basically like a table of numbers with rows and columns.

36
00:05:09,290 --> 00:05:18,999
That's what I would say. You're going to use most commonly in practice, one dimensional and two dimensional arrays,

37
00:05:19,000 --> 00:05:24,910
although you can you can define higher dimensional arrays on it.

38
00:05:25,390 --> 00:05:26,590
Sometimes it's useful, but.

39
00:05:28,440 --> 00:05:37,890
That's a most you're going to most often use one dimensional and two dimensional arrays was compared to higher dimensional entries.

40
00:05:40,200 --> 00:05:49,740
So you know the way you. And create and not be erased just with this array of function or indeed operating functions.

41
00:05:50,370 --> 00:05:57,959
And here it just at least a basic way of creating one is to convert a list or any type of other kind of

42
00:05:57,960 --> 00:06:10,890
sequence object like a tuple and directly convert it into a not be ending array which in never say it again.

43
00:06:11,880 --> 00:06:18,810
You know, the only one major difference between not being array on a list, for example,

44
00:06:18,810 --> 00:06:27,510
is that kind of all of the elements of a not being array have to have the same and have the same type basically.

45
00:06:28,770 --> 00:06:32,370
So they all have to be either all numbers or all strings.

46
00:06:33,660 --> 00:06:41,340
You can't mix these different data types like you can with a with a list, basically.

47
00:06:41,340 --> 00:06:42,450
So you can see that here.

48
00:06:42,960 --> 00:06:55,610
Even if we try to convert this list to a numpy array, I mean, you can't convert it, but it automatically converts all the elements to strings.

49
00:06:55,650 --> 00:07:03,840
So we have this list here where it said some numbers add one string converted to a number of everything.

50
00:07:04,290 --> 00:07:14,609
All the elements become becomes strings. Okay, so that's what we mentioned last time.

51
00:07:14,610 --> 00:07:23,729
So I think that's the next topic we want to discuss, which is different indexing tricks for beginners.

52
00:07:23,730 --> 00:07:30,240
Basically, these are just different ways of accessing different items.

53
00:07:32,100 --> 00:07:45,630
So just different tricks for accessing one element or different subset of elements of an array, just the different syntax that's available.

54
00:07:46,440 --> 00:07:50,579
Okay. So you can do slicing basically.

55
00:07:50,580 --> 00:07:55,230
I mean, we already talked about kind of slicing for lists.

56
00:07:55,920 --> 00:08:07,020
So it's actually it's actually exactly the same thing, pretty much for a for indeed arrays and nothing like if we first create this,

57
00:08:07,740 --> 00:08:23,850
not the array here, you know, actually the first create is not the array here, it's just the numbers 012345, six using this function a range.

58
00:08:24,660 --> 00:08:32,820
So a range seven just creates an array starting from zero up to seven.

59
00:08:33,420 --> 00:08:40,230
So it starts at six. It's basically all the numbers, less than seven or all the integers less than seven.

60
00:08:41,850 --> 00:08:52,950
And if you want to look at elements like I'm calling it element three, it's elements index two up through five, but not including five.

61
00:08:53,010 --> 00:08:56,190
That's that's the way to do it, to call in five.

62
00:08:57,210 --> 00:09:01,590
So that would be two is like the total element three,

63
00:09:01,590 --> 00:09:08,430
but it's like index two since we're starting from zero and then it's kind of up to five but not including five.

64
00:09:09,510 --> 00:09:16,990
So that's kind of the calling notation when we're doing slicing, if we don't have anything before calling,

65
00:09:17,400 --> 00:09:22,860
it's at the beginning of the array and it goes up to four, but it knows it doesn't include index four.

66
00:09:23,940 --> 00:09:29,280
If we start from on some index two and then do columns with nothing after the two,

67
00:09:29,850 --> 00:09:35,370
it starts from index to here and then it goes all the way to the end of the array.

68
00:09:36,060 --> 00:09:51,090
This is really the exact same thing as you did for four lists, which is a little bit in this review for a 2D array.

69
00:09:53,460 --> 00:10:00,720
The way you can create it is is to convert kind of a one dimensional array.

70
00:10:00,720 --> 00:10:12,750
But using reshape, like if I create a one dimensional array first and then do appreciate it will convert that

71
00:10:14,850 --> 00:10:21,600
kind of one dimensional array into a two dimensional array with kind of dimensions three,

72
00:10:21,600 --> 00:10:27,480
three and three plus. This just means that it's like has three rows and three columns more or less.

73
00:10:28,230 --> 00:10:31,410
So that's the way now be it's enough.

74
00:10:31,410 --> 00:10:40,649
This is, this is like a matrix with three rows and three columns and then it kind of fills everything by row.

75
00:10:40,650 --> 00:10:52,500
Like it fills in the numbers. All the numbers from this one dimensional riddle fill in the first row in first moved to the second row in the third.

76
00:10:55,180 --> 00:10:59,080
So for this type of two dimensional writing can slice in both dimensions.

77
00:10:59,090 --> 00:11:09,700
So for example, if you do zero colon two and then in the row position and then zero colon to the column position,

78
00:11:09,700 --> 00:11:17,589
it looks kind of it looks at like the first and second elements in both the row and column direction,

79
00:11:17,590 --> 00:11:24,999
basically, since all of the entries from the first and second row and first and second columns.

80
00:11:25,000 --> 00:11:32,620
So it's kind of like this is part of the matrix of the first and second row and then first and

81
00:11:32,620 --> 00:11:43,600
second column is upper left and we are slicing in both dimensions for a two dimensional array.

82
00:11:45,250 --> 00:11:55,120
So what would this do? So this is basically going to look at the index for Row zero and one and column index two.

83
00:11:55,180 --> 00:12:03,020
So it's basically the first season of really like the first two rows from column 2 to 5.

84
00:12:03,910 --> 00:12:10,150
You can see that first class. So this is column index two is the last column.

85
00:12:11,560 --> 00:12:15,670
You know, the first two rows of letters is just too far.

86
00:12:16,000 --> 00:12:19,270
Okay, let's see what that means.

87
00:12:20,080 --> 00:12:23,800
If we do this type of syntax, this is going to give us.

88
00:12:25,420 --> 00:12:31,329
Both the first and second row columns are all of the rows from this column.

89
00:12:31,330 --> 00:12:37,690
So this is basically all of the all of the numbers from the first and second columns.

90
00:12:38,320 --> 00:12:48,220
Okay. What if we do this thing that means that we're we're only looking at kind of numbers from,

91
00:12:49,120 --> 00:12:55,690
I would call it the second row like row index one and then kind of all of the.

92
00:12:58,910 --> 00:13:11,890
And all of the entries for that that were also this is basically all of these numbers from this second row of the row with index one.

93
00:13:12,490 --> 00:13:16,600
Let's keep this this thing here. Three, four, five.

94
00:13:19,240 --> 00:13:24,040
So that's. So that's what that means.

95
00:13:24,080 --> 00:13:27,420
So let's see here. What are some other combinations then you can do?

96
00:13:27,990 --> 00:13:31,830
So you can use something like this.

97
00:13:32,160 --> 00:13:38,250
We would use it for not having anything prior to the prior.

98
00:13:39,840 --> 00:13:48,750
To the colon or after the colon in this case. So this syntax is going to look at the first two rows.

99
00:13:50,300 --> 00:13:55,220
A and the column starting from two all the way to the end.

100
00:13:55,730 --> 00:14:00,230
So like the last since we only have three columns, this is like the last two columns.

101
00:14:00,230 --> 00:14:04,160
So this is the all of the numbers from the first two columns.

102
00:14:04,610 --> 00:14:07,730
Sorry, the first two rows and the last two columns.

103
00:14:08,450 --> 00:14:17,419
So that's kind of this thing, which is, if you remember, should be the first two rows and last two conflicting.

104
00:14:17,420 --> 00:14:23,090
So should be one, two, four or five. That's kind of that's what this is.

105
00:14:23,180 --> 00:14:30,500
That's what this means. It's one, two, four, five. Here, something else that you can do.

106
00:14:31,740 --> 00:14:36,200
I don't think I really use that much just because I don't think it's as clear.

107
00:14:36,200 --> 00:14:44,300
But you can give a single number as a as an end, an index that you enter.

108
00:14:45,650 --> 00:14:50,810
So even though a is like a two dimensional array, you can use this bracket with a single number.

109
00:14:50,820 --> 00:15:00,310
That's perfectly valid. I don't I don't really discriminate as clear as that.

110
00:15:00,320 --> 00:15:04,220
So this basically just gives you the control for this index.

111
00:15:04,910 --> 00:15:10,520
So I would call this like the third row, but it's the it's just the row row index, too.

112
00:15:11,450 --> 00:15:19,069
So that's almost four times, but it's just it's returning the same thing is this two.

113
00:15:19,070 --> 00:15:27,020
And then I feel like this is more explicit. It's showing that we're including all the data from for this row in all of the columns.

114
00:15:29,900 --> 00:15:41,840
So that's that's the main that all the main combinations that you could do what you're doing, slicing for two dimensional arrays.

115
00:15:45,060 --> 00:15:56,720
All right. So that's those are all tricks for accessing kind of elements of an array or a two dimensional ray using like numeric indexes.

116
00:15:57,950 --> 00:16:06,530
The other main way of accessing kind of certain components of an array is using kind of blue IT boolean indexing.

117
00:16:07,340 --> 00:16:14,299
So there's like numeric indexing, we're actually giving it the actual number of the elements that you want to access.

118
00:16:14,300 --> 00:16:22,280
The other main way is Boolean indexing, where you're accessing elements based on kind of the,

119
00:16:22,790 --> 00:16:25,910
you know, whether or not certain things are true or false.

120
00:16:29,930 --> 00:16:37,909
Okay. So I guess what we use for numeric indexing, that that's just by that I just mean like X bracket,

121
00:16:37,910 --> 00:16:46,910
two things like that or X columns where we're using slicing for Boolean indexing.

122
00:16:46,910 --> 00:16:57,160
I mean, that comes up when you where it's a little bit easier to compute something that you're interested in based on on a condition, right?

123
00:16:58,580 --> 00:17:04,250
So something like, you know, a few of the mean of some variable.

124
00:17:04,940 --> 00:17:13,310
Well, based on whether or not, you know, some other variable is greater than zero, he only want to do it for that, for that subset.

125
00:17:14,330 --> 00:17:19,460
So you can go in and compute all of the correct numeric indexes if you want.

126
00:17:21,020 --> 00:17:27,020
But a lot of times I would say it's usually easier to just represent that condition as a boolean

127
00:17:27,020 --> 00:17:35,790
expression and just use that to take the subset of the array that that you're interested in and.

128
00:17:37,570 --> 00:17:41,260
So yeah. So in many cases this is a common example.

129
00:17:41,680 --> 00:17:51,370
You want to compute the mean of a of an array of data, but you only want to compute that means using only those elements,

130
00:17:51,810 --> 00:17:55,960
you know, for example, that come from a specific group of events.

131
00:17:56,680 --> 00:18:02,650
And it's easier to kind of index a group or category using a billion expression.

132
00:18:04,800 --> 00:18:12,490
Okay. Okay. So Boolean indexes,

133
00:18:13,000 --> 00:18:19,420
when you saw you want to do some setting based on the condition here is kind of how

134
00:18:19,450 --> 00:18:29,669
things work when you believe you're actually doing kind of a when indexing in practice.

135
00:18:29,670 --> 00:18:32,940
So let's look at this example. We have this example.

136
00:18:33,670 --> 00:18:40,660
So I'm calling a group of labels. This is this is a not the array, which is has numbers, which is 001.

137
00:18:43,360 --> 00:18:48,849
So what happens when you write like a blue an expression where you have a number,

138
00:18:48,850 --> 00:18:58,050
the array involved usually at least as you've written, candidate Boolean expression in a sensible way.

139
00:18:58,060 --> 00:19:11,140
It does. It'll also return a not the array, but the elements of that return array are basically boolean values.

140
00:19:11,150 --> 00:19:16,600
So if I just write this expression here, I just say group labels double equals zero.

141
00:19:16,600 --> 00:19:21,459
That returns a not the array of the elements of that.

142
00:19:21,460 --> 00:19:25,210
Not B array are just boolean variables itself.

143
00:19:25,220 --> 00:19:28,470
So it returns that not b array. True. True.

144
00:19:28,480 --> 00:19:37,440
False. Okay. So let's just say that the first element is true because the first element here equals zero.

145
00:19:37,450 --> 00:19:41,650
The second element is also true because this element equals zero.

146
00:19:42,220 --> 00:19:49,270
And then the third element equals false, because the third element a group labels equal is not equal to zero.

147
00:19:49,390 --> 00:19:53,709
Okay. So that's that's how it works.

148
00:19:53,710 --> 00:19:58,000
It evaluates this kind of Boolean expression, element by element.

149
00:19:58,000 --> 00:20:03,160
So we just test whether or not the first element equals zero.

150
00:20:04,240 --> 00:20:07,330
Next thing test whether or not the second element equals zero.

151
00:20:07,990 --> 00:20:12,550
And then the last one, absolutely not. The third element equals zero.

152
00:20:14,170 --> 00:20:20,530
And similarly, if we do labels equals one will return.

153
00:20:20,530 --> 00:20:24,130
False. False, true. Okay.

154
00:20:26,110 --> 00:20:29,530
Okay. So where this becomes useful?

155
00:20:29,550 --> 00:20:40,920
Well, this is sometimes useful by itself. You know, if you just want to see whether or not certain things are true or false or yes.

156
00:20:43,830 --> 00:20:54,690
However, for the for the indexing part of the where this becomes useful, they should use a boolean, a boolean, not the array to to subset.

157
00:20:55,610 --> 00:21:09,900
To subset, another array. Okay. So basically so the way I think it's better to just see an example, let's,

158
00:21:10,680 --> 00:21:15,479
let's use the same example or at least to start out with or you have the group labels.

159
00:21:15,480 --> 00:21:20,490
This is just 001 as we said before. And let's define another way.

160
00:21:20,940 --> 00:21:27,490
This is a are it's just going to be as three elements it's just the numbers 012.

161
00:21:27,540 --> 00:21:40,139
So if I do a R, I mean group labels it's the way this works is it returns an array,

162
00:21:40,140 --> 00:21:49,530
but it only returns an array where this vector here or this array here is true.

163
00:21:50,010 --> 00:21:58,590
Okay. If you remember that. When this boolean expression is evaluated, this returns and not be erased.

164
00:21:59,160 --> 00:22:02,160
True. True or false? Okay.

165
00:22:02,890 --> 00:22:24,540
Cause I mean the way to. Actually, I probably should have printed it out like any R is like r r labels.

166
00:22:29,520 --> 00:22:35,450
It was one that's kind of the same thing. Same thing as writing.

167
00:22:37,640 --> 00:22:42,440
You don't usually write it anyway, but you could write it if you had a number, right?

168
00:22:42,770 --> 00:22:51,120
If you had an update or a. That's right.

169
00:22:51,400 --> 00:23:01,950
That's kind of the same the same thing as actually writing out this is better for this, not be afraid.

170
00:23:02,070 --> 00:23:11,979
Kind of explicitly the Blue Mountains. And here, when you consider this, it basically only keeps it only keeps the elements where it's true.

171
00:23:11,980 --> 00:23:16,240
So it's this returns.

172
00:23:19,990 --> 00:23:36,309
Yes, I guess a numpy array with only the first that basically this thing returns kind of another numpy

173
00:23:36,310 --> 00:23:41,440
array where it only keeps the the first two indices because these are only the first two indices,

174
00:23:41,440 --> 00:23:46,120
which is kind of what's going on here.

175
00:23:46,510 --> 00:23:51,600
So it's only returning first to the real author.

176
00:23:52,000 --> 00:23:55,879
And here if we do this Boolean expression, only returning.

177
00:23:55,880 --> 00:24:02,320
The third element, because this of an expression evaluates to false, false, true.

178
00:24:02,650 --> 00:24:12,580
Okay, that's how you can do. That's how boolean indexing works for numpy arrays.

179
00:24:13,900 --> 00:24:18,760
So you could do the same thing for to arrays.

180
00:24:18,760 --> 00:24:31,600
I would say the way it's usually used and I would say usually is, is, is some setting taking a subset of the rows of a to the array.

181
00:24:32,680 --> 00:24:44,470
So like if I define this two dimensional, not the array called a, it's basically a three by three matrix and I just do the same group labels.

182
00:24:45,200 --> 00:24:50,049
I look at a and then group labels zero.

183
00:24:50,050 --> 00:24:54,370
I still have this equals zero is still the same boolean expression, right?

184
00:24:54,370 --> 00:25:03,099
That's true. True, false. And I do comma column that basically it's just going to keep the first two rows and then this

185
00:25:03,100 --> 00:25:10,990
basically returns the all of the numbers from the first two rows of okay so you can see like here,

186
00:25:11,500 --> 00:25:15,579
this is just keeping the first two rows in a kind of similar way.

187
00:25:15,580 --> 00:25:20,300
If I do this one, this only keeps the third row of seats.

188
00:25:20,320 --> 00:25:24,010
This is true. This is false. False, true. Okay.

189
00:25:26,770 --> 00:25:32,560
So I'd say that's at least in terms of like data analysis this week.

190
00:25:33,040 --> 00:25:38,500
I would say this is a little bit more common. You're basically keeping a kind of a subset of the roles of your data.

191
00:25:42,040 --> 00:25:45,129
Okay. So here I mentioned this.

192
00:25:45,130 --> 00:25:57,580
I think it's I think it's useful because it comes up quite a bit if you're doing kind of the B and or type of Boolean logic.

193
00:25:57,580 --> 00:26:02,050
If you want to do that element by element,

194
00:26:04,420 --> 00:26:14,530
you have to use as a kind of a separate or a specific command rather than a simple like keyword and or the keyword or.

195
00:26:15,220 --> 00:26:22,360
So basically, if you want to do what I mean by element, by element, if you have to boolean, not be arrays.

196
00:26:27,710 --> 00:26:30,260
They all have true false values. I just want to compare.

197
00:26:30,740 --> 00:26:38,210
I want to do a comparative element, one from the first array versus element, one on the second array,

198
00:26:38,300 --> 00:26:44,690
and then move on to the second element of first array versus the second element of the second

199
00:26:44,690 --> 00:26:50,360
or a third element of the first array versus the third element from the second array.

200
00:26:50,930 --> 00:27:00,230
Do those types of comparisons kind of element by element and so on and so forth and so on until you reached the end of the gateway.

201
00:27:01,890 --> 00:27:11,300
Okay. So for example, if you define these 2 billion numpy arrays, X and Y, they do like a,

202
00:27:12,830 --> 00:27:23,030
the kind of the boolean element by element operations to use this function input, logical underscore.

203
00:27:23,030 --> 00:27:28,860
And we put that to two arguments in the function X and Y.

204
00:27:29,840 --> 00:27:39,770
So this, if I run this in P, logical and X and Y, it just returns kind of the element of my element and operation basically.

205
00:27:39,770 --> 00:27:45,409
So if we look at the first two elements of X and Y, it's true and it's true versus true.

206
00:27:45,410 --> 00:27:48,740
So we say true and true. That's true.

207
00:27:49,490 --> 00:27:54,590
So the first element is true of the returned object.

208
00:27:55,580 --> 00:28:00,230
Here we had true and false. So that's false and true and false.

209
00:28:00,920 --> 00:28:04,459
It's also false. And then the last one is false and false.

210
00:28:04,460 --> 00:28:16,790
So that's also false. Also, if you do that ampersand for X and Y, that actually does the same thing is in fact logical and so values an X,

211
00:28:16,790 --> 00:28:20,329
ampersand Y that's basically doing the same thing.

212
00:28:20,330 --> 00:28:29,450
So there's basically two different options for doing that kind of the element by element and operation for for not be arrays.

213
00:28:31,490 --> 00:28:39,590
So for if you want to do like the same type of thing, doing like an element by element or comparison,

214
00:28:40,040 --> 00:28:46,040
you have to use this in p dot logical underscore or or just the vertical bar.

215
00:28:46,820 --> 00:28:58,710
Okay. So if I do the kind of a similar type of thing where I have two boolean numpy arrays, you know, true, true or false is I do in fact logical.

216
00:28:58,910 --> 00:29:02,870
Your store of you might be the first one is true.

217
00:29:03,690 --> 00:29:06,919
Second one is true because we are true or false.

218
00:29:06,920 --> 00:29:16,040
And then third one is also true. Since if true or false, the only one that's false is the last one since it's really returning the result.

219
00:29:17,120 --> 00:29:20,300
False or false? Okay.

220
00:29:20,710 --> 00:29:28,580
And yeah, this is just pointing out that the the vertical bar is the same thing as a new logical underscore for.

221
00:29:32,850 --> 00:29:36,450
So here's an example of where it might be useful.

222
00:29:37,590 --> 00:29:44,700
So doing the element wise kind of boolean or it could be useful, for example,

223
00:29:44,700 --> 00:29:51,200
to count the number of, you know, how many numbers are in between two other numbers.

224
00:29:51,210 --> 00:29:55,500
So let's say we had an array of, of, of numeric values.

225
00:29:55,500 --> 00:30:05,490
I just want to count the number, the number of elements and acts that are in between zero and five, which is like a common type of thing.

226
00:30:08,250 --> 00:30:16,260
So, you know, first off, I had an example where we count the I'm counting the numbers that are that are greater than zero,

227
00:30:17,040 --> 00:30:23,000
or you could count the number that are greater than zero from there.

228
00:30:23,010 --> 00:30:30,050
So when I first had this numeric count, the array x is like six elements.

229
00:30:31,560 --> 00:30:43,770
If I look at x is greater than zero that that x if I just run x greater than zero by itself, that returns a boolean numpy array.

230
00:30:43,770 --> 00:30:49,590
So it's basically each element is whether or not that element is greater than zero.

231
00:30:50,790 --> 00:30:56,070
So if you actually take the sum of this array, if I do this,

232
00:30:56,460 --> 00:31:07,050
if we mentioned before and on some is the way some of the elements in a numpy array if you do input sum of X greater than zero and actually did that,

233
00:31:07,320 --> 00:31:13,610
that result is it's just a number of elements of zero, the number of elements of X that are greater than zero.

234
00:31:15,000 --> 00:31:27,240
Similarly, if I look at do X less than five that returns a boolean array, it's just saying whether or not this particular element is less than five.

235
00:31:27,960 --> 00:31:36,060
So you can see here the first element is not less than five. So it returns true of the second element of X is ten.

236
00:31:36,060 --> 00:31:39,420
So it's greater than five so that greater than or equal to five.

237
00:31:39,420 --> 00:31:46,560
So that returns false. So that's kind of where it belongs in everything, element by element.

238
00:31:48,450 --> 00:32:01,979
If I want to look at whether or not an element is both greater than zero or and less than five, I can do this in p logical.

239
00:32:01,980 --> 00:32:09,030
And so this only returns true if it's both greater than zero and less than five.

240
00:32:09,030 --> 00:32:18,870
So if only the first number or number in the fifth number, only those three cases.

241
00:32:21,270 --> 00:32:31,530
So you can if you just want to count the number of elements that are zero and five, you can just run in some on this logical or this boolean.

242
00:32:32,730 --> 00:32:40,750
Right. Because when you're when you run this function song which treating the the true as a Z as one and the false is a zero.

243
00:32:40,770 --> 00:32:49,890
So if I just take the some of that just gives us the number of elements of X that are both greater than zero and less than five.

244
00:32:52,380 --> 00:32:56,010
Let's see. Oh, yeah. This is basically the same thing.

245
00:32:56,010 --> 00:33:00,420
I was just a reminder. You want to use the ampersand?

246
00:33:01,140 --> 00:33:09,330
I think just want to put these things inside of parentheses before you before you run it.

247
00:33:09,330 --> 00:33:18,720
Because I think if you put you try to run this without the parentheses, it doesn't interpret it the way you want it to.

248
00:33:22,650 --> 00:33:30,660
If you have this person without first evaluating these logical or legal instructions, you.

249
00:33:34,360 --> 00:33:42,910
But if you feel as long as you put these things in the inside of parentheses and does the same thing as in logical, underscore hand.

250
00:33:43,610 --> 00:33:56,379
Okay, so this is an example of this before these quick reminder questions before we move on to the next topic.

251
00:33:56,380 --> 00:34:03,190
So let's say if we had this example, what would it frown?

252
00:34:03,200 --> 00:34:11,020
So we have not the array as five elements basically.

253
00:34:12,640 --> 00:34:21,340
So basically this thing inside of parentheses is a logical vector or boolean boolean array.

254
00:34:23,890 --> 00:34:31,090
And then we're printing out kind of using the numeric indexing to print out a.

255
00:34:33,480 --> 00:34:41,130
A certain subset of that went back to her choice to ride it out in.

256
00:34:44,050 --> 00:34:51,700
So any IRR would be greater than zero in this case would be.

257
00:34:59,080 --> 00:35:09,190
Or is that a return? So that basically returns and returns a numpy array with five elements so that it's basically.

258
00:35:10,930 --> 00:35:14,470
False. False. False. True. True. Only the last.

259
00:35:15,130 --> 00:35:18,390
Only the last. Two elements. False.

260
00:35:19,320 --> 00:35:30,890
False. That's basically what that prints out.

261
00:35:31,290 --> 00:35:36,110
Well, not the whole thing, but that's what they are a greater than zero returns.

262
00:35:36,560 --> 00:35:46,040
And then if we do this kind of the numeric indexing, what is that?

263
00:35:46,040 --> 00:35:53,990
That starts an index one which is really like this. The second component here should be.

264
00:35:56,040 --> 00:35:59,190
False. Of course.

265
00:35:59,200 --> 00:36:04,860
True. True one. Well, this is.

266
00:36:06,200 --> 00:36:11,480
Starts from, if that's what it should turn out, if you run it.

267
00:36:13,560 --> 00:36:18,830
I mean. Ever since Free Street.

268
00:36:20,960 --> 00:36:25,510
But there's a little reminder question.

269
00:36:25,510 --> 00:36:36,940
It kind of combines this Boolean NumPy evaluates a Boolean expression when you're using a numpy array and then come this slicing,

270
00:36:37,930 --> 00:36:42,760
slicing notation as well. All right.

271
00:36:43,960 --> 00:36:54,970
Okay. So I think the next really topic is just kind of doing kind of basically math with numpy arrays and kind of different useful

272
00:36:54,970 --> 00:37:08,080
functions for working with not be arrays or computing summary statistics from an LP array like the median and things like that.

273
00:37:08,980 --> 00:37:14,950
Okay. So the first thing I guess to mention is about multiplication or addition.

274
00:37:15,970 --> 00:37:25,780
So when you have to not be arrays, if you just add them if you like an X plus five,

275
00:37:25,780 --> 00:37:34,420
if both X and Y are not the arrays, it returns an array where you're just adding each element separately.

276
00:37:35,690 --> 00:37:37,060
Same thing for multiplication.

277
00:37:37,070 --> 00:37:48,139
So this is this is different than in the python lists or if you had to list it does some contamination here for doing addition

278
00:37:48,140 --> 00:37:59,030
that that kind of operates more in the way you would expect if you're you're adding kind of numeric numeric vectors.

279
00:37:59,660 --> 00:38:09,230
So let's look at this example. If there are one and they are two, if we add them plenty, don't have the same length.

280
00:38:09,950 --> 00:38:20,160
If we add them they just the first element of the of the addition is the first element of this plus the first element.

281
00:38:21,260 --> 00:38:29,659
The second element of the return of the addition is the sum of the second element and the components of the addition.

282
00:38:29,660 --> 00:38:41,420
Okay. So just everything is element by element. Same thing for multiplication, everything is element.

283
00:38:42,620 --> 00:38:50,330
The first element of R one times they are two is the front of the that the first, the first element of air one.

284
00:38:51,020 --> 00:38:53,210
So the first element of air two.

285
00:38:54,530 --> 00:39:09,200
So I think this is probably nice if you're doing a lot of math with not B arrays, this is a lot nicer to deal with this than with lists of.

286
00:39:11,420 --> 00:39:20,960
Okay, yeah, I just thought I'd mention this. I mean, you know, if you're doing this element by element, addition or multiplication,

287
00:39:21,860 --> 00:39:26,149
if you're wanting to do that, it's a lot easier to do this with not be erased.

288
00:39:26,150 --> 00:39:36,469
And, you know, trying to do this with your list, for example, where you would write it for a loop and and add things one by one.

289
00:39:36,470 --> 00:39:47,150
So if you wanted to do a a for a loop where you were, let's say, multiplying two thing arrays directly, I mean, you could do it.

290
00:39:47,990 --> 00:39:52,190
This is this might be the way you would do it for loops to do it.

291
00:39:53,480 --> 00:39:59,180
It's kind of a lot easier to just do ar1 times R two.

292
00:40:01,350 --> 00:40:13,970
I think I mentioned that just because just as a general point, you know, when whenever you can,

293
00:40:15,500 --> 00:40:22,790
it's generally better to kind of use these built in procedures when you can rather than kind of,

294
00:40:23,360 --> 00:40:27,979
you know, writing everything and the loops, for example, usually a lot more efficient.

295
00:40:27,980 --> 00:40:38,030
If you whenever possible, you can kind of use the kind of built in there, not be multiplication type or procedures or,

296
00:40:38,420 --> 00:40:49,280
or not b functions just because these kind of these these functions have been kind of optimized to be computationally efficient,

297
00:40:51,230 --> 00:40:55,790
especially compared with kind of writing out all of these for an while.

298
00:40:59,590 --> 00:41:08,660
You know, first of all, it's, it's it's a lot and it's usually a lot more code is a lot more compact, but also that code should run a lot faster.

299
00:41:09,680 --> 00:41:19,460
So this is often referred to as factorization just means you just you're kind of operating your.

300
00:41:21,150 --> 00:41:28,420
Kind of the vector itself and the array itself, rather than kind of fighting out all of the operations,

301
00:41:28,990 --> 00:41:32,950
you know, explicitly element by element inside of it, for example.

302
00:41:33,850 --> 00:41:35,640
So at least whenever possible, it's,

303
00:41:35,770 --> 00:41:48,580
it's usually better to kind of work directly on the individual numpy arrays and use a kind of a built in anomaly procedures.

304
00:41:49,550 --> 00:41:51,700
You know, it's not it's not always possible.

305
00:41:51,700 --> 00:42:01,959
It's sometimes you have certain certain computations where you're almost forced to write a loop or several loops to to do it.

306
00:42:01,960 --> 00:42:05,440
But, you know, whenever you can, it's it's good.

307
00:42:05,560 --> 00:42:13,960
It's good to use the built in capabilities of building.

308
00:42:15,400 --> 00:42:20,860
Okay. So let's see. Yeah, I mean, this is kind of the same thing.

309
00:42:20,860 --> 00:42:25,710
Subtraction and division out.

310
00:42:26,350 --> 00:42:38,770
Everything is element by element for little unit. Kind of tough to not be praised at the same length for an hour doing exponential action,

311
00:42:41,470 --> 00:42:51,490
you know exponent by one number or raise it to the power of one number and you'll do that same thing for each element of the array.

312
00:42:52,870 --> 00:43:01,840
So I can see here this double star, it's kind of the same thing that's used in all of Python four for exponential.

313
00:43:02,050 --> 00:43:07,810
So this is basically the same thing is taking the square root, which this is raising it to the power one.

314
00:43:12,190 --> 00:43:21,579
Okay. Yeah, this was just a note about how I mean, once you kind of get good at this type of thing,

315
00:43:21,580 --> 00:43:30,370
I mean, you can write fairly in a series of operations, you know, within a single line of code.

316
00:43:31,120 --> 00:43:46,179
So kind of once you get at least proficient kind of doing boolean sub setting and other types of setting,

317
00:43:46,180 --> 00:43:52,329
you can kind of do, you know, fairly complex operations in a, in a single line of code.

318
00:43:52,330 --> 00:44:00,370
So for example, let's say you wanted to create a numpy array based on an original array, a r,

319
00:44:00,850 --> 00:44:12,190
so I want to create another array whose elements equal, let's say two times and r k over divided by r r k plus one.

320
00:44:12,790 --> 00:44:26,500
If a r k is positive. Otherwise I would see or I wanted to say zero if it's not positive.

321
00:44:26,920 --> 00:44:32,110
Oh yeah I have zero here is equals zero if it's not positive.

322
00:44:33,180 --> 00:44:45,520
So you can do that with really like a single line of code and then I can just say r r or zero times two times r r over I r r plus one.

323
00:44:46,660 --> 00:44:56,530
So the one that works is because this is a boolean vector multiplied by this does all of the multiplication element by element, right?

324
00:44:57,250 --> 00:45:07,000
And when you do a multiplication with a boolean array, it kind of automatically will treat the truth as one and the zero is false as a zero.

325
00:45:07,570 --> 00:45:16,450
So basically you're basically multiplying the elements of this by zero in R as lesser than or equal to zero.

326
00:45:17,260 --> 00:45:23,620
So just as this this type of thing is, do a lot of these.

327
00:45:25,160 --> 00:45:29,030
Maybe it's not super complicated, but it's reasonably complicated.

328
00:45:34,290 --> 00:45:39,690
It's a transformation of a vector with a single line of code that.

329
00:45:43,150 --> 00:45:49,580
Okay. So actually so I just mentioned this.

330
00:45:49,580 --> 00:45:52,970
You have for four edition of two diaries.

331
00:45:58,750 --> 00:46:11,620
So addition does everything element by element or if that's probably expected, if we do to 2D arrays,

332
00:46:11,620 --> 00:46:17,110
if we add to two dimensional arrays, it will kind of do everything element by.

333
00:46:18,850 --> 00:46:31,850
However, if you do the multiplication symbol, if you have two, two dimensional arrays, that also does element by element of multiplication, right?

334
00:46:32,470 --> 00:46:43,930
So it does not do kind of quote unquote true matrix multiplication.

335
00:46:43,960 --> 00:46:49,600
And you might see it in linear algebra, but there is a way of doing it often in a few slides.

336
00:46:49,600 --> 00:46:54,070
Let's see, this is multiplication symbol star.

337
00:46:54,610 --> 00:47:01,270
If we're doing two two dimensional rays, it still just does an element by element multiplication.

338
00:47:01,900 --> 00:47:10,570
So you can see that here. If I had this matrix a few times and basically the squares,

339
00:47:10,570 --> 00:47:21,520
each of the individual elements since it's kind of multiplying everything element by all right and I'll make

340
00:47:21,520 --> 00:47:29,230
sure I think in a few slides there there is a way to do kind of matrix multiplication if you're if you need it.

341
00:47:30,490 --> 00:47:36,520
All right. So this is a term called universal functions,

342
00:47:37,510 --> 00:47:50,260
basically just functions made available by NumPy that apply a function element by element to a to a numpy array kind of returns that result.

343
00:47:51,190 --> 00:48:00,460
So an example of this is important as q r t, so that can work on a healthy array that just returns the square root of each number.

344
00:48:00,860 --> 00:48:07,950
You just kind of. You were an example of that.

345
00:48:08,550 --> 00:48:12,720
I mean, do you think the universal function.

346
00:48:14,560 --> 00:48:21,830
So if I have this array here and if I do NP that's square root of air just returns

347
00:48:21,830 --> 00:48:26,300
a not the array of the same length where we're just square root in each element.

348
00:48:26,480 --> 00:48:32,450
Okay. So that's how kind of most of these you find functions work.

349
00:48:35,570 --> 00:48:56,390
So in this example, I'm, I'm generating a kind of a random or some a an array with random numbers of a line for each and last time.

350
00:48:57,860 --> 00:49:08,000
P dot random dot random generates a uniformly distributed random numbers over here in the exp

351
00:49:08,390 --> 00:49:18,500
computes that the exponential of each of each component you got on computes the algorithm.

352
00:49:19,020 --> 00:49:23,110
There's an actual that can be done log into the natural function.

353
00:49:23,930 --> 00:49:28,430
And if you got log ten as that as log base ten of each other.

354
00:49:30,590 --> 00:49:38,659
So I'm just mentioning just useful things that others that I didn't mentioned, probably some of the more useful ones.

355
00:49:38,660 --> 00:49:45,740
So in beyond for just such a numbers, it just rounds down to the nearest integer for each number.

356
00:49:46,550 --> 00:49:59,090
If you got seal returns, he rounds up to the nearest the nearest and Tajura greater than in p around it similar.

357
00:49:59,090 --> 00:50:08,540
But you can specify the number of digits. So if I do in fact round to common to it just brings it does rounding to the nearest two decimal places.

358
00:50:11,540 --> 00:50:17,600
There are other useful ones that I mentioned so in up the maximum that just returns the oh select.

359
00:50:17,810 --> 00:50:22,160
Yeah. In P maximum returns like the pairwise maximum.

360
00:50:22,550 --> 00:50:33,530
So basically if we have two arrays like an R to an air input maximum with a R,

361
00:50:35,390 --> 00:50:42,200
R two, that's going to return a numpy array the same length as both of these.

362
00:50:42,200 --> 00:50:47,059
But it just does does the maximum element by element.

363
00:50:47,060 --> 00:50:56,940
Comparing each one. Comparing the. The first number from me are with the first number of they are two.

364
00:50:57,780 --> 00:51:04,860
The second number of air first to the second number of air to and return to the maximum of those those two numbers,

365
00:51:05,070 --> 00:51:10,470
which basically just a pairwise maximum from these two B arrays.

366
00:51:11,070 --> 00:51:17,460
And then the same thing with the minimum, it's a kind of a pairwise minimum, so it should return a number, the array,

367
00:51:17,910 --> 00:51:26,820
the same length as both of these, not be arrays that are that are components of it and that are the arguments to the empty minimum function.

368
00:51:27,910 --> 00:51:38,250
Correct. Yeah. So those are I just started a list of the useful universal functions which probably the most some of the most useful ones.

369
00:51:42,060 --> 00:51:49,660
Okay. So the next. Topic is just calling it numpy arrays statistics.

370
00:51:50,440 --> 00:51:58,390
These are just like statistics that what you would compute from a if you have a one dimensional array,

371
00:51:58,990 --> 00:52:03,010
things like the mean or the median or the standard deviation.

372
00:52:03,010 --> 00:52:10,120
So like basically single numbers, summaries of the of the numbers in that one dimensional array.

373
00:52:10,510 --> 00:52:13,540
You can also do it like in two dimensional arrays.

374
00:52:14,080 --> 00:52:20,350
You might often want to compute kind of a single number summary for each column, for example, or for each row.

375
00:52:20,770 --> 00:52:22,660
So we'll mention how to do that.

376
00:52:23,560 --> 00:52:32,770
So NumPy has kind of a number of built in functions that allow you to compute kind of certain statistics from from one or two dimensional arrays.

377
00:52:34,930 --> 00:52:42,610
And I mean, standard deviations, I think mentioned kind of most of these.

378
00:52:43,570 --> 00:52:48,250
Some mean the median standard deviation is steady.

379
00:52:49,120 --> 00:52:53,200
Max is just just max and percentile.

380
00:52:54,370 --> 00:53:01,270
That just computes kind of a percentile of the kind of percentile you do.

381
00:53:01,600 --> 00:53:05,600
You wouldn't have to specify another another number like this.

382
00:53:06,160 --> 00:53:12,010
If you want the 60th percentile example, it's kind of whatever percentile you get that.

383
00:53:12,760 --> 00:53:19,270
So I thought this was just an example of a good time to start looking at kind of specific data sets.

384
00:53:19,270 --> 00:53:32,990
So this is a data set that you can import from this, which is as key as K Learn data sets library.

385
00:53:33,030 --> 00:53:42,040
So this is the library that helps as a number of data sets that I think you're all right.

386
00:53:42,370 --> 00:53:47,260
I'm going to go ahead. Try. I tried using that actually just right now from scalar datasets it says.

387
00:53:47,770 --> 00:53:50,770
It says no module named task learning. But I need to do something.

388
00:53:52,290 --> 00:53:56,560
Did you import pandas first or. I imported. I did import pandas first.

389
00:53:58,560 --> 00:54:03,510
I got in trouble loading. And so it's set up to steer.

390
00:54:14,360 --> 00:54:17,960
You can try just importing scalar and DOD data sets by itself.

391
00:54:18,830 --> 00:54:22,780
Do we have to root for God? Okay. As opposed to just import load ii results?

392
00:54:23,540 --> 00:54:33,710
Yeah. I forgot to find it. Possibly after you to scale.

393
00:54:34,430 --> 00:54:37,910
To search for money elsewhere.

394
00:54:38,720 --> 00:54:46,020
Other people are trying. Did you install the scanner package?

395
00:54:46,930 --> 00:54:51,660
Do you have to do that? I think yes, probably.

396
00:54:51,700 --> 00:54:58,989
I may have done that before. I generated oh three slides, responds you for Spider.

397
00:54:58,990 --> 00:55:04,970
It says you're trying to use a module that doesn't come with our installer. Okay.

398
00:55:05,210 --> 00:55:09,110
Maybe. Yes. I may have had a installed somewhere.

399
00:55:09,440 --> 00:55:17,920
Probably have installed somewhere. I've. Basically on my home computer when I.

400
00:55:18,900 --> 00:55:22,240
This. Something shouldn't stop this.

401
00:55:27,360 --> 00:55:32,640
You talk about your clients, you're still having problems. Try and stop them.

402
00:55:33,960 --> 00:55:38,720
But at least once you get it kind of working out, you have this data set.

403
00:55:38,740 --> 00:55:42,000
A lot of ideas are not followed.

404
00:55:42,000 --> 00:55:45,780
Iris listens. Oh, yeah. Well, you.

405
00:55:45,840 --> 00:55:54,090
The thing that object is low to Iris. There isn't a data set that comes with it once you come do this.

406
00:55:54,870 --> 00:56:06,780
So at least once you've done that, you can basically extract the data set as a numpy array.

407
00:56:07,550 --> 00:56:17,860
So I guess the way that it's stored is as the way they store the data is as I guess the,

408
00:56:18,150 --> 00:56:27,719
the main numeric data is as a numpy array, it's called if you assign it by respect, first it would be iris.

409
00:56:27,720 --> 00:56:32,670
That is the this is going to be a numpy array.

410
00:56:33,150 --> 00:56:43,260
And then there's also this is just the names for like the columns of the array so that the interpretation

411
00:56:43,260 --> 00:56:51,090
of this numpy arrays that each of the columns is like a variable or a feature like they call it.

412
00:56:53,340 --> 00:56:59,040
And then kind of the rows of the numpy array are observations.

413
00:56:59,730 --> 00:57:05,580
And I think there is also a way you could have put it in a bigger array,

414
00:57:05,580 --> 00:57:19,020
but the way they kind of stored the data is that they have separate species information and I think that's as kind of like a one dimensional array.

415
00:57:21,420 --> 00:57:30,330
So there's like the way this data is set up, there's like three different species in the Irish economy at the top.

416
00:57:30,840 --> 00:57:36,900
And then they also have the names of that of the of the target.

417
00:57:38,840 --> 00:57:46,280
Okay. So I guess we can just look at an example. So the way the num Iris the way.

418
00:57:46,340 --> 00:57:51,560
Yeah. So num IRAs is going to be like just a numeric two dimensional numpy array.

419
00:57:54,220 --> 00:58:00,680
So it just says like 150 observations for variables where they call it like features.

420
00:58:02,500 --> 00:58:08,000
So if you look at the shape of this array should be like you should print out 150 comma four.

421
00:58:10,040 --> 00:58:13,239
So here I'm just looking at some of the numbers inside of numerous.

422
00:58:13,240 --> 00:58:18,380
So if you look at the row zero, the first row, it looks like this.

423
00:58:18,450 --> 00:58:23,810
So like, for instance, there's four columns. There should be four numbers in the first row.

424
00:58:23,820 --> 00:58:30,610
If you look at this, 51st row, row 54 looks like this, etc.

425
00:58:30,620 --> 00:58:35,810
So this is kind of what the numbers in the numbers numpy array look like.

426
00:58:37,160 --> 00:58:48,410
So 150 by four. So iris names is a that's actually a non edited list.

427
00:58:48,680 --> 00:58:51,800
They loaded it as a list. So those are just names.

428
00:58:52,460 --> 00:58:58,520
Those are the four names of the features are columns and they're not the array.

429
00:58:59,810 --> 00:59:07,430
These just represent different features of the iris, which is a little plant that's just like the length of the.

430
00:59:08,950 --> 00:59:15,969
I've seen all two separate like that with measurements.

431
00:59:15,970 --> 00:59:21,670
Basically, that's what it represents. The other major thing is the type.

432
00:59:22,870 --> 00:59:28,060
So they have a now another numpy array. It's it has 150.

433
00:59:29,770 --> 00:59:45,040
It's like 150. So it's basically the the species of the for which the length of numeric data corresponds to like the first.

434
00:59:49,330 --> 00:59:58,630
So this number array of zeros means that it's like species zero and kind of the corresponding numeric data will be in the first,

435
00:59:58,870 --> 01:00:07,660
the first row of computers. So these are the names of the species other than others.

436
01:00:09,610 --> 01:00:14,290
I mean, it's huge because the names of these species is provided.

437
01:00:14,290 --> 01:00:22,249
So P zero is. So the first 50 or so, the second fifth, these observations are virtually all other.

438
01:00:22,250 --> 01:00:30,200
And the last the last 50 are here.

439
01:00:30,490 --> 01:00:35,510
It's kind of set up here. All right. So this is just kind of a data set.

440
01:00:35,530 --> 01:00:41,470
You can kind of just illustrate how to take differently summary statistics that you might be interested in.

441
01:00:42,790 --> 01:00:50,950
So I guess the first thing you might be interested in is like the mean of the first of these, the mean of all four variables.

442
01:00:51,610 --> 01:01:03,700
So you can just do and then you can either use NCPDP mean or you can use the name of the number braked.

443
01:01:03,700 --> 01:01:07,510
Mean was basically two two ways of doing the same thing.

444
01:01:08,200 --> 01:01:13,030
So if I do the name of the array not mean, that's perfectly fine.

445
01:01:15,190 --> 01:01:22,540
You want to include axis that zero x axis equals zero that basically is telling it whether or not to take the mean of each,

446
01:01:23,440 --> 01:01:26,950
each of the columns or each of the rows, basically.

447
01:01:27,490 --> 01:01:33,380
So if you do axis equals zero, that's when you take a mean of each of the each of the four columns.

448
01:01:34,100 --> 01:01:41,590
So I should return for numbers like the mean of the numbers in the first column is 5.4.

449
01:01:43,660 --> 01:01:50,260
Again, you could do you can do in p dot meaning of underscore iris and you have to give it like a second argument,

450
01:01:51,550 --> 01:02:00,129
telling it whether or not in which axis you want it to compute, the axis equals one.

451
01:02:00,130 --> 01:02:03,270
That's going to basically do the opposite. It's going to return.

452
01:02:03,280 --> 01:02:10,570
It's going to do a mean for each of the rows, median of each of each column.

453
01:02:11,140 --> 01:02:21,460
So if you wanted to do a median of each of the the four columns median and also the unit axis equals zero, which is kind of the same thing.

454
01:02:21,860 --> 01:02:32,139
You're just computing medians, rather. That means the in p max and pin then kind of works the same way to return for numbers.

455
01:02:32,140 --> 01:02:43,510
These are just the maximum numbers of each of the columns. So the maximum number in the first column, 7.9 maximum number, and the second columns 4.4.

456
01:02:46,570 --> 01:02:57,430
The whole country works the same way. If you wanted to do the standard deviation for each variable and keep that steady iris axis equals zero.

457
01:02:57,430 --> 01:03:01,240
Like the first standard deviation in the first variable.

458
01:03:01,630 --> 01:03:05,980
Sorry. Yeah. The first variable is 0.825.

459
01:03:07,330 --> 01:03:18,730
The second variable is .134. So that kind of all of these, these main summaries, statistic functions kind of have a similar syntax.

460
01:03:20,470 --> 01:03:25,120
Something slightly different, I mean, would be these kind of correlation measures.

461
01:03:25,720 --> 01:03:39,760
So correlation measures are basically based on two numeric variables rather than kind of a single variable at a time.

462
01:03:40,570 --> 01:03:51,330
So if you wanted to compute the correlation, so basically the classic Pearson's correlation coefficient between two arrays you can do in P core code.

463
01:03:51,550 --> 01:04:07,780
If so, like for example, you wanted to compute the correlation between the first and the first column of numbers and the second column.

464
01:04:08,540 --> 01:04:17,090
But now Iris can do it this way in that coracle course, you know, just give it that to two arrays here.

465
01:04:17,900 --> 01:04:25,370
You kind of want to basically to arrays. These are two columns of data and what it returns is this actually it returns a little.

466
01:04:28,930 --> 01:04:33,970
Returns a little to buy to buy tricks. Although in this case, it's kind of not.

467
01:04:35,260 --> 01:04:42,010
It's a little bit redundant, but that's what it returns, since the correlation between itself is always one.

468
01:04:42,640 --> 01:04:47,260
This is like the correlation between the first variable itself, which is only one,

469
01:04:47,830 --> 01:04:53,200
and then this is the correlation between the two variables out here, one and two.

470
01:04:53,200 --> 01:04:56,530
And this is like two. It doesn't really matter. This is symmetric.

471
01:04:57,160 --> 01:05:02,890
So this correlation that you're interested in, is this so -2.117.

472
01:05:08,430 --> 01:05:16,350
So if you. Although I think you can. I don't know if I had an example later.

473
01:05:16,350 --> 01:05:24,809
If you put that kind of the entire matrix in there, you can compute multiple correlation coefficients at the same time,

474
01:05:24,810 --> 01:05:28,710
and that's of the syntax you're just comparing to arrays.

475
01:05:30,720 --> 01:05:33,840
So here's probably the other thing I thought, I just thought I mentioned,

476
01:05:34,260 --> 01:05:39,030
since this is often kind of a useful summary statistic, which is the percentile.

477
01:05:39,600 --> 01:05:51,059
So here, if you want to compute the percentiles from a numeric array of data you have to do, you can use the n p dot percentile.

478
01:05:51,060 --> 01:06:01,230
So here, if I wanted to compute the 50th percentile at least for each column actually, so you could do percentiles for each column.

479
01:06:01,620 --> 01:06:03,900
So again, we want to do axis equals zero.

480
01:06:04,740 --> 01:06:13,860
You could just use the in-person method and you have to give it an extra arm, you have to tell it which kind of which percentile you want to compute.

481
01:06:15,450 --> 01:06:20,879
So that would be. So in this case, we're doing the 15th percentile.

482
01:06:20,880 --> 01:06:27,390
You have to give it the. Q are you have to say keeping yourself in this case, we're actually just computing the median.

483
01:06:27,480 --> 01:06:35,490
The 50th percentile is actually then the median. But, you know, you often want to do other things like the 25th percentile.

484
01:06:36,120 --> 01:06:39,810
So of this is returning use the 25th percentile of each column.

485
01:06:40,710 --> 01:06:43,800
This would return the 75th percentile of each column.

486
01:06:46,800 --> 01:06:58,980
Okay. So you just wanted to run through an example at least of, I think kind of boolean sub setting or sub setting.

487
01:06:58,980 --> 01:07:06,900
The Boolean indexing is actually useful. One area I would start computing different summary measures from a from a data set.

488
01:07:08,280 --> 01:07:15,840
So let's say we wanted to compute kind of the the median for each variable set, only the first two iris species.

489
01:07:16,710 --> 01:07:20,310
So we're not interested in kind of the signal, the third iris species.

490
01:07:20,310 --> 01:07:23,670
We just want the medians for only the first two.

491
01:07:25,850 --> 01:07:30,650
Okay. So remember that the Irish species information is stored in this array.

492
01:07:31,100 --> 01:07:36,740
Irish types. So Irish types only had the values like zero one and two.

493
01:07:37,320 --> 01:07:41,330
Okay. So the way you could do that,

494
01:07:42,000 --> 01:07:52,700
if you compute the median for each column only looking at the first two types or maybe the first two

495
01:07:52,700 --> 01:07:59,720
types separately way to do that with like a single line of color is is false and say import median.

496
01:08:00,260 --> 01:08:08,420
And then I only look at the array and we look at the two dimensional numpy array where we only have, you know, type equals zero.

497
01:08:09,490 --> 01:08:16,100
And so that's what this kind of code here is to find in some iris and then Irish types equals zero.

498
01:08:16,920 --> 01:08:18,740
You're like double equals zero.

499
01:08:19,340 --> 01:08:30,620
This is basically only extracting the the array, like the subset of rows of the array where the Irish type equals zero.

500
01:08:31,280 --> 01:08:41,180
So this is going to show you that this is basically returning the median for each column, you know, only considering the first type.

501
01:08:42,270 --> 01:08:49,440
Of species. This, for example, would be the median on each column.

502
01:08:49,950 --> 01:08:54,390
Only looking at typing a one. Okay. So this is like the second type.

503
01:08:54,860 --> 01:09:00,840
Okay. Know, we can kind of compare the millions of different variables across species type.

504
01:09:03,450 --> 01:09:11,609
So you can see here like the. The third variable would actually be quite different between these two species.

505
01:09:11,610 --> 01:09:15,230
So that may or may not be of of interest.

506
01:09:17,450 --> 01:09:25,490
We'll talk about a few extra other things, I think, but let's do a kind of a little bit of a wrap up question,

507
01:09:28,700 --> 01:09:35,599
or at least that combines a lot of things we talked about before. So let's look at this example.

508
01:09:35,600 --> 01:09:40,730
We have this array X, which is just a numpy array with five numbers.

509
01:09:41,270 --> 01:09:48,380
What would this printout? So y y is also a brain with four numbers.

510
01:09:49,610 --> 01:10:03,890
So what is like sitting by the Y in this case over B?

511
01:10:04,940 --> 01:10:10,220
It's basically x times x is less than two.

512
01:10:11,930 --> 01:10:20,660
So X is less than two on the basically on the extreme ends on the first component.

513
01:10:24,590 --> 01:10:28,800
So it should be zero and there should be one there.

514
01:10:28,820 --> 01:10:34,210
Sorry, this should be one at the ends and then zero here.

515
01:10:34,220 --> 01:10:41,330
Here we multiply that by x, it should be something else.

516
01:10:44,560 --> 01:10:48,040
0001.

517
01:10:58,180 --> 01:11:03,370
The other components you're multiplying in five zero since the statement is false.

518
01:11:04,960 --> 01:11:10,300
And so when we take the median of this well, I think it's just in this case, it's just the arrow.

519
01:11:16,870 --> 01:11:27,240
The median of these five numbers is zero. Two Western recruits on either side.

520
01:11:28,530 --> 01:11:37,270
So the answer to this should be zero. Since.

521
01:11:48,820 --> 01:11:53,350
Okay. So I think one can mention, you know, few and a few other things.

522
01:11:55,180 --> 01:12:00,470
So you often want to add like rows or columns to an existing array.

523
01:12:01,300 --> 01:12:08,170
So you could do that. The way you do that is with these numpy functions called stack or or stack.

524
01:12:08,620 --> 01:12:17,500
So a stack stands for like I guess horizontal stacking basically allows you to kind of add columns this way.

525
01:12:18,280 --> 01:12:35,780
So horizontally. So you can assume if you're working with a two dimensional array, I mean, you do need to you want to add like a single column.

526
01:12:35,780 --> 01:12:43,550
You do need to convert it to a two dimensional array where there's only like one column in the two dimensional array.

527
01:12:44,230 --> 01:12:49,340
You do need to do that if you're working with a static. It's just something to keep in mind.

528
01:12:50,750 --> 01:12:58,129
So as an example of this, let's say you wanted to add the types like we had this factor with the iris types.

529
01:12:58,130 --> 01:13:08,570
So that's a one dimensional B array. It really doesn't need to be in a separate, it doesn't really need to be stored in a separate variable.

530
01:13:09,360 --> 01:13:15,229
You could just add it to this to a single array so you can do that with a stack.

531
01:13:15,230 --> 01:13:23,720
So let's just I'm defining this like this new B array called Iris Full.

532
01:13:24,230 --> 01:13:28,700
I just do in part H stack. I'm just adding a column to Num Iris.

533
01:13:30,980 --> 01:13:35,330
So I'm adding the iris types. Iris types array.

534
01:13:35,900 --> 01:13:37,580
The only reason I'm using reshape,

535
01:13:37,580 --> 01:13:47,540
you do have to when you're using a static or be static kind of all of them kind of all of the arguments inside of the H stack function,

536
01:13:47,870 --> 01:13:54,139
they all have to be two dimensional. So here I'm just reshaping it to be a note.

537
01:13:54,140 --> 01:14:04,340
The array where we find the number of rows or the length of the original, not one dimensional, not the array, and it has a single column.

538
01:14:05,090 --> 01:14:12,500
So that's where this one comes from. I'm not just saying having a single column when we're doing P shape, it's a here.

539
01:14:12,980 --> 01:14:20,450
Once we've done this H stack, Iris Full is now a 150 by five, so we just added an extra column.

540
01:14:21,500 --> 01:14:34,430
So originally like NOM Iris was one 5425 and I finally just added a single column so you can see that here about my iris,

541
01:14:34,430 --> 01:14:37,820
there's only four columns here,

542
01:14:38,690 --> 01:14:47,420
basically the same thing we've just added an extra column at the end of the data from the first four columns is the same as numbers,

543
01:14:50,920 --> 01:15:01,340
a similarly like V stack that's basically stacking things vertically and that's basically if you want to add extra rows,

544
01:15:01,340 --> 01:15:11,470
that kind of the bottom of an existing two d array. So let's say you had a new you had a new observation and you wanted to add it to your

545
01:15:12,040 --> 01:15:20,630
existing numpy array and that's storing a larger collect should not observations,

546
01:15:21,470 --> 01:15:27,020
you could just use the stack. So let's say I have this new observation, I'm just calling it new data.

547
01:15:28,040 --> 01:15:36,589
This would be just something it has, you know, it has four elements since it's just kind of it's going to be an extra row and the

548
01:15:36,590 --> 01:15:45,379
num iris to the array the I can just add it to the bottom of the existing note.

549
01:15:45,380 --> 01:15:51,860
The array is just to do V stack and again you need to reshape it so that it's two dimensional.

550
01:15:51,860 --> 01:15:57,470
So in this case you want it to have one row and four columns.

551
01:15:57,960 --> 01:16:05,330
I'm doing this. This is basically like a row with one row and columns.

552
01:16:05,780 --> 01:16:11,360
So you can see here after we front this V stack, we've added an extra row.

553
01:16:11,900 --> 01:16:18,020
Originally nom iris was 154, now it's 151.

554
01:16:21,300 --> 01:16:32,480
Okay. Oh, oh this is yeah.

555
01:16:32,480 --> 01:16:41,360
This if I use this that much, this is just an alternative way for doing kind of the same thing as each stack or

556
01:16:41,390 --> 01:16:47,180
this stack is kind of just being a single function that does kind of both ends.

557
01:16:48,290 --> 01:16:55,520
And you could use access equals one for accessing to zero depending on whether or not you're adding columns or rows.

558
01:16:56,480 --> 01:17:02,780
So if we wanted to add a column, use access equals one concatenate function.

559
01:17:03,140 --> 01:17:07,160
If you wanted to add kind of a row, I would use access equals zero.

560
01:17:07,160 --> 01:17:12,860
So that's just kind of an alternative way of doing each stack, our V stack.

561
01:17:12,860 --> 01:17:19,370
I mean, that's I usually use each stack or B stack, but this is kind of does the same thing.

562
01:17:20,090 --> 01:17:25,220
Yeah. If you use access equals zero, right. You can add additional rows.

563
01:17:31,000 --> 01:17:40,270
I just mentioned this, and I don't think I'm actually this is not going to be on any of the homework or quizzes.

564
01:17:41,050 --> 01:17:42,910
So I'll just I'll just mention it quickly.

565
01:17:43,360 --> 01:17:54,040
I don't think you don't really have to know this, but just in case you want to do some of these things, I think it be good to know.

566
01:17:55,270 --> 01:18:04,420
So if you wanted to do like a classic, you know, matrix vector or matrix matrix multiplication,

567
01:18:05,050 --> 01:18:15,100
you might see in a linear algebra book you could do it in its impact function or a dot function.

568
01:18:16,240 --> 01:18:29,020
So for example, if I wanted to multiply this, this num iris to not be erased, to think of this as a matrix,

569
01:18:29,530 --> 01:18:39,580
if I wanted to multiply it by this vector with four elements, I can just do in p dot with those as the two arguments.

570
01:18:40,030 --> 01:18:47,770
Okay. And that works perfectly fine. And so that should be, I guess, really prints it out in this way.

571
01:18:48,530 --> 01:18:58,420
You know, if you're thinking of this as linear algebra, the results of this should be like a 151, 150 by one vector.

572
01:18:58,930 --> 01:19:05,320
So that's kind of what I want to print out as the shape. So this is kind of perfectly valid.

573
01:19:05,980 --> 01:19:09,400
So if you wanted to do that, you use in a few.

574
01:19:10,880 --> 01:19:17,330
But again, if we wanted to do like nom iris, if you wanted to multiply the force,

575
01:19:18,820 --> 01:19:24,730
that two dimensional matrix with itself, I mean you have to take the transpose so that the dimensions match.

576
01:19:25,270 --> 01:19:35,530
You could just do import dot the transpose of the Irish matrix with the the the num iris matrix itself.

577
01:19:36,010 --> 01:19:41,050
So that should be that works perfectly fine. That should return as a four by four matrix.

578
01:19:43,780 --> 01:19:53,140
Anything else? Mean like I just mentioned this if you wanted to do it in common thing is like the inverse of a matrix.

579
01:19:53,920 --> 01:19:57,760
So if you want to do the inverse of a matrix of this,

580
01:19:58,390 --> 01:20:07,480
let's say we had this matrix x x you have to do in p .1.8 and be somewhere else if the

581
01:20:07,480 --> 01:20:16,360
inverse of x to x if you want the eigenvalues of x to execute if you got in our high levels,

582
01:20:17,320 --> 01:20:20,680
I think those are probably popular in algebra things.

583
01:20:23,320 --> 01:20:26,920
But just reference here, I think there's this length.

584
01:20:26,920 --> 01:20:36,790
There should be a list of other syntax for kind of other of the common linear algebra type of operations.

585
01:20:38,640 --> 01:20:42,080
Oh, we're out of time. So I think we'll stop. We'll stop there.

586
01:20:42,080 --> 01:20:46,440
And I guess next time we'll start with the text files.

587
01:20:49,230 --> 01:20:57,330
Pamela's right if you think you get the answers.

588
01:21:01,470 --> 01:21:05,590
It doesn't tell you that right or wrong that I'll tell you what I did.

