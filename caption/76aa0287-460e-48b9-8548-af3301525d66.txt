1
00:00:02,220 --> 00:00:25,710
So this is something we wanted to get started because they were already so useful.

2
00:00:26,880 --> 00:00:30,150
It started started just close to home.

3
00:00:30,360 --> 00:00:36,580
Not the end, but the second. So this is an hour or two away.

4
00:00:37,770 --> 00:00:53,820
Well, first of all, tomorrow, when the quiz is due of October 27th, some of us working in the same or the day after 27.

5
00:00:55,680 --> 00:00:59,730
It was key. Look out for the homework.

6
00:01:00,240 --> 00:01:05,010
I was given some time to my students. All right.

7
00:01:07,920 --> 00:01:14,610
So I guess it will be the sort of kind of a meeting which topics that are in cover.

8
00:01:14,610 --> 00:01:29,129
So I guess sense of dictionaries are kind of the last to fill in and data structures in Python that we'll talk about which we started

9
00:01:29,130 --> 00:01:39,630
since last time we recently finished a discussion of sense and then with the dictionary of these things called list comprehension,

10
00:01:42,240 --> 00:01:49,709
which I guess is not that new, but it's more of this way.

11
00:01:49,710 --> 00:02:02,570
It's kind of a compact way of writing and lists expressions that kind of come by and for loops and his statements in Python,

12
00:02:02,590 --> 00:02:06,640
things that you might see and it's useful to know about.

13
00:02:06,720 --> 00:02:11,760
So you can kind of like write something in a single line.

14
00:02:11,760 --> 00:02:20,590
They come from something they have to write a full for Lewis plus just a little so

15
00:02:21,900 --> 00:02:31,830
and then I guess numpy is to be thought of you know I guess and he was probably

16
00:02:31,830 --> 00:02:39,690
some on Monday this class a little bit all right so I let's do set our finish

17
00:02:39,690 --> 00:02:44,790
up sets I think we did these we started this last time like set up some space.

18
00:02:44,790 --> 00:02:56,680
And so basically like. Unordered collection of items that have no space for their all unique values.

19
00:02:57,460 --> 00:03:08,170
So on order just means if you have if you define the set as 1 to 3, as if it were treated the same, as if you define it as the numbers 3 to 1.

20
00:03:08,350 --> 00:03:20,229
So sets are useful for just testing whether or not a value of some variable is contained in some collection.

21
00:03:20,230 --> 00:03:25,750
For instance, you don't need to know exactly where the location of the variable is.

22
00:03:25,750 --> 00:03:32,320
You just want to know if it's within this collection of items or not.

23
00:03:33,810 --> 00:03:44,620
Also, in many cases, you also want to use the union or intersection of different sets of values and those types of things.

24
00:03:44,620 --> 00:03:51,820
It's easy to just define the things that you're interested in as sets and then just take the union and intersection with them.

25
00:03:52,570 --> 00:03:58,330
So the way you define sets is with like the curly braces or the that were set.

26
00:03:59,200 --> 00:04:08,979
So you can put like a column either with a function set you can would like a list inside of the set function.

27
00:04:08,980 --> 00:04:17,260
So create a list of the sense three, four or five, or you can just put them inside curly braces separated by commas.

28
00:04:18,280 --> 00:04:20,800
It's the two way main ways to create sets.

29
00:04:21,340 --> 00:04:27,579
So you can see here, even though we have kind of duplicate values of three, just one, it kind of creates this set.

30
00:04:27,580 --> 00:04:33,520
It only keeps two, three, four and five. It doesn't matter that you put duplicates there.

31
00:04:35,260 --> 00:04:46,120
All right. So set the union of two sets can be done with the vertical bar operator, or you can do kind of this dot union method.

32
00:04:46,990 --> 00:04:54,969
So the union of two sets is basically like a collection of items that are there in either of the two sets that you're taking of the union of.

33
00:04:54,970 --> 00:05:05,890
Right. So if we look here at this example as one and as two, if I do se one vertical bar as two as the union of these two.

34
00:05:05,890 --> 00:05:10,360
So one of these two sets is just three, four or five, six, seven.

35
00:05:10,690 --> 00:05:14,440
Those are the numbers that are in either sets.

36
00:05:15,460 --> 00:05:20,590
I can do this. Also, the unique you can do is one that you can do this to.

37
00:05:21,370 --> 00:05:27,160
That's another way to do it. Very easy to do as two dot union as a last one.

38
00:05:27,460 --> 00:05:34,150
It's also another example of how we do intersection.

39
00:05:34,150 --> 00:05:39,309
The main way you do Intersection two is with the and or the ampersand operator.

40
00:05:39,310 --> 00:05:47,350
So the intersection of two sets is the kind of the collection of items that are in both sets, right?

41
00:05:49,210 --> 00:05:53,680
So in this example, the only number that's in both of these sets is five.

42
00:05:54,340 --> 00:06:07,660
So the intersection of these two sets is five. We can do that with the ampersand as one, ampersand as to kind that'll give you the set intersection.

43
00:06:08,380 --> 00:06:11,530
And then the same way we do it with the union kind of method,

44
00:06:12,100 --> 00:06:22,179
you can take the intersection of two sets as one as two by doing S1, but an intersection of the two are or vice versa.

45
00:06:22,180 --> 00:06:25,990
You can also suggest to intercede as to the intersection of this one.

46
00:06:27,190 --> 00:06:31,059
Okay, so that's what we mentioned last time.

47
00:06:31,060 --> 00:06:40,810
So there's just some other so I guess each union and intersection are probably the most common set operations,

48
00:06:40,810 --> 00:06:44,380
but there's a few others that are quite useful.

49
00:06:44,890 --> 00:06:50,830
So one is just to determine, like if one set is a subset of another set.

50
00:06:50,830 --> 00:07:03,240
So it's basically means. Are all the items in this set can also contained in this other set?

51
00:07:03,750 --> 00:07:07,680
Okay. So we can see an example of this here.

52
00:07:07,680 --> 00:07:10,700
We have three sets as one, as two, as three.

53
00:07:10,710 --> 00:07:24,990
So in this case, as one, as a subset of estimations, all of the items in S1 are also in S3, even though S3 is extra items.

54
00:07:25,500 --> 00:07:31,080
All they need is that all of the items S1 has to be in S3.

55
00:07:31,920 --> 00:07:48,680
Okay. However, S1 is not a subset of Mr. Right, since none of the items in this one are in this to actually S2 is also a subset of S3.

56
00:07:52,070 --> 00:07:55,790
The first thing that we can test is whether or not S1 is a subset of S2.

57
00:07:56,270 --> 00:08:02,420
So the way you do that, a sense it is just this lesser than or equal to operator here.

58
00:08:03,970 --> 00:08:07,070
Right. That's basically what you're testing what this is.

59
00:08:07,820 --> 00:08:13,210
S1 is a subset you see here it returns false.

60
00:08:13,220 --> 00:08:16,459
S1 is not a subset of as to here.

61
00:08:16,460 --> 00:08:20,090
If we look at S1 an S3, I see that.

62
00:08:22,740 --> 00:08:28,650
S1 is a subset of S3 some sense it's kind of returning what we expected.

63
00:08:29,820 --> 00:08:36,840
You can also check it two things that this joint two sets are disjoint with two sets of disjoint.

64
00:08:36,840 --> 00:08:41,309
If they don't have they don't share any elements.

65
00:08:41,310 --> 00:08:45,480
Basically, there's no common elements between two sets.

66
00:08:45,480 --> 00:08:57,380
That means that it's joint. So like you can see here. S1 And as to our disjoint, we don't have any numbers, incomes, 34526, seven.

67
00:08:57,440 --> 00:09:02,220
They don't share any of the same numbers. That just means they're disjoint.

68
00:09:02,910 --> 00:09:07,560
So you can do that by looking at S1 is disjoint.

69
00:09:07,810 --> 00:09:14,580
That's two. You can test that or you can say it doesn't really matter.

70
00:09:14,580 --> 00:09:20,010
But when you first need to do as to that as as.

71
00:09:23,380 --> 00:09:27,850
So that'll test whether or not they're disjoint or not.

72
00:09:28,510 --> 00:09:31,659
And then this is testing whether or not S1 and S3 are disjoint.

73
00:09:31,660 --> 00:09:35,260
So S1 and three are not disjoint.

74
00:09:35,260 --> 00:09:40,570
Of course, this one has three or four or five and has three also has three, four or five.

75
00:09:42,420 --> 00:09:51,310
It's not true and false. So these things are really more useful when it's like a really large, a lot bigger sets that.

76
00:09:53,880 --> 00:09:57,900
You can tell just by looking at it whether or not they're disjoint.

77
00:09:59,330 --> 00:10:06,940
So if you feel sense with kind of a thousand elements, then these operations are mortgages.

78
00:10:09,140 --> 00:10:15,500
Quickly tell whether they share any elements or one set is completely a subset of another.

79
00:10:16,850 --> 00:10:31,020
Okay, so let's see. So the way you add or remove elements to to a set is just using this dot add or remove method.

80
00:10:31,020 --> 00:10:41,399
I mean, you don't really have the append for sets just because I guess there's no really there's no really ordering.

81
00:10:41,400 --> 00:10:50,120
There's no notion of adding an element to the end of the set since it is kind of bordering on the ownership as a it matters.

82
00:10:50,130 --> 00:10:57,870
You just you just really want to use the thing that only makes sense or is just adding

83
00:10:57,870 --> 00:11:04,170
or removing elements to a set as a kind of matter where you place them in the set.

84
00:11:04,950 --> 00:11:17,519
So the way you add elements to a set, just I have a set as one I can just do as one add and then give the name of the thing which I don't want to add.

85
00:11:17,520 --> 00:11:22,680
If I want to add a string font, if you want to add a number, you can just put a number here.

86
00:11:25,920 --> 00:11:34,230
If you want to remove do S1 dot move and give it the kind of the, the value of the element that you want to add, you want to remove.

87
00:11:34,980 --> 00:11:42,660
Okay, so let's see. Yeah, I think the print statement should make it clear.

88
00:11:42,660 --> 00:11:48,540
So once we originally we had blue, green, red, once we add yellow,

89
00:11:48,540 --> 00:11:57,960
now yellow is added to the set and the final print statement is number one, your has blooming and that's how you add or remove elements.

90
00:11:58,920 --> 00:12:12,900
I think that was about it. And I mean, I think those are probably the main. Language and remains mentioned in later.

91
00:12:12,990 --> 00:12:19,500
If you want to test whether or not something is in a set or not, it is.

92
00:12:19,500 --> 00:12:25,950
Probably the other main useful thing is about sets, but I think that's all I'll mention for now.

93
00:12:28,300 --> 00:12:38,220
So you can. That sets the last names at least like built in Python data structure is the dictionary.

94
00:12:39,480 --> 00:12:53,730
Okay, so dictionaries are basically just a set data structure that's used to connect kind of a collection of related pieces of information.

95
00:12:54,510 --> 00:13:05,760
Basically when you have in a dictionary is an unordered set of key value papers like a dictionary has a word and a definition that's kind of the same,

96
00:13:07,020 --> 00:13:13,320
or a big collection of words and associated definition that's kind of the same thing.

97
00:13:13,890 --> 00:13:18,780
For Python dictionaries, we have kind of a collection of key and value pairs.

98
00:13:20,700 --> 00:13:36,990
So a key can be any immutable data type, basically, let's say a common type or any dictionary key.

99
00:13:37,030 --> 00:13:46,220
It's a string. But I think it could be a beautiful type like in the tool.

100
00:13:46,740 --> 00:13:54,210
I mean, you could not have a list as a key in a dictionary or you could not have other dictionaries

101
00:13:55,260 --> 00:14:01,620
as or you can not have a dictionary that serves as a key inside of a dictionary.

102
00:14:01,830 --> 00:14:10,980
Okay. And then the other the other main restriction is that, like, the Chinese have to be unique.

103
00:14:11,250 --> 00:14:18,150
Okay. That's basically see the two main restrictions the keys cannot have.

104
00:14:19,220 --> 00:14:24,540
They cannot be mutable data types like lists, for example.

105
00:14:25,080 --> 00:14:28,770
The other main restriction is that they cannot have duplicate keys.

106
00:14:29,460 --> 00:14:40,830
So in that way, they're kind of similar to two sets of duplicates are not allowed, at least for the keys, because you cannot have duplicates.

107
00:14:42,830 --> 00:14:47,160
Okay. So values are kind of the other main component of dictionaries.

108
00:14:47,200 --> 00:14:51,870
So there's really no restriction on values and it can be any type.

109
00:14:51,870 --> 00:15:01,700
And you can also have duplicates. Okay. So you can have you know, you have a certain value for one teammate.

110
00:15:01,730 --> 00:15:04,890
You're allowed to have the same value for another team, another.

111
00:15:07,440 --> 00:15:12,310
Okay. So there are multiple ways to create dictionaries.

112
00:15:14,030 --> 00:15:21,420
This the first common way to create a dictionary is to use curly braces.

113
00:15:22,020 --> 00:15:27,570
And then you you separate each each element of the dictionary with commas.

114
00:15:28,050 --> 00:15:32,730
So that's kind of the same is the same way that you would create a set, right?

115
00:15:34,680 --> 00:15:40,500
But kind of each each element of a dictionary is really a key value pair.

116
00:15:41,250 --> 00:15:46,260
It's kind of different than sense. So like this, this here I would say this.

117
00:15:46,980 --> 00:15:53,430
So if we define this dictionary called states, I would say this is a this is really a dictionary with three components.

118
00:15:53,870 --> 00:16:01,919
And so the components are separated by commas. And each component of a dictionary is a is a key value pair.

119
00:16:01,920 --> 00:16:07,319
So this is a first element is a key value pair.

120
00:16:07,320 --> 00:16:12,390
So the key is Michigan and then the value is one.

121
00:16:12,930 --> 00:16:17,610
So these are two of the keys and the values are strings.

122
00:16:17,730 --> 00:16:23,460
Okay. So the second component, this is a key value pair.

123
00:16:24,060 --> 00:16:27,600
First, the key is Ohio in the values.

124
00:16:27,990 --> 00:16:38,100
So we're separating that the key value pairs with the column or separating the key and the value, I guess in an individual pair with a code.

125
00:16:38,460 --> 00:16:43,420
Okay. So this is kind of the way we print it out.

126
00:16:43,450 --> 00:16:50,999
If you print it out and then you can also look at the type of thing if you want to just confirm that this is a a dictionary.

127
00:16:51,000 --> 00:16:55,739
So if you have a dictionary variable, if you look at the type,

128
00:16:55,740 --> 00:17:08,580
it'll it'll turn out the classes indicate as well print out this is how you one way to create dictionaries in Python.

129
00:17:09,180 --> 00:17:12,989
So this is an example of a dictionary of length three.

130
00:17:12,990 --> 00:17:18,870
So this has three three components. So each component is a is a key value pair.

131
00:17:19,560 --> 00:17:19,890
Okay.

132
00:17:22,250 --> 00:17:34,970
So kind of similar to the way you said with curly braces or that or with the set keyword, you can also create a dictionary with the dict keyword.

133
00:17:35,600 --> 00:17:39,739
So here I'm kind of creating the same dictionary.

134
00:17:39,740 --> 00:17:44,030
I was using the dict keyword instead of the curly braces.

135
00:17:44,660 --> 00:17:50,980
So here I can just do. If you're using this approach, the way you do,

136
00:17:51,410 --> 00:17:59,270
the way you do it is you have the name of the key and then you have an equal sign and kind of the name of the the values to the right.

137
00:18:00,050 --> 00:18:09,410
Okay. And then you you separate each of the kind of components of the dictionary with with with columns.

138
00:18:09,490 --> 00:18:16,100
Okay. So here this is this is only in that the first key is Michigan.

139
00:18:16,700 --> 00:18:24,350
And then the associated value is Lansing. Second key is Ohio and associated value is Columbus.

140
00:18:24,680 --> 00:18:31,070
So this is just another way of creating the same dictionary that we had on the previous slide.

141
00:18:32,090 --> 00:18:37,990
Okay. You can also create a dictionary from like a collection of lists.

142
00:18:38,870 --> 00:18:42,170
All right. And this is actually a list of lists. So.

143
00:18:46,290 --> 00:18:51,930
This should be a list of to eliminate this as candidate form that it has to be.

144
00:18:51,940 --> 00:19:01,350
And so here you can see we have dict and then we have if you look at the outer bracket.

145
00:19:01,380 --> 00:19:07,800
So we have as we're giving it a single list and then each component of the list is a two element list.

146
00:19:08,460 --> 00:19:14,850
So this is the first component in the list. This will be the key that kind of the first key in the dictionary.

147
00:19:14,850 --> 00:19:21,990
This will be the the associated value. The second key of the the dictionary is eve.

148
00:19:22,200 --> 00:19:28,200
This is the show shaded value. So this is just a note and another way of creating a dictionary.

149
00:19:29,550 --> 00:19:33,210
So this is a dictionary with three elements.

150
00:19:36,340 --> 00:19:48,130
So this is my okay. So that's basically how you are kind of the main ways to create a dictionary to access the individual elements of a dictionary.

151
00:19:49,150 --> 00:20:02,110
The way you do it is you give it the name of the dictionary and then you give it the actual name of the which is what you put in brackets.

152
00:20:02,390 --> 00:20:12,010
Okay, the name of the dictionary and then like the, the name of the key that you're interested in and then it'll kind of,

153
00:20:12,340 --> 00:20:17,559
it'll, it'll output the value basically when you, when you run this code.

154
00:20:17,560 --> 00:20:18,660
So it's, it's going to be,

155
00:20:18,730 --> 00:20:28,360
it's going to output or you said you can say it'll return the the value associated with the key that you've given as key name.

156
00:20:30,250 --> 00:20:39,380
So for example, we have this dictionary here and you want to X or like you want to access the value associated with the the Michigan key.

157
00:20:39,400 --> 00:20:47,380
You just do states and Michigan in quotes determine the value associated with the Michigan key.

158
00:20:48,330 --> 00:21:02,750
Right? So that's kind of how you access individual individual values for a given input sheet.

159
00:21:03,630 --> 00:21:12,250
If you would just want to get like the entire collection of keys or an entire collection of values or the entire collection of key value pairs,

160
00:21:12,250 --> 00:21:16,930
you can just, you can use these dichotomies, dot values or items method.

161
00:21:16,930 --> 00:21:24,670
So you just have to give like the name of the dictionary and then just do dark keys that will give you all the keys in the dictionary.

162
00:21:25,420 --> 00:21:30,100
You want to get all the values in the dictionary, you can just do the name of the dictionary values.

163
00:21:30,850 --> 00:21:34,930
Or if you want to get all the key value pairs, you can just do the name of the dictionary dot items.

164
00:21:35,680 --> 00:21:36,579
So you can see that here.

165
00:21:36,580 --> 00:21:45,700
If we use the same the same dictionary that we talked about before, we just do states that keys that that'll format all the keys,

166
00:21:46,030 --> 00:21:52,389
states that values it'll print out all the values which states items that'll print out

167
00:21:52,390 --> 00:21:59,560
kind of all three state value papers and kind of print this out as a list of assets.

168
00:21:59,600 --> 00:22:03,880
That was kind of three key value pairs.

169
00:22:05,260 --> 00:22:17,260
Okay. So let's. So I would say it's common to have dictionaries with a value, I mean strings as the keys,

170
00:22:17,260 --> 00:22:20,740
but you can have dictionaries with numbers as the keys as well.

171
00:22:21,420 --> 00:22:29,100
So let's define this dictionary called squares where the keys are just the numbers one, two, three and four.

172
00:22:29,730 --> 00:22:31,180
And that's perfectly fine.

173
00:22:31,930 --> 00:22:44,170
And then if I access squares, one that's going to return the value associated with the key one plus one in this case and in squares,

174
00:22:46,200 --> 00:22:51,500
the three that's going to return nine.

175
00:22:51,520 --> 00:22:56,320
So the value associated with the keys three.

176
00:22:56,980 --> 00:23:00,340
So you can certainly use numbers as keys.

177
00:23:02,410 --> 00:23:18,070
Okay. So you can you certainly are allowed to modify the values associated with a given key.

178
00:23:18,850 --> 00:23:32,200
So, for example, to do that, you just kind of assign something to the name of the dictionary with the name of the key and brackets.

179
00:23:32,200 --> 00:23:37,240
So if I want to update the value associated with the key.

180
00:23:37,510 --> 00:23:40,960
Michigan is the name of the dictionary in then Michigan in quotes.

181
00:23:41,590 --> 00:23:56,590
And then here I'm giving it to the public. Okay. So it's all you have to do to update a value associated with the key or modify it, as I'm calling it.

182
00:23:58,570 --> 00:24:07,210
So you can also you can also add key value pairs to the dictionary.

183
00:24:07,780 --> 00:24:16,810
So to do that, you don't really need to necessarily add a pair before you.

184
00:24:18,620 --> 00:24:25,130
Well, I want to say, I guess you don't need to be like State Scott ad or anything like that.

185
00:24:25,640 --> 00:24:36,180
You can just basically kind of assign a value to an as yet undefined key.

186
00:24:36,200 --> 00:24:42,500
So I guess doing this type of statement is kind of this creates a C,

187
00:24:43,190 --> 00:24:54,240
Wisconsin and the associated value of Madison kind of at the same time we kind of added this single line adds the key value pair,

188
00:24:54,270 --> 00:24:58,340
Wisconsin Madison to your dictionary.

189
00:24:58,460 --> 00:25:12,030
Okay. So you don't necessarily have to. A dot ad or anything you can if you just do the code as if you were just modifying an existing key,

190
00:25:12,030 --> 00:25:16,680
that that will automatically kind of add this key value pair to your dictionary.

191
00:25:17,560 --> 00:25:21,360
So it's kind of one way to add a key value pair.

192
00:25:24,780 --> 00:25:29,130
Okay. So this is also something that's useful.

193
00:25:29,140 --> 00:25:32,190
So this is also useful for sense of the game.

194
00:25:32,310 --> 00:25:39,020
I put an example, slide four in this sense, but using in or not in.

195
00:25:39,190 --> 00:25:46,650
That's that's often useful. So if you just want to test kind of what if you have some word, for example,

196
00:25:47,220 --> 00:25:52,860
and you just want to test whether or not it's, it's one of the keys in your dictionary.

197
00:25:53,310 --> 00:25:56,940
So you can just use n or not for that purpose.

198
00:25:57,180 --> 00:26:01,049
And you can also use end or not in four sets.

199
00:26:01,050 --> 00:26:08,680
Like if you have some word or some number, if you want to test whether or not it's an asset, you can just use this key word in or not in.

200
00:26:10,650 --> 00:26:18,090
So as an example of this, so I'll just look at this dictionary called Word Cloud here.

201
00:26:19,290 --> 00:26:29,460
This is a dictionary with line of three. We have three keys, each one is a string, and then each value is kind of a number.

202
00:26:31,050 --> 00:26:37,890
So let's just check. I want to just check if the word is the this is one of the keys in this dictionary.

203
00:26:38,520 --> 00:26:49,480
All you have to do is just do the in quotes and then just in words mean in the dictionary and then return a true or false one,

204
00:26:49,740 --> 00:26:53,250
depending on whether or not the is in the dictionary or not.

205
00:26:54,360 --> 00:26:58,530
So here it is in the dictionary.

206
00:26:58,530 --> 00:27:13,320
So it returns true. If you look at whether or not is not in the word clouds as it's testing, whether or not that is not one of the keys.

207
00:27:13,470 --> 00:27:18,600
So let's return false since that is a key in the dictionary.

208
00:27:21,640 --> 00:27:27,620
And in this case, I'm testing if the word hello is one of the keys in the in the dictionary.

209
00:27:27,630 --> 00:27:32,470
So here it puts false since hello is not one of the keys information.

210
00:27:33,570 --> 00:27:38,180
So in or not is used always for these types of membership tests.

211
00:27:38,190 --> 00:27:48,720
If you want to see if you know a word or some number is one of the keys in the dictionary, it's just useful for these types of integer tests.

212
00:27:49,530 --> 00:27:55,750
Okay. So I think that's. That's all I'm going to say for now.

213
00:27:55,760 --> 00:28:00,080
I might say a little more about eight years later.

214
00:28:00,470 --> 00:28:10,610
That's basically it. So this is just kind of a table that summarizes everything we talked about, I guess, in the last two or two and a half classes.

215
00:28:10,610 --> 00:28:21,500
So these are basically like the I'd say these are like the four main built in kind of data structures for storing collections of items.

216
00:28:22,850 --> 00:28:26,690
Those are basically just lists, tuples, sets, dictionaries.

217
00:28:27,440 --> 00:28:35,150
So here's the definition. These are just basically the way you create either a list or tuples of or a set or a dictionary.

218
00:28:38,730 --> 00:28:41,780
Oh, sorry. Indexing, I guess so.

219
00:28:41,780 --> 00:28:48,200
It lists and tuples are order and meaning. There's like really a first element, a second element and so forth.

220
00:28:48,860 --> 00:28:54,319
So, as we said before, is keep in mind that in fact, indexing starts from zero.

221
00:28:54,320 --> 00:28:59,149
So you start counting from zero and you're dealing with which are tuples sets.

222
00:28:59,150 --> 00:29:03,050
There's really no there's not really ordering.

223
00:29:03,800 --> 00:29:10,760
So you don't really accept if you're really no way to access like the first or second element there.

224
00:29:10,760 --> 00:29:19,280
So dictionaries are not really ordered as well, but you access kind of individual values using kind of the key.

225
00:29:19,940 --> 00:29:28,729
The key serves as an index, even though it's not really ordered from one to, you know, the last value of the dictionary.

226
00:29:28,730 --> 00:29:34,830
The way you kind of access individual values from the dictionary is based on that key.

227
00:29:34,940 --> 00:29:39,950
Okay. So you can access individual values, giving it like the name of the key and so forth.

228
00:29:43,330 --> 00:29:58,330
Emerging examples of the mutable versus immutable is basically whether or not you can change values inside

229
00:29:58,330 --> 00:30:04,840
of it after it's been defined or whether or not you can change certain elements after it's been defined,

230
00:30:04,840 --> 00:30:16,090
I guess. Tuples are the only thing that's going to be the cool. I guess the only thing to mention here about dictionaries is the key.

231
00:30:16,090 --> 00:30:20,080
You should have a mutable an the mutable data and type.

232
00:30:20,800 --> 00:30:24,640
So it's something that cannot be changed for the key part.

233
00:30:26,440 --> 00:30:30,670
So that's kind of some of the.

234
00:30:36,010 --> 00:30:39,999
The main data structure is in Python.

235
00:30:40,000 --> 00:30:44,110
So this will do list comprehension.

236
00:30:44,110 --> 00:30:53,860
There really is SAT and dictionary comprehension as well the kind of the same syntax as list comprehension.

237
00:30:53,860 --> 00:31:00,230
So we'll just I'll just mention that before going on to not be so list comprehension is

238
00:31:00,370 --> 00:31:09,970
are useful for generating kind of a another list from an existing data structure you.

239
00:31:11,290 --> 00:31:24,670
Such as a list or a tuple, you're basically you're creating another list that kind of transforms the data that you have an existing list in some way.

240
00:31:25,000 --> 00:31:37,150
And it's basically just a comprehension, I think, of it's just a it's a very compact way of of kind of transforming elements of the list.

241
00:31:37,780 --> 00:31:46,630
So, I mean, for comprehension, you can do the same thing with your writing, writing things in a different way.

242
00:31:48,350 --> 00:31:53,290
You certainly don't have to use comprehension if you're writing Python code.

243
00:31:55,870 --> 00:31:58,929
It's just it's just a very compact.

244
00:31:58,930 --> 00:32:07,720
You are kind of writing certain things, expressing certain types of computations.

245
00:32:08,290 --> 00:32:15,129
And so you might also see this a lot, this type of thing in a lot of other python code that you might come across.

246
00:32:15,130 --> 00:32:20,530
So it's good to be aware of that when you see something that looks like this, this is like a list.

247
00:32:20,620 --> 00:32:25,930
This is a list comprehension. So it's good to know what it's doing over.

248
00:32:27,770 --> 00:32:34,129
So basically you have all this comprehension of basically creating a new list that's basically

249
00:32:34,130 --> 00:32:41,030
filtering or transforming kind of the the elements that are in an original list and so on.

250
00:32:42,080 --> 00:32:45,920
So it's probably more clear if we just do some examples.

251
00:32:47,160 --> 00:32:57,959
So this is a list comprehension to construct a list with the first of the first nine squares,

252
00:32:57,960 --> 00:33:05,670
meaning that one squared zero squared is the first element.

253
00:33:06,270 --> 00:33:13,110
One squared is the second element, two squared is it is the third element and so forth and so forth for the first nine.

254
00:33:15,480 --> 00:33:20,250
So the way you can do that with a list comprehension is kind of this syntax.

255
00:33:20,250 --> 00:33:26,820
I put everything in brackets and then I just say kind of the kind of the first

256
00:33:27,510 --> 00:33:31,890
part in your list comprehension is the thing that's going to be returned.

257
00:33:33,060 --> 00:33:45,770
Okay. So you're saying basically what your returning is is squared and you're doing that for you're doing that for a range of values.

258
00:33:45,780 --> 00:33:49,469
And so you're doing that for each guy in range ten.

259
00:33:49,470 --> 00:33:55,260
So that's basically for I going from zero one, two, three, four all the way through nine.

260
00:33:55,470 --> 00:33:55,850
Okay.

261
00:33:57,980 --> 00:34:09,320
So that's basically what that's basically going to do is going to return a list where each kind of the first component of the list is is zero squared.

262
00:34:10,040 --> 00:34:16,700
Then the next component of the list is one squared and the next component of the list is two squared and so forth.

263
00:34:16,790 --> 00:34:21,139
So this is just kind of a, I guess,

264
00:34:21,140 --> 00:34:26,870
a compact way of writing this with a single line without first defining the

265
00:34:26,870 --> 00:34:31,130
list and then writing a full for loop and then appending each element to the,

266
00:34:31,700 --> 00:34:38,960
to that existing list. This is kind of a compact way of writing with it is list comprehension with a single line.

267
00:34:40,220 --> 00:34:53,450
Okay. So yeah, this would be yeah, this is really an example of writing the same, the same thing without using a list comprehension.

268
00:34:54,260 --> 00:35:02,419
So here is, it's a little bit longer, like you might try to create an empty list and then you write it for a loop.

269
00:35:02,420 --> 00:35:09,890
And then each time you get inside of the group, append square to the existing.

270
00:35:10,190 --> 00:35:18,650
So again, this comprehension is like this more compact way of writing the same path.

271
00:35:20,410 --> 00:35:25,930
Doing the same type of computation. So that's how it was comprehension work.

272
00:35:25,940 --> 00:35:33,249
So maybe it's more helpful to see that kind of general form, far less comprehension,

273
00:35:33,250 --> 00:35:38,920
I guess the way the general form, basically the way it works, you have some kind of expression.

274
00:35:38,920 --> 00:35:49,060
You're so. Basically an expression that does some type of computation like this.

275
00:35:49,780 --> 00:35:57,570
In the previous example, it computes, I squared and then you, uh, and after that you have some,

276
00:35:57,900 --> 00:36:05,190
you know, a type of force statement, you have some for value and some indexing collection.

277
00:36:05,790 --> 00:36:11,370
So basically like value is like the would be variable values kind of in check.

278
00:36:11,500 --> 00:36:17,840
It's going to move through each component of this collection.

279
00:36:18,360 --> 00:36:28,349
And then what we didn't have in the previous examples and you can also add an F statement with it as part of the list comprehension.

280
00:36:28,350 --> 00:36:39,540
So you can even have kind of if parts you can even have kind of slightly more complex logic within a single list comprehension.

281
00:36:40,440 --> 00:36:51,990
Okay. So basically the way you use F is if you only want to include kind of items that satisfy some condition.

282
00:36:52,110 --> 00:37:02,250
So in the previous example, we wanted to we didn't have a big part, but let's say we wanted to create a list of the first in squares,

283
00:37:02,970 --> 00:37:07,200
but we only wanted that was to have kind of the square of even numbers.

284
00:37:07,890 --> 00:37:12,480
So to do that with a list comprehension in the previous example,

285
00:37:12,480 --> 00:37:22,690
we would just have to add this extra if statement I'm only I'm only going to execute the expression if I modulus two is zero,

286
00:37:22,690 --> 00:37:32,210
which is basically I'm only going to perform this expression here if I is even place.

287
00:37:33,030 --> 00:37:36,870
So we can kind of add more complex logic to your list expression.

288
00:37:37,530 --> 00:37:46,020
Okay. So you can see that a here these are the the E this returns a list of the even squares, I guess.

289
00:37:50,060 --> 00:37:53,480
So it's kind of the same thing we had before.

290
00:37:53,510 --> 00:38:00,860
We have high times, high for Iron Range ten. We're just adding this extra condition and I modulus two is equal to zero.

291
00:38:01,490 --> 00:38:08,240
This is basically saying it's going to only it's going to return a list of only eight even numbers.

292
00:38:10,070 --> 00:38:14,030
So you can add this extra condition.

293
00:38:14,990 --> 00:38:25,270
Okay. So this is. Oh, yeah. So this is probably more, slightly more realistic example that you might use in practice.

294
00:38:25,280 --> 00:38:29,749
So let's say we have a we have a list, but this is a list of tuples.

295
00:38:29,750 --> 00:38:36,470
So each element of our list is a is a is a length two tuple.

296
00:38:39,530 --> 00:38:51,850
So these are like basically steak names in there as like the first element of the tuple and then the population as the second element.

297
00:38:52,010 --> 00:38:52,460
Simple.

298
00:38:53,720 --> 00:39:07,070
So let's say you want let's say we wanted to create a list of the state names whose populations are less than 15 and say, yes, that's 15 in this case.

299
00:39:08,180 --> 00:39:19,880
These are in millions. So the way you could do that is I'm going to is with this following list comprehension so I can I'm just going to return it x.

300
00:39:22,340 --> 00:39:29,290
So X is like the first component of the tool. So it's basically the name of someone.

301
00:39:29,900 --> 00:39:37,190
It's basically going to return the name of the others in the first element of

302
00:39:37,190 --> 00:39:43,729
the tuple and then here to loop over kind of all of the tuples in the list.

303
00:39:43,730 --> 00:39:47,780
All you have to do is do four x, comma, y and state.

304
00:39:49,420 --> 00:39:59,649
That's basically saying that. We're looping over all of the tuples where the first element of the tuple is X,

305
00:39:59,650 --> 00:40:07,780
and the second element of the table is why for all the tuples in the lists, they pop on them.

306
00:40:08,800 --> 00:40:17,140
So that's how you can list over tuples in a in a list or even or it's basically the same thing.

307
00:40:17,140 --> 00:40:22,120
If you were looping over lists within a list, like if you had,

308
00:40:22,660 --> 00:40:29,740
if these were two component lists and this lists the way you would do this same exact thing for X,

309
00:40:30,520 --> 00:40:37,390
I guess you would have these brackets, but the same, almost the same syntax.

310
00:40:38,350 --> 00:40:41,260
And then what is this condition means?

311
00:40:43,340 --> 00:40:55,310
Here we have if y is less than 15, that just basically means we're only going to return x if the second component of the tuple is less than 15.

312
00:40:55,970 --> 00:41:05,030
Okay. So this is going to return the names for those tuples where the second component of the two points less than 15.

313
00:41:06,410 --> 00:41:08,710
So this that's what this is returning here.

314
00:41:09,730 --> 00:41:20,380
This is returning kind of all of the state names where the kind of the associated component of the tuple is less than 15.

315
00:41:23,550 --> 00:41:31,890
So this is a list. So this is not really related to comprehension.

316
00:41:31,890 --> 00:41:45,330
It's a reminder if you want to sort a list. If you have a list of all strings, if you just it's not sorted, it'll sort of alphabetical order.

317
00:41:45,990 --> 00:41:50,790
So this is the same thing, just sort of in order.

318
00:41:53,910 --> 00:42:02,670
Okay. That's basically the idea behind list comprehension.

319
00:42:02,700 --> 00:42:07,920
You just go to an expression that returns something and then you have some.

320
00:42:10,910 --> 00:42:22,310
Luke We have a looping variable and indexing set for your looping variable, and then you can also add an if statement.

321
00:42:22,490 --> 00:42:25,850
Okay. So pretty much the same type of.

322
00:42:27,720 --> 00:42:36,720
Syntax applies. If you're doing to full comprehension or comprehension or dictionary comprehension, you're just returning a tuple.

323
00:42:39,100 --> 00:42:41,740
Rather than my list. That's what's going to be returning.

324
00:42:42,310 --> 00:42:49,960
So if I knew a tuple comprehension, I could just use the use the keyword tuple instead of these brackets.

325
00:42:50,530 --> 00:43:00,750
So fighting tuples I for iron range ten that is just going to return integers 01234567898.

326
00:43:01,540 --> 00:43:11,619
By the second one, see two. This is we still have the same kind of loop loop in the tuple, but we have this extra if condition.

327
00:43:11,620 --> 00:43:17,590
So it has to be divisible by three. So it's just going to return zero, three, six and nine.

328
00:43:17,900 --> 00:43:23,800
Okay, so this is a 2.606369.

329
00:43:24,460 --> 00:43:33,930
Pretty much the logic of a tuple comprehension is the exact same thing as a list comprehension, english returns and tuple instead of list.

330
00:43:35,800 --> 00:43:41,010
Yes. Set and set comprehension.

331
00:43:41,030 --> 00:43:44,950
That pretty much the same thing. Logic is the same thing. I guess the.

332
00:43:45,370 --> 00:43:58,790
The only. Is the only difference is that it's kind of the way you set up your kind of I guess your computation is

333
00:43:58,790 --> 00:44:08,839
that like if you're four statements and the return value is set up so that it returns duplicate values,

334
00:44:08,840 --> 00:44:13,940
kind of the set comprehension will automatically kind of remove those duplicates.

335
00:44:14,570 --> 00:44:18,340
So I think probably only the main difference between.

336
00:44:23,040 --> 00:44:31,449
Would say comprehension works versus the stereotypical comprehension of the duplicates which would be automatically removed.

337
00:44:31,450 --> 00:44:36,220
But otherwise the logic of a sentence comprehension is exactly the same.

338
00:44:38,460 --> 00:44:41,520
So let's see here this first example.

339
00:44:43,620 --> 00:44:52,440
Yeah. So for a set comprehension, you use the curly braces instead of the brackets first that you would use for a list comprehension,

340
00:44:53,790 --> 00:45:00,750
but otherwise kind of the syntax is the same. So let's say in this first example, I'm returning x for x.

341
00:45:02,340 --> 00:45:13,120
X is the interest variable here and the one from one is going to cross these elements in this index, etc.

342
00:45:13,320 --> 00:45:22,799
Okay, so this is going to return X, all the elements, basically every value of X here,

343
00:45:22,800 --> 00:45:27,810
but it's going the thing that it's going to return is, is going to have the duplicates.

344
00:45:28,860 --> 00:45:39,870
So it should return 1 to 3 and it's not going to return these extra threes that it's going to have seven, nine and 12, seven and five.

345
00:45:40,890 --> 00:45:46,230
So you can see that here. S1 one has the elements one, two, three, five, seven, nine, 12.

346
00:45:47,400 --> 00:45:58,320
Okay. Then here, if you wanted to filter this kind of this list further into numbers that are divisible by three,

347
00:45:58,740 --> 00:46:04,380
you can just add this extra condition if x modulus 3 to 0.

348
00:46:05,040 --> 00:46:13,980
You can see back here, here as two is this set just nine 312, which you can kind of remove the numbers that are divisible by three.

349
00:46:15,540 --> 00:46:24,540
So that is a set comprehension. A dictionary comprehension is also pretty similar.

350
00:46:30,940 --> 00:46:34,840
However, you have to have it return kind of a key value pair,

351
00:46:35,590 --> 00:46:43,360
kind of the expression that you have on the front, the furthest to the left hand side of the expression here.

352
00:46:43,360 --> 00:46:51,219
Here's the thing that's going to be returned. So for that, you have to have it in the format of a key value pair.

353
00:46:51,220 --> 00:46:58,540
So you have to have something that's kind of separated by a colon, but for a dictionary comprehension.

354
00:46:58,790 --> 00:47:06,400
You kind of you put everything inside of curly prices in the same way that you do for, say, comprehension.

355
00:47:07,150 --> 00:47:17,020
Right. So here in this example, what's being returned is the P value pair x and then to raise to the power x.

356
00:47:17,920 --> 00:47:26,320
And so each two key value pairs are going to be kind of numbers of the form X and then to race to the X power.

357
00:47:26,410 --> 00:47:35,200
Okay. So here in this dictionary, D one, we have X going from zero all the way up to nine,

358
00:47:35,980 --> 00:47:41,129
and then each key value pair is going to be kind of X and then to raise to the power x.

359
00:47:41,130 --> 00:47:53,890
So you can see that here we print out this dictionary D one, and the first component is zero as the dictionary as the key, and one is the value.

360
00:47:54,370 --> 00:48:02,229
So for one in one key, the value is two, and here the key is two.

361
00:48:02,230 --> 00:48:21,550
And in the value, just so the logic is pretty much the same as another comprehension, which is you have to do which is your dictionary comprehension.

362
00:48:23,200 --> 00:48:32,529
You have to return a key value pair of what you're returning and of the expression

363
00:48:32,530 --> 00:48:36,730
in the leftmost left hand side of that of the dictionary comprehension.

364
00:48:42,050 --> 00:48:52,540
Is other example. This is just a we have a list of strings and here we're just doing it with a dictionary comprehension and

365
00:48:52,540 --> 00:49:10,540
creating a dictionary where we have each text we have each key will be a kind of a word from this list.

366
00:49:11,410 --> 00:49:23,530
And then the, the value of the associated value is the length and how many, how many letters are in that string.

367
00:49:28,150 --> 00:49:32,590
So you can see that here we had the two. Like the first key is Apple.

368
00:49:33,250 --> 00:49:37,450
The associated value is the length of Apple and Virgin.

369
00:49:37,450 --> 00:49:43,260
Their second key is orange and the value is kind of the which.

370
00:49:45,490 --> 00:49:50,650
It's just another example of using a dictionary comprehension to create a dictionary.

371
00:49:55,620 --> 00:49:59,780
Oh, yeah, I think. Please.

372
00:50:02,880 --> 00:50:07,650
Yeah, you can. You can use a nested type of loop for.

373
00:50:07,830 --> 00:50:11,810
For English comprehension. There's nothing stopping you from doing that.

374
00:50:11,820 --> 00:50:26,940
So, like, let's say you wanted to create a list of tuples where we have like a pair of basically the pair of, of even odd integers.

375
00:50:27,660 --> 00:50:38,130
Like if we wanted to look at all pairs of integers between zero and five, where the first component like the first,

376
00:50:38,940 --> 00:50:43,140
the first integer and the pair was even, and then the second integer and the pair was odd.

377
00:50:44,340 --> 00:50:49,380
You can do that with a a list comprehension start, right?

378
00:50:50,310 --> 00:50:54,959
I mean, you can definitely do in writing out a full nested for loop yourself,

379
00:50:54,960 --> 00:51:00,420
but it's just an example of how to do a list, a list comprehension with a nested loop to do that.

380
00:51:01,080 --> 00:51:10,320
So here it would be like a way of doing it. With this kind of a full nested for loop, you would first create an empty list here.

381
00:51:10,680 --> 00:51:17,700
Your pairs is the empty list and then you have a loop over both X and Y going from zero up to five.

382
00:51:20,250 --> 00:51:30,959
And then you would only you would only add a pair of a numbers x and y axis even.

383
00:51:30,960 --> 00:51:42,090
And then why is odd. So that's kind of the that is kind of the list that we were trying to create.

384
00:51:42,590 --> 00:51:47,370
So you have a list of tuples where the first component of the two fold is.

385
00:51:47,430 --> 00:51:52,509
Even in the second component of the two, pull is odd. So you can do that with this type of nested.

386
00:51:52,510 --> 00:51:57,660
It was basically only adding things to the list.

387
00:51:58,050 --> 00:52:06,000
If both we have both x modulus two equals zero and y modulus two is one.

388
00:52:06,570 --> 00:52:06,990
So that's,

389
00:52:07,170 --> 00:52:18,180
that's how you could do the full kind of nested for for loop written over multiple lines is you also write that with a with a list comprehension.

390
00:52:18,180 --> 00:52:23,190
So here is an example of like a single line list comprehension that does the same thing.

391
00:52:23,190 --> 00:52:29,009
So to say E2 is equal to kind of bracket and then we have X, comma,

392
00:52:29,010 --> 00:52:39,120
y or in parentheses just basically reason for turning x, x and Y as a, as a tuple a length to a tuple.

393
00:52:39,750 --> 00:52:51,510
Now we have two for loops for X and range five for Y and range five, which we put two for loops together, like one right next to each other.

394
00:52:51,510 --> 00:53:00,090
That's basically the same thing as writing a nested loop where this x part it would be treated as an outer loop,

395
00:53:00,630 --> 00:53:03,630
and then the Y part is treated as like the inner loop.

396
00:53:05,690 --> 00:53:15,900
Then we have this kind of filtering condition here for only adding things to our list effects at Modulus to a zero and Y Modulus two is one,

397
00:53:17,490 --> 00:53:20,640
which is kind of just the filtering condition here.

398
00:53:21,450 --> 00:53:27,509
And so this is just a list comprehension that does the same thing as what we have above.

399
00:53:27,510 --> 00:53:36,130
It just kind of does everything in a single line. So you certainly be allowed to have one.

400
00:53:40,020 --> 00:53:47,740
Nested loops within a list comprehension or more comprehension or full comprehension of any numbers.

401
00:53:48,230 --> 00:53:52,230
So that's, that takes care of comprehension.

402
00:53:52,230 --> 00:54:02,820
So. Pause for 1/2, any questions or comments.

403
00:54:04,860 --> 00:54:08,549
So that was kind of just kind of finishing a big section.

404
00:54:08,550 --> 00:54:16,710
So this is kind of the start of a new group of somewhat bigger section of the course.

405
00:54:18,620 --> 00:54:30,920
So this is the pie, not the package that we've seen on the injury symptoms got cut off.

406
00:54:33,240 --> 00:54:36,420
Okay. So anyway. So.

407
00:54:41,330 --> 00:54:50,990
I said MP It basically just stands for numerical python, which won't be true.

408
00:54:52,820 --> 00:54:56,060
Oh, is that on my end? I thought so.

409
00:54:56,080 --> 00:55:00,840
You say. Trying to fix that.

410
00:55:01,010 --> 00:55:07,090
So yeah, it's probably the most popular package for a lot of times, medical type of computations.

411
00:55:07,840 --> 00:55:18,070
It's basically useful for it's going to be the most widely used thing if you're doing any type of linear algebra type of information,

412
00:55:18,100 --> 00:55:24,480
like any type of computations that involve vector and matrices and,

413
00:55:24,720 --> 00:55:30,520
and things like that vector matrix, multiplication, matrix matrix multiplication,

414
00:55:31,630 --> 00:55:36,790
any type of computation where that's used a lot, you generally want to use numpy.

415
00:55:40,420 --> 00:55:47,799
So kind of the key, key thing in NumPy are these multi dimensional arrays.

416
00:55:47,800 --> 00:55:59,440
So a vector would be you can think of sector as like a field, you will define it as a one dimensional array.

417
00:55:59,950 --> 00:56:04,089
A matrix has a two dimensional array. You can define kind of higher words.

418
00:56:04,090 --> 00:56:23,649
I mean these as well. You're just some reference to the kinds of features, how to use a lot of just the key commands and key features of NumPy.

419
00:56:23,650 --> 00:56:26,950
At least it's pretty small list when you're getting started.

420
00:56:29,590 --> 00:56:44,140
So if you're processing numerical data or doing any type of, I guess, larger numerical computations, I would definitely recommend using NumPy.

421
00:56:44,680 --> 00:56:49,329
You're kind of writing it yourself using test loops or other things.

422
00:56:49,330 --> 00:56:59,170
It's often going to be substantially slower than using built in some of the built in functions that nobody has.

423
00:57:00,190 --> 00:57:11,169
If you're doing statistical analysis well, just use pandas well, either numpy or pandas.

424
00:57:11,170 --> 00:57:27,970
But if you're doing kind of computing summary statistics anyway as directly where you're kind of getting summary statistics from a big table of data,

425
00:57:28,630 --> 00:57:34,900
I would strongly recommend just storing that data as kind of a not being array and working with

426
00:57:34,900 --> 00:57:45,940
that kind of things because it's a lot more straightforward than storing things as a list.

427
00:57:46,060 --> 00:57:51,459
Okay. So a lot of basic kind of operations make a lot more sense.

428
00:57:51,460 --> 00:57:56,080
And numpy. Okay, so let's see.

429
00:57:57,160 --> 00:57:59,559
Okay. So this, I think, has something for I mean,

430
00:57:59,560 --> 00:58:12,850
there's there's just a lot of built in functions that support the kind of standard things that you do when you're working with actors.

431
00:58:12,850 --> 00:58:13,479
It's interesting.

432
00:58:13,480 --> 00:58:32,410
So and as a lot of this are similar, I guess type of functionality is are easy to find my other titles separate similar types programs.

433
00:58:34,060 --> 00:58:42,040
Okay so also you know it's also useful though as well because kind of the way the

434
00:58:42,070 --> 00:58:47,800
way you work with some of the arrays is the syntax is often similar to pandas,

435
00:58:48,700 --> 00:59:02,499
which we'll talk about. And so if you're familiar with accessing specific elements of numpy arrays of do the same type

436
00:59:02,500 --> 00:59:10,670
of syntax carries over because it's convenient to learn of not being pandas as a as a parent.

437
00:59:11,140 --> 00:59:19,450
So I guess the first thing to note is that it might not be is not if it's not partly built in Python.

438
00:59:20,170 --> 00:59:32,590
So when you if you want to work with numpy, you have to you actually have to import kind of you have to import, but that will not be a library.

439
00:59:32,590 --> 00:59:39,910
So I would say the most common way is to use this kind of this command or this or run this line of code first.

440
00:59:40,600 --> 00:59:49,659
So you often see something like import numpy as in so you'll get a lot of python code,

441
00:59:49,660 --> 00:59:56,440
especially python code that's used for doing science types of things.

442
00:59:57,790 --> 01:00:01,800
One of the first lines of code. It will be important to me.

443
01:00:02,900 --> 01:00:11,240
That just means that you're importing not be saddled with a lot of the functions that nobody has.

444
01:00:12,800 --> 01:00:16,810
So basically that means that when once you run this, you can act,

445
01:00:16,940 --> 01:00:23,630
you can use a lot of the not functions just using kind of this syntax we have

446
01:00:23,990 --> 01:00:31,459
import something so I just means give us it's not the function called func name.

447
01:00:31,460 --> 01:00:39,260
The way you use it is going to be import funding and then kind of whatever arguments are in parentheses,

448
01:00:39,260 --> 01:00:41,390
you're going to you're going to place in here.

449
01:00:44,810 --> 01:00:51,560
So that's kind of the purpose of running this line of code at the at the beginning that this just allows you to be.

450
01:00:52,850 --> 01:01:03,530
So the basic piece thing, really the key object when you're using numpy is the is the the empty array.

451
01:01:03,530 --> 01:01:05,450
So it's the in dimensional array.

452
01:01:07,520 --> 01:01:20,060
Basically, the linear arrays are not the arrays are used for is to like store a large collection of elements that had all of the same type.

453
01:01:22,410 --> 01:01:31,040
And so that's the main restriction that the elements of your array have to have all of the same type.

454
01:01:32,540 --> 01:01:38,540
So we'll see later with pandas, we don't have that restriction.

455
01:01:39,200 --> 01:01:42,290
Or if you remember before, like lists don't have this restriction,

456
01:01:43,100 --> 01:01:49,790
but this is a restriction for not be arrays all the elements of an not to really have to have been the same type.

457
01:01:51,800 --> 01:01:57,170
So to use it in the array or to create it in the area, just use the array function for one.

458
01:01:57,290 --> 01:02:00,710
I think that's probably the main way to create an empty array.

459
01:02:01,130 --> 01:02:06,650
Just use the array function. So let's say we want to create an array with three elements.

460
01:02:07,130 --> 01:02:11,150
I mean, one way to do it is you can convert a list directly.

461
01:02:11,900 --> 01:02:23,520
So we first create a list with three elements to. To convert this into a number array, we can just do M.P. dot array by name.

462
01:02:23,840 --> 01:02:35,330
So this is going to create a a multi array, I guess we call it like a one dimensional number array with three elements.

463
01:02:35,430 --> 01:02:44,690
Okay. So this interpret is basically kind of like the same thing as an vector with three elements.

464
01:02:44,690 --> 01:02:49,100
If you, if you took the AR module. So you can see that here.

465
01:02:49,260 --> 01:02:55,850
If we look at a type of r one, arr1, it's a it's a different type than the list.

466
01:02:55,910 --> 01:03:01,090
Okay. So what it'll print out is like class not being done in the array.

467
01:03:01,100 --> 01:03:05,300
So it's a different, different data type and then lists.

468
01:03:05,660 --> 01:03:11,900
Okay. So this is a this is a one dimensional numpy array with three elements.

469
01:03:12,930 --> 01:03:21,200
Okay. So as I mentioned before, numpy arrays. The main restriction is that all the components of a number array have to have the same data type.

470
01:03:21,990 --> 01:03:29,090
NumPy basically forces you to do that. So let's say let's let's first create this list with mixed data types.

471
01:03:29,600 --> 01:03:38,120
We have this list with three components where two of the two of the components are numbers and one is a string.

472
01:03:41,700 --> 01:03:49,559
So let's say. Oh, I don't think I printed out the entire array.

473
01:03:49,560 --> 01:04:03,060
But basically if we try to convert this list to a the array, it's going to convert it to a it's going to convert each component to a list.

474
01:04:03,070 --> 01:04:07,649
It's kind of a kind of force each component to the list. So you can see that here.

475
01:04:07,650 --> 01:04:16,139
If we look at the class or I use the types of each component of are to each component is a string.

476
01:04:16,140 --> 01:04:23,520
So it's kind of forcing all of the components of the not be afraid of these strings.

477
01:04:27,870 --> 01:04:33,809
So that's just an important thing to keep in mind.

478
01:04:33,810 --> 01:04:39,600
Even if you try to create an operation with different data types, it's basically going to force everything to have the same type.

479
01:04:41,310 --> 01:04:41,580
All right.

480
01:04:41,580 --> 01:04:53,700
So here are just some useful there's some other useful functions that are good for like initializing arrays or creating arrays with certain patterns.

481
01:04:53,700 --> 01:05:01,110
So one thing that's often useful is often we just want to create an array that has all zero elements.

482
01:05:01,830 --> 01:05:09,320
Like if you want to create an array, you initialize it and then kind of fill in different values later on.

483
01:05:09,330 --> 01:05:14,790
A common way of doing that is just creating, creating or creating an array with all zeros.

484
01:05:15,360 --> 01:05:23,580
So the way you do that is just in P does zeros with the length of the array.

485
01:05:24,270 --> 01:05:29,250
So this is going to create a one dimensional array with seven components.

486
01:05:29,820 --> 01:05:34,020
And each each component of the arrays is to have the values zero.

487
01:05:36,000 --> 01:05:39,060
So that just means that it's like a floating point.

488
01:05:40,560 --> 01:05:43,980
Each element is treated as a floating point rather than an integer.

489
01:05:45,660 --> 01:05:49,590
So this another useful thing is this a range function?

490
01:05:50,220 --> 01:06:02,430
If I just want to create an array of integers going from 0 to 6, I can just do a range of seven.

491
01:06:03,420 --> 01:06:08,730
I will create an array of numbers going from 0 to 6.

492
01:06:09,840 --> 01:06:19,049
If you want to do like a if you want to have a different pattern that maybe has a jumps and it's increments of two,

493
01:06:19,050 --> 01:06:30,510
you can do in P that a range 0 to 13, which means it's starting from zero, it goes up to 13 and then the increment size is two.

494
01:06:30,510 --> 01:06:37,709
So this is kind of has a same similar syntax to kind of how we do slice where the this is the

495
01:06:37,710 --> 01:06:44,880
starting indexes in the finishing index and then this is the increment size as well as the third,

496
01:06:45,240 --> 01:06:51,940
third harmony. So this just creates a sequence going from 0 to 13 that incremented to.

497
01:06:54,120 --> 01:06:59,610
So other useful things for creating arrays with certain pattern.

498
01:06:59,620 --> 01:07:13,739
So if we want to create like an array that goes from 0 to 9 or sorry 0 to 2, but it has 9/11 with kind of all the elements are equally spaced.

499
01:07:13,740 --> 01:07:16,950
So there's equal space between each elements.

500
01:07:16,950 --> 01:07:25,890
But you don't, you don't necessarily want to divide things up yourself and find the right increment.

501
01:07:26,310 --> 01:07:31,920
And easy way to do that is just do zero in one space, zero comma to come on.

502
01:07:32,820 --> 01:07:37,469
That just means it's going to create an array where the first component is zero.

503
01:07:37,470 --> 01:07:46,530
The last component is to it has a length nine and then it kind of divides everything so that everything's equally spaced.

504
01:07:46,530 --> 01:07:49,760
Sort of like that.

505
01:07:51,120 --> 01:07:57,760
Yes. Kind of the increment between neighboring elements is .25.

506
01:07:58,480 --> 01:08:06,860
So the first element zero that we have 2.25 and increase again by 0.25 of the 0.5 and then up 2.75, etc.

507
01:08:06,880 --> 01:08:18,280
So when space allows you to create kind of these equally spaced arrays, there's also a bunch of I mean, not bunch, but a decent amount of.

508
01:08:20,570 --> 01:08:25,640
Functions that allow you to generate random numbers. That's often useful.

509
01:08:26,300 --> 01:08:36,290
So if you want to create an array of kind of random numbers, you want to sample from a uniform, a01 distribution.

510
01:08:36,800 --> 01:08:41,000
You just do this in a random dot random of seven.

511
01:08:41,000 --> 01:08:52,520
So it's going to create an array of like seven where all of the components of the array are generated from a uniform zero one distribution.

512
01:08:53,010 --> 01:08:57,800
You can see that here. All of these all of these components here are in between zero and one.

513
01:08:59,070 --> 01:09:06,380
If you want to generate like random numbers from a like a standard normal distribution, I can pick up random that normal.

514
01:09:09,380 --> 01:09:15,709
And then I guess size is set. And I think I believe you have to look at the documentation and figure out what they call it.

515
01:09:15,710 --> 01:09:23,630
But there's extra arguments if you want to have a different being, a different standard deviation for your for your normal distribution.

516
01:09:24,210 --> 01:09:28,310
But but as a default value, size equals seven.

517
01:09:28,310 --> 01:09:32,090
That's going to generate an array of seven numbers.

518
01:09:34,280 --> 01:09:38,870
We're kind of generating random numbers from a standard normal distribution.

519
01:09:40,640 --> 01:09:46,220
Okay. So what we talked about before are just one dimensional arrays.

520
01:09:48,680 --> 01:10:02,799
So it's the way one dimensional arrays are just printed out and following which kind of everything is then separated by brackets at either end,

521
01:10:02,800 --> 01:10:06,190
end of the components of this one dimensional array.

522
01:10:06,200 --> 01:10:07,669
Well, they want to print it out.

523
01:10:07,670 --> 01:10:16,940
It actually doesn't have commas, but there's usually like a space that separates the, the components of of a one dimensional array.

524
01:10:19,070 --> 01:10:22,850
You can do higher dimensional arrays, I would say.

525
01:10:24,630 --> 01:10:28,690
You know, in practice, mostly what you're going to do, it is two dimensional rays.

526
01:10:30,450 --> 01:10:38,370
The most common thing I think you do in practice, although you can define higher dimensional arrays,

527
01:10:38,370 --> 01:10:44,190
is you want to create a two dimensional array, which you can think of.

528
01:10:44,430 --> 01:10:50,880
It's basically like a matrix. It's just like a table of data where you have row rows and columns.

529
01:10:51,720 --> 01:11:00,810
So to create like a two dimensional array, one way to do that is to give it a list of lists.

530
01:11:01,100 --> 01:11:01,440
Okay.

531
01:11:03,570 --> 01:11:13,160
Again, you're you're all you're still using the important ray function to create the array, but you're rather than giving a single list of numbers.

532
01:11:13,780 --> 01:11:21,330
I need a list of choices. Okay, so this is what I've done here.

533
01:11:22,200 --> 01:11:33,870
I give it a list with two lists, and then each of the component lists is has length three.

534
01:11:34,410 --> 01:11:40,290
Okay. So the way it's the way this is going to convert this into it.

535
01:11:40,300 --> 01:11:50,760
And then to add to the array is the following. It's the number of lists within the lists that's going to be like the number of rows in

536
01:11:50,790 --> 01:11:56,999
our two dimensional array and then the number of elements within each of the lists here,

537
01:11:57,000 --> 01:12:00,600
the number of elements within each component list. That's like the number of colors.

538
01:12:01,170 --> 01:12:08,850
So in this example, when I, when I run this, this is going to create like a matrix with the two rows and three columns.

539
01:12:09,990 --> 01:12:14,040
So that's the way it prints it out and don't really.

540
01:12:16,110 --> 01:12:20,700
Yeah. I mean, I guess it's okay. I don't really like the way it prints it out.

541
01:12:20,700 --> 01:12:28,950
It's not as nice as offering. You can kind of see that the sense this is like a major with two rows and three columns.

542
01:12:29,160 --> 01:12:44,690
Okay. So the way you can access, like if you have a two dimensional array where you can access individual elements of this array is just this,

543
01:12:44,730 --> 01:12:53,160
this bracketed notation where we have a common j so like to access the a common j component of a matrix,

544
01:12:53,200 --> 01:12:57,470
a two dimensional matrix, two dimensional array.

545
01:12:57,650 --> 01:13:03,180
Just do it and bracket by common j so you can see that here.

546
01:13:03,180 --> 01:13:08,550
This is accessing a lot of different elements of this two dimensional array.

547
01:13:09,150 --> 01:13:16,260
So again, the thing to keep in mind is that the indexing starts from zero, as with everything in Python.

548
01:13:16,770 --> 01:13:20,969
So both the rows and the columns indexing is going to start from zero.

549
01:13:20,970 --> 01:13:29,820
So if we look at a00, that's like this first thing in the top left corner, that's the zero common zero component.

550
01:13:30,540 --> 01:13:40,349
2.4 would be the zero comma one component and 3.0 would be the zero comma two component.

551
01:13:40,350 --> 01:13:50,399
Since it's still the zeroth row in the column index to here, 4.0 would be the one common zero component.

552
01:13:50,400 --> 01:14:00,780
5.1 is the one comma one component, and then 6.3 is the the one comma two component.

553
01:14:00,990 --> 01:14:08,760
Okay. So it's kind of an important thing to keep in mind, both the row and the column indexing everything.

554
01:14:09,240 --> 01:14:17,130
It starts from zero in the top, almost all.

555
01:14:17,160 --> 01:14:25,140
Let's just I'll just mention one or two more things then.

556
01:14:25,860 --> 01:14:32,700
So how do we convert so you can converge like a one dimensional array to a two dimensional array.

557
01:14:33,240 --> 01:14:36,480
So to do that you just have to use in p dot reshape.

558
01:14:38,760 --> 01:14:40,110
So like in this example here,

559
01:14:40,110 --> 01:14:50,790
if I create a one dimensional array using a range that's going to be a one dimensional array of numbers starting from zero going up to five,

560
01:14:51,840 --> 01:14:54,630
if I want to convert that into a two by three matrix.

561
01:14:58,800 --> 01:15:06,600
The way you could do that is with the impetus to reshape science so you can reshape by just give it the name on the right.

562
01:15:07,350 --> 01:15:10,140
And I just give it a dimension that you want.

563
01:15:10,290 --> 01:15:19,440
Like the second argument is telling it the dimensions that you want it to kind of reshape it as basically.

564
01:15:20,010 --> 01:15:26,130
So this is just saying that I want to reshape this one dimensional array into a two dimensional array,

565
01:15:26,790 --> 01:15:29,790
that is to buy it and to have two rows and three columns.

566
01:15:30,510 --> 01:15:38,430
And the way it does this is actually this is the opposite of that.

567
01:15:38,600 --> 01:15:49,589
It fills in like the first row first and then then after fill it like the first three

568
01:15:49,590 --> 01:15:57,090
components of this one dimensional array are filled in first as the first row of the 2D array,

569
01:15:57,780 --> 01:16:04,919
and then like the last three components are filling in as the second row.

570
01:16:04,920 --> 01:16:05,790
Add this to the unit.

571
01:16:06,450 --> 01:16:14,700
If you wanted to reshape it as a three by two matrix, you should still use reshape and just give it three comma two as the bottom line.

572
01:16:14,910 --> 01:16:19,950
And here again, it's going to go and fill in kind of rows at a time,

573
01:16:20,610 --> 01:16:28,080
like it'll fill in zero one as the first row to create the second row within four or five and a third.

574
01:16:29,970 --> 01:16:38,820
So that's kind of the default way that it fills in numbers from a one dimensional array into a two dimensional array.

575
01:16:44,930 --> 01:16:51,380
Okay. Yeah, you can. You can also reshape like a two dimensional array to a one dimensional array.

576
01:16:51,650 --> 01:16:53,870
You just have to give a single number, basically.

577
01:16:54,410 --> 01:17:02,810
Like if I wanted to reshape, this is a three by two matrix, so it's like a two dimensional or a three by two.

578
01:17:03,500 --> 01:17:12,200
You want to reshape this into like a single one dimensional array with, with, uh, with, uh, with six elements.

579
01:17:12,200 --> 01:17:13,730
You just have to give it a single number.

580
01:17:14,270 --> 01:17:22,549
I do it in p dietary shapes and this is just going to convert it into a one dimensional array of a single components.

581
01:17:22,550 --> 01:17:31,490
And again, it kind of takes the, the values kind of row, back row when it's filling things in.

582
01:17:33,080 --> 01:17:44,950
So again, you can use the Len function for not be erased if you look at one here in 20 the return six so.

583
01:17:48,470 --> 01:17:51,530
Oh well, yeah. Since this is the entity with a subsection.

584
01:17:51,830 --> 01:17:58,100
Yeah. I just mentioned that if you want to take like the transpose of a, a matrix,

585
01:18:01,100 --> 01:18:08,240
you can just the way you do it with the arrays is just to look at like the name of the array doc t r dot capital t.

586
01:18:09,170 --> 01:18:16,729
So the transpose of a matrix is basically just a matrix where we flip the, the rows and columns.

587
01:18:16,730 --> 01:18:30,860
So like, uh, we have a m by an m by n matrix where the transpose of that, that would be an N by m matrix where you just swap the,

588
01:18:31,280 --> 01:18:37,280
you flip the, the rows and the columns and all the transpose is and the way to kind of.

589
01:18:40,140 --> 01:18:48,270
I guess we're turn the transpose of a like a matrix called A and B is just a do entity.

590
01:18:48,270 --> 01:18:51,630
So if we have example here, this is a two by three.

591
01:18:52,710 --> 01:18:56,490
Number two, the array of you're calling it a matrix.

592
01:18:57,000 --> 01:19:02,010
If we just do a dot T, that's going to be a three by two matrix.

593
01:19:02,220 --> 01:19:06,990
Okay. So should we just add where the rows are now?

594
01:19:07,010 --> 01:19:10,050
The in a or not, the columns are paid.

595
01:19:10,620 --> 01:19:14,810
So that's out. That's how you can compute the transpose of a matrix.

596
01:19:14,820 --> 01:19:19,049
And so I think, yeah, yeah. Well basically at a time anyway.

597
01:19:19,050 --> 01:19:22,550
So I think we'll stop there. Yeah.

598
01:19:22,770 --> 01:19:36,899
Next time we'll talked about dysfunctional ways of accessing certain components, of coming up with some basic things and splicing notations.

599
01:19:36,900 --> 01:19:49,740
And so when you start this was getting started next week.

