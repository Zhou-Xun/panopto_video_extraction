1
00:00:04,750 --> 00:00:10,380
Very nice. All right.

2
00:00:10,620 --> 00:00:14,490
Let's go ahead and get started. All right.

3
00:00:15,480 --> 00:00:25,860
So I am in Syria and a it's not that long ago, like an hour ago,

4
00:00:25,920 --> 00:00:35,400
we're supposed to go to the refineries on the western side, should be able to access on with one.

5
00:00:37,800 --> 00:00:43,950
It's their younger kids in the school and the homework as well.

6
00:00:44,640 --> 00:00:52,380
That's interesting. Both of those are due by the end of the day, Saturday.

7
00:00:52,410 --> 00:01:00,640
So it's actually the first time this relationship class you're not supposed to to a large

8
00:01:02,910 --> 00:01:13,110
heavy so okay so yeah these are the days to keep track of your assignments or something.

9
00:01:16,160 --> 00:01:25,020
Oh yeah. Both of them are do on Saturdays first first on my first quiz.

10
00:01:26,790 --> 00:01:37,709
Okay. So I guess today's topics basically like functions and reviewing functions and I guess this

11
00:01:37,710 --> 00:01:45,490
concept of scope and namespace and variable is that related to the way we talk about them,

12
00:01:45,490 --> 00:01:51,059
that is related to how we relate it to functions or, you know.

13
00:01:51,060 --> 00:01:58,380
Question Yeah, but the whole reason you have to like check whether the variables are from, you know, structurally,

14
00:02:00,870 --> 00:02:14,820
you could just assume that the input is follows the, follows the guidelines, but you simply don't have to check if this is.

15
00:02:17,700 --> 00:02:23,300
So so many other questions about donations.

16
00:02:28,770 --> 00:02:37,049
Just basically, you knew a little bit about function scope and name space.

17
00:02:37,050 --> 00:02:43,440
And then I guess the biggest topic will be lists in Python.

18
00:02:44,670 --> 00:02:51,100
So I just thought I'd throw in some additional examples.

19
00:02:51,120 --> 00:03:01,139
These are just mostly just to get to practice using kind of the correct syntax for writing functions.

20
00:03:01,140 --> 00:03:10,280
I mean, these functions are are fairly short, but it's good practice to, you know,

21
00:03:10,350 --> 00:03:13,560
make sure you know the right syntax and how to put everything together.

22
00:03:14,100 --> 00:03:17,200
So let's say we just wanted to write a python function.

23
00:03:17,200 --> 00:03:24,179
It just has three parameters that you think are of interest and arguments, and then it's just going to return.

24
00:03:24,180 --> 00:03:32,790
The minimum of those three numbers of it can be without using the menu function directly or writing your own then function,

25
00:03:32,790 --> 00:03:36,030
or at least the main function that works for three numbers.

26
00:03:36,040 --> 00:03:49,640
So the way you could write that in as a python function is the following except you are first and then name the function.

27
00:03:49,650 --> 00:03:58,290
5 minutes we have three kind of primary taxonomy, so you need to be three different variables.

28
00:03:59,130 --> 00:04:12,060
And then the colon after closing to do the calculations to figure out if those chains are just saying no X is less than Y.

29
00:04:12,060 --> 00:04:18,690
And that's what you can do is X is the benchmark is tied for the middle.

30
00:04:21,060 --> 00:04:29,730
So that's true. I say know this is not true.

31
00:04:29,730 --> 00:04:31,090
I'll check another condition,

32
00:04:31,100 --> 00:04:43,680
so I'll check if y is the minimum f lines that are equal to action and must really need to be in that case and then not lie.

33
00:04:43,740 --> 00:04:48,450
And then the other kind of the only other cases where neither of these things are true,

34
00:04:48,450 --> 00:04:55,590
that automatically means that you use that system and the final house sentence.

35
00:04:57,120 --> 00:05:00,750
So this is functional.

36
00:05:00,900 --> 00:05:05,530
Do so return the final result.

37
00:05:05,590 --> 00:05:12,000
Remember for the if statements you do need to add content of each part.

38
00:05:13,690 --> 00:05:26,400
So that's what I'm doing here. And then the code that is associated with the if chunk, same thing for the elephants.

39
00:05:27,000 --> 00:05:35,480
And I'm also inventing kind of everything in the function program extra.

40
00:05:35,550 --> 00:05:43,780
And eventually we go inside yourself and then this is just what it looks like when you run into this.

41
00:05:44,190 --> 00:05:50,999
So you can call the function three numbers, so it works as expected.

42
00:05:51,000 --> 00:05:56,820
So this is just an example of a function writing a function in Python.

43
00:05:58,260 --> 00:06:09,750
Let's see, just in another example, this was just a reminder of how to use default arguments.

44
00:06:09,870 --> 00:06:18,270
So let's say we want to write a python function that just does like pounds two kilograms conversion.

45
00:06:20,970 --> 00:06:24,660
So the way it's going to work are going to have two parameters of two input arguments.

46
00:06:24,660 --> 00:06:27,870
The first is just like a number that you want to convert,

47
00:06:28,530 --> 00:06:38,070
and the second input is just a boolean of it's going to be a boolean random variable, not a random variable boolean variable.

48
00:06:40,110 --> 00:06:46,629
And she's going to set it to saying whether or not you want to do kilograms to pounds or vice versa.

49
00:06:46,630 --> 00:06:52,020
This I think if it's true then you do it with kilograms, £2 conversions.

50
00:06:52,980 --> 00:07:11,639
Oh, you type the word, switch the wrong if the second parameter is false and it saved her from the pounds two kilogram conversion, it should be.

51
00:07:11,640 --> 00:07:15,720
If the second parameter is false then.

52
00:07:16,460 --> 00:07:21,140
Supposed to be. And then the other convention.

53
00:07:22,760 --> 00:07:27,340
Okay. So basically this is what I had in mind and I'd probably just wait.

54
00:07:27,350 --> 00:07:40,130
Converge has a default argument, but just call it the default argument is take Casey to Alby she could default on is true.

55
00:07:40,910 --> 00:07:45,470
So by default this function does KG to power conversion.

56
00:07:50,030 --> 00:07:56,960
Otherwise if this is false, it does kind of split LB two kilograms conversion.

57
00:07:59,060 --> 00:08:05,990
This is just kind of reminder of how to write how these kind of functions with default.

58
00:08:07,550 --> 00:08:17,720
So you can call it this way. So this way convert 5.3 is should get the same values for white convert 5.3

59
00:08:18,320 --> 00:08:23,090
common true since you don't actually have to put true as the second argument,

60
00:08:23,090 --> 00:08:32,270
that's like the default. That's I mean you can if you want but it's not this is the only case where you kind of need

61
00:08:32,270 --> 00:08:39,110
to put are it need to provide the second arguments when you want to specified as follows.

62
00:08:39,200 --> 00:08:53,120
So here we have fonts so that it is a pounds, £2, two kilograms conversion.

63
00:08:53,720 --> 00:08:56,879
And remember, this is just also this last line.

64
00:08:56,880 --> 00:09:00,410
This is another way of calling a function using keywords.

65
00:09:01,100 --> 00:09:10,970
You actually kind of put the name of the argument next to the kind of the value that you that you're using.

66
00:09:11,540 --> 00:09:17,660
So t equals 5.3 and taking two of the equals false.

67
00:09:18,350 --> 00:09:20,180
It's just calling it using keyword.

68
00:09:20,190 --> 00:09:27,590
So that's it does the same thing as the previous columns, these two function calls kind of return to the same date.

69
00:09:29,220 --> 00:09:44,350
And that's just in her examples, which are a view of the last time I just mentioned things that we just had to write comments about,

70
00:09:44,350 --> 00:09:47,770
because you've probably seen it in some of the examples.

71
00:09:48,190 --> 00:09:55,150
It's actually the way to write comments in Python is the exact same way to read comments in art.

72
00:09:56,470 --> 00:10:05,260
So comments are basically just ways to allow you to write notes in human language.

73
00:10:06,010 --> 00:10:18,220
They allow you to make comments about different parts of your code and maybe will make it easier to kind of interpret or explain what's going on.

74
00:10:18,400 --> 00:10:21,700
Okay. So basically anything that's a comment.

75
00:10:21,770 --> 00:10:30,930
The computer ignores it when interpreting your comments or comments don't affect anything about how your code writes.

76
00:10:31,060 --> 00:10:35,770
Okay. I would definitely suggest trying to write comments,

77
00:10:35,770 --> 00:10:46,780
at least as you're writing kind of more complicated contents becomes helpful, more reasonable for others.

78
00:10:46,780 --> 00:10:54,820
And I think it helps when you're doing longer projects when you might need to go back to code that you've written in the past.

79
00:10:55,510 --> 00:11:00,040
So the way you write comments in Python, it's just this hash mark symbol.

80
00:11:00,050 --> 00:11:04,460
So it's just the exact same way you write a comment.

81
00:11:04,480 --> 00:11:10,840
Ah, so kind of if you have a line with the hash mark symbol kind of everything after that,

82
00:11:10,840 --> 00:11:17,470
all of the text after that is just ignored by the computer when it's kind of interpreting your code.

83
00:11:19,150 --> 00:11:25,420
So you see that here in this line, X equals 64 is ignored.

84
00:11:25,840 --> 00:11:36,370
So this is basically a comment. Okay. So just kind of everything after a hash mark on the sink on the same line is a comment.

85
00:11:36,550 --> 00:11:51,370
Okay. So you can even write kind of both code and comments on the same line like we have here in the code here, python code here.

86
00:11:52,120 --> 00:11:58,750
And then we have everything kind of after this first hash mark symbol is a comment.

87
00:11:59,380 --> 00:12:06,760
So it's kind of everything to the right of a hash mark symbol on the on the same line of the interpreted as a comment.

88
00:12:07,180 --> 00:12:10,570
So that's how you write comments in Python.

89
00:12:13,360 --> 00:12:25,720
So again, this is the practice of writing at least small comments, especially for further complicated code or longer projects.

90
00:12:28,160 --> 00:12:32,290
I think that's about it for comments. Okay.

91
00:12:32,290 --> 00:12:39,190
So there's this concept of namespace and scope,

92
00:12:41,230 --> 00:12:47,620
which is really kind of talked about in our as well as kind of something that's common to many languages.

93
00:12:47,620 --> 00:12:55,060
But we kind of just go through it here at least kind of a basic description of what it is.

94
00:12:56,410 --> 00:13:07,660
So, I mean, a namespace is basically, I guess, a system for looking up this stored value that's associated with with a name.

95
00:13:07,780 --> 00:13:29,170
Okay. To make it the definition or I guess it's it's a certain tells it is a tells computer where to look in a certain sense.

96
00:13:29,770 --> 00:13:35,740
So you can think of a namespace as kind of a mapping from a name to an object stored in the computer.

97
00:13:39,160 --> 00:13:46,180
So, so when you define kind of variable, I mean,

98
00:13:46,180 --> 00:13:53,420
variables have names of functions have names or other objects that are stored in and

99
00:13:53,530 --> 00:14:09,189
namespaces basically you basically have a distinction between local and global namespaces.

100
00:14:09,190 --> 00:14:17,319
It's basically when you call something that is knows where, it's when you call something using a certain name,

101
00:14:17,320 --> 00:14:21,270
it knows where to look to find the right associated value.

102
00:14:26,800 --> 00:14:32,400
So you can have that if you. Of different namespaces existing at the at the same time.

103
00:14:32,400 --> 00:14:42,930
So I think especially when we're talking about functions, the main distinction between the kind of states and the local namespace,

104
00:14:44,830 --> 00:14:49,410
I guess the global namespace is kind of the variable defined find.

105
00:14:50,790 --> 00:15:01,470
It's related to the variables that are defined kind of outside of a functions kind of available anywhere in your Python program.

106
00:15:01,920 --> 00:15:10,200
So it's really kind of an association between names and the values for variable names that would be used outside of a function.

107
00:15:11,280 --> 00:15:20,490
The local namespace is kind of an association between names and the objects within that are only valid inside of a function.

108
00:15:20,550 --> 00:15:30,680
So like we've seen before, you can have a function that has a name of a variable X inside of the function.

109
00:15:31,290 --> 00:15:39,930
So that refers to a different object and a variable named X that's defined kind of outside of the function.

110
00:15:40,440 --> 00:15:47,370
Okay. So there's like a difference association between the name X and the stored value

111
00:15:47,910 --> 00:15:51,660
depending on whether or not you're inside the functions of the local namespace.

112
00:15:52,500 --> 00:15:56,940
And then like a global namespace where you're outside of the function.

113
00:16:01,830 --> 00:16:10,530
So scope is really. Related concepts.

114
00:16:10,530 --> 00:16:15,790
It's basically kind of the region where.

115
00:16:19,490 --> 00:16:25,600
You know, the correct namespace is accessible, I guess is probably the way to think about.

116
00:16:25,640 --> 00:16:30,080
I think we'll do a few examples in a little while, which I want to clear.

117
00:16:30,800 --> 00:16:42,980
So because they're part of a program or a variable, I the value associated with the variable name is directly accessible is that variable scope.

118
00:16:43,850 --> 00:16:50,960
So I guess, I mean, the best way to think of this is very inside of a function versus outside of a function.

119
00:16:51,560 --> 00:16:55,790
So if you have a variable X kind of defined inside of a function,

120
00:16:55,790 --> 00:17:04,699
kind of the value associated with X is only accessible inside of the function, it's not accessible outside of the function.

121
00:17:04,700 --> 00:17:13,160
So kind of the scope of that variable is kind of a local namespace associated with that function.

122
00:17:13,310 --> 00:17:18,170
The scope is only kind of valid within that function.

123
00:17:19,480 --> 00:17:26,000
Okay. So examples make it more clear.

124
00:17:26,000 --> 00:17:35,059
But let's see. Maybe it helps to think about what happens when you kind of use a name in Python.

125
00:17:35,060 --> 00:17:41,180
So you run a piece of code that has a name, a variable name or a function names.

126
00:17:41,630 --> 00:17:44,980
What are the steps that that happens? That happened.

127
00:17:47,090 --> 00:17:58,669
So a local name. Well, if you are in something that can be thought of as a local namespace and local namespace is searched first.

128
00:17:58,670 --> 00:18:05,030
So you search for a matching name to that, to the name that's been run.

129
00:18:06,110 --> 00:18:10,700
If there's no name in that, there's no matching name in that local nickname space.

130
00:18:11,360 --> 00:18:14,510
And kind of the global namespace is searched.

131
00:18:15,200 --> 00:18:21,510
So if there's no kind of matching name within the local namespace, it'll go to the higher level and look through.

132
00:18:22,040 --> 00:18:23,690
If there's a match for that name.

133
00:18:25,700 --> 00:18:34,190
If there's no name in the global namespace, then it'll be some type of it says this kind of this variable is not found for, for example.

134
00:18:40,710 --> 00:18:46,860
So I think this is something we've used to kind of use this, define this.

135
00:18:47,290 --> 00:18:57,590
But if you use the same name multiple times, the same scope. For instance, I guess if you define the variable with the same name multiple times,

136
00:18:58,170 --> 00:19:07,530
times it just looks for the most recent, the most recent definition of this variable within that scope.

137
00:19:09,450 --> 00:19:22,490
This is a little less general, perhaps, but I think it's better.

138
00:19:22,860 --> 00:19:32,340
I mean, I would think of this as basically stuff inside of a function versus things that are defined kind of in your general python.

139
00:19:32,970 --> 00:19:41,700
The best way to think of this. So I think the local namespaces, for example, names as variables or other things defined inside of a function,

140
00:19:42,540 --> 00:19:50,430
local namespace is kind of the names of variables that need defined in general Python programing, the larger Python program.

141
00:19:51,220 --> 00:19:59,550
I guess there's other things and kind of the built in Python namespace that are kind of built in that you can change.

142
00:19:59,910 --> 00:20:07,830
So that's basically always there. So this is kind of a visual illustration of that.

143
00:20:12,310 --> 00:20:17,270
I think so. I think some basic yeah,

144
00:20:17,350 --> 00:20:26,370
we're basically going to talk about namespace in scope in the context of writing functions so that think about scope for functions.

145
00:20:26,370 --> 00:20:42,120
So inside the the local scope of a function, you can see we are allowed to access a variable that are defined outside of the function.

146
00:20:42,330 --> 00:20:48,420
So that's even if you did didn't define that variable separately within the file,

147
00:20:48,420 --> 00:20:53,880
you could still access the value of a variable as defined outside of the function.

148
00:20:54,930 --> 00:21:01,100
There's a defined and a variable Y somewhere outside of the function.

149
00:21:01,110 --> 00:21:05,960
You can still use that value inside of a function, even to define it anywhere.

150
00:21:05,970 --> 00:21:11,190
I think the only thing that you can do is you can't modify its value.

151
00:21:11,370 --> 00:21:26,100
You can't change the value of a variable that is that has been defined outside of the function.

152
00:21:27,300 --> 00:21:39,150
We'll see an example of that. So here's just some examples which I think will illustrate the main point.

153
00:21:39,150 --> 00:21:51,660
So I define this variable and just basically takes an input argument X and increases X by one and prints the result.

154
00:21:52,080 --> 00:21:58,230
Okay. So when I after defining that function, if I.

155
00:22:01,370 --> 00:22:06,080
Men do say X is equal to 42 and print X.

156
00:22:07,320 --> 00:22:15,080
Well, that's going to be 42. I mean, I think that's that's you. So the next thing I'm going to do is run the function with X.

157
00:22:15,890 --> 00:22:26,030
So here, when I run this, the print statement inside of the function is run, but it prints the value 43, which is this 42 plus one.

158
00:22:26,330 --> 00:22:35,670
Okay. So I then after running this, if I just print X again, it does 40 prints out for it.

159
00:22:35,720 --> 00:22:43,850
So I guess the point here is that this x running this code x equals x plus one

160
00:22:45,260 --> 00:22:48,770
inside of the function doesn't change the value of X outside of the function.

161
00:22:49,400 --> 00:23:01,010
So there's not a local namespace that defines the relationship between the name X inside of the function and a certain value.

162
00:23:01,010 --> 00:23:04,100
And there's also a different namespace.

163
00:23:04,610 --> 00:23:08,480
Associated experts mean a certain value kind of outside of the function.

164
00:23:08,670 --> 00:23:16,550
Okay. So changing, changing X inside of the function doesn't change X outside of the function since there's kind of a different,

165
00:23:18,110 --> 00:23:26,900
totally different association between names and values when you're looking at things going on inside of the function versus outside the function.

166
00:23:27,490 --> 00:23:32,030
Okay. So that's kind of the key point here.

167
00:23:32,520 --> 00:23:38,270
Doing this stuff type of thing inside of a function doesn't change the value of X outside of the function.

168
00:23:39,190 --> 00:23:42,799
Okay. So I guess this I guess these comments kind of wrap it up.

169
00:23:42,800 --> 00:23:51,200
So when we kind of initialized our assignment in the outside of the function,

170
00:23:51,200 --> 00:23:58,310
when we do this X equals 42 assignment, it's basically saying that X has the value 42 in the global namespace.

171
00:24:01,130 --> 00:24:08,110
Kind of inside of the function in there are there are basically two x are two possible X's that you can use.

172
00:24:08,120 --> 00:24:15,040
I guess there's kind of local namespace packs and then there's this global namespace X,

173
00:24:15,050 --> 00:24:23,180
but by default, the local namespace kind of overrides the global namespace.

174
00:24:23,180 --> 00:24:35,840
So when you run this x search is the local namespace first and uses that, it kind of uses that value as long as there's a match in the name.

175
00:24:36,200 --> 00:24:49,260
Okay. So the local version of access is manipulated inside the function and then you can say, can we call and fax?

176
00:24:49,470 --> 00:24:53,180
It doesn't change the value of X in the global namespace.

177
00:24:54,110 --> 00:25:02,299
Okay. Yeah, we saw it before with if you want a friend of X after this, it's it's 42 minutes and running.

178
00:25:02,300 --> 00:25:06,800
This doesn't change the value of X in the global namespace.

179
00:25:08,780 --> 00:25:21,019
All right. So this is just a description of kind of at least roughly what's going on when you call it a function in Python.

180
00:25:21,020 --> 00:25:31,669
So basically when you call a function, it creates kind of a separate namespace for for that function if there are parameters.

181
00:25:31,670 --> 00:25:40,880
So if there are input arguments and your in your function, it kind of allocates spaces for those,

182
00:25:43,910 --> 00:25:50,330
those parameters in a new namespace and then it kind of matches those parameters.

183
00:25:50,330 --> 00:25:57,229
And the argument values that you get when you can call the function and after it's kind of set up that

184
00:25:57,230 --> 00:26:08,000
namespace and executes all of the code inside the function body and then it returns some value or possibly no,

185
00:26:08,120 --> 00:26:14,269
no value at the end of the function. And then after it's kind of return its final value.

186
00:26:14,270 --> 00:26:20,929
It basically destroys that namespace and it's created just for that function.

187
00:26:20,930 --> 00:26:23,870
So kind of every time you call a function,

188
00:26:23,870 --> 00:26:33,350
it's kind of creating a new a new namespace that kind of works as a as a a local namespace for running that function.

189
00:26:34,860 --> 00:26:45,709
Okay. So I think that's two or three more examples which illustrate this even more.

190
00:26:45,710 --> 00:26:52,640
So this is another example. So here we have the function in two.

191
00:26:53,810 --> 00:27:03,410
So in two has a kind of name of the parameter is why we don't, we don't really use fly anywhere inside of the function.

192
00:27:04,310 --> 00:27:09,830
But this is this is perfectly fine to do. So we have the name of the parameter.

193
00:27:09,830 --> 00:27:22,510
Here is why. And then it basically inside of the function it says X is equal to one, x is an x plus one within print.

194
00:27:23,990 --> 00:27:30,860
So what happens when we after defining this function, what happens when we run this these three lines down here?

195
00:27:32,180 --> 00:27:40,669
So first, sort of finding the variable X is kind of equal to five and we run up two.

196
00:27:40,670 --> 00:27:41,810
So what happens then?

197
00:27:42,920 --> 00:27:52,280
Well, it just prints the value two since it's it's actually using this amount, it's using this value of X that we define inside the function.

198
00:27:53,660 --> 00:27:59,270
So it's kind of created the variable X inside of our local namespace.

199
00:27:59,270 --> 00:28:02,930
And it's just using this values of this local x, which is,

200
00:28:03,080 --> 00:28:09,889
which is two when we hit the prints and then this has no effect on X in the global namespace.

201
00:28:09,890 --> 00:28:22,430
So we French X after running in to this, these lines of code have no effect on X in the global instance,

202
00:28:22,450 --> 00:28:27,050
so that the value of X in the global namespaces is still five.

203
00:28:27,230 --> 00:28:30,830
So print out five when we run this line.

204
00:28:31,220 --> 00:28:34,670
Right? So that's kind of another example.

205
00:28:36,980 --> 00:28:39,770
Okay. So here is another example.

206
00:28:39,770 --> 00:28:48,559
So again, here we we have an input parameter wire that's never used inside the function and we have some print of X statements.

207
00:28:48,560 --> 00:28:57,620
But however, the difference between this and the previous one is that we've never we never defined X inside of a function before.

208
00:28:57,620 --> 00:29:06,980
We're printing it. Okay. So this is kind of the main difference between this example and the previous example.

209
00:29:07,820 --> 00:29:11,180
However you can still you can this still runs perfectly fine.

210
00:29:13,460 --> 00:29:16,400
What it's going to do when it runs these press fitments I mean,

211
00:29:16,400 --> 00:29:24,049
it checks the local namespace first and it's going to see that there's kind of no X in the local namespace.

212
00:29:24,050 --> 00:29:30,140
And then since that didn't work, it checks the global namespace and there's kind of a.

213
00:29:36,200 --> 00:29:39,290
An association between a name X and some value. Okay.

214
00:29:40,940 --> 00:29:48,680
So that. So as long as there's kind of an ex defined in the global namespace, this print statement should print out of nothing.

215
00:29:50,510 --> 00:29:53,990
Okay. So let's see what happens when you run this code.

216
00:29:54,020 --> 00:30:00,020
So first we define actually to five and we do three x.

217
00:30:00,750 --> 00:30:04,940
So what is that? So it just prints X and X plus one.

218
00:30:04,940 --> 00:30:14,480
And here it's it's actually going to print X and X plus one those values of X in the and the global namespace, which is five and six.

219
00:30:15,170 --> 00:30:19,310
So you can see here the first two things that are printed are five and six.

220
00:30:20,090 --> 00:30:24,470
That's printing when we want to run in 34.

221
00:30:25,550 --> 00:30:28,700
Next thing we run is print of X. So that's going to print five.

222
00:30:30,170 --> 00:30:37,490
I saw that saying running in three of x didn't affect the value of X at all.

223
00:30:38,330 --> 00:30:41,750
Global namespace. There's no reason why it should.

224
00:30:42,560 --> 00:30:52,610
So running in front of extras prints out five. And then the last thing that's printed out is only two and three, too.

225
00:30:53,720 --> 00:30:55,820
So again, that prints up five six.

226
00:30:56,990 --> 00:31:06,890
That's because it's actually doesn't matter as an input argument we give it since Y as it becomes an effect is print statements.

227
00:31:07,860 --> 00:31:11,060
Right. This is print of x and x.

228
00:31:11,490 --> 00:31:19,400
And again, this is printing out five and six since x has the value of five in the global namespace.

229
00:31:24,160 --> 00:31:29,980
All right. So there was maybe give us one last example.

230
00:31:31,840 --> 00:31:42,760
Okay. So here's an example where we are trying to modify the value of a variable that's only to find a single namespace.

231
00:31:44,530 --> 00:31:48,670
So here we have another option, I'm calling it in Q4.

232
00:31:48,680 --> 00:31:57,550
So we have to keep the parameter Y kind of the first line of this function is what's going to cause a problem.

233
00:31:57,680 --> 00:32:07,310
Saying X is equal to x plus one, so mean x is not defined anywhere inside of that.

234
00:32:07,330 --> 00:32:11,320
I mean, it wasn't created inside of the function first.

235
00:32:12,610 --> 00:32:20,890
If we're running this here, it's there's an X, it is an X in the global namespace.

236
00:32:21,580 --> 00:32:30,250
It's going to note that you're trying to change the value of a variable that's defined in the global namespace,

237
00:32:30,250 --> 00:32:37,720
but you're trying to do it inside of and kind of inside of this function, and that's not allowed.

238
00:32:39,490 --> 00:32:45,160
So you can see that here. Well, print out the error message, but seems like if you try to run this,

239
00:32:45,160 --> 00:32:53,920
if I say X is equal to five and run the code in for x, that should give some error message.

240
00:32:55,310 --> 00:33:05,270
I should not run. The is because we try to change the value of x which is defined in the global namespace.

241
00:33:05,270 --> 00:33:12,670
So you're not allowed to do that inside of a function. That's.

242
00:33:16,390 --> 00:33:25,420
So that's kind of scope and namespace. So I think really what I'm trying to emphasize is the distinction between the namespace,

243
00:33:28,120 --> 00:33:36,730
longer namespace that's associated with a function versus the it's kind of the global namespace for things that are defined outside the function.

244
00:33:37,300 --> 00:33:43,840
That's really the main, main point. Okay.

245
00:33:43,840 --> 00:33:51,280
So the next topic or I guess series of topics are these different, I guess built in data structures in Python.

246
00:33:52,160 --> 00:33:58,810
So I think the main themes are going to be lists, tuples, sets and dictionaries.

247
00:33:59,950 --> 00:34:03,760
So the first thing we're going to talk about is lists.

248
00:34:04,480 --> 00:34:07,719
So I guess a data structure, maybe it's just a general term,

249
00:34:07,720 --> 00:34:15,850
it's just a way of kind of organizing and storing different pieces of information or are a

250
00:34:15,850 --> 00:34:20,680
collection of different pieces of information with any kind of under a single variable name.

251
00:34:20,820 --> 00:34:25,629
Obviously, with lists can star a bunch of different types of information,

252
00:34:25,630 --> 00:34:31,480
but there's only kind of one variable name that you give to a to a list type of area.

253
00:34:31,810 --> 00:34:37,370
Okay. So it's I think it's just at least I'm using data structures in that way.

254
00:34:37,390 --> 00:34:47,590
It's kind of different structures that allow you to kind of organize a bunch of pieces of data under a single variable.

255
00:34:49,720 --> 00:35:04,510
So the most common built in data structures in Python are nice to fold it to dictionaries and set the frame for sense.

256
00:35:04,770 --> 00:35:07,920
Okay. So this will first talk about lists.

257
00:35:11,710 --> 00:35:21,100
That's kind of one of the probably the biggest one. I think tuples are pretty similar to lists, but they're slightly, slightly different.

258
00:35:21,100 --> 00:35:26,350
But so spend a little time on tuples, but it comes with a lot more time on lists.

259
00:35:27,190 --> 00:35:31,589
Okay, so a list. Python.

260
00:35:31,590 --> 00:35:36,300
I would think of it as just a collection of items that are arranged in a particular order.

261
00:35:37,260 --> 00:35:41,870
So you can put really you can mix and match different types of variables list.

262
00:35:42,480 --> 00:35:46,920
So you can have a list with some numbers, some booleans, some strings.

263
00:35:48,300 --> 00:36:02,370
You can even have a list within a list. So that's it's basically they're pretty flexible in terms of the types of things you can store within a list.

264
00:36:03,270 --> 00:36:13,170
So the way you create a list is basically you have brackets and then you separate the components of the lists by icons.

265
00:36:14,190 --> 00:36:18,930
So it's like this an example of creating a list of four strings.

266
00:36:19,710 --> 00:36:30,990
So this this list has four basically four elements of this same family to separate of each element or component of the list.

267
00:36:34,480 --> 00:36:38,350
So this is just a list. Four elements.

268
00:36:38,890 --> 00:36:43,420
Each one is a string. Here's another example of a list.

269
00:36:43,420 --> 00:36:46,420
This is a list of numbers. Three elements.

270
00:36:48,910 --> 00:37:01,870
This is. So here's an example of a list with different variable types.

271
00:37:02,590 --> 00:37:09,210
So this was has three components. The first one is a string.

272
00:37:09,220 --> 00:37:17,470
The second one is number three. So it's no problem to have different variable types in your system issue.

273
00:37:18,340 --> 00:37:22,330
The other thing, you could have a list inside of lists. So this is an example of a list.

274
00:37:23,290 --> 00:37:26,350
So I would say this list has three components.

275
00:37:27,040 --> 00:37:33,750
So like if you checked the length of this list in Python, it's going to return 303.

276
00:37:33,760 --> 00:37:38,860
So this list has three components. The second component is a list itself.

277
00:37:39,550 --> 00:37:44,110
So the second component of the list is a list with three components.

278
00:37:44,110 --> 00:37:47,890
And I guess you could even have a list within a list within the list.

279
00:37:53,080 --> 00:37:57,220
It's more common to start with a list within a list.

280
00:37:57,610 --> 00:38:02,060
That's kind of enough. So this one this is this is a list with length three.

281
00:38:02,080 --> 00:38:09,040
Even though it has kind of a longer list, there's still as it still has length three.

282
00:38:11,070 --> 00:38:13,299
Okay. Okay.

283
00:38:13,300 --> 00:38:23,200
So as I said before, I think a list is just kind of an order, a collection of elements that just basically means that like the list two, one, three,

284
00:38:23,650 --> 00:38:30,190
you start started as it's a different list than 3 to 1, even though these are the exact same set of numbers,

285
00:38:30,610 --> 00:38:34,510
the order in matters, these are these are different lists.

286
00:38:34,720 --> 00:38:44,050
Okay. The way you access individual components or elements of the list is with this kind of brackets.

287
00:38:46,990 --> 00:38:50,650
Indexing is actually the same way you access components of a string.

288
00:38:51,460 --> 00:38:56,620
I see this is the name of the list and then I'm calling it K minus one.

289
00:38:57,760 --> 00:39:07,960
If you think of the K in the case where you're starting tying from, basically the thing to keep in mind is the indexing starts from zero.

290
00:39:08,500 --> 00:39:15,640
For the zero, a component is just the first, the first component of the string.

291
00:39:17,860 --> 00:39:22,810
One component one corresponds to the second item in the list.

292
00:39:23,440 --> 00:39:27,380
Indexing starts from zero, like everything in Python.

293
00:39:27,400 --> 00:39:30,640
So all of the indexing in Python stations.

294
00:39:32,950 --> 00:39:36,730
Okay. So we can see an example of this. Let's look at this list.

295
00:39:37,480 --> 00:39:42,490
This is a list with four elements, right?

296
00:39:42,790 --> 00:39:50,290
So the set, this length, this list has a for the frame out fruit list bracket zero.

297
00:39:50,860 --> 00:39:57,630
That's going to print out kind of the first component. So let's tackle the fruit list, too.

298
00:39:57,640 --> 00:40:01,990
That'll print out peach because this is like the zeroth component,

299
00:40:01,990 --> 00:40:12,340
first component set element or element within indexed to the last one is the element with index three.

300
00:40:13,750 --> 00:40:19,270
So just keep in mind that indexing always starts from from zero in Python.

301
00:40:20,620 --> 00:40:25,260
So it's okay.

302
00:40:25,270 --> 00:40:37,809
So yeah. So you can, you can add and subtract components of the list are numbers or you can combine them in certain ways,

303
00:40:37,810 --> 00:40:43,570
but just by treating the individual elements as a single variables themselves.

304
00:40:43,570 --> 00:40:50,140
So for example, we add two components on the list, or at least for this list.

305
00:40:51,040 --> 00:41:01,020
These are strings, right? So this variable to fruit will also be a string and we'll see contamination of fruit list, wine and fruit.

306
00:41:01,270 --> 00:41:05,380
Three Contamination of orange and pear.

307
00:41:06,470 --> 00:41:16,750
Here we have one, which is the result. You know, if you have a numeric list, if you want to add or do other types of math with different components,

308
00:41:18,310 --> 00:41:22,990
it just means you just access each individual element using such bracket notation.

309
00:41:22,990 --> 00:41:31,569
So here, if we add the component with index zeros that four plus the value with index one,

310
00:41:31,570 --> 00:41:40,570
which is three, so it's four plus three raised to the power to one was two is two.

311
00:41:41,890 --> 00:41:45,610
So it's four plus three squared. So should be 13.

312
00:41:45,710 --> 00:42:01,590
It's four plus nine. So also here's just basically a lot of things I've listed are just kind of useful things to know for manipulating this.

313
00:42:02,250 --> 00:42:10,080
So you could do this like minus bracket notation. So if you do the list name minus one, it gives you the last element of the list.

314
00:42:10,830 --> 00:42:16,020
So if you just want to look at the last element of the list without necessarily looking up the length,

315
00:42:16,700 --> 00:42:20,220
a quick way to do that is just minus one as the index.

316
00:42:20,820 --> 00:42:26,370
And if you keep going backwards, actually the second to last is minus two thirds.

317
00:42:26,370 --> 00:42:36,750
The last is minus three and so forth. So it's just something that works as it can come in handy.

318
00:42:37,350 --> 00:42:44,750
So if you look at this list, why this has 66 components, the last one is for 96.

319
00:42:44,760 --> 00:42:52,470
So if you look at my -146, then my my solution for now, 28.

320
00:42:55,950 --> 00:43:07,499
Okay. So that's that's the minus notation to change values of a list of oh, so you just add, so yeah,

321
00:43:07,500 --> 00:43:21,360
you just assign kind of a value directly to that, the list name kind of bracket, the element that you're trying to change.

322
00:43:22,740 --> 00:43:25,890
You see that here I like.

323
00:43:27,030 --> 00:43:33,479
So if you want to change the value at index one, just divide bracket.

324
00:43:33,480 --> 00:43:37,830
One is equal to something. That's how you modify the elements.

325
00:43:37,840 --> 00:43:44,590
And actually I guess I just did it as a list, an example of a list of links one.

326
00:43:45,140 --> 00:43:54,270
So I signed the element that index one a sequel to a list of length.

327
00:43:54,990 --> 00:44:03,480
This is the length of a list of length one. So you can see that here we have 42, then 17 in brackets.

328
00:44:04,080 --> 00:44:16,440
Okay, so we no longer have the value 1024 bracket 17 And so that's how you modify elements of the list.

329
00:44:20,850 --> 00:44:24,690
An easy way to add a new element to a list.

330
00:44:25,230 --> 00:44:29,730
So adding basically adding an element to the end of the list.

331
00:44:30,330 --> 00:44:34,139
So you're basically increasing the length of the list by one and adding kind of a new

332
00:44:34,140 --> 00:44:39,900
element to the link to the end of the list is just to use the append method for that list.

333
00:44:39,900 --> 00:44:45,990
So the way you do that is you just use the name of the list and then dot a pattern and

334
00:44:45,990 --> 00:44:51,990
then in parentheses you give it the value of the thing that you want to add to the list.

335
00:44:53,790 --> 00:44:56,910
So here's some examples of we find this fruit list.

336
00:44:57,960 --> 00:45:00,960
This has four elements, four strings.

337
00:45:03,690 --> 00:45:12,959
You just want to add another thing to the list. You can just steal from list and I just add another string as a string banana here.

338
00:45:12,960 --> 00:45:17,670
So now, so now that the list has five components, okay?

339
00:45:19,080 --> 00:45:25,920
So that's how that's an easy way to kind of add something to the end of the list if you don't want to if you

340
00:45:25,920 --> 00:45:32,730
want to add something but you don't want it to be in the last position of the list you want to insert instead.

341
00:45:34,380 --> 00:45:38,160
So the way you do insert is just the name of the list, dot insert.

342
00:45:38,880 --> 00:45:42,870
And then there's kind of two arguments you have to give in the index,

343
00:45:42,870 --> 00:45:48,900
which is basically where you want to insert a list index of where you want to insert on the list.

344
00:45:49,530 --> 00:45:54,390
And this new element is the and the value of the new thing that you want to add to the list.

345
00:45:55,530 --> 00:46:03,929
You can see that here. If you have this column listed as four elements, I want to insert something in the position.

346
00:46:03,930 --> 00:46:12,149
One, the first argument you have to get this one, and I just give it the name of the string that I want to insert.

347
00:46:12,150 --> 00:46:18,360
So this is going to insert it. Which one would see that here?

348
00:46:18,360 --> 00:46:25,560
Now we have brand yellow and then everything, kind of everything after the insertion is moved to the right.

349
00:46:26,190 --> 00:46:31,560
So like blue is now as index two and green as index three and so forth.

350
00:46:34,320 --> 00:46:44,879
And then if you keep doing this, if you want to insert something again in position to insert something, a position to I can do it this way.

351
00:46:44,880 --> 00:46:52,280
And the name of the list insert to. With an orange that puts orange in the second position.

352
00:46:52,970 --> 00:46:56,330
You see that here. And then again, kind of everything after that,

353
00:46:56,380 --> 00:47:07,490
it shifted to the right and that's insert if you want to add multiple elements to the list

354
00:47:09,710 --> 00:47:17,720
rather than using append is to use an easier way to extend to the top extend method.

355
00:47:19,940 --> 00:47:23,390
So let's say I wanted to add two components to the end of the list.

356
00:47:25,520 --> 00:47:33,080
I could do the list and and then I just give it a list as each these two extra components.

357
00:47:33,470 --> 00:47:37,640
So that is the difference between using this and pens.

358
00:47:38,300 --> 00:47:46,100
If you ran this with a pen, it would add it would have this list as a as the final component.

359
00:47:46,370 --> 00:47:49,790
Okay. So here I'm here. I didn't want to do that.

360
00:47:49,790 --> 00:47:56,210
I wanted to add the components of this list as components.

361
00:47:58,010 --> 00:48:04,860
And this makes the list I'm going to. I wanted to add two extra components.

362
00:48:04,860 --> 00:48:08,519
I didn't want to just add a single extra component stored as a list.

363
00:48:08,520 --> 00:48:09,870
So that's what append would do.

364
00:48:10,410 --> 00:48:20,640
If you want to just add all the elements of the list to add to an existing of all the elements of one list to an existing list.

365
00:48:21,300 --> 00:48:28,500
A good way to do that is the extent. So it's similar to a pen with slightly, slightly different.

366
00:48:31,500 --> 00:48:37,140
So in contrast to append, often you want to remove things from from a list.

367
00:48:40,140 --> 00:48:50,670
So one way to do that is with the pop method. So to remove an element of a list at a specific location, can you name that pop?

368
00:48:51,720 --> 00:48:56,730
And that's it. And then give it the index of the element that you want to remove.

369
00:48:56,730 --> 00:49:09,210
So this will be as an integer. So I guess one thing to note about Pop is that it actually returns the value of the element that it removed.

370
00:49:09,810 --> 00:49:17,070
So for example, if we define this is our list, if I do come the stock pop of one.

371
00:49:17,640 --> 00:49:23,400
So the, the, the string that's index one is blue.

372
00:49:24,270 --> 00:49:33,470
So it's when I run this, it's going to remove the blue from this list, but it's also going to return in to return the value blue.

373
00:49:33,590 --> 00:49:38,490
So it's the return to a certain value and assign them to the variable.

374
00:49:38,760 --> 00:49:43,350
So you can see that here. When I print X, it has the value.

375
00:49:44,430 --> 00:49:52,710
And then when you print out color list after running the dot pop method, it no longer has some blue in the list.

376
00:49:54,090 --> 00:50:03,390
So that's how that's how pop works. So you don't have to give it a number when you run pop.

377
00:50:04,170 --> 00:50:10,840
Do open closed parentheses. When you do that by default, it automatically just does the last couple in the list.

378
00:50:10,860 --> 00:50:16,110
So if I run this type of thing and it'll just remove the last element.

379
00:50:17,310 --> 00:50:26,580
So that's so that's purple. So in parentheses, you can see that this list no longer has the string per se.

380
00:50:27,360 --> 00:50:31,740
So that's how pop works. If you don't if you don't, give it a number.

381
00:50:35,730 --> 00:50:48,930
Okay. So another thing that I guess is pretty similar to Pops, but there's another option.

382
00:50:48,930 --> 00:50:54,000
The main difference is that it doesn't return anything. Sometimes that's preferable.

383
00:50:56,220 --> 00:51:03,450
So you can remove an element at a specified index using the command DDL.

384
00:51:05,940 --> 00:51:09,620
So the way you can do that is incomplete lists, name and index.

385
00:51:10,380 --> 00:51:13,530
So that removes the elements. Index.

386
00:51:13,530 --> 00:51:23,410
Index. Okay. And then the main difference between this and pop method is that running it doesn't return anything.

387
00:51:23,590 --> 00:51:29,280
Doesn't return about the value of the component that was needed.

388
00:51:30,420 --> 00:51:37,380
So if I run this thing, if I run this code, this should be blue.

389
00:51:38,220 --> 00:51:43,200
Delete the string blue from the color list and should delete it.

390
00:51:43,200 --> 00:51:46,530
But it doesn't. It doesn't return the string.

391
00:51:47,590 --> 00:51:50,820
This. It just. It just deletes.

392
00:51:51,090 --> 00:51:55,800
Okay. So that's just one alternative to pop.

393
00:52:01,890 --> 00:52:08,910
Okay. So the pop pop method and the delete are all there.

394
00:52:10,020 --> 00:52:15,510
They remove something by having you provide like an index number.

395
00:52:16,200 --> 00:52:21,570
In many cases you want to remove the value of something.

396
00:52:22,350 --> 00:52:29,640
You want to get the best way to say it. You want to remove all of the elements that have a certain about nothingness.

397
00:52:30,120 --> 00:52:38,910
You don't really know the way. Don't write the code to look up the index of that value.

398
00:52:39,750 --> 00:52:42,870
So for that type of case, you can use the remove method.

399
00:52:43,440 --> 00:52:47,100
So let's say we had this string or this list called color list.

400
00:52:49,050 --> 00:52:57,120
I just want to remove the the element that has that says green, I don't have to know the index number of three.

401
00:52:57,510 --> 00:53:00,510
Okay. So the way you can do that is with the remove method.

402
00:53:01,080 --> 00:53:05,580
Let me just do color list, remove and give it the string name green.

403
00:53:06,210 --> 00:53:10,110
You automatically remove green from this.

404
00:53:12,150 --> 00:53:24,540
I guess the thing to keep in mind about this is that is that if you have had a multiple of values of the same thing

405
00:53:24,540 --> 00:53:33,450
in the list and it only removes the first kind of the first first held the first element where there's a match.

406
00:53:34,110 --> 00:53:39,780
So I think if you look at this color list two and this has green repeated twice.

407
00:53:41,190 --> 00:53:49,740
So when I do this, when I run the remove method giving it green, it only removes the first time green features.

408
00:53:50,370 --> 00:54:04,320
Okay. So not only removes for the first time, it reappears, but you can see here that the second second green is still there after after running this.

409
00:54:04,750 --> 00:54:12,650
So that's just something to keep in mind. It's not going to remove all the places that green occurs.

410
00:54:17,510 --> 00:54:28,370
So. All right. So now we'll go. Those are kind of the main met some of the main methods for kind of manipulating list a little bit.

411
00:54:29,390 --> 00:54:33,170
Now I used to do some talk about a different operations with lists.

412
00:54:34,130 --> 00:54:42,410
So one thing that might be useful when you're working with LIST is this Boolean operator.

413
00:54:42,410 --> 00:54:49,310
And it just it's basically just telling you whether or not a certain item belongs to the list or not.

414
00:54:50,270 --> 00:54:53,900
So it can be useful if you have kind of a very long list.

415
00:54:55,070 --> 00:55:00,320
So you can see that here in this example, I have a color list with a bunch of different strings.

416
00:55:02,270 --> 00:55:06,920
You can just test whether or not certain strings are elements of that list by using it or not.

417
00:55:07,640 --> 00:55:16,940
So again, this is probably more useful if you have very super long lists and you want to just check if if something is an element on that list,

418
00:55:18,260 --> 00:55:22,760
you can just use again. All right. And I'll return a true or false event.

419
00:55:23,070 --> 00:55:34,309
If I want to test if the string brown is in this list, I can just do a round in the name of the list and that I'll return either true or false.

420
00:55:34,310 --> 00:55:38,480
So in this case, it's false. So the list Brown does not belong.

421
00:55:41,750 --> 00:55:52,340
On the other hand, in a blue in color list that returns true since blue is a string that is a component of this list.

422
00:55:56,630 --> 00:56:04,570
Here's another example I can just do. I can look at three in this list that should return, true or false.

423
00:56:04,610 --> 00:56:07,760
So three is actually an element of this list.

424
00:56:08,470 --> 00:56:12,380
It's in this position here and the next to.

425
00:56:12,830 --> 00:56:18,860
So it should return. True. So this you run this code that should return and should return.

426
00:56:18,860 --> 00:56:28,760
True, isn't it? Okay, so here's I'm just listing out useful things that you should know or that are useful to know.

427
00:56:30,080 --> 00:56:40,230
If your list is all numbers you can do with things like some max and men like that.

428
00:56:40,250 --> 00:56:43,460
So I will return to some of the elements of the list.

429
00:56:45,020 --> 00:56:50,000
Max will return the maximum number that lists mean the same things.

430
00:56:50,270 --> 00:56:57,350
And then at the end, when a function gives you the length of a list, it's just how many components are in that list.

431
00:56:57,360 --> 00:57:03,350
So here we have one, two, three, four components of the length of the list is four.

432
00:57:03,470 --> 00:57:08,090
So you can see here, Len number list returns for okay.

433
00:57:09,020 --> 00:57:18,320
So at least if you have all numbers that are you can compute these some of these basic summaries of the numbers of that list and this.

434
00:57:20,410 --> 00:57:32,110
Okay. So here's. Something that's that's you need to know if you if you have to list and you add them.

435
00:57:33,200 --> 00:57:41,180
And even if they're all numbers, it still does kind of concatenation the same ways, same way that strings work.

436
00:57:41,230 --> 00:57:47,590
So if you have this list one, two, three and four or five, six, one, two, six, four, five, six.

437
00:57:47,590 --> 00:57:51,400
If I add those two lists, it just creates a bigger list.

438
00:57:52,000 --> 00:57:53,380
One, two, three, four, five, six.

439
00:57:53,440 --> 00:58:07,540
So just adds the second list to the to the first mistake and kind of appends the elements from the second list on at the end of the first list.

440
00:58:10,690 --> 00:58:16,780
And if you do multiplication by a list by an integer, so it should be an integer.

441
00:58:17,350 --> 00:58:25,479
It's just and this so for example, if you multiply by two, that's just basically the same thing as adding the list with itself.

442
00:58:25,480 --> 00:58:37,660
So it just kind of repeats the list twice or if you multiply it by three, that's just adding it with itself three or two more times.

443
00:58:37,660 --> 00:58:41,469
So it's basically just repeats the list three times.

444
00:58:41,470 --> 00:58:50,140
So you can see that here. If we have this list, one, two, three, and then we multiply it by two, that's going to be the list.

445
00:58:50,140 --> 00:58:57,610
One, two, three, one, two, three. If we have the list for five, six, we multiply that by three.

446
00:58:57,610 --> 00:59:02,980
It just repeats that pass three times. So it's four, five, six, four, five, six, four, five, six.

447
00:59:04,980 --> 00:59:14,790
So I guess the thing I want to point out, I wanted to point out, I mean, these two kind of look like vectors in a sense,

448
00:59:18,990 --> 00:59:24,960
at least if you have all numbers, however, doing kind of multiplication or addition.

449
00:59:25,980 --> 00:59:32,850
It doesn't work like you might expect, at least if you're thinking of doing operations that you might do like.

450
00:59:35,730 --> 00:59:47,309
My work the same way it is linear algebra. Like if you had two vectors, it just adds another factor at the same time that has an individual component.

451
00:59:47,310 --> 00:59:58,360
So addition or multiplication of lists, even if they're numeric, doesn't work like that in Python.

452
00:59:58,380 --> 01:00:07,290
So. So basically for for for those types of things,

453
01:00:07,290 --> 01:00:23,010
it's better to use arrays with numpy that kind of has the behavior that you would more expect for doing kind of computations that make sense,

454
01:00:23,340 --> 01:00:29,550
you know, I guess in the linear algebra sense. So we're going to talk about that I guess probably next week.

455
01:00:31,320 --> 01:00:39,120
So doing arrays with obvious is what we want to use for those for those types of calculations.

456
01:00:39,750 --> 01:00:51,389
I mean, you could in principle do that with lists, by the way, forcing it to do it by writing code loops and things.

457
01:00:51,390 --> 01:01:03,300
But if you just want kind of just want to do vector addition in an easy way with just like having a plus B and so forth.

458
01:01:03,840 --> 01:01:08,370
I really, really want to use arrays with NumPy instead.

459
01:01:09,210 --> 01:01:12,390
So that's just something to keep in mind that, you know,

460
01:01:12,780 --> 01:01:23,580
if you're expecting list or kind of the math to do with list to work in the same ways as numeric vectors, it's it doesn't work in the exact same way.

461
01:01:24,210 --> 01:01:28,380
Okay. All right. So here is this.

462
01:01:29,810 --> 01:01:38,190
Oh, here's something about accessing multiple elements from a list.

463
01:01:38,190 --> 01:01:47,400
So this kind of syntax is similar to accessing multiple elements from a vector in a, but in Python, they call it slicing.

464
01:01:50,130 --> 01:01:55,770
So slicing is just a way to access multiple elements from a from a list.

465
01:01:56,700 --> 01:02:00,390
So the kind of syntax from that for that is using a colon.

466
01:02:01,020 --> 01:02:08,339
So if I want to access the elements of a list from a, a starting index,

467
01:02:08,340 --> 01:02:19,430
I just do the list name and then start as like the starting index and then I have a colon and then I extract all the elements up to end.

468
01:02:19,470 --> 01:02:27,060
So the thing that I feel is a little bit weird, at least if you're coming from R,

469
01:02:27,060 --> 01:02:36,660
is that you only access all of the elements up to end, to end, but not including.

470
01:02:36,670 --> 01:02:47,250
And okay, so if you go from like zero colon to that only extracts the elements zero and one, it doesn't go all the way up to two.

471
01:02:48,030 --> 01:02:55,889
Or if you do, if you go one code for that only extracts the elements with index one, two, three.

472
01:02:55,890 --> 01:03:03,060
It doesn't kind of extract all the way up to four because it's like the largest integer strictly less than anything.

473
01:03:03,610 --> 01:03:09,080
So it's just something that I don't know.

474
01:03:09,090 --> 01:03:15,410
It's something to keep in mind. I mean, it may or may not feel unnatural to you when you do it, but.

475
01:03:17,400 --> 01:03:24,550
That's that's the way Python works. So here's some other things you could do with slicing.

476
01:03:24,570 --> 01:03:31,830
If you just have a a colon with nothing after it, that just goes all the way to the end of the list, basically.

477
01:03:31,840 --> 01:03:35,220
So if I do start it, let's say five.

478
01:03:36,240 --> 01:03:41,250
It'll extract all the elements, starting from index five all the way to the end of the list.

479
01:03:41,790 --> 01:03:44,970
So that's what this colon with nothing after it means.

480
01:03:46,140 --> 01:03:57,900
Kind of on the flip side, if you do the colon with nothing before it basically starts from the beginning of the listing that goes up,

481
01:03:57,900 --> 01:04:02,870
taking out basically everything up to and it doesn't include the index.

482
01:04:03,990 --> 01:04:13,649
Okay. So that's kind of what the syntax means when you have either nothing after a colon or nothing before a kind of either either

483
01:04:13,650 --> 01:04:19,230
goes all the way to the end of the list or it starts from the beginning of the list and goes up to a stopping point.

484
01:04:23,920 --> 01:04:27,490
So slicing can be used if you just run this code.

485
01:04:28,240 --> 01:04:34,560
It basically extracts elements. If you run something like this, it extracts certain elements of the list.

486
01:04:34,630 --> 01:04:38,800
You can also reassign multiple elements on a list using slicing.

487
01:04:39,460 --> 01:04:47,950
If you have if you use this but you have equal sign and you assign if you have something to the right of the equals sign,

488
01:04:47,960 --> 01:05:02,680
and we assign the values to all of these all of those multiple values in the list specified by this this indexing.

489
01:05:02,920 --> 01:05:07,209
Okay. So that's kind of a description of slicing.

490
01:05:07,210 --> 01:05:12,070
I think probably some some examples probably make it more clear.

491
01:05:12,580 --> 01:05:15,580
So here's an example.

492
01:05:15,580 --> 01:05:20,110
We have a list with this.

493
01:05:20,110 --> 01:05:25,750
When we first define it, it has one, two, three or five components.

494
01:05:26,890 --> 01:05:28,090
It has five components.

495
01:05:28,090 --> 01:05:41,379
So if we want to extract elements, index zero and one using kind of the slicing syntax, we can do zero column see that extracts that.

496
01:05:41,380 --> 01:05:48,070
So we can see that here. The first thing that's printed you just add should remember we a zero colon two it

497
01:05:48,070 --> 01:05:54,890
doesn't it doesn't extract the element with index to just a01 because everything listed.

498
01:05:56,600 --> 01:06:04,750
So the second example, we have 1 to 4. So that's going to extract the elements index one, two, three, not including.

499
01:06:05,050 --> 01:06:11,320
So one, two, three is this orange peach pair. So you can see that here, this one here.

500
01:06:13,720 --> 01:06:17,310
In the third case, we have to call in with nothing after the colon.

501
01:06:18,310 --> 01:06:24,890
That should start at the index two, which is peach, and then it'll extract everything.

502
01:06:25,750 --> 01:06:30,579
So that's peach, pear, banana. See that here?

503
01:06:30,580 --> 01:06:36,250
Peach, pear, banana. And then kind of the last example, we had nothing before the colon,

504
01:06:36,760 --> 01:06:46,719
so that should start at the beginning of the list and then go up to everything before index three.

505
01:06:46,720 --> 01:06:56,960
So it's not going in. So it should go, it should extract the element 012 so that should be, as should be apple and peach.

506
01:06:56,980 --> 01:07:03,550
And you can see that here in the last example, it extracts only the elements apple, orange, peach.

507
01:07:06,730 --> 01:07:17,830
Okay. Okay. So here's just an example of not just extracting elements of a list using slicing, but assigning new values on a list.

508
01:07:17,890 --> 01:07:34,120
So if we want to assign the elements an index one and two, you can use this notation fruit list one, tolerance three, and then you can assign,

509
01:07:34,930 --> 01:07:43,300
assign a list to kind of the the length of this list should match kind of the number of items that it should replace.

510
01:07:43,930 --> 01:07:51,280
So here, this notation means that we're we're looking at two items from the list.

511
01:07:51,280 --> 01:07:58,360
So the length of the list that we're reassigning, those values should be equal to one.

512
01:07:58,990 --> 01:08:06,350
So you can see here, after we run this, the strings at position one into our difference.

513
01:08:06,350 --> 01:08:13,390
So originally we had orange and peach and now after running this code, it's grapes and kiwi.

514
01:08:14,080 --> 01:08:22,420
But if you just want to change the first two elements of the list, you can just call it two.

515
01:08:23,110 --> 01:08:27,069
That's going to change. Just this looks at the first two elements of the list, right?

516
01:08:27,070 --> 01:08:34,450
So so that position is zero and one and not actually two, but that's basically the first the first two elements of the list.

517
01:08:35,110 --> 01:08:45,910
So I can reassign that also with a list of length two, since this is continue to suggest we're extracting two of two components.

518
01:08:46,240 --> 01:08:54,280
So after running this one, before running this, the first two components were apple and grapes.

519
01:08:55,270 --> 01:09:01,240
And then after running this code, it's now one of the pineapples.

520
01:09:02,530 --> 01:09:13,630
So that's how you can be assigned multiple elements of the list of a list at the same time using this kind of slicing, slicing syntax.

521
01:09:19,140 --> 01:09:31,110
So let's see. Maybe this was just he's throwing in a question to kind of answer this question.

522
01:09:35,990 --> 01:09:40,520
Shows that you kind of remember everything that we've been talking about.

523
01:09:40,520 --> 01:09:44,390
So let's say we run the following python code.

524
01:09:45,330 --> 01:09:50,040
What is this going to turn out? So we first define this fruit list.

525
01:09:50,060 --> 01:10:05,270
Apple, banana, orange. After we do insert and position one as the lost feature, it's going to be apple, peach, banana or orange.

526
01:10:05,270 --> 01:10:14,810
Right? So it's basically inserting peach acquisition one and then kind of everything banana and orange will to the right.

527
01:10:15,560 --> 01:10:23,870
So after running this line of code, the list should be apple, banana white, apple, peach, banana, orange.

528
01:10:24,590 --> 01:10:29,070
Okay. And then we run this code.

529
01:10:29,750 --> 01:10:41,180
It's basically going to just add, oh, it's going to add pineapple to the end of the list.

530
01:10:41,960 --> 01:10:47,870
Okay. So it should be apple, peach, banana, orange pineapple.

531
01:10:48,950 --> 01:10:54,950
So what is this code? It's going to print out those at index one, two and three.

532
01:10:55,880 --> 01:11:00,050
So we had apple, peach, lemon, orange, pineapple.

533
01:11:01,700 --> 01:11:09,050
So should pronounced peach banana distinction.

534
01:11:09,310 --> 01:11:12,680
I'm pretty sure it's pronounced prince.

535
01:11:12,830 --> 01:11:18,200
Sorry. Should pronounce a peach. Banana orange should pronounced that as a list.

536
01:11:22,220 --> 01:11:27,830
Really makes sense. Peach.

537
01:11:29,050 --> 01:11:35,840
And that was that's about it.

538
01:11:35,860 --> 01:11:41,110
Let me just mention to you, I think we're basically out of time anyway.

539
01:11:41,450 --> 01:11:47,500
A few minutes left, I mentioned of two last useful methods to know.

540
01:11:48,310 --> 01:11:59,350
So what? We want to find the location that matches a certain or tone of matches a certain value that you're interested in for that type of thing.

541
01:11:59,470 --> 01:12:03,010
You can use the index method is how you do it.

542
01:12:06,910 --> 01:12:09,670
So you can see an example here.

543
01:12:09,670 --> 01:12:20,020
If we have a color list, this list of strings, if I just want to find out the position where the string green is located,

544
01:12:20,470 --> 01:12:27,230
I can just do the name of the list stock index. So this just tells me that it's it's an index, too.

545
01:12:27,750 --> 01:12:39,370
Okay. Also, if you have run it with purple index, this is just telling me that purple is located at the index.

546
01:12:40,360 --> 01:12:44,499
And again, this is more useful if you have a really long list or a target and you just

547
01:12:44,500 --> 01:12:50,020
want to quickly look up maybe the position where a certain value is located.

548
01:12:51,550 --> 01:12:54,250
And if the only thing to keep in mind about this index,

549
01:12:54,250 --> 01:13:09,290
this is kind of similar to some of the other methods in Python is that it only looks at the first occurrence if you have duplicates.

550
01:13:09,290 --> 01:13:15,670
So if we have if we have this list here where a certain number is repeated more than once,

551
01:13:16,300 --> 01:13:28,210
if I do provide the index with this number that's repeated, it's only going to give us the index the first time it occurs.

552
01:13:29,260 --> 01:13:36,700
So it doesn't print out all of the index and all of the indices where it's located just only prints out a single index,

553
01:13:36,700 --> 01:13:39,750
and that's kind of the index of the first match.

554
01:13:40,240 --> 01:13:49,510
Okay. So it's just something, again, to keep in mind, if you're looking up a value, it potentially has a lot of duplicates.

555
01:13:49,990 --> 01:13:53,320
It's only going to return the first the first matching index.

556
01:13:55,270 --> 01:14:03,760
So here, here's just another useful thing. I kind of like a large python, but I don't think are if it's not as nicely implemented,

557
01:14:05,290 --> 01:14:15,170
it's just a sort of method you can kind of easily sort of list just by by running the method dot sort,

558
01:14:15,190 --> 01:14:17,890
you then have to kind of reassign it to anything.

559
01:14:18,670 --> 01:14:30,129
You could see an example here, if I defined this variable number list, if I just want to rearrange the list of I sort it from lower to high,

560
01:14:30,130 --> 01:14:37,450
for example, I just have to run the line number list that's sort of open and close parentheses.

561
01:14:38,050 --> 01:14:43,900
And then now the number of lists, the number listed, the kind of the list is actually changed.

562
01:14:44,320 --> 01:14:48,370
I mean, it has the same elements, but now it's sorted from low to high.

563
01:14:50,320 --> 01:14:57,710
You know, by by default, it goes from low to high. If you want it to go from high to low, all you have to do is give it this argument.

564
01:14:58,840 --> 01:15:04,540
Reverse equals true. So if you don't do that, anything goes from low to high.

565
01:15:04,540 --> 01:15:15,129
If you want to say, I can't do this, I know you just gave the argument reverse equals true now, so that from high to low.

566
01:15:15,130 --> 01:15:19,230
So that's the timing.

567
01:15:19,390 --> 01:15:31,030
So I believe it's all ahead anyway for today's list. That wraps up mostly this case the next time I go to both sets and dictionaries.

568
01:15:34,390 --> 01:15:48,640
After that news conference, you know what it is.

569
01:15:49,580 --> 01:15:51,080
So I'm.

