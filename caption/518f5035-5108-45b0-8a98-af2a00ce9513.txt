1
00:00:08,950 --> 00:00:12,370
Okay. Sorry for the delay today.

2
00:00:13,330 --> 00:00:18,610
You know, let's get started. So a couple of announcements.

3
00:00:18,940 --> 00:00:24,580
So I have posted a.

4
00:00:27,540 --> 00:00:31,020
These examples.

5
00:00:31,290 --> 00:00:39,200
Okay. So you can see the example proposals from the the previous years.

6
00:00:39,220 --> 00:00:44,070
So a positive example. Those are those are good proposals.

7
00:00:44,070 --> 00:00:55,260
So if you see them as in terms of formats and contents, that will be helpful to come up with your own proposal.

8
00:00:56,300 --> 00:00:59,580
So yeah, that's that's one thing.

9
00:01:00,390 --> 00:01:03,629
As you know, homework three is posted.

10
00:01:03,630 --> 00:01:07,860
If you have any question with the homework three, please let me know.

11
00:01:08,910 --> 00:01:12,840
In this time there's a three problems.

12
00:01:12,840 --> 00:01:18,600
And I think, you know, this first matrix in the interpolation part,

13
00:01:19,110 --> 00:01:28,830
I believe that you should be able to solve this, but if you have any questions, feel free to let me know.

14
00:01:30,930 --> 00:01:36,120
Okay. So any any other questions?

15
00:01:42,810 --> 00:01:45,930
So it's not. Okay.

16
00:01:54,710 --> 00:02:01,540
Okay. So. Today.

17
00:02:01,540 --> 00:02:06,610
Today's office hours. I'll start at ten.

18
00:02:07,120 --> 00:02:13,030
Okay. So I have something to do in 10 minutes, so I will start at ten.

19
00:02:13,420 --> 00:02:23,440
You know, you can come to my office in my offices a lot, so I'll make sure that those are those are open at ten.

20
00:02:23,680 --> 00:02:28,090
Okay. Okay. So that's.

21
00:02:28,420 --> 00:02:38,400
That's all I have. Okay. Uh, I, uh, I updated this, but I actually didn't do that yet.

22
00:02:38,440 --> 00:02:45,280
But I've also the corrected version of slides so that you don't have a, uh,

23
00:02:46,270 --> 00:02:52,000
you don't have confusion with this particular field, which had had a problem before.

24
00:02:53,530 --> 00:03:06,190
Okay. So, so we, we, uh, talked about these, uh, golden search algorithm.

25
00:03:07,000 --> 00:03:13,870
Okay. So, uh, so basically the this is a key slide.

26
00:03:14,260 --> 00:03:20,590
Okay. So the coding search algorithm does not.

27
00:03:23,740 --> 00:03:34,030
So is not depend on does not depend on the how the function looks like the performance is all the same regardless of the how the function looks like.

28
00:03:34,690 --> 00:03:42,010
That's one benefit. The other benefit is that you don't have to have the derivative of the function.

29
00:03:42,130 --> 00:03:46,120
So it's a third of the revision of the revision free algorithm.

30
00:03:46,570 --> 00:03:50,670
So that's another benefit benefit.

31
00:03:50,680 --> 00:03:59,860
And the way how this golden certainty algorithm is working is very similar to the binary search.

32
00:04:00,520 --> 00:04:04,640
But in binary search you have a single interval.

33
00:04:05,050 --> 00:04:13,060
So it's a, it's a very straightforward to find the midpoint and the find find another meta point and so on.

34
00:04:13,090 --> 00:04:17,770
So that's that's how it works in the problem minimization.

35
00:04:18,220 --> 00:04:21,730
You always you always have to keep track of these three points.

36
00:04:22,300 --> 00:04:30,400
So while you are keeping track of three points, you need to get rid of one point in the next iteration.

37
00:04:30,940 --> 00:04:38,260
You need to get rid of one point and of find the find the new three points.

38
00:04:38,530 --> 00:04:46,360
So how do you do that? So that's the basically be basically the decision point.

39
00:04:47,620 --> 00:04:51,070
And here you start with a, B, C. Okay.

40
00:04:51,730 --> 00:04:55,690
So B F will be the smaller than F of A and F of a C.

41
00:04:56,560 --> 00:05:03,970
And if you if you choose an X where so where these ratio.

42
00:05:04,300 --> 00:05:13,650
So when you have ABC first, let's assume that this ratio is 0.3381996 in the well.

43
00:05:14,340 --> 00:05:22,110
We'll see. So except for the first first iteration, you can ensure that this ratio is always the same in the.

44
00:05:22,290 --> 00:05:33,220
Well, I'm going to I'm going to get to that part. But once you have so you have this ratio between the A and B compared to the.

45
00:05:33,370 --> 00:05:37,750
So this is 38% of A the full interval.

46
00:05:38,410 --> 00:05:52,450
And if you if you select the new point to be 38% from the other side, and if you pick this point, then you're in the your next iteration,

47
00:05:53,560 --> 00:06:04,600
depending on the what the value of F of X becomes, the next next iteration interval will be either the A to X or B to C.

48
00:06:04,710 --> 00:06:12,340
Okay. So those are ab x or three point or P 03. depending on the F of x is greater than F for B or not.

49
00:06:13,450 --> 00:06:27,410
So then in the next iteration, you still have the same guarantee that this is a 38% of the full interval, no matter which part is selected.

50
00:06:27,430 --> 00:06:31,060
So that's that's how you started with to works.

51
00:06:31,420 --> 00:06:36,680
And how how was this 38% was selected.

52
00:06:36,680 --> 00:06:41,140
And that that's that's the part that requires the math here.

53
00:06:41,560 --> 00:06:50,350
So you have a two criteria here. So when I selected, I want to make sure that in the protein tables.

54
00:06:50,500 --> 00:06:59,200
So because we don't know whether a2x will be selected or B to B to C will be selected,

55
00:07:00,790 --> 00:07:04,930
we're going to make sure that those two in cable has exactly the same size.

56
00:07:05,020 --> 00:07:13,690
So that's one criteria. And and second criteria is that there was a small so you selected three points.

57
00:07:13,700 --> 00:07:17,079
So if you calculate the ratio of the small smaller,

58
00:07:17,080 --> 00:07:25,570
so eight to be compared to eight to see those should be always the same ratio across all the iteration.

59
00:07:26,530 --> 00:07:35,500
So if you use those two criteria, you're going to have the these ratio W is the proportion of those eight.

60
00:07:35,620 --> 00:07:40,839
So AB divided by eight C is roughly 38%.

61
00:07:40,840 --> 00:07:50,799
And this is called the golden ratio. So, so that's, uh, that's the key part of the discord.

62
00:07:50,800 --> 00:07:59,500
The search and go the search ability you see is the bracketing about 30%, about 40% of the evaluation.

63
00:07:59,500 --> 00:08:02,680
So the performance is independent of the function.

64
00:08:03,280 --> 00:08:07,480
So this is similar to the binary.

65
00:08:07,810 --> 00:08:15,970
So the basic algorithm in many ways, but this is a working for minimization problem.

66
00:08:17,890 --> 00:08:21,910
So that's what we did before. And.

67
00:08:22,020 --> 00:08:27,000
We went through the the code a little bit and didn't.

68
00:08:27,360 --> 00:08:33,480
So I you it read a little bit. So I just wanted to make sure that we were on the same page.

69
00:08:35,550 --> 00:08:38,730
So. So to.

70
00:08:38,730 --> 00:08:42,240
To do that. Uh, so.

71
00:08:42,380 --> 00:08:44,940
So these. These are the algorithms. Okay.

72
00:08:45,570 --> 00:08:59,280
So the discordance that is basically, uh, the, the procedure to select X, you have A and B and C and the where to find the ex.

73
00:08:59,370 --> 00:09:03,810
Okay. So this XY finding X is a very simple.

74
00:09:03,820 --> 00:09:06,960
So I have a discordant ratio, 38% roughly.

75
00:09:06,990 --> 00:09:12,750
Right. So then let's find the midpoint and length.

76
00:09:13,530 --> 00:09:18,960
So if the P is greater than midpoint, that means that, uh, a.

77
00:09:20,790 --> 00:09:28,380
So if that happens, then you have a and, uh, a a and C here.

78
00:09:29,280 --> 00:09:33,430
And, uh, this is a midpoint and B is located here.

79
00:09:33,450 --> 00:09:38,700
So this means that these are 38%, roughly, that you will you want to select X here.

80
00:09:39,000 --> 00:09:45,810
Okay. So, uh, so I'm selecting the X, so x to be.

81
00:09:46,050 --> 00:09:50,640
Okay, golden ratio. So if this is a coded step, so how much?

82
00:09:52,320 --> 00:10:03,990
How much a step? I need to go. So, uh, so a, you know, minus B, you know, will be negative, right?

83
00:10:04,620 --> 00:10:10,410
So, uh, 38% of these.

84
00:10:10,780 --> 00:10:19,970
Uh, so you're just making, making a 30, 30% of these steps, including going backward from, from the B.

85
00:10:20,220 --> 00:10:23,420
So is it this is 30% of.

86
00:10:23,490 --> 00:10:29,660
So. So this is.

87
00:10:29,930 --> 00:10:38,020
This is. This is a love letter to you.

88
00:10:38,440 --> 00:10:50,980
38% of AC write and that this is the lovely 30% of AC and this becomes 38 per 0.38 times 0.38 times.

89
00:10:51,670 --> 00:11:01,560
AC Okay. Or equivalently, this is a 0.38 of a B or 0.38 of the ecstasy.

90
00:11:01,570 --> 00:11:05,470
So that's, that's the, that's how the golden ratio works.

91
00:11:07,210 --> 00:11:14,730
So you just going to go back, you want to go backward from B, so this value will be negative, okay?

92
00:11:15,430 --> 00:11:18,850
And so this value, this value will be negative.

93
00:11:19,510 --> 00:11:27,640
Otherwise you e, otherwise you have A and B and C here.

94
00:11:27,700 --> 00:11:35,860
So if you want to select the X somewhere here, so you want to have positive in a about about this much.

95
00:11:36,100 --> 00:11:40,479
Okay. So that's, that's the delta you want it to go from.

96
00:11:40,480 --> 00:11:49,510
B Okay. So that's the goal this step. So you use this code in step here so that you add.

97
00:11:53,190 --> 00:11:59,340
And add or subtract certain amount from the zero to find the next point.

98
00:11:59,700 --> 00:12:11,670
So this this is the X and after after that you need to evaluate F of x and depending on the if F of x is a smaller than F of B or not.

99
00:12:12,000 --> 00:12:21,030
You make a different decision. If F of x is a smaller than F will be, then so f of x is x is a new minimum.

100
00:12:21,030 --> 00:12:33,810
So I make a triple triplet using x as the midpoint, which means that then I need to go between the eight and a, a and B, right?

101
00:12:34,050 --> 00:12:41,340
So, so next. Next, so.

102
00:12:43,470 --> 00:12:51,750
Okay, so, so if f f f a f of x is new minimum, then my new interval.

103
00:12:51,990 --> 00:12:56,340
Okay, so let's, let's, let's think about these two cases.

104
00:12:56,760 --> 00:13:00,570
So give x axis new, new minimum here.

105
00:13:01,080 --> 00:13:09,540
Okay then the next interval is A to B if x is in the interval.

106
00:13:10,410 --> 00:13:17,580
So it is a new minimum. In this case, due interval is a B to C, right?

107
00:13:18,030 --> 00:13:21,480
So this is what is trying to do. If X is greater than B drop.

108
00:13:22,020 --> 00:13:27,060
If in this case my new A zero will be b zero.

109
00:13:27,450 --> 00:13:36,090
My new new. So my new a new my my new new interval start from B okay.

110
00:13:36,720 --> 00:13:40,360
Otherwise my new interval okay.

111
00:13:41,940 --> 00:13:46,890
So ends. So my new interval ends at B, so that's what it says.

112
00:13:47,100 --> 00:13:54,659
Okay. So, and the in this case, the start of the start of the interval didn't change.

113
00:13:54,660 --> 00:13:59,250
So you don't need to update a in this case and the interval doesn't change.

114
00:13:59,260 --> 00:14:07,530
So you need to, you don't need to update the C, so you're just not updating either A or C in this particular case.

115
00:14:08,250 --> 00:14:13,710
And you also need to state to be, which is a new minimum and update to F of B as well.

116
00:14:22,980 --> 00:14:35,210
So let me let me. Sorry.

117
00:14:36,050 --> 00:14:44,930
Sorry for the voice problem. Okay. Otherwise, this means that bees are still my new M.O.

118
00:14:45,320 --> 00:14:57,260
So that means that my if a bees be still due, minimum is still still the minimum, and my new interval will be an x8x or x to see.

119
00:14:57,260 --> 00:15:08,750
Right. So. So in this case, if X sees this as X is less than B, in this case, my new interval is x to ecstasy.

120
00:15:09,260 --> 00:15:13,070
That means that I need to update to a2x.

121
00:15:13,670 --> 00:15:20,270
If this was the case, I need to update the mine to new interval to end.

122
00:15:20,270 --> 00:15:23,330
And this c. So my new C is X.

123
00:15:23,450 --> 00:15:24,649
So that's that's how it works.

124
00:15:24,650 --> 00:15:36,200
So this these two may look a little bit confusing, but it's trying to update the minimum amount of information in the avoid redundant assignment.

125
00:15:38,360 --> 00:15:48,589
So is this part. Okay. So if if you if you try to narrow these both cases and try to enumerate all possible cases,

126
00:15:48,590 --> 00:15:53,510
these are these you will realize this method is exactly doing what it's supposed to do.

127
00:15:54,800 --> 00:16:01,730
And after that, you update the number of iteration and check whether they converge.

128
00:16:01,850 --> 00:16:06,350
So convergence is checked by just side of interval. If the size of the interval is.

129
00:16:10,000 --> 00:16:15,930
Smaller. Sorry. Okay.

130
00:16:16,070 --> 00:16:22,570
So side of interval is smaller than the smaller than the tolerance level.

131
00:16:22,600 --> 00:16:29,440
So then you you say this is convergent and you break the loop.

132
00:16:30,010 --> 00:16:43,300
Otherwise keep doing this. So there is no real risk that this is going to be the going to be actually not converge.

133
00:16:43,750 --> 00:16:52,780
But in a very, very rare cases, if the number of max iteration is not large enough, this may go out of the loop.

134
00:16:52,780 --> 00:16:57,160
And in the case, convergence will be one. So and this will.

135
00:16:57,520 --> 00:17:07,239
So at the end, what you want to know is that your minimum value of so minimal is an x value will be be zero in the

136
00:17:07,240 --> 00:17:14,830
objective function F of F of minimum is a four be in return convergence in number of iterations.

137
00:17:14,830 --> 00:17:19,080
And that's what the holding search algorithm is working.

138
00:17:20,980 --> 00:17:31,460
Okay. So let's see whether this works.

139
00:17:33,810 --> 00:17:37,920
So you you. You have this function here.

140
00:17:38,740 --> 00:17:46,980
And if you. Look at this function and see what the minimum looks like.

141
00:17:47,350 --> 00:17:52,920
Okay. So this minimum is reached at the 43rd iteration.

142
00:17:54,870 --> 00:17:58,500
So in this case, the total tolerances are ten to the minus eight.

143
00:17:58,920 --> 00:18:05,650
So if you think about this, I gave that what is the initial interval I gave?

144
00:18:05,670 --> 00:18:10,440
I started with a zero negative five p0001.

145
00:18:10,440 --> 00:18:20,610
So my initial recovery stages were five and each of the time in the interval reduces by by roughly 40%.

146
00:18:21,240 --> 00:18:25,930
So if so, that means that the it.

147
00:18:26,790 --> 00:18:32,820
So if you calculate this so it's a 0.62 roughly, right?

148
00:18:32,830 --> 00:18:37,550
So five times 0.62 to how how.

149
00:18:38,010 --> 00:18:48,540
So 43 iteration. If you try this, this number of iteration, the interval size becomes a lovely five, six, six times, ten times nine,

150
00:18:48,540 --> 00:18:55,020
which is barely the the smaller than the ten to the minus eight, which is the tolerance threshold.

151
00:18:55,030 --> 00:19:09,690
So that's why it is stopped at the 43/43 iterations and it gave a relatively reasonable value for that for the minimum to find a minimum.

152
00:19:11,340 --> 00:19:15,320
Any questions so far? Okay.

153
00:19:17,560 --> 00:19:21,360
Okay. So. Okay.

154
00:19:23,160 --> 00:19:27,000
Let me move on to the for the next thing.

155
00:19:27,180 --> 00:19:32,610
Okay. So so for the search, what is the convergence rate?

156
00:19:33,660 --> 00:19:38,390
So does it linearly converge or quadratic converge or how?

157
00:19:38,550 --> 00:19:43,410
What do you think? Raise your hand if you think it linearly.

158
00:19:43,410 --> 00:19:50,970
Converge. If you think it's a quadratic converge.

159
00:19:54,860 --> 00:19:59,540
Uh, looks like, uh, those are those are not clear to you.

160
00:19:59,910 --> 00:20:03,930
Okay, so how how do you define the convergence?

161
00:20:04,220 --> 00:20:07,570
The weather? Weather, this convergence? What is the convergence rate?

162
00:20:07,580 --> 00:20:13,309
So it's here. So linear they converge.

163
00:20:13,310 --> 00:20:16,670
It means that the PE equal one. Quadratic converge.

164
00:20:16,970 --> 00:20:20,020
Quadratic quality converge. Typical to. Right.

165
00:20:20,030 --> 00:20:25,340
So, uh. So what do you think?

166
00:20:25,850 --> 00:20:44,360
What. What do you think the p p is? So in this case is lawfully I mean, and I support and I itself is not bound.

167
00:20:44,450 --> 00:20:53,360
So if you definitely place this to the just to be so C minor C in this case.

168
00:20:53,570 --> 00:20:59,240
So just the C and plus one that they need.

169
00:20:59,990 --> 00:21:03,889
So if you replace says the maximum bound of these, this is it.

170
00:21:03,890 --> 00:21:11,990
Which actually. Like This is so lovely.

171
00:21:12,230 --> 00:21:19,130
This is the menu. This is Olivia. So.

172
00:21:19,140 --> 00:21:22,550
Yeah. And an error rate is a radially converge.

173
00:21:23,240 --> 00:21:32,430
And the is constant is lovely in this case are not that 38%, one, one minus three and present.

174
00:21:32,450 --> 00:21:35,910
Right. So one, one minus two.

175
00:21:37,280 --> 00:21:40,520
Okay. So this is roughly 60, 62%.

176
00:21:40,940 --> 00:21:44,569
Okay. So this is order, order one convergence.

177
00:21:44,570 --> 00:21:48,220
Linear convergence. Okay.

178
00:21:53,680 --> 00:21:58,200
Okay. So then let's think about this.

179
00:21:58,210 --> 00:22:01,920
So, well, this is a linear conversion, which is which is good.

180
00:22:01,930 --> 00:22:11,620
There is a good guarantee. But 43 iterations may sound a little bit too much if you're impatient and think about that.

181
00:22:11,620 --> 00:22:20,140
So in bisexual algorithm, so in the route of finding out what to do with the file.

182
00:22:20,200 --> 00:22:33,940
So think about think about the root finding problem in root, the finding problem of we we looked at many,

183
00:22:35,020 --> 00:22:45,080
many different languages, but the one is the first thing we do, we, we look at this is a bisexual algorithm, right.

184
00:22:46,000 --> 00:22:49,690
In a in minimizing language. We looked at the code in search everybody.

185
00:22:50,740 --> 00:22:55,620
Okay. So both of them has a linear convergence.

186
00:22:55,860 --> 00:23:02,320
Okay. And what was the method?

187
00:23:02,340 --> 00:23:09,560
We tried next in the root finding language. So it worked.

188
00:23:09,610 --> 00:23:20,230
What one method would you try? So if the U.S. doesn't work very well, let's say you have one value here, one value here.

189
00:23:20,500 --> 00:23:27,430
And if you think that trying at the midpoint, this this might be silly, why would you do that?

190
00:23:28,210 --> 00:23:34,690
Instead, what you can do is that I am going to believe that this might be this might be linear, although,

191
00:23:35,050 --> 00:23:40,180
you know, there is no guarantee if you make a linear approximation, this would be the better point.

192
00:23:40,590 --> 00:23:50,469
Okay. So that's what the second method is actually doing in a little international algorithm is doing a similar thing.

193
00:23:50,470 --> 00:23:59,080
But I would do it. This method is is a trying to start from the single point.

194
00:23:59,080 --> 00:24:07,510
The second the method is starting from to point and try to find a find a point that that works.

195
00:24:07,510 --> 00:24:11,049
So if you use a second method if exactly.

196
00:24:11,050 --> 00:24:14,650
Use a linear interpolation. Right. So.

197
00:24:18,110 --> 00:24:21,209
So this is, you know, not quite quadratic.

198
00:24:21,210 --> 00:24:24,440
So almost. But it is a better than linear convergence.

199
00:24:24,440 --> 00:24:33,410
So if if the function is reasonably can reasonable close to linear function.

200
00:24:35,030 --> 00:24:39,590
So in the mean imagine that way you what can you do.

201
00:24:47,440 --> 00:24:50,980
You have three points here.

202
00:24:51,760 --> 00:25:00,700
You have evaluated this. Okay. Okay. So this is a four way be F of a C.

203
00:25:00,940 --> 00:25:08,950
Okay. Go to the search algorithm. Regardless of the how this looks like, you always are, you know, select something here.

204
00:25:09,100 --> 00:25:13,330
I don't want to look at the function function shape.

205
00:25:13,690 --> 00:25:17,589
I just wanted to look at the balance between the X intervals.

206
00:25:17,590 --> 00:25:25,160
And that's what this is trying to do. And but until you are 21, you.

207
00:25:25,180 --> 00:25:29,110
What can you do? Let's say your f of f may look like this.

208
00:25:29,860 --> 00:25:37,980
Or sometimes f f away. Oh, I don't know.

209
00:25:37,990 --> 00:25:41,900
So. Uh.

210
00:25:42,380 --> 00:25:48,740
Well, I mean, it's hard to visualize, but let's say.

211
00:25:49,490 --> 00:25:54,080
And sometimes I for way it looks like this probably looks like this purposely looks like this.

212
00:25:54,380 --> 00:26:02,210
So a lot of different things could happen. Right. So in this case, what would you try to do?

213
00:26:02,630 --> 00:26:07,610
If you are trying to make a best case, you have three points.

214
00:26:08,030 --> 00:26:10,370
So why don't we use a quadratic approximation?

215
00:26:11,000 --> 00:26:18,050
So let's assume, although there is no guarantee that this is a quantitative function, I'm going to assume that this is a positive function.

216
00:26:18,360 --> 00:26:25,130
So maybe more dramatic example would be F overseas, an example somewhere here.

217
00:26:25,850 --> 00:26:31,700
So you can you can make an approximation. This would be quadratic and try to find the minimum point.

218
00:26:32,090 --> 00:26:39,739
So this is a similar extension of this linear interpolation, but this is a quadratic interpolation.

219
00:26:39,740 --> 00:26:49,550
So you can approximate this three points of the parabola, quadratic parabola and try to guess what the minimum point is.

220
00:26:50,600 --> 00:26:54,290
So what do you think about this way? This way?

221
00:26:54,800 --> 00:26:59,210
Do you think it's working? This this was always better or this could.

222
00:26:59,600 --> 00:27:06,120
There are cases this method could fail. In which case is this method fail?

223
00:27:07,440 --> 00:27:17,060
Let's think about it. What if this looks like something like this?

224
00:27:17,550 --> 00:27:21,890
Okay, then. Then you know it.

225
00:27:22,220 --> 00:27:25,820
This may look like this to. You never know how this function should look like.

226
00:27:26,450 --> 00:27:31,320
And in this case, this approximation is just not a good approximation.

227
00:27:31,340 --> 00:27:36,260
Right. So. But this doesn't really fail, though.

228
00:27:36,500 --> 00:27:49,340
This just to make, uh, you know, make of the way how you make a guess using this method is probably less efficient than the coded research.

229
00:27:50,180 --> 00:27:58,070
But it's not, you know, it's not a big deal if most of the approximation of approximation works.

230
00:27:58,790 --> 00:28:02,060
So that's another way to try it.

231
00:28:02,090 --> 00:28:05,750
So this is called a parabolic interpolation.

232
00:28:05,900 --> 00:28:12,139
So we already looked at the interpolation problem and we, we all we did a cubic interpolation.

233
00:28:12,140 --> 00:28:15,350
But you can do the similar thing with a parabolic interpolation.

234
00:28:15,360 --> 00:28:21,620
This is a basically a polynomial interpolation. You can do it with a just the degree of two and that's what it is.

235
00:28:23,280 --> 00:28:30,229
OC In a, in, in the public domain interpolation is interested in finding all the interpolation,

236
00:28:30,230 --> 00:28:35,420
but in this case you're trying to guess the what the minimum is so approximate the function

237
00:28:35,420 --> 00:28:40,010
is a quadratic equation and the estimate the minimal point based on the parabola.

238
00:28:40,640 --> 00:28:44,780
And this is basically straightforward extension of linear interpolation.

239
00:28:45,260 --> 00:28:50,870
Okay. So this one, this method works in most cases.

240
00:28:51,050 --> 00:28:55,010
This is probably more efficient than the search.

241
00:28:55,010 --> 00:29:02,629
But as I said, the because there are so many different shapes of this function and in some shapes,

242
00:29:02,630 --> 00:29:09,620
the convergence is going to be very slow or sometimes it just doesn't doesn't converge at all if you're stuck in the,

243
00:29:09,860 --> 00:29:14,360
you know, going iterating the same place, one over and over again.

244
00:29:14,390 --> 00:29:21,830
So in the in the worst case. Okay. So so that's that's the parabolic interpolation.

245
00:29:22,280 --> 00:29:32,609
So the the very common mode of failure of the interpolation is that you try to find the value in the two values are extremely similar to each other.

246
00:29:32,610 --> 00:29:35,630
Then you fail in the public interpretation.

247
00:29:36,020 --> 00:29:46,280
If the three points you evaluated are extremely, you know, is basically the same like this, then it fails to function,

248
00:29:46,400 --> 00:29:57,320
which may look like they said, if you get unlucky that you'll get stuck and that you basically don't know how to how to reduce the interval.

249
00:29:57,380 --> 00:30:04,310
Right. So. Well, but but in the coded search, you don't have this problem.

250
00:30:04,520 --> 00:30:08,480
As long as there is a local, local minima, it keeps reducing it.

251
00:30:08,570 --> 00:30:12,240
Okay. Okay.

252
00:30:13,140 --> 00:30:16,379
So, so that's the parabolic interpolation.

253
00:30:16,380 --> 00:30:24,630
We can go over the details of parabolic interpolation, but I thought that that's a little bit tedious, so I'm going to just explain it as a concept.

254
00:30:24,960 --> 00:30:33,540
But this is a very, very useful way to interpolate, uh, interpolate and do the minima.

255
00:30:33,600 --> 00:30:41,760
So the minimization problem typically more efficient than the code is search like similar, similar reader.

256
00:30:42,390 --> 00:30:49,470
So you could the method is a more efficient than the by section method in most of the cases.

257
00:30:49,950 --> 00:31:00,060
Okay. So in the last part of we are not going to cover details either.

258
00:31:00,600 --> 00:31:07,320
He's a print method. Okay. So print method was developed about 50 years ago.

259
00:31:09,600 --> 00:31:18,089
So this is basically so. So the print method keep track of.

260
00:31:18,090 --> 00:31:22,620
Instead of keeping track of three points, you keep track of six different points.

261
00:31:23,550 --> 00:31:28,110
And it does perform various check.

262
00:31:29,280 --> 00:31:36,150
So what it does is basically sometimes the most of the times that parabolic interpolation actually works better.

263
00:31:36,720 --> 00:31:40,350
But there are cases probably interpolation doesn't work well.

264
00:31:40,950 --> 00:31:50,969
So it does check all the six values in the have a set of steps or in this case, I'm going to use coordinate search.

265
00:31:50,970 --> 00:31:56,700
In this case, I'm going to use the parabolic interpolation, so on, so it doesn't make a prediction.

266
00:31:57,180 --> 00:32:04,620
And by doing that, it is basically by combining this coded search in a parabolic interpolation, it solves the two problems.

267
00:32:04,620 --> 00:32:10,290
One is that, you know, this search can be true, inefficient sometimes, so it can be more efficient,

268
00:32:10,890 --> 00:32:16,380
but the primary interpolation can stop it stuck or just have a problem in convergence.

269
00:32:16,720 --> 00:32:25,140
So in that case, you just switch it to the code in search to make sure that it does converge in a reasonably constant rate.

270
00:32:25,140 --> 00:32:29,219
So it's not always faster than code in search or parabolic interpolation,

271
00:32:29,220 --> 00:32:34,590
but it just is faster than go to search in a stable, more stable than parabolic interpolation.

272
00:32:35,040 --> 00:32:40,380
So this is the most widely used algorithm in the one dimensional optimization problem.

273
00:32:40,750 --> 00:32:46,050
Okay. So this is a this has a lot of citations, too.

274
00:32:47,750 --> 00:32:58,770
Okay. So so and I'm not going to go to the details of this print method because it's sorry.

275
00:32:59,940 --> 00:33:03,090
It has its.

276
00:33:06,200 --> 00:33:11,310
Uh, I guess I. Oh, yeah.

277
00:33:12,180 --> 00:33:27,270
Okay. So it didn't have. Uh, so the implementation is very complicated, so I'm not going to go through the details of the implementation.

278
00:33:27,270 --> 00:33:38,909
But if you look at the paper, those paper explained quite a bit of uh, quite a bit of those, uh, the algorithm.

279
00:33:38,910 --> 00:33:46,889
So if you're interested in how this works, I definitely recommend to read the paper and try to see the details.

280
00:33:46,890 --> 00:33:51,330
But those are probably a little bit too technical to cover in this case.

281
00:33:52,650 --> 00:34:01,410
But this print method is the most efficient way to to perform the one dimensional

282
00:34:01,410 --> 00:34:06,900
optimization in the case that you don't have to implement this all by yourself,

283
00:34:07,170 --> 00:34:11,430
you can actually just use it. It's a plug and play kind of situation.

284
00:34:12,090 --> 00:34:18,660
So here, here, here's an example. So we're doing trying to do the same minimization of same function.

285
00:34:19,140 --> 00:34:29,040
Good. And let's try to do the use the print algorithm which is implemented in the optimize function in in R.

286
00:34:29,550 --> 00:34:36,810
So our optimization optimized function takes the function as an argument and it takes the.

287
00:34:40,080 --> 00:34:51,570
It takes the interval to start an end, and if you give the tolerance parameter, it does perform the optimization for you.

288
00:34:52,980 --> 00:35:00,840
And yeah, this is the minimum you're getting and then this is objective function.

289
00:35:00,960 --> 00:35:05,010
So it does perform pretty well.

290
00:35:05,190 --> 00:35:11,790
Okay. So, but it doesn't, it doesn't provide a number of iterations.

291
00:35:11,790 --> 00:35:21,000
So here there is a 43 iterations it says, but here it doesn't show how, how many iterations was used.

292
00:35:21,180 --> 00:35:27,450
So let's try to see in that case, do you do you know how to do this?

293
00:35:28,170 --> 00:35:31,350
If you want to keep keep track of keep track of the count.

294
00:35:33,090 --> 00:35:40,710
Okay? You can use a global, uh, assignment.

295
00:35:40,920 --> 00:35:44,160
Let's say this. So let's say this county called zero.

296
00:35:44,520 --> 00:35:49,370
Okay? And whenever this function is called, I'm going to call the count.

297
00:35:50,520 --> 00:36:01,469
Count the plus one. Okay, so you know that the when you do the assignment, you can use the equals sign or sometimes you can use these arrows.

298
00:36:01,470 --> 00:36:12,390
Sorry. Right. This one is a local assignment which doesn't, which disappears is this update is only valid within the function and outside of function.

299
00:36:12,390 --> 00:36:17,340
This is not valid. If you do this, then it does global assignment.

300
00:36:17,340 --> 00:36:22,350
So even if the function ended this, this variable still remains intact.

301
00:36:22,800 --> 00:36:31,170
So this is this is a way you can keep track of some of the values easily after function ended.

302
00:36:31,800 --> 00:36:37,440
So if you try to do that, this basically shows how many iterations was used.

303
00:36:37,440 --> 00:36:47,340
In this case, 14 iterations was used. So compared to the 43 before, this is much more much bigger increment with the same amount of precedence.

304
00:36:49,440 --> 00:36:57,419
So in a print item, the nice thing is the printer doesn't also require that this interval has the local minimum.

305
00:36:57,420 --> 00:37:06,610
So if it doesn't have a local minimum, in this case, in this particular interval, it doesn't have a local minimum, it does it it is encoding function.

306
00:37:06,630 --> 00:37:10,050
In this case, it tried to find the minimum at the boundary as well.

307
00:37:10,050 --> 00:37:13,460
So that's that's a good thing as well. Okay.

308
00:37:14,970 --> 00:37:23,010
So so this is the end of the one dimensional optimization and we're going to move through to the multidimensional optimization.

309
00:37:23,820 --> 00:37:32,100
Okay. Any questions about this coding search, parabolic search and or the or print method?

310
00:37:36,970 --> 00:37:44,380
So just my recommendation is that if you don't have to implement yourself, use the present method.

311
00:37:44,590 --> 00:37:51,489
Okay. If you need to implement some algorithm yourself, a method is a little bit tricky to implement.

312
00:37:51,490 --> 00:37:55,990
So implementing as opposed to a search algorithm is as important as.

313
00:37:56,380 --> 00:37:59,920
So just to here, would it be good enough in most of the case?

314
00:38:07,280 --> 00:38:14,490
Okay. So let's move on to the multidimensional optimization.

315
00:38:19,540 --> 00:38:25,020
So before going there, we need to just recap the code, the search algorithm.

316
00:38:25,030 --> 00:38:29,410
So let me try to do this. Okay. So.

317
00:38:30,280 --> 00:38:37,810
Okay. So this is the code.

318
00:38:37,990 --> 00:38:45,040
So now I change the function name is a code in search that one D because it's a one dimensional algorithm.

319
00:38:45,400 --> 00:38:48,650
Okay. And this is the full function. Okay.

320
00:38:50,170 --> 00:38:56,890
It's a pretty long. But it does have all the steps that are required.

321
00:38:57,160 --> 00:39:02,200
Okay. And if you see, the poor part is a problem, pretty much the same.

322
00:39:02,560 --> 00:39:08,710
The difference is that I included this code in step as an internal function.

323
00:39:09,010 --> 00:39:16,480
So the nested function. So when you have a function and you want to, you are you have another function that you want it to call.

324
00:39:16,960 --> 00:39:21,820
But I'm pretty sure that this function is not going to call the outside of my function.

325
00:39:22,450 --> 00:39:28,660
Then you can just define the function inside your function as a nested function that that make your code cleaner.

326
00:39:29,660 --> 00:39:34,000
Okay. And in the same same for the bracketing algorithm.

327
00:39:34,000 --> 00:39:45,540
So this this part is makes more of this this part to make things a lot more that a lot longer.

328
00:39:45,550 --> 00:39:49,420
But basically, this this is these are all the functions we already covered.

329
00:39:50,260 --> 00:40:07,770
Okay. And the other part I wanted to highlight is that we're going to use this kind of notation so to to to document a function.

330
00:40:07,780 --> 00:40:18,640
So this is the kind of the standard that are supported by supported by packages for the option to and if you write,

331
00:40:19,150 --> 00:40:24,190
document your function in this way in this format.

332
00:40:24,190 --> 00:40:32,769
So if you the details, you can just go to allocation to packages and they have documentation how you document a function,

333
00:40:32,770 --> 00:40:37,030
but basically you have a description of function and that is the parameter in the written value.

334
00:40:37,240 --> 00:40:40,300
And that's the basic format with this spatial keyword.

335
00:40:40,900 --> 00:40:46,840
If you do that, then later when you make a package, it does create a menu by itself.

336
00:40:46,990 --> 00:40:49,900
So you don't have to write a separate menu. So that's the.

337
00:40:50,380 --> 00:41:01,540
So then you in the menu becomes consistent with your code and the generated menu that, that can be used when, when other people use it.

338
00:41:01,570 --> 00:41:10,090
So I strongly recommend to have a habit of documenting your function in the option

339
00:41:10,090 --> 00:41:16,210
to format because this is kind of our standard you and in documenting things.

340
00:41:16,450 --> 00:41:23,790
So this is how, how I would describe it, but you don't have to stick with the exact sent text.

341
00:41:23,800 --> 00:41:30,340
You can change the text here. Okay. So those are the those are the just two things I just wanted to mention.

342
00:41:30,580 --> 00:41:40,870
The other part is pretty much the same. So it just to find the intervals and the run, the code, the search algorithm is, as I explained.

343
00:41:41,170 --> 00:41:44,650
And it'll, it'll return the minimum and the objective function and so on.

344
00:41:45,130 --> 00:41:53,140
So this is a one dimensional called the search algorithm, which you will partially use in some of these multidimensional optimization library.

345
00:41:53,920 --> 00:42:04,800
Okay. So now let's go through the multidimensional optimization.

346
00:42:05,000 --> 00:42:12,329
Okay. So what is a multidimensional optimization? So. Well, a function sometimes takes only one parameter,

347
00:42:12,330 --> 00:42:20,280
but many functions you are using is taking multiple parameters or sometimes a vector of parameters.

348
00:42:20,970 --> 00:42:22,560
So which is a multidimensional.

349
00:42:24,800 --> 00:42:32,880
Uh, we are still considering actual function, so we assume that the function returns a single dimension of our scalar value.

350
00:42:33,330 --> 00:42:39,030
And the objective is to find a combination of parameters that minimize the objective function.

351
00:42:39,240 --> 00:42:44,760
Okay. So that's that's a much more typical situation you're going to get into.

352
00:42:44,790 --> 00:42:50,249
I usually you have you will have a multiple parameters and you need to find those combination

353
00:42:50,250 --> 00:42:56,640
of time here that maximize your likely function or minimize the loss functions and so on.

354
00:42:56,850 --> 00:43:05,790
Okay. So but multidimensional optimization is a much harder problem than the single dimension optimization.

355
00:43:06,060 --> 00:43:16,400
Okay. Why is that? So let's say you have a single dimensional space, okay?

356
00:43:17,400 --> 00:43:27,870
And in this case, you can if you even if you don't know what your what the optimization algorithm is,

357
00:43:28,200 --> 00:43:31,140
you can do some very basic thing, like a quality search.

358
00:43:31,320 --> 00:43:38,670
I'm going to make a grid of these intervals and I'm going to evaluate the whole all the value of the screen.

359
00:43:39,240 --> 00:43:42,990
And you have a pretty good understanding where the minimum will occur.

360
00:43:43,470 --> 00:43:52,680
And you can uh, in the UK you can identify the region which might contain the minimum.

361
00:43:53,130 --> 00:43:57,560
And the key dividing is agreed. And that's one way to solve the problem, right?

362
00:43:58,120 --> 00:44:06,380
And the colors are chosen or print algorithm is just a step to reduce the number of number of functional locations.

363
00:44:07,650 --> 00:44:11,130
Well, let's say you're doing the research in one dimension.

364
00:44:11,310 --> 00:44:14,880
This is to have a good image. Okay.

365
00:44:15,450 --> 00:44:19,540
So let's say you have P number to read.

366
00:44:19,890 --> 00:44:25,330
Okay. And then you need a P evaluation of the function.

367
00:44:25,350 --> 00:44:31,410
If you make a green two dimensional, you need a P to the to number of three.

368
00:44:32,550 --> 00:44:41,250
If you have the individual of five years, you need to the number of brain you need to evaluate exponentially increase.

369
00:44:41,520 --> 00:44:51,060
Okay. So the search space is a lot a lot larger than the single dimensional optimization problem.

370
00:44:51,390 --> 00:45:00,540
That's a problem one. Okay. Second problem is that sometimes it's a problem, too, is that in this case,

371
00:45:00,540 --> 00:45:07,270
even if you have local minimum, global minimum, you may have a very complicated looking function.

372
00:45:07,500 --> 00:45:10,830
But this is a pretty still single dimension. It's a pretty simple.

373
00:45:11,460 --> 00:45:17,430
But in the multi-dimensional cases, you may have a very different sort of, uh.

374
00:45:18,930 --> 00:45:26,850
So the functional function may look like very, very different, very correlated between the common images sometimes.

375
00:45:27,390 --> 00:45:32,310
So it's very, it's much more variable. Various patterns you can see.

376
00:45:33,100 --> 00:45:44,490
So in, in, in some cases, just a discrete search that is more nonspecific shape of these functions to find a minimum.

377
00:45:45,610 --> 00:45:52,620
And so there's a lot more different mode of this, how this function will look like.

378
00:45:53,160 --> 00:45:57,180
So it's hard to find where the minimum occurs.

379
00:45:57,500 --> 00:46:03,780
Okay. And it's also harder to find where the global minimum occurs.

380
00:46:03,930 --> 00:46:12,450
So here, you know, you can try to try to do the research and then it doesn't guarantee that you can find the global minimum,

381
00:46:12,810 --> 00:46:18,330
but it's pretty reasonable that you can find the global minimum except for very crazy looking functions.

382
00:46:18,720 --> 00:46:26,040
But in this case, even if you do enumerate all these possible cases, to find a global minimum would be a lot harder.

383
00:46:28,750 --> 00:46:32,139
So. So just this is a preamble.

384
00:46:32,140 --> 00:46:39,790
So we're going to try to solve this problem. So solving this problem completely is almost impossible to.

385
00:46:39,970 --> 00:46:43,030
Meaning that your algorithm is most likely.

386
00:46:43,030 --> 00:46:47,680
That there are quantum cases, that your your automation doesn't work.

387
00:46:48,100 --> 00:46:54,970
So it's hard to find the algorithm that you know, that fit for all use cases.

388
00:46:55,180 --> 00:47:02,590
So but we're trying to find the algorithm that works reasonably well for most of the cases, if that makes sense.

389
00:47:05,050 --> 00:47:10,150
So how they do it, if you can no longer.

390
00:47:11,140 --> 00:47:15,000
So what what is question again? We can also do business on those phone cameras.

391
00:47:18,910 --> 00:47:21,910
Sorry. What? Why did I not upload it?

392
00:47:22,630 --> 00:47:27,670
I think you put it into lectures and people would be like, Oh, really?

393
00:47:28,180 --> 00:47:34,210
I'm sorry. I did upload lecture eight, I believe.

394
00:47:45,940 --> 00:47:52,380
Okay. I did applaud, but I probably didn't in the wrong version, I guess.

395
00:47:52,390 --> 00:47:55,660
I'm sorry about that. So.

396
00:47:58,180 --> 00:48:01,750
Okay. So let me try to update this. This this may.

397
00:48:01,930 --> 00:48:06,460
Sometimes these take take time. So, uh, but let me try.

398
00:48:11,550 --> 00:48:29,990
So I'm really sorry about this. Oh. Okay.

399
00:48:30,170 --> 00:48:33,710
Looks like it updated. So please take a look.

400
00:48:33,730 --> 00:48:39,170
And if you still have a problem, I'll let me know. Okay.

401
00:48:43,460 --> 00:48:52,240
Okay. So I'll. I'll give you a time to download it. Okay.

402
00:48:52,510 --> 00:49:02,630
So. So first our wisdom we're going to try is a coordinated descent algorithm.

403
00:49:04,970 --> 00:49:12,560
So coded descent is a the idea is that, oh, we're going to do the multidimensional optimization.

404
00:49:13,130 --> 00:49:17,540
How hard could it be if we're going to just optimize a one dimension at a time?

405
00:49:17,940 --> 00:49:26,509
All right. So what what your what these arguments are trying to do is that I'm going if you have ten dimensions,

406
00:49:26,510 --> 00:49:31,310
let's say, then I'm going to fix all the other nine dimension.

407
00:49:31,430 --> 00:49:34,880
I'm going to optimize over one dimension at a time.

408
00:49:35,180 --> 00:49:42,920
Okay. And once I optimize that, I'm going to move to the next dimension, try to optimize the next dimension, and so on.

409
00:49:43,340 --> 00:49:50,710
And this is what will look like. Okay, so in this case, I'm going I'm going to find I'm going to only look at.

410
00:49:51,050 --> 00:49:56,330
So I am starting from this point, I'm going to look at only this point and try to find a minimum here.

411
00:49:56,960 --> 00:50:00,170
I find it and I'm good.

412
00:50:00,200 --> 00:50:04,940
I'm going to look at the second dimension going here, going here, going here and going here.

413
00:50:05,150 --> 00:50:13,160
Okay. So so that's that's how how this argument works.

414
00:50:13,460 --> 00:50:22,850
Okay. But there are the there are cases, as you might guess, there are cases.

415
00:50:22,850 --> 00:50:28,069
This is a problematic obviously, this is very slow.

416
00:50:28,070 --> 00:50:34,370
That's a problem one. But our problem, too, is that if your function looks like this,

417
00:50:34,550 --> 00:50:41,090
this is the case where these parties rejected it flat and this part is also actually flat.

418
00:50:41,360 --> 00:50:47,209
Okay. In that case. But it so this part this flat.

419
00:50:47,210 --> 00:50:55,150
This part is flat. But it's clear that if you go this way, it the function value is smaller.

420
00:50:55,290 --> 00:51:00,320
You get it in in those cases, these are which does not work.

421
00:51:01,370 --> 00:51:10,069
And so you can make a very weird looking functions where these quality center doesn't work.

422
00:51:10,070 --> 00:51:16,550
So this is not definitely a general solution that works for all different cases.

423
00:51:19,800 --> 00:51:26,430
So. But this is so. If you have to implement the multidimensional optimization routine,

424
00:51:26,970 --> 00:51:36,300
this is definitely one very simple alternative you can use, especially if you know how to optimize one dimension.

425
00:51:36,310 --> 00:51:40,260
So let's try to implement it.

426
00:51:40,740 --> 00:51:43,360
So this is a coordinate, this entire rhythm. Okay.

427
00:51:43,410 --> 00:51:52,890
So there are there are four parameters function and the integer point and the relative error you can tolerate and the maximum number of iteration.

428
00:51:53,310 --> 00:51:58,379
And it's going to return these values. Okay. So X values and Y values.

429
00:51:58,380 --> 00:52:01,320
And whether it converges or not, how does it work?

430
00:52:01,500 --> 00:52:07,979
So I'm going to say convergence equals 1/1, then I'm going to go through the next number of iteration.

431
00:52:07,980 --> 00:52:16,650
When I each iteration, I'm going to select each coordinate one of the time I to do the round robin and here.

432
00:52:17,520 --> 00:52:27,060
So this is an interesting okay. In the sense that if this function the function declaration has this dot, dot, dot part.

433
00:52:27,900 --> 00:52:38,040
Okay. So you may not have seen this before, but if you have this data, then this function can have any extra parameters.

434
00:52:38,760 --> 00:52:46,020
Okay. And this data that can be used when you call this function F.

435
00:52:46,590 --> 00:52:56,280
Okay. So this works when this only works when your function is actually the first part of it is actually a function.

436
00:52:56,820 --> 00:53:00,420
But first parameters function, you can use this trick. Okay.

437
00:53:00,910 --> 00:53:03,989
So you can pass any kind of function.

438
00:53:03,990 --> 00:53:07,139
So this you can use a general function.

439
00:53:07,140 --> 00:53:12,930
So this function may have. So they may take a lot of parameters.

440
00:53:12,930 --> 00:53:17,610
Right. So what it what this is doing is that I'm going to make.

441
00:53:19,410 --> 00:53:20,070
So this is.

442
00:53:20,460 --> 00:53:30,780
So this is a f of I is a function that I made this this function F takes the multidimensional input and I f of I takes the single dimension input,

443
00:53:30,870 --> 00:53:33,480
single dimension of X or Y. How do I change it?

444
00:53:33,510 --> 00:53:46,680
So what I did is I copied x one values, current quantity, context value, and I update only the dimension index of I.

445
00:53:47,190 --> 00:53:50,310
And I run, run those function with X of K.

446
00:53:50,460 --> 00:53:53,850
And if there's any extra parameter, I'm going to pass it along to.

447
00:53:54,600 --> 00:54:03,390
Now this became f i because it's a one dimensional, a function that fixed every other value, every other dimension except for the dimension.

448
00:54:04,020 --> 00:54:08,610
You can use the code to search, to find the minimum point.

449
00:54:09,960 --> 00:54:19,290
And it just if if it's converted, each of each of the dimensions keep going on across across multiple dimensions.

450
00:54:19,680 --> 00:54:25,440
If it didn't converge, just stop it and just report the errors and keep doing it.

451
00:54:26,580 --> 00:54:30,210
And each each of the cases, after doing this,

452
00:54:30,400 --> 00:54:39,060
what I'm going to do is I am going to evaluate the objective function after iterating all the different dimensions, and I'm going to check.

453
00:54:39,180 --> 00:54:48,990
So this is a new function and F of zero is the value that in the audit that was evaluated with the original x x value.

454
00:54:49,410 --> 00:54:57,960
So when I, when I went through all dimensions and try to minimize it, those differences should be large.

455
00:54:58,530 --> 00:55:04,080
If it does, it does reduce the function values.

456
00:55:04,350 --> 00:55:12,480
But if it's not small, not very large, if it's very small, that means that you may have reached a local ultimate error.

457
00:55:12,900 --> 00:55:22,139
So there is not so much improvement. Then you calculate the relative relative errors between those two two values.

458
00:55:22,140 --> 00:55:25,020
And if the relative error is less than that tolerance,

459
00:55:25,680 --> 00:55:32,280
then I declare this was converted in the break break out of the loop before the maximum number iteration.

460
00:55:32,880 --> 00:55:40,500
Otherwise I'm going to just save the current x values or zero in the current f of one is f zero.

461
00:55:40,500 --> 00:55:45,930
And the way we do this or till I find a reasonable level of convergence.

462
00:55:46,170 --> 00:55:51,510
So that's that's how this works. And that is this is a relatively very quick rate.

463
00:55:51,510 --> 00:55:57,600
So and if you have a good one dimensional language, you don't have to use the code in search.

464
00:55:57,600 --> 00:56:04,890
You can use anything else. But if you have that, then you can you can solve this.

465
00:56:05,730 --> 00:56:09,570
Okay. Any questions?

466
00:56:12,410 --> 00:56:14,810
Okay. So that's the coordinating center.

467
00:56:16,640 --> 00:56:24,680
But as you see this podium, this interview is probably not the best way to perform the multidimensional optimization,

468
00:56:24,680 --> 00:56:29,090
because it's a slow and it's there's no guarantee of convergence.

469
00:56:30,050 --> 00:56:40,640
So why don't we try something else? Okay. So the next target, Jim, is we're going to try is a limited algorithm.

470
00:56:41,780 --> 00:56:47,270
And this algorithm is how many of you heard about the ultimate algorithm or simplex method?

471
00:56:47,360 --> 00:56:50,480
Okay. So some of some of you have heard about it.

472
00:56:51,110 --> 00:56:54,470
Why do you think this method is extremely popular? Okay.

473
00:56:54,890 --> 00:56:59,750
So. And this algorithm, the nice thing.

474
00:56:59,780 --> 00:57:04,550
One one nice thing about this algorithm is that most of the multidimensional,

475
00:57:06,200 --> 00:57:09,950
multidimensional optimization algorithm requires a derivative to be calculated.

476
00:57:09,980 --> 00:57:15,360
You need to you need to have a gradient. So you probably have no this gradient descent or something else.

477
00:57:15,380 --> 00:57:19,010
But these are which does not require a gradient.

478
00:57:19,130 --> 00:57:23,170
Those are not derivative free. So you don't have to calculate the derivative.

479
00:57:23,180 --> 00:57:29,749
So if you if you are either I'm too lazy to calculate the derivative.

480
00:57:29,750 --> 00:57:34,130
And this is a to be very simple optimization. I'm going to plug into no limit.

481
00:57:34,520 --> 00:57:39,620
Okay. The other use cases that credit is somehow just very hard to calculate.

482
00:57:39,620 --> 00:57:43,870
Some, some, some sort of function could be or there is no closed form.

483
00:57:44,340 --> 00:57:48,370
Then that's another reason to use another with you.

484
00:57:49,880 --> 00:57:56,960
So this is also sometimes called a simplex method or the simplest method that there is a you know,

485
00:57:57,140 --> 00:58:05,270
there is a there could be confusion with that simplex method and in integer programing it's a linear programing.

486
00:58:05,510 --> 00:58:15,440
So in a amoeba method is, uh, is another, another way to describe this because of the way how this looks like.

487
00:58:15,590 --> 00:58:26,030
Okay. So, so what it does is that you cut your head, you have, uh, calculate the likely, the simplest vertices, okay?

488
00:58:26,150 --> 00:58:29,660
And the participants axes. Okay. So simplex.

489
00:58:29,810 --> 00:58:34,190
So if you have a K dimension, you keep track of K plus one points.

490
00:58:34,190 --> 00:58:36,800
So in two dimension, you keep track of three points.

491
00:58:37,250 --> 00:58:44,030
So that means that you make you maintain trend triangle in the three dimension, you maintain a pyramid.

492
00:58:44,270 --> 00:58:47,630
Okay. So those are the shape you're maintaining.

493
00:58:48,710 --> 00:59:00,950
And so and what it what it does is that those are simple triangle or pyramid or those simplex are supposed to crawl towards the minimum.

494
00:59:01,400 --> 00:59:04,760
Okay. And a move away from the maximum.

495
00:59:04,770 --> 00:59:12,290
So that's how it's designed. Okay. So this is a very popular method that I use it.

496
00:59:12,290 --> 00:59:25,010
I use it a lot in my paper, too. Okay. So because it does work very well, uh, for, for arbitrary optimization method without requiring derivative.

497
00:59:25,040 --> 00:59:32,790
So sometimes derivative can take really long, even though function evaluation is very quick, derivative evaluation can take a really long time.

498
00:59:32,810 --> 00:59:37,130
And in that case, also, this is this is a good way to do it.

499
00:59:37,520 --> 00:59:46,220
Okay. So the problem of this method is that this method is not guaranteed to converge.

500
00:59:46,490 --> 00:59:56,569
Okay. It can it can be trapped into local, local, optimal, where it can search and it can cycle through like sometimes.

501
00:59:56,570 --> 01:00:00,460
So it has a risk of not converging.

502
01:00:00,800 --> 01:00:05,690
Okay. So that's, uh, that's the biggest drawback of this method.

503
01:00:06,230 --> 01:00:15,020
Okay. So what we're going to do is that we're going to try to understand how this.

504
01:00:15,200 --> 01:00:25,610
Mm. Method works. So, uh, in two dimension, and you can generalize this idea into multiple dimension, as you can see.

505
01:00:26,420 --> 01:00:37,020
So, uh, so no matter whether this is a two dimensional or three dimensional four dimension and so on, these mm.

506
01:00:37,040 --> 01:00:40,160
Always only focuses on three points. Okay.

507
01:00:41,330 --> 01:00:50,270
Three points. So in, in two dimensions you all, you just have a three points by in ten dimension, for example, you have 11 points.

508
01:00:50,690 --> 01:00:54,530
But among among those 11 points, you keep track of these three points.

509
01:00:55,850 --> 01:00:58,970
The highest, worst point. What does worst point means?

510
01:01:00,200 --> 01:01:07,190
We're trying to do the minimization. The worst point. That means that these are, you know, the function values, the largest.

511
01:01:07,490 --> 01:01:11,000
Okay. And the next highest points.

512
01:01:11,040 --> 01:01:19,200
Second worst point. Okay. So instead of focusing on the best one, these are always trying to focus on the worst one.

513
01:01:19,560 --> 01:01:23,100
Okay. And you also keep track of the best point.

514
01:01:23,810 --> 01:01:27,150
There are two. Two worst points and one best points.

515
01:01:27,390 --> 01:01:38,400
That's what you are trying to do. And what this article is trying to do is move away from the worst point and try to go closer to the highest point.

516
01:01:38,910 --> 01:01:42,500
Okay. As a closer to the minimum point. Naught point.

517
01:01:42,990 --> 01:01:48,210
Okay. Okay. So how does it do that?

518
01:01:48,720 --> 01:01:54,090
So now it's a bunch of heuristics. Okay. But these heuristics kind of make sense.

519
01:01:54,450 --> 01:01:57,720
Okay. So.

520
01:01:58,560 --> 01:02:06,000
So if you if you are looking for mathematical beauty, this is not the place you're I mean, this is not the place.

521
01:02:06,210 --> 01:02:15,600
But this is a good example of how sometimes mathematically ugly heuristic actually works in practice.

522
01:02:16,020 --> 01:02:19,409
Okay. And that's a lot of cases in the optimization problem.

523
01:02:19,410 --> 01:02:22,500
If you know all these, like, you know, great.

524
01:02:22,770 --> 01:02:29,850
You know, all these recent are with them for doing this optimization, stochastic gradient stent or something.

525
01:02:29,880 --> 01:02:37,710
So these are like, I don't know how this actually works, but that works in the and it's not,

526
01:02:37,920 --> 01:02:45,030
not all the method of mathematically beautiful and a some some method are and those those methods are tend to be good.

527
01:02:45,360 --> 01:02:52,770
But there are always some heuristic parts that this method assumes that this assumption works.

528
01:02:53,340 --> 01:02:57,810
And if the assumption is reasonable, then the method was really well.

529
01:02:58,860 --> 01:03:05,460
So in this case, what you have is this.

530
01:03:05,700 --> 01:03:13,020
Okay. So X, you know, here is the worst point.

531
01:03:13,710 --> 01:03:14,010
Okay.

532
01:03:15,150 --> 01:03:26,700
x1x2x2 is because this is a two dimensional you have two different points, but you may have like in ten dimensional, you may have ten points here.

533
01:03:26,710 --> 01:03:37,080
And this is the worst point. Okay. What it does is that it calculates the average of all points except for the worst point,

534
01:03:38,280 --> 01:03:48,510
and try to draw a line that that passes the worst point and and go through the midpoint.

535
01:03:48,570 --> 01:03:51,630
So this is a line the oldest of the dimensions. Okay.

536
01:03:53,640 --> 01:03:59,700
So so then what do you think it'll happen here?

537
01:04:00,810 --> 01:04:05,219
So here is some some of one of them would be the best point.

538
01:04:05,220 --> 01:04:09,960
And or one of them the second, second worst point or second best point in three dimension.

539
01:04:10,380 --> 01:04:14,060
Okay. If you go through this. Okay, what do you expect?

540
01:04:16,900 --> 01:04:26,170
Well, this is the worst point. So maybe they're these points are probably some are better than the worse point.

541
01:04:26,180 --> 01:04:38,200
Some are worse than the worst point. Right. So what these these are what you are trying to do is trying to determine the axes.

542
01:04:38,200 --> 01:04:42,160
I want to optimize. So this is the axes I want to determine.

543
01:04:42,190 --> 01:04:48,160
I want to optimize a primarily. Okay. And try to find the optimal point.

544
01:04:48,340 --> 01:04:55,810
But it doesn't do real optimization. You just try it a couple of points and I've picked the next my next move.

545
01:04:55,960 --> 01:05:00,760
Okay. So what is the what is a possible point where this is always a constraint?

546
01:05:00,790 --> 01:05:04,480
I said a very heuristic, so don't be disappointed.

547
01:05:05,050 --> 01:05:09,850
First is that maybe this is the worst point. So maybe best point is here.

548
01:05:10,840 --> 01:05:20,200
Okay. I just reflect with this thing and if, you know, if I'm very lucky, you know, the best point might be located here.

549
01:05:20,410 --> 01:05:27,440
So that's one possible way to try the new point.

550
01:05:28,060 --> 01:05:32,560
So I'm going to try this method, this algorithm always try this live collection point.

551
01:05:34,210 --> 01:05:42,040
And maybe if I'm really lucky, then these keep this may keep decreasing.

552
01:05:42,220 --> 01:05:47,590
So if I find a reasonable, reasonable excuse, I'm going to very optimistic.

553
01:05:48,160 --> 01:05:51,940
So this may keep decreasing. So I'm going to evaluate here.

554
01:05:52,120 --> 01:05:55,780
So twice. So, so different.

555
01:05:55,900 --> 01:05:59,530
So one. The same same distance.

556
01:05:59,530 --> 01:06:02,830
I'm going to expand and try try this point, too.

557
01:06:02,890 --> 01:06:06,400
So it's evaluating the value in the same line.

558
01:06:06,640 --> 01:06:14,350
Two values. Okay. But I'm going to be also pessimistic.

559
01:06:14,620 --> 01:06:19,570
Okay. So maybe sometimes this could be very high, right?

560
01:06:19,990 --> 01:06:24,300
So if so, this this happens.

561
01:06:24,310 --> 01:06:31,000
Let's say I'm going to evaluate this. And if this really becomes a best point, then, oh, I found the right direction.

562
01:06:31,420 --> 01:06:34,870
I'm going to go more. So that's why. What what's going to do?

563
01:06:35,350 --> 01:06:40,420
But what if this is the worst point? Then I follow this direction.

564
01:06:40,600 --> 01:06:46,059
Might be right. But you went too far. So in that case, what is trying to do is.

565
01:06:46,060 --> 01:06:49,870
Oh, maybe the best point is or is some way somewhere this way.

566
01:06:50,350 --> 01:06:54,880
So I'm going to try a smaller step. I'm going to do the halfway through here.

567
01:06:55,600 --> 01:06:59,830
And that's that's the point I'm going to evaluate.

568
01:07:00,070 --> 01:07:03,870
Okay. If this becomes really bad. Okay.

569
01:07:03,970 --> 01:07:11,830
But all these algorithms are trying to do four find the minimum in the in one dimension.

570
01:07:12,850 --> 01:07:21,070
So but, you know, maybe this this excuse yourself, it may not be very good access.

571
01:07:21,260 --> 01:07:28,059
Okay. So and you may not end up having a so none of them are better than the better than

572
01:07:28,060 --> 01:07:34,710
the my my best point that they might be what one might be happening in that case,

573
01:07:35,320 --> 01:07:39,280
what we are trying to do. So this is the worst point. This is the best point.

574
01:07:39,700 --> 01:07:48,529
I'm going to I'm going to contract. I'm going to shrink my region into the smaller piece because of my step size.

575
01:07:48,530 --> 01:07:52,330
It might be too big. So I'm going to reduce my step size.

576
01:07:52,990 --> 01:08:00,790
So I'm going to reduce my step this way and redo restart the same algorithm.

577
01:08:00,790 --> 01:08:06,700
Then maybe if I go over here, I may I may be more lucky.

578
01:08:06,910 --> 01:08:10,630
Okay, so that's that multiple contraction.

579
01:08:10,990 --> 01:08:17,680
Okay. So this is a three dimensional case.

580
01:08:17,860 --> 01:08:22,810
So you have a now it's a keep track keeping track of a yeah.

581
01:08:23,380 --> 01:08:33,190
Keeping track of these. So keeping track of this is a pyramid.

582
01:08:34,060 --> 01:08:41,799
In this case, let's say this is a pyramid where we're trying to we study from.

583
01:08:41,800 --> 01:08:46,300
This is already in our original simplex. And this is the worst point.

584
01:08:46,660 --> 01:08:49,750
This is the low point. Maybe there is a some best point here.

585
01:08:50,210 --> 01:08:59,020
Okay. What is trying to do is that now you you find the midpoint here and the from from high to the midpoint.

586
01:08:59,590 --> 01:09:03,440
We're trying to expand or reflect or something like this, this.

587
01:09:03,460 --> 01:09:13,000
So if I if I decide to reflect, that means that I'm I'm trying to find this point and evaluate that.

588
01:09:13,060 --> 01:09:18,610
If this point becomes a bit better, then this is a my my new simplex.

589
01:09:20,020 --> 01:09:24,840
If this point becomes better, I'm going to evaluate the further and try to expand more.

590
01:09:24,850 --> 01:09:30,640
And if this point becomes better, I'm going to just keep keep this as my new simplex.

591
01:09:31,390 --> 01:09:38,350
If this difference point is a worse and the worse, actually worse point, then I'm going to instead of going to this direction,

592
01:09:38,770 --> 01:09:46,690
I'm going to find the something in the middle and I'm going to contract my simplex into some smaller scale.

593
01:09:47,320 --> 01:09:52,360
And if none of these work, I'm going to move,

594
01:09:52,570 --> 01:10:01,420
move my simplex into toward the best point and I'm going to do the multiple dimensional contraction and see whether this works.

595
01:10:01,570 --> 01:10:04,990
Okay. So this is the.

596
01:10:05,470 --> 01:10:12,100
Now, let me document this visualization. And this looks like a bunch of heuristics, as I learned.

597
01:10:12,730 --> 01:10:16,750
And there's no guarantee that obviously, there's no guarantee that this method works.

598
01:10:17,020 --> 01:10:31,509
But in practice, this works really well. Okay. So so I'm going to just do so before, before getting getting to the actual implementation.

599
01:10:31,510 --> 01:10:34,960
I just wanted to have some.

600
01:10:36,850 --> 01:10:40,240
So well, the actual implementation is really long.

601
01:10:40,510 --> 01:10:43,930
First, this is actually implementation. Okay.

602
01:10:44,710 --> 01:10:54,160
So, so I'm going to explain the, the key part, which is which is this main part.

603
01:10:54,340 --> 01:11:02,440
Okay. So and the main parties is this main part is relatively short.

604
01:11:02,680 --> 01:11:07,210
Okay. So what does this main part do?

605
01:11:07,490 --> 01:11:10,840
Okay. So I'm going to do multiple number of iterations.

606
01:11:11,440 --> 01:11:15,469
Okay. And what I'm going to do is I'm going to update update.

607
01:11:15,470 --> 01:11:22,180
The extremes are going to find the best point, worst point and second worst point.

608
01:11:22,480 --> 01:11:28,390
Okay. And so in a check, check the convergence.

609
01:11:28,720 --> 01:11:35,770
Okay. And the next part is, I'm going to find a line that could go through this.

610
01:11:36,010 --> 01:11:42,100
I'm sorry. The line that goes through from highest point into to the middle point.

611
01:11:42,160 --> 01:11:47,290
I'm going to find the line. And that's the that that's this part.

612
01:11:47,510 --> 01:11:52,690
Okay. And after that. So now you have.

613
01:12:02,200 --> 01:12:08,970
You have this triangle? I found this line. Okay, then this line.

614
01:12:08,980 --> 01:12:12,640
Basically. If. If you so let.

615
01:12:12,760 --> 01:12:16,810
Let's say, uh, this.

616
01:12:17,050 --> 01:12:23,110
This is, you know, this is the one is the negative one. This is going to is the 0.5.

617
01:12:23,500 --> 01:12:28,150
So just don't skip. You're just skimming and because you're trying to evaluate.

618
01:12:28,210 --> 01:12:35,560
So this is one dimensional function apple the sum some value but this is value if this value that you know,

619
01:12:35,560 --> 01:12:41,080
I'm going to evaluate these values, the one I'm going to evaluate is negative one and so on.

620
01:12:41,560 --> 01:12:51,490
Okay. So then if I evaluate the of this value and the negative one, that becomes a reflection.

621
01:12:51,960 --> 01:12:58,480
Okay, so do the reflection first. And if that changed my minimum.

622
01:12:59,050 --> 01:13:06,160
Okay. And so this means that, oh, you know, I did a reflection.

623
01:13:06,460 --> 01:13:11,770
So if you do the reflection, this is just replacing my worst point.

624
01:13:12,190 --> 01:13:20,010
If the if the my worst point is actually better than the my best point, then I'm going to keep expanding.

625
01:13:20,020 --> 01:13:24,100
Oh, I found the right direction. I don't want to stop. I'm going to go further.

626
01:13:24,250 --> 01:13:31,360
Okay. If it's if my my reflection didn't work.

627
01:13:31,750 --> 01:13:37,810
So this is the worst and the second worst point. Okay, then I'm going to the contraction.

628
01:13:38,170 --> 01:13:41,350
Okay. So I'm going to evaluate here. Okay.

629
01:13:42,730 --> 01:13:48,160
If so, I need the contraction. But if this contraction didn't work either.

630
01:13:48,310 --> 01:13:52,410
So there is nothing better than. So this is.

631
01:13:52,430 --> 01:13:55,910
Make it all better. This part is all very, very bad.

632
01:13:56,620 --> 01:14:00,009
And this is the best point, right? So maybe.

633
01:14:00,010 --> 01:14:05,110
Maybe this is not the right dimension in the drug. And then I'm going to do the multiple contraction.

634
01:14:05,620 --> 01:14:08,770
Okay. So this is a multiple contraction path. Okay.

635
01:14:09,280 --> 01:14:17,950
So that's the algorithm high level. The the next part is just how do I how do I implement this function?

636
01:14:18,430 --> 01:14:25,750
This function and the and this are evaluating next point and doing the multiple contraction.

637
01:14:26,290 --> 01:14:29,830
So those are the those are the part that I describe here.

638
01:14:30,490 --> 01:14:35,560
Okay. So understanding the the high level part is important.

639
01:14:37,240 --> 01:14:40,890
And let's let's talk about the others. Okay.

640
01:14:40,900 --> 01:14:45,790
So so this part is just a setting setting the algorithm up.

641
01:14:46,930 --> 01:14:53,829
So starting with the starting with the initial simplex is not very straightforward.

642
01:14:53,830 --> 01:15:00,280
But basically what you're trying to do is start with a point and adds and so

643
01:15:00,460 --> 01:15:05,260
start from the one point and add the value of one for each of the dimension.

644
01:15:05,650 --> 01:15:09,070
And you can create a. So you create a simplex.

645
01:15:09,490 --> 01:15:20,020
Usually if you if you add end and and additional point just by by adding the adding the value of one in each of the dimensions.

646
01:15:20,020 --> 01:15:29,139
So that's what what you start with. Okay. And, and after that, you evaluate all the all the values here using.

647
01:15:29,140 --> 01:15:35,200
Just in this case, I'm using applied function instead, using loop to evaluate all the all the value.

648
01:15:36,250 --> 01:15:41,980
And as I said, I'm trying to evaluate I'm trying to keep track of these three values.

649
01:15:42,520 --> 01:15:48,970
So so which dimension? So index. So I have a I have Capel de plus one.

650
01:15:49,000 --> 01:15:55,420
So these are dimension. So the plus one value I need to keep track of, but I'm only keeping track of three values.

651
01:15:55,420 --> 01:15:59,680
Which one is the worst? Which one is the best? And which one is the second worst?

652
01:16:00,550 --> 01:16:04,840
And I'm going to keep track of these two points. Midpoint is a medium.

653
01:16:05,410 --> 01:16:09,970
B, the point is the average average of all point, except for the worst point.

654
01:16:10,120 --> 01:16:16,570
So that's the midpoint total line is that this line the from the worst point to the midpoint.

655
01:16:16,960 --> 01:16:20,410
And what is the slope, you know.

656
01:16:21,250 --> 01:16:27,490
So slope intercept for for these values. So those are those are the things I need to keep track of.

657
01:16:28,480 --> 01:16:36,070
And here, as you probably see, there's a lot of global assignment because when you when you run this function,

658
01:16:36,220 --> 01:16:40,880
it it has to update the value that are outside of this function.

659
01:16:40,900 --> 01:16:44,320
So this is a good use of using the global assignment here.

660
01:16:44,680 --> 01:16:52,870
Okay. So update extreme, basically trying to find the best point, worst point and second worst point.

661
01:16:53,200 --> 01:16:59,820
And it does it does go through all these points and try to figure out which one.

662
01:16:59,970 --> 01:17:05,970
The best choice. Second best one is the worst. I'm not going to go into the detail, but it should be very straightforward.

663
01:17:06,990 --> 01:17:19,620
UPDATE The meat is basically I'm going to exclude the worst point and use the rest of them to calculate the mean that that's that's updating midpoint.

664
01:17:20,130 --> 01:17:28,550
After that, the two line is basically just the difference between the worst point, worst point and the midpoint.

665
01:17:28,570 --> 01:17:35,640
And then those will give you a vector of direction going from the worst point to the to the midpoint.

666
01:17:36,000 --> 01:17:41,880
Okay. So, so then.

667
01:17:45,200 --> 01:17:48,410
Okay. So so we have one minute.

668
01:17:48,590 --> 01:17:57,530
Okay. So this update next point is basically where we're going to evaluate the functional function value in this axis,

669
01:17:57,980 --> 01:18:01,940
but trying to find different step scale.

670
01:18:01,940 --> 01:18:07,550
So if this step scale becomes negative one, that means I'm going to find a reflection point.

671
01:18:08,330 --> 01:18:14,630
If not, I'm going to find if it's negative two is I'm trying to find the expansion, so on.

672
01:18:15,410 --> 01:18:24,770
So that's the part that this function is doing and I can explain the contract simplex function in the next lecture.

673
01:18:24,890 --> 01:18:29,870
So we're almost done with explaining the simple math.

674
01:18:32,090 --> 01:18:39,889
Okay, so let's continue it. If you have any questions, feel free to combine it as a question or comfort.

675
01:18:39,890 --> 01:18:40,370
Okay, so.

