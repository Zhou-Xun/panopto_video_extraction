1
00:00:04,290 --> 00:00:18,240
Do you think that you might just not be worth so much anyway?

2
00:00:18,360 --> 00:00:27,360
Let's just start, I guess. Let's see.

3
00:00:29,160 --> 00:00:36,210
I guess the first thing is that, like you said, the homework thing today is another homework.

4
00:00:39,960 --> 00:00:46,920
I guess I do slightly after the break on Tuesday, and I just posted the first quiz as well.

5
00:00:46,920 --> 00:00:50,190
So it's the things that are coming up.

6
00:00:54,620 --> 00:01:10,210
So it's. I guess the first thing for the second homework, I guess you have to read a numbers from a file.

7
00:01:10,220 --> 00:01:19,430
I think you just do that. You mentioned it before. The way you the way you read it in is exactly the same as the example we had in class.

8
00:01:20,870 --> 00:01:31,519
You just have to declare yourself to declare a number, basically that you're reading it rather than a string.

9
00:01:31,520 --> 00:01:36,730
It should work because the the file is the file is a bunch of numbers.

10
00:01:36,860 --> 00:01:44,510
You should should just like double x.

11
00:01:46,370 --> 00:01:51,189
You just have to do like double. AX.

12
00:01:51,190 --> 00:02:13,830
And then what is it like? I have I have stream, so I have stream ISIS and whatever the name of the file is.

13
00:02:19,790 --> 00:02:33,840
And then you just two while. Yeah.

14
00:02:33,870 --> 00:02:43,350
Savile size. So it should be. And then, like x x should kind of automatically it should automatically read it in as a double click.

15
00:02:44,250 --> 00:02:53,670
So that's all I have to change. Uh, like last time we had a text file where this was a strange kind of line was a strange thing.

16
00:02:54,610 --> 00:02:58,379
If you just change it to double, it should kind of work out automatically.

17
00:02:58,380 --> 00:03:06,240
It should read it in as a double sentence from the American text.

18
00:03:06,900 --> 00:03:11,790
I think that's the name of it are numeric values, dot text, whatever the name of it is.

19
00:03:14,590 --> 00:03:17,660
And you started mentioned that I don't think I mentioned an example.

20
00:03:17,670 --> 00:03:20,740
It was numbers in a in a text file.

21
00:03:20,880 --> 00:03:28,560
Okay. So today's topic is basically arrays and pointers for the most part.

22
00:03:31,170 --> 00:03:34,850
All right. So this is just a review, a little bit of a review exercise.

23
00:03:34,860 --> 00:03:43,600
So it's like a review example to make sure we kind of kind of remember this, all the syntax.

24
00:03:43,620 --> 00:03:51,360
Let's say you wanted to write a function to integer vectors as arguments so you can have vectors as arguments.

25
00:03:52,140 --> 00:03:58,440
And then we want to compute the number of common elements from the two vectors

26
00:03:58,440 --> 00:04:03,720
and then just return the number so the number of column of its common element.

27
00:04:03,740 --> 00:04:08,160
So you probably want that function to return a integer type.

28
00:04:10,800 --> 00:04:16,440
That's just what I had heard of this. And then you have to declare the type for a function.

29
00:04:16,440 --> 00:04:22,950
If it returns a type, if it doesn't return anything, you just declare it as a void type.

30
00:04:23,700 --> 00:04:29,249
So I have to declare it as an integer type. And then here the two arguments.

31
00:04:29,250 --> 00:04:34,290
You also have to declare the type of the arguments. So these are integer vectors.

32
00:04:37,050 --> 00:04:44,430
And then I guess I was you could modify it so that they don't have the same length,

33
00:04:44,430 --> 00:04:50,480
but I'm just assuming that the two vectors have the same length that we want to look at.

34
00:04:51,600 --> 00:04:56,250
I have a number of common elements.

35
00:04:56,370 --> 00:05:04,800
Okay. So you can just do a loop based loop over each element of, of, of the two vectors.

36
00:05:04,810 --> 00:05:11,000
So here we start from zero and go up to the size of the vector.

37
00:05:11,010 --> 00:05:17,670
So we don't, we don't include the length, the size of the vector, the size of the vector minus one.

38
00:05:18,570 --> 00:05:23,580
And if it's if there equal if v one.

39
00:05:24,010 --> 00:05:27,719
Okay. This is wrong. Actually.

40
00:05:27,720 --> 00:05:31,440
Sorry. Should be pi.

41
00:05:31,530 --> 00:05:35,830
Sorry because the index wrong. Okay.

42
00:05:35,910 --> 00:05:41,550
So I didn't test this method. That index just should be like instead of k.

43
00:05:42,120 --> 00:05:52,500
I'll change that. So if we want to i equals v to align and then you increase this variable here by one num common,

44
00:05:53,100 --> 00:05:57,510
you just do the thing that we're going to return at the end. This is the number of common elements.

45
00:05:58,020 --> 00:06:02,460
So if they're the same, you just increase that by one and then you just return that at the end.

46
00:06:02,580 --> 00:06:09,870
Okay, this is kind of how you would do that. I just you should just replace K with ISO, kind of fix that.

47
00:06:11,400 --> 00:06:14,790
Okay. So I was just kind of, I think a review exercise.

48
00:06:14,790 --> 00:06:25,110
I mean, I think you should just it's more just to be familiar with the syntax and then just remembering that,

49
00:06:26,550 --> 00:06:31,460
remembering you should basically declare everything you do in C++.

50
00:06:31,500 --> 00:06:39,570
You should be declaring the type of the function and the the type of the arguments and the type for every variable you use inside the function.

51
00:06:40,320 --> 00:06:47,580
Okay. So here I, we did this, I just did this last time.

52
00:06:47,580 --> 00:06:53,100
But just basically to start off from where we did, where we ended last time.

53
00:06:53,100 --> 00:06:56,220
So this is an example of using a map.

54
00:06:56,910 --> 00:07:13,139
So here I just this example, we wanted to create a map where kind of the keys of the map were the four words and then the values were integers, right?

55
00:07:13,140 --> 00:07:17,130
So number maps just contain key value pairs.

56
00:07:17,910 --> 00:07:27,390
So here that in this example, the key is all the words from the associated values, the number of times that.

57
00:07:27,560 --> 00:07:38,840
It appeared in the document. Okay. So this is basically how we did it is the key computation is actually just one line,

58
00:07:39,320 --> 00:07:47,750
more or less like once you declare the map, it's actually not that hard to do this type of computation.

59
00:07:48,170 --> 00:08:04,100
All you have to do is do this increment the value associated with a a the word s kind of every time you see it, basically.

60
00:08:04,190 --> 00:08:08,179
So every time, every time you read in a word.

61
00:08:08,180 --> 00:08:18,740
S If it's not there, the value associated with that word becomes one.

62
00:08:19,280 --> 00:08:22,370
If it's already there, you increase the value associated with that key.

63
00:08:22,640 --> 00:08:29,480
Okay. So it's really that all of the computation is basically in here in this line.

64
00:08:30,320 --> 00:08:36,500
The rest of it is just either declaring the types of certain variables.

65
00:08:37,190 --> 00:08:39,469
And then here is this more or less. This is just printing.

66
00:08:39,470 --> 00:08:45,620
Now, printing out the results and this is just showing how to do that for maps if you want to.

67
00:08:46,700 --> 00:08:55,370
If you have an iterator to a map, the way you print out the keys is this i t arrow first is that's how you do it.

68
00:08:55,820 --> 00:09:03,680
If you're printing out the value of from entering from an iterator to a mapping to this and the name of the iterator,

69
00:09:03,680 --> 00:09:06,840
and then the arrow to the, the word second. Okay.

70
00:09:06,860 --> 00:09:13,640
So that's just basically an example of how you can print out components of a map, which is really the point of that.

71
00:09:14,880 --> 00:09:20,600
Okay. I think that's where we start last. Yeah, this is just a screenshot of what you get when you run it.

72
00:09:21,290 --> 00:09:24,860
Okay. So I think that's basically where we stopped last time.

73
00:09:26,060 --> 00:09:29,870
So the next topic is arrays. So arrays.

74
00:09:33,860 --> 00:09:43,850
So I guess we'll just give a general definition of an array. Plus an array is really just kind of a collection of elements of the same type.

75
00:09:46,610 --> 00:09:56,780
And I guess this is important at least to if you really want to know how a raid worked,

76
00:09:57,350 --> 00:10:02,810
it's important that they're stored in kind of neighboring locations of memory.

77
00:10:03,710 --> 00:10:14,210
So you can think of the computer as kind of memory locations, which are you can think of them as boxes, which store numbers or something like that.

78
00:10:14,400 --> 00:10:22,580
And I just it's kind of a collection of neighboring boxes, basically, that store kind of a collection of items.

79
00:10:24,440 --> 00:10:30,860
So the reason, you know, kind of similar to vectors, at least in the way that you can use them,

80
00:10:31,500 --> 00:10:37,309
are similar in that they store kind of a collection of items of the same type and that the ordering

81
00:10:37,310 --> 00:10:44,930
matter is like the first element of the array really refers to kind of the first element of the array.

82
00:10:45,920 --> 00:10:52,790
It's not like an ordered unordered collection of items like a set, so they're definitely similar in that sense.

83
00:10:54,830 --> 00:11:11,000
However, I guess with what's built in to arrays and it's not as many like special I guess methods or features in an array like you have with vectors.

84
00:11:11,000 --> 00:11:21,650
So vectors is like kind of a special built built up type that's not part of like we used to have built in features of C++.

85
00:11:22,340 --> 00:11:32,900
So vectors kind of have a lot of nice extra capabilities that are added, but arrays are really a more kind of fundamental component of single supply.

86
00:11:32,910 --> 00:11:38,030
So they're not part of the and still library.

87
00:11:38,030 --> 00:11:43,250
So you don't really you can use them automatically. You don't have to do any kind of include to use them.

88
00:11:46,970 --> 00:11:55,700
One of the other main differences is that the size of an array cannot be changed after it's after it's declared.

89
00:11:55,700 --> 00:11:59,540
So he can't like add or remove components from an array.

90
00:12:01,180 --> 00:12:12,379
I mean, you could change their value, but you cannot kind of add new components like to an existing array.

91
00:12:12,380 --> 00:12:16,040
So you can't add an extra component once it's been declared.

92
00:12:16,230 --> 00:12:19,240
Okay. Okay.

93
00:12:19,640 --> 00:12:27,350
So I think in that sense, arrays are a little bit more limiting if you just add.

94
00:12:27,420 --> 00:12:35,790
And subtract components as you want. But at what you might gain from this is that you're working with arrays, might be,

95
00:12:37,560 --> 00:12:42,390
in some cases, more, more computationally efficient if you use them correctly.

96
00:12:43,420 --> 00:12:46,980
So that would be the advantage of knowing how to work with arrays.

97
00:12:47,910 --> 00:13:00,330
Okay. So let's see. I guess this is not a major difference, but if you don't initialize an array to certain values,

98
00:13:00,330 --> 00:13:04,170
then they're kind of there's no set rules for what they are.

99
00:13:04,170 --> 00:13:10,950
They kind of you can kind of get crazy values for your for the initial values of an array if you don't set it.

100
00:13:10,950 --> 00:13:19,589
It's not like it's not like vectors where if you do an integer vector and you don't initialize it there automatically zero, that's not the case.

101
00:13:19,590 --> 00:13:26,490
Then you kind of get unpredictable values if you don't if you don't give them an initial value.

102
00:13:28,440 --> 00:13:31,739
So one one else other reason for for looking at arrays.

103
00:13:31,740 --> 00:13:39,390
I think there are a few I don't know if you know really the details of how arrays work.

104
00:13:39,960 --> 00:13:45,600
It's kind of a useful way to start understanding kind of memory management in C++.

105
00:13:46,080 --> 00:13:56,910
We'll see that actually later, later on a little bit. Just basically from the connections, I guess the strong connection between arrays and pointers.

106
00:13:57,030 --> 00:14:00,149
So kind of understand arrays,

107
00:14:00,150 --> 00:14:13,110
it's kind of a useful way to start learning about how can control exactly how much memory C++ is using and some of your and some of your programs.

108
00:14:14,370 --> 00:14:17,990
Okay. So here's just started.

109
00:14:19,260 --> 00:14:22,260
Yeah, basically details of how to use arrays.

110
00:14:22,770 --> 00:14:28,139
So the way you declare an array is just you have to specify the type of an array.

111
00:14:28,140 --> 00:14:33,690
So for example in int or a double character array.

112
00:14:34,470 --> 00:14:38,160
So you have to put that here and then whatever the name of the array you choose,

113
00:14:42,690 --> 00:14:48,090
you put that here and then in brackets you have to put the size of the array or the length of the array.

114
00:14:48,540 --> 00:14:54,060
So here it's okay. So that's just how many components are going to be inside of the array.

115
00:14:55,290 --> 00:15:01,079
So it's all K represents here. So all, all the elements of an array are going to have the same type.

116
00:15:01,080 --> 00:15:04,139
So in that sense, it's, it's the same thing as a vector.

117
00:15:04,140 --> 00:15:12,090
So if we did declare this as an end type, all of the kind of, all of the elements should be integers.

118
00:15:15,350 --> 00:15:20,400
What I said before the time. You have to include the type of your array when you're declaring.

119
00:15:21,300 --> 00:15:25,500
So here's an actual example of declaring an array.

120
00:15:25,620 --> 00:15:32,740
If I want to declare an integer array, I can do. Let's say it's called into r, underscore r.

121
00:15:33,600 --> 00:15:37,770
I just have to put the keyword int i n t and then enter.

122
00:15:37,770 --> 00:15:44,730
And then this would be. This is going to be an integer, an array with three with three components.

123
00:15:45,030 --> 00:15:54,450
Okay. So if we do this declaration, we haven't initialize the components to anything.

124
00:15:54,450 --> 00:16:06,540
So if you're actually if you want to run this and print out the like the components of and say, are the IPC crazy values that are stored there?

125
00:16:07,680 --> 00:16:12,510
Here's another example. If you wanted to do it for what?

126
00:16:12,810 --> 00:16:20,340
I think I wanted to put something else after this. It's still backing up if you want to do a double array.

127
00:16:23,310 --> 00:16:29,730
This is size five, not size ten. We start here.

128
00:16:29,730 --> 00:16:37,220
So this is declared an array of doubles with size five typo.

129
00:16:38,130 --> 00:16:41,490
So this is an array of doubles.

130
00:16:41,610 --> 00:16:55,769
Size ten are sort of size five. So if you want to declare an array where you give it an initial specific values that you want to initialize with it,

131
00:16:55,770 --> 00:16:58,410
the way you do it is curly braces.

132
00:16:58,920 --> 00:17:06,420
So if we wanted to give a like integer around called a R, if you wanted to give the initial values, one, two, three.

133
00:17:08,100 --> 00:17:16,200
So this way you just put one, two and three and curly braces and then separate each component with a column.

134
00:17:17,310 --> 00:17:20,910
You don't actually have to test a three here if you want to.

135
00:17:21,210 --> 00:17:31,620
You don't have to, though. If you do this, it kind of automatically, since you have three components inside the curly braces,

136
00:17:31,620 --> 00:17:37,470
it kind of automatically infers that the size of the array is three.

137
00:17:38,460 --> 00:17:46,200
But you can, if you want to estimate the size of this array is three,

138
00:17:48,360 --> 00:17:55,919
but you don't have to include the three since you already have three components inside of the curly braces kind of automatically figures.

139
00:17:55,920 --> 00:18:00,050
It figures out that this array has size three, basically.

140
00:18:01,000 --> 00:18:04,020
Okay. So here, here's just an example.

141
00:18:04,020 --> 00:18:12,010
I think it's just better to just look at examples two. I see what's going on.

142
00:18:12,860 --> 00:18:15,920
Okay, so what is this? What is this going to print out?

143
00:18:15,940 --> 00:18:23,380
So this is so in the first place, the first line of main and we're just declaring an array, but we're not initializing it.

144
00:18:24,700 --> 00:18:30,010
So that's first line and main. So declaring a but not initializing it.

145
00:18:30,970 --> 00:18:37,480
The second line in main, we're declaring an integer a, B and we're giving it three initial values.

146
00:18:38,260 --> 00:18:41,020
And then I guess after that we have to print F statements.

147
00:18:41,020 --> 00:18:47,260
The first one word is printing out or basically just putting out the components of both A and B.

148
00:18:47,830 --> 00:18:53,020
So this is how you print out that. This is how you access the kind of the components of an array.

149
00:18:53,470 --> 00:18:56,500
It's basically the same way as you do with the vectors.

150
00:18:56,500 --> 00:19:02,230
You just use brackets and the indexing starts from zero.

151
00:19:02,290 --> 00:19:07,780
Okay. So this is going to print out the components of A and then the components of piece of the components of A.

152
00:19:08,590 --> 00:19:17,140
Yeah, I don't know what they are. There will be something. And then the components of B should be 42,000, 24 and six.

153
00:19:18,670 --> 00:19:25,239
And then here after those two print statements, we're just modifying the values and then we're putting it out again.

154
00:19:25,240 --> 00:19:31,450
So I think should be the same. It's just at the and the value with index one.

155
00:19:31,450 --> 00:19:36,940
So you can think of it like the second component that should be 23 for both A and B.

156
00:19:37,750 --> 00:19:44,930
Okay. Yeah, that's yeah, that's, that's what's shown here.

157
00:19:44,930 --> 00:19:53,450
So you can see the if we turn out the components of ads has its first one big negative value then it's something else.

158
00:19:53,870 --> 00:20:01,670
Okay so it's kind of unpredictable what that is. And then B is worth, like we said, 40, 20, 24 and six.

159
00:20:02,480 --> 00:20:13,790
And then once we change A one and B one, we can see now that the the second component in both of the is is 23.

160
00:20:15,020 --> 00:20:21,919
So it's just kind of an example of of declaring arrays and what you get after you declare an array.

161
00:20:21,920 --> 00:20:29,940
So accessing the components of an array is basically that you do it the same way as you would with a vector.

162
00:20:30,840 --> 00:20:31,850
So here's just an example.

163
00:20:31,850 --> 00:20:42,560
If you wanted to use an array well without using kind of calling by reference or anything, which we'll do, which we'll do later,

164
00:20:43,610 --> 00:20:49,670
this is how you would use a function and ah, sorry, here's how you would use an array as a function argument.

165
00:20:52,970 --> 00:21:01,970
Okay, so that you don't really have to do much different, you just have to include these brackets when you're declaring kind of the function argument.

166
00:21:01,970 --> 00:21:05,960
So I'm assuming that this argument numbers will be an array.

167
00:21:06,590 --> 00:21:11,930
I just have to include the brackets when I kind of declaring that argument.

168
00:21:12,740 --> 00:21:16,850
So this is going to be, you know, this function, this argument.

169
00:21:16,850 --> 00:21:25,110
We're in a suit. We're assuming that the argument here is as an array with all double types.

170
00:21:25,160 --> 00:21:28,250
So numbers will be an array of all double types.

171
00:21:28,970 --> 00:21:38,460
So and the body of the function we can use, use the assumption that now is an array with all double self.

172
00:21:38,840 --> 00:21:43,190
And this is an example where we're just computing the mean of an array, okay?

173
00:21:43,990 --> 00:21:56,719
A mean of the elements of an array. So here is you can just, you can just we could just initialize a double variable equal to zero.

174
00:21:56,720 --> 00:22:00,500
And here you just add in each iteration of the loop,

175
00:22:00,500 --> 00:22:08,390
you just add the next component in the array divided by the length of the array or the size of the array can use the same word for both.

176
00:22:08,960 --> 00:22:18,530
And here, I guess, is something else I want to point out. If you wanted to use the length of an array in some way in your function you have,

177
00:22:18,890 --> 00:22:27,670
you probably you have to include it as a separate argument, like the the the length is not like this.

178
00:22:27,680 --> 00:22:36,919
It's not a feature that comes with the array by itself, like a vector you can do.

179
00:22:36,920 --> 00:22:45,139
Like if you have a vector V you can access the size of that vector doing v dot size that that's kind of not available

180
00:22:45,140 --> 00:22:54,810
with an array array doesn't have any really does have any extra kind of extra information that that is stored with it.

181
00:22:54,830 --> 00:23:06,260
It's basically because it is storing just the raw, raw numbers by itself that.

182
00:23:08,390 --> 00:23:11,340
It's not just something I point out at your door.

183
00:23:11,600 --> 00:23:19,400
If you want to use an array with with a function, you will probably need an extra argument which has the length of the array,

184
00:23:20,210 --> 00:23:27,380
or unless your function doesn't use the the length in any way.

185
00:23:29,660 --> 00:23:35,170
Okay, here's just an example of what it looks like when you run it in.

186
00:23:35,660 --> 00:23:40,010
If you were to use this function, you might do this in made.

187
00:23:40,010 --> 00:23:47,450
For example, you could declare this declares of an array of of length six gives it all initial values.

188
00:23:47,450 --> 00:23:54,410
And then I just call this function event array as the first argument.

189
00:23:54,430 --> 00:23:57,440
And then the second argument is six since as the length of the array.

190
00:23:58,070 --> 00:24:01,310
And then it just, you know, just pointing out the result.

191
00:24:02,540 --> 00:24:06,110
Okay. So that's how you can use an array in a function.

192
00:24:06,860 --> 00:24:15,020
Okay. So here is some details if you want to do multidimensional arrays.

193
00:24:16,940 --> 00:24:23,809
In this example, I just did a two dimensional artwork array, which is probably the most common thing you'll see.

194
00:24:23,810 --> 00:24:27,950
I mean, you can do kind of higher dimensional arrays if you want to,

195
00:24:27,950 --> 00:24:38,870
but I think probably two dimensional arrays covers kind of the most common example of using multi-dimensional arrays in practice.

196
00:24:40,280 --> 00:24:46,070
So basically with like a two dimensional array, each component of that array is an array itself.

197
00:24:46,970 --> 00:24:50,930
Okay, so that's all it needs. So yeah.

198
00:24:53,120 --> 00:24:58,250
So as an example, let's like declare a two dimensional array.

199
00:24:59,780 --> 00:25:05,000
So for each component of that array is going to have is going to be an array with three elements.

200
00:25:06,500 --> 00:25:07,280
And that's what we're going to do.

201
00:25:07,280 --> 00:25:18,260
So here I have, I've done this is an example of an array with these two components, but each of those components is an array with three components.

202
00:25:18,770 --> 00:25:21,860
I think it's the way that you can interpret this.

203
00:25:22,430 --> 00:25:27,510
So the way you can declare it is the following. And I, I didn't.

204
00:25:27,740 --> 00:25:34,729
Ah, and then the first number in brackets like the length of the array on this array has linked to.

205
00:25:34,730 --> 00:25:44,570
And then I guess the second number is the, the length of, of each array in that, in that larger array I guess is the way to think about it.

206
00:25:45,320 --> 00:25:53,990
So the components of the first array in this larger array are going to have the two components 11, 12 and seven.

207
00:25:54,620 --> 00:26:03,080
And then the second array in this larger array are going to have to have the values five, three and 14.

208
00:26:04,160 --> 00:26:07,220
So this is how you can declare a two dimensional array.

209
00:26:09,710 --> 00:26:13,310
So this is this is just a two dimensional integer array.

210
00:26:14,120 --> 00:26:23,360
I guess I just look and so here oh so here I'll show its what's printed out.

211
00:26:24,500 --> 00:26:30,370
I think this will make more sense when we talk about pointers, but I want to show you it's printed it out anyway.

212
00:26:31,090 --> 00:26:34,960
I think I have a screenshot. Okay.

213
00:26:35,360 --> 00:26:38,839
So what's so here? In this example?

214
00:26:38,840 --> 00:26:45,530
I've just declared a two dimensional array like we had on the previous slide, so we've declared that first.

215
00:26:45,620 --> 00:26:49,550
I'm just going to print out kind of different components of that array.

216
00:26:50,180 --> 00:26:53,650
So in the first C out statement, what am I putting out?

217
00:26:53,660 --> 00:26:55,070
So I'm actually printing out.

218
00:26:57,940 --> 00:27:07,480
So you would think that should print out the this is in some sense prints out like the first the first array of this larger array.

219
00:27:08,500 --> 00:27:14,229
So it kind of does that, but it doesn't print out three numbers.

220
00:27:14,230 --> 00:27:25,209
So it's it's related to the way arrays are, I guess the way arrays work in C++, what this actually does,

221
00:27:25,210 --> 00:27:34,870
it prints out the memory address of the first component of the first array section where it's going to print out.

222
00:27:37,360 --> 00:27:42,190
So does it print out like three numbers? It prints out a memory address.

223
00:27:45,310 --> 00:27:53,740
This one, it prints out the the address of the memory for the first component of the second array.

224
00:27:53,890 --> 00:27:57,490
And ah, so that's what's going to be printed out.

225
00:28:00,760 --> 00:28:08,200
So we'll see why when we, we talk about the relationship between arrays and pointers, we'll see why that makes sense.

226
00:28:09,070 --> 00:28:12,820
So these actually these print statements don't print out numbers.

227
00:28:12,820 --> 00:28:19,930
They print out memory addresses. These these bottom two see out statements.

228
00:28:19,930 --> 00:28:23,469
They will print out numbers. So this this will print out.

229
00:28:23,470 --> 00:28:32,980
So for the this will print out, I guess the third component or however you want to say add this the component with index tissue from the first array,

230
00:28:34,220 --> 00:28:45,940
this will be so print out set. And I think so this kind of index too of the first array and then this printout number

231
00:28:45,940 --> 00:28:53,530
with index two for the second shows this should print out 14 when we run this,

232
00:28:53,530 --> 00:29:00,490
it should print out like two addresses and then it should print out seven and then 14 and say, think what you should see.

233
00:29:02,350 --> 00:29:09,249
Okay. So that's right. And I got it right. So yeah, so this is this is kind of what it looks like if you if you print out I mean,

234
00:29:09,250 --> 00:29:16,240
this the exact address will depend on kind of your on your computer, but it usually looks something like this.

235
00:29:17,320 --> 00:29:25,390
So these are what it turns out, like the address of a location in memory, something like that.

236
00:29:26,080 --> 00:29:32,709
And then it prints out seven and 14. Okay. So the reason for this.

237
00:29:32,710 --> 00:29:44,020
Yeah, what we'll see later when you actually print out an array by itself, like without the rack, like without printing out individual components,

238
00:29:44,350 --> 00:29:54,520
it prints out the location of a memory address so it doesn't print out like a string, a list of numbers.

239
00:29:54,850 --> 00:29:58,290
Okay. So that's that's the way C++ works.

240
00:29:58,300 --> 00:30:02,140
And we'll talk a little bit more about that today.

241
00:30:03,070 --> 00:30:08,620
Okay. So here's another example of this, Larry, and using arrays.

242
00:30:10,090 --> 00:30:18,460
So here's a character array. So you can definitely you're not limited to numbers when you're doing arrays, so you can declare an array of characters.

243
00:30:19,090 --> 00:30:25,389
So here is a character array I'm calling scene.

244
00:30:25,390 --> 00:30:36,010
It has six elements. And then I guess I'm after declaring that I'm just changing the second component of C, it's a capital.

245
00:30:36,250 --> 00:30:40,989
So should you be capital H then capital here now and then?

246
00:30:40,990 --> 00:30:43,059
After that I have a couple print statements.

247
00:30:43,060 --> 00:30:52,510
So what we're doing, first print statement, I'm turning out the first three elements and then the second print statement I'm printing out,

248
00:30:53,680 --> 00:30:59,230
oh, this is actually if you do this print styling,

249
00:30:59,250 --> 00:31:10,390
you can do this as with print F, if you can actually print out all of the arrays, sorry,

250
00:31:10,600 --> 00:31:16,570
not all the arrays, all of the components of an array as a kind of a single string.

251
00:31:17,200 --> 00:31:17,470
Okay.

252
00:31:21,600 --> 00:31:35,860
Quite simply with print out you can actually if you use kind of the right the right percent character like the right character associated with, uh,

253
00:31:36,620 --> 00:31:41,420
with the percent, you can actually print out all of the contents of an array directly,

254
00:31:41,570 --> 00:31:46,040
especially like here, for example, with a, with a character array.

255
00:31:48,640 --> 00:31:51,590
So you can print out all of the contents of an array.

256
00:31:52,250 --> 00:31:59,900
Well, with print f I said before, if you just print out an array directly, it'll print out an address.

257
00:32:00,410 --> 00:32:08,490
I guess that's not always true if you do, if you use the kind of the correct percents,

258
00:32:09,520 --> 00:32:18,170
uh, tag this with print half so that it can print out all of the contents of the array.

259
00:32:19,040 --> 00:32:25,910
However, if you just do like a C out without doing any of this princess style, you know, it should print out an address.

260
00:32:26,600 --> 00:32:31,550
And that's that's what'll happen if you do print F with percent percent percent of this.

261
00:32:33,890 --> 00:32:38,300
So here this is 50% P with this thing it'll print out.

262
00:32:39,420 --> 00:32:44,570
It's really the address of the first element of C is actually what's printed on here.

263
00:32:46,010 --> 00:32:52,820
So here in the first print statement, we just print out the first kind of three letters in this case.

264
00:32:53,300 --> 00:33:00,680
Yeah, go ahead. Okay. You tell the address of each element in that vector or.

265
00:33:00,950 --> 00:33:08,000
Oh, yeah, I'll show later how to do it.

266
00:33:09,750 --> 00:33:16,610
Oh, I mean, I know this is the first address, so that's because the when you print out the like an array by itself,

267
00:33:16,610 --> 00:33:21,210
it's always the it's always does the the address of the first element.

268
00:33:21,230 --> 00:33:27,860
That's just how the array works. So there is a way to do that.

269
00:33:28,010 --> 00:33:32,180
The A name. So I guess we'll talk about it in a minute.

270
00:33:32,180 --> 00:33:34,159
So the way the array works,

271
00:33:34,160 --> 00:33:47,540
it's like the all the elements are stored in the neighboring addresses so you can make sure you really want it to know the address of.

272
00:33:51,750 --> 00:33:54,840
Of the neighboring elements. You could just do a.

273
00:33:59,420 --> 00:34:05,290
You know, reference to that to like C one, C bracket one.

274
00:34:07,030 --> 00:34:14,830
Well, actually talking well we're going to talk about how to get the addresses of and well, not just elements of array and really any variable.

275
00:34:15,430 --> 00:34:19,840
Okay. We'll talk about that soon.

276
00:34:20,470 --> 00:34:24,490
But yeah. And as a default like the. Yeah, the reason I just that was the first element.

277
00:34:24,490 --> 00:34:33,010
That's how if you just kind of print out the array by itself, it's always just the first, the address of the first element.

278
00:34:36,430 --> 00:34:40,600
Okay? Yeah. Yeah, I guess. Yeah, we're getting to to do what you're asking.

279
00:34:40,600 --> 00:34:47,170
But yeah, this is just a visual depiction of kind of how a raise or at least how arrays are stored.

280
00:34:48,010 --> 00:34:52,520
So the. The rate.

281
00:34:55,130 --> 00:34:58,250
So I don't know. That's the way to say it.

282
00:34:58,250 --> 00:35:04,210
So the way you do play, if you're doing kind of different computations with an array,

283
00:35:04,220 --> 00:35:12,350
like maybe certain mathematical computations, you the way you work with it is as if you could think of it almost as a vector.

284
00:35:14,450 --> 00:35:20,930
That's fine. So you can do certain computations accessing certain elements.

285
00:35:21,530 --> 00:35:27,430
But the way C++ thinks about arrays, it's actually arrays.

286
00:35:27,440 --> 00:35:31,910
Actually a pointer, which is actually defined in a minute,

287
00:35:32,630 --> 00:35:45,890
which is a pointer is just a variable whose value value is an address actually is actually all a pointer is so few words.

288
00:35:46,340 --> 00:35:55,190
So we think of C C as an array. Its value is actually if you were to actually print out it.

289
00:35:55,310 --> 00:36:00,410
That's why when you print it out, it often prints out something like this, its value as an address.

290
00:36:00,980 --> 00:36:04,280
Okay. And there's also an address that stores this address.

291
00:36:04,280 --> 00:36:16,520
So the value of this address is stored somewhere, but it's kind of not important right now and then the way kind of to the individual.

292
00:36:17,360 --> 00:36:25,519
So when you declare an array the way it's it stores these other characters.

293
00:36:25,520 --> 00:36:34,309
For example, if we're declaring a character, it is it stores these individual characters at these neighboring memory locations.

294
00:36:34,310 --> 00:36:43,910
So I was thinking of this memory. The location of what's stored at the first memory location is h like the first element of the array.

295
00:36:44,330 --> 00:36:48,170
The next element in the array is stored at this neighboring one.

296
00:36:48,290 --> 00:36:55,610
I'm just using this notation. It's like the same, almost the same address, except the last one is B instead of A,

297
00:36:56,210 --> 00:37:01,940
and that the next neighboring memory address is stored the third element of the array.

298
00:37:02,430 --> 00:37:15,920
So that's kind of how it works. So the array itself has the value of an address and then you access certain components of the bracket.

299
00:37:16,250 --> 00:37:20,270
That bracket notation is what allows you to access certain components.

300
00:37:20,270 --> 00:37:34,370
So when you do like C bracket zero, it knows to look at the first element and to look at the basically the value stored at the so.

301
00:37:37,330 --> 00:37:42,700
Knows to look at what's stored at the address of the array as I guess the way to think of it.

302
00:37:42,700 --> 00:37:54,159
And if you do see one, it knows to look at the value of the array and what's stored at the neighboring ones, at the neighboring location of memory.

303
00:37:54,160 --> 00:37:57,250
If you do see bracket two, it will accept it.

304
00:37:59,800 --> 00:38:12,400
What's stored using the memory address to over from the value stored by the array?

305
00:38:12,520 --> 00:38:23,720
It's kind of kind of how it works. So really the value of an array by itself is really just a memory converter.

306
00:38:24,300 --> 00:38:27,660
Yeah. The address and the location, you know.

307
00:38:29,600 --> 00:38:37,010
So that leads us to our next topic, which is planners.

308
00:38:38,930 --> 00:38:47,400
Because as a general definition, a pointer is just a variable that contains the address of a of a variable display.

309
00:38:48,020 --> 00:38:55,190
So the value of a pointer is like an address. So like each data type, there's a corresponding pointer type.

310
00:38:55,190 --> 00:39:04,130
So where you usually denote this is like here's an end to star type, that's a separate type that can contain.

311
00:39:04,940 --> 00:39:09,860
So, and star types contain the addresses of INT type variables.

312
00:39:10,970 --> 00:39:15,860
Double star types contain the addresses of double type variables.

313
00:39:16,790 --> 00:39:24,560
Char R type contains the address of the char variable, etc., etc. Every type and even vector types,

314
00:39:24,980 --> 00:39:30,380
there's a special pointer type for for vectors or integer vectors specifically.

315
00:39:31,290 --> 00:39:35,029
Okay. So that's, that's what a pointer is. That's the general definition.

316
00:39:35,030 --> 00:39:43,430
And I think maybe some examples will kind of clear it, clear out kind of the way it's used.

317
00:39:44,150 --> 00:39:57,440
Okay. So, so if you have any variable X, so you have any variable X where you can access like the location of the, the,

318
00:39:57,560 --> 00:40:05,360
the address of memory where I stored it just to use this ampersand, ampersand x like kind of extracts the,

319
00:40:05,930 --> 00:40:10,400
the memory or the location of memory where that variable is stored.

320
00:40:12,080 --> 00:40:22,370
So let's say, you know, that if the type of X is, is, and so it's an integer type A, the type of ampersand X is and star.

321
00:40:22,790 --> 00:40:31,010
Okay. And if you print out like ampersand of X, it should print out like some kind of memory address.

322
00:40:31,710 --> 00:40:41,790
Okay. So that's that's how you can go from a, like a variable regular variable to a, a memory address.

323
00:40:42,300 --> 00:40:49,770
I could do a vice versa, like going from an address to a, like a value and that's usually called D referencing.

324
00:40:50,880 --> 00:40:58,080
So basically if you have a pointer, which pointer is just an address or the value, a pointer is an address.

325
00:40:58,560 --> 00:41:06,270
If you want to see what's stored in that address, that's called D, referencing the way you do that is just is just start.

326
00:41:06,510 --> 00:41:15,150
So let's say X is a pointer. If you want to see, I guess, the values stored in the the address of the pointer.

327
00:41:15,960 --> 00:41:18,990
You can just do star of X. Okay.

328
00:41:19,860 --> 00:41:23,880
You can actually do X bracket zero. That actually does the same thing.

329
00:41:25,810 --> 00:41:32,020
So you can see that little boy that kind of works with a raise. So if you think of a ray as like technically being a pointer.

330
00:41:32,470 --> 00:41:43,580
So if X is a pointer and X of zero actually looks at what's stored at the address stored by x.

331
00:41:43,580 --> 00:41:56,950
So remember that for an array the values stored by the array are value stored by a right is the address of the first element in the array.

332
00:41:56,950 --> 00:42:06,100
So if I d reference that using an xa0, that should be that should give us kind of a number that's stored in the first element of the array.

333
00:42:07,570 --> 00:42:16,660
So that's kind of a new kind of y, that type of bracket.

334
00:42:16,660 --> 00:42:20,680
Zero works at least if you think of an array as a pointer.

335
00:42:22,840 --> 00:42:28,510
Okay. So if a pointer points to nothing.

336
00:42:28,510 --> 00:42:35,560
So I guess the way that's generally phrased is like a pointer usually points to something

337
00:42:36,400 --> 00:42:45,160
that just means that the address that it stores inside something is stored there.

338
00:42:45,710 --> 00:42:50,170
Right? So if you have a pointer X, it might point to a variable called Z.

339
00:42:52,240 --> 00:43:01,209
And so all that means is that the pointer X stores the A memory location where the value Z is stored.

340
00:43:01,210 --> 00:43:05,290
So let's say Z is integer to stored somewhere.

341
00:43:06,370 --> 00:43:19,810
We'll say that X points to Z. If Z if x kind of stores that memory load X has the memory location where kind of the number Z is stored.

342
00:43:20,290 --> 00:43:29,260
That's kind of the way the terminal is usually used, like X is pointing to Z, it's kind of pointing to where Z is stored.

343
00:43:30,550 --> 00:43:34,570
However, you can I mean, you can declare a pointer where it kind of points to nothing.

344
00:43:34,570 --> 00:43:37,930
There's no like variable associated with that.

345
00:43:40,420 --> 00:43:48,850
In that case, I usually do usually assign the value multiple.

346
00:43:48,970 --> 00:43:56,660
Okay. You don't just kind of declare. So I think I said that.

347
00:43:59,810 --> 00:44:06,650
Yeah. Yeah. You want to declare it? Yeah, you want to when you declared if you don't have a variable in mind, usually want to assign it to null.

348
00:44:07,330 --> 00:44:09,860
Okay. Okay.

349
00:44:10,190 --> 00:44:22,430
I just because I think if there's a variety of things that can go wrong, if you don't assign into something initially, it could be, you know,

350
00:44:22,520 --> 00:44:33,829
to be assigned to a variable address, which is which is kind of valid in some sense, which or some other variable is stored there later on.

351
00:44:33,830 --> 00:44:38,570
And you kind of you don't realize that something's already pointing to that.

352
00:44:39,020 --> 00:44:42,380
I think there's other errors that could be can happen as well.

353
00:44:43,310 --> 00:44:49,100
So in general, yeah, I guess this is the general recommended recommendation.

354
00:44:50,520 --> 00:44:56,400
You don't want to declare an initialized pointer basically is, I think, a good rule to follow.

355
00:44:56,420 --> 00:45:03,079
So this is this is an example of declaring an initialized pointer, basically.

356
00:45:03,080 --> 00:45:06,560
So there's no kind of address that we're assigning it initially.

357
00:45:08,530 --> 00:45:13,939
So this yeah, this is an example of declaring an initialized integer pointer.

358
00:45:13,940 --> 00:45:17,480
So this is this is okay. I mean, this is fine to use.

359
00:45:18,140 --> 00:45:26,270
But yeah, I would not it's not recommended to do this without kind of giving it an initial value.

360
00:45:26,270 --> 00:45:29,370
So the way you declare a pointer is with this star.

361
00:45:30,270 --> 00:45:35,840
I just put a star before the kind of the name of the variable. So this declares integer type pointer.

362
00:45:36,920 --> 00:45:44,569
So if we don't want to so if we don't have any kind of address that we want it to point to,

363
00:45:44,570 --> 00:45:49,040
like we don't have that anything in mind when we declare it. You can just do null.

364
00:45:49,130 --> 00:45:53,380
That's kind of the usual way of doing it. Okay, we just declare it.

365
00:45:53,390 --> 00:45:54,770
We just set it equal to non.

366
00:45:56,570 --> 00:46:04,430
If we wanted to point to like a specific variable or like the is, what you're really doing is pointing to the the address of a particular variable.

367
00:46:04,560 --> 00:46:09,380
The way to do it is this. So let's say we have this integer variable x.

368
00:46:09,860 --> 00:46:17,240
If I wanted to point to x, if I want point underscore there 2.2 x, I just do star point where equals.

369
00:46:19,000 --> 00:46:25,270
Ampersand of X and remember, ampersand of X is like the the memory associated with X.

370
00:46:25,330 --> 00:46:28,660
This one is stored in this memory location.

371
00:46:28,870 --> 00:46:32,560
Okay. So that's how you initialize a pointer.

372
00:46:36,280 --> 00:46:42,190
Okay. Here's just an example, I think, just to hopefully make it a little bit more clear.

373
00:46:42,670 --> 00:46:49,840
So here we have an example where declaring a variable A is integer variable and we want to initialize a pointer.

374
00:46:49,900 --> 00:46:58,720
I guess I said a pointer. And then we after doing that, we assign the pointer the address of a.

375
00:46:58,750 --> 00:47:08,170
So here in the first line we're just declaring the variable A so it has a value and it also has like an address or kind of that values stored.

376
00:47:08,830 --> 00:47:13,660
And in the second line, we're basically declaring a pointer, kind of a null pointer.

377
00:47:14,260 --> 00:47:21,340
And then here in the the third line and main or assigning the pointer a different address, all that.

378
00:47:22,150 --> 00:47:25,750
And then I guess the last one and he's pointing it out. So I'm putting everything out.

379
00:47:25,750 --> 00:47:29,860
So here in this print statement, we're printing the value, so that should be one.

380
00:47:30,790 --> 00:47:35,290
And then the next thing we're putting out as we're printing out the value of the pointer.

381
00:47:36,250 --> 00:47:39,940
Okay. So the pointer is that should be an address.

382
00:47:40,850 --> 00:47:44,980
So I think percent P is used to print out the contents of a pointer.

383
00:47:46,000 --> 00:47:50,990
And then then the last thing we're printing out is Star and P, so.

384
00:47:52,150 --> 00:47:56,530
Oh yeah. So I guess this part tells me what's being printed out.

385
00:47:56,530 --> 00:48:01,570
So A and P, which is address and then start.

386
00:48:02,470 --> 00:48:05,470
So remember star P is D referencing the pointer.

387
00:48:05,470 --> 00:48:10,990
So it's it's printing out whatever is stored in that in that memory location.

388
00:48:10,990 --> 00:48:14,290
So it should be should be one as well.

389
00:48:14,590 --> 00:48:24,010
Right. Because the pointer stores the memory address of any reference that just prints out the value of a, which is one.

390
00:48:24,640 --> 00:48:30,070
So you can see that here. The first thing figured out is basically the one and we print out the value of the

391
00:48:30,070 --> 00:48:35,649
pointer is the second thing and then we print out the value of the reference pointer,

392
00:48:35,650 --> 00:48:43,720
which is one of the pointers a little bit more clear.

393
00:48:44,320 --> 00:48:50,380
So that is the pointer value of the value of a pointer is an address.

394
00:48:52,870 --> 00:48:58,479
Most important thing to keep in mind over here is you got one more example.

395
00:48:58,480 --> 00:49:11,110
I think it's necessary, but trust me, it's another exercise just to make sure we're clear or at least more clear on how pointers work.

396
00:49:11,830 --> 00:49:22,840
So here we have in main, we have we're declaring two integer variables, A and B in the second line and main, we're declaring a null pointer.

397
00:49:23,350 --> 00:49:32,620
And then the third line and main, I'm assigning the address of A to p p as a pointer.

398
00:49:33,730 --> 00:49:38,800
So after running these, the first three lines, P is a pointer and it stores the address of that.

399
00:49:39,640 --> 00:49:44,800
So let me do this first print statement and print out the value of a, which is one,

400
00:49:45,730 --> 00:49:50,110
and it should print out the the address of A is the second thing you should print

401
00:49:50,110 --> 00:49:55,120
out and then it should print out what stored at that that address which is one.

402
00:49:55,120 --> 00:50:00,280
So this is p has the address of A, so I should print out one.

403
00:50:01,870 --> 00:50:05,499
So I think that should be the first print statement. All right.

404
00:50:05,500 --> 00:50:11,710
So now when we do this, P equals ampersand, a, B, so what?

405
00:50:12,010 --> 00:50:19,570
What changed? So P now has the address of B, that's basically the only thing that's changed.

406
00:50:20,760 --> 00:50:31,420
Okay. So now when we do the second print statement, it should print out the value of P, which is two, and it should print out the address of B.

407
00:50:32,230 --> 00:50:39,420
So the address will be different than the previous print statement, since it has the address of B and then you print out.

408
00:50:39,430 --> 00:50:47,410
This is actually just an alternative way of DE referencing. So I think it should print out too, since P now has the address of B.

409
00:50:49,270 --> 00:50:57,850
All right. So now let's go to this line where we have now we change the value of B to three.

410
00:50:58,840 --> 00:51:03,070
So when we do this print statement first printing out the value of B, which is three.

411
00:51:03,910 --> 00:51:13,690
So we should find out the P, which is the address of B, so it should print out the same address as the previous print statement.

412
00:51:14,230 --> 00:51:18,220
And then the last one, it should point out that D referenced value P, which is.

413
00:51:18,300 --> 00:51:23,100
Just three. So should three address three?

414
00:51:26,640 --> 00:51:34,020
Right. So even though we didn't update the value, we didn't update P in any way between these two statements.

415
00:51:34,020 --> 00:51:40,400
But here the direct point to do with the D referenced key is it should print out a different number.

416
00:51:40,410 --> 00:51:47,460
That's because the value at the addressed store by P has changed.

417
00:51:47,690 --> 00:51:51,810
Okay, so that's kind of the main thing that's changed to these two prints.

418
00:51:52,140 --> 00:52:00,690
So we didn't reference the pointer, even though that the pointer hasn't changed to D reference it, it it should have a different value.

419
00:52:01,990 --> 00:52:07,260
Okay. So that's yeah, we can see that here. So we have a first statement.

420
00:52:07,260 --> 00:52:13,080
We have prints of 80 to 1, the address of A and then the reference value P, which is one.

421
00:52:13,920 --> 00:52:21,390
And then to the address of B, the reference which is two.

422
00:52:22,380 --> 00:52:32,060
And here we have last line b03. And here this is putting out the value of the pointer and it should be the same as the previous print statement.

423
00:52:32,410 --> 00:52:38,230
And since it's still the address of B and here we didn't reference it to print out the value of B,

424
00:52:39,450 --> 00:52:48,359
since it was just another example which hopefully makes the pointers work a little more clear.

425
00:52:48,360 --> 00:52:56,880
So I did a oh, this not fit in. I need to readjust that PDA.

426
00:53:00,270 --> 00:53:06,820
Oh. Some kind of mystic.

427
00:53:07,360 --> 00:53:07,659
Okay.

428
00:53:07,660 --> 00:53:18,489
So, yeah, this was just I think we walked through it before, but this is just kind of a series of slides that was supposed to clarify it a little bit.

429
00:53:18,490 --> 00:53:31,290
So like when we run this first series of lines like a has the value one because the value to and the P as a pointer which has the added.

430
00:53:33,370 --> 00:53:36,969
Oh yeah, it has a it doesn't have an address related to this at all.

431
00:53:36,970 --> 00:53:48,220
So it has a totally different address from AP that when we do this assignment of the address of A to P,

432
00:53:48,880 --> 00:54:00,790
so now the address is, I'll say the value of the pointer is the address and that's kind of how it works.

433
00:54:01,810 --> 00:54:07,180
So the, you know, so the pointer has its own address where the the address is stored.

434
00:54:07,400 --> 00:54:15,640
So it's this thing, but the value of a pointer is, it is an address itself and it's the address of what's going to happen.

435
00:54:16,390 --> 00:54:21,170
So think about it here. Yeah.

436
00:54:21,190 --> 00:54:24,880
In this case, I didn't show up in here the way you do this assignment.

437
00:54:25,900 --> 00:54:33,430
And in that example, the value of the pointer is now the address of B, so we can't see it,

438
00:54:33,430 --> 00:54:41,710
but it's supposed to be the the address of B is stored here and you could see here and the address of the pointer didn't change.

439
00:54:42,460 --> 00:54:48,640
So it was the same thing as if we had it for the value of the pointer is different so the value is down

440
00:54:48,640 --> 00:54:56,770
here will stores the address and B so here the next thing we change which is B is equal to three.

441
00:54:57,550 --> 00:55:02,980
So none of the other addresses change. The value of the pointer didn't change.

442
00:55:02,980 --> 00:55:10,780
None of these other addresses changed. The only thing that changes the value of D, which is three and the previous example was two.

443
00:55:10,780 --> 00:55:15,960
So now it's three. Okay. I think that was it then.

444
00:55:15,990 --> 00:55:19,840
That was kind of all of the things that we changed in that example.

445
00:55:19,840 --> 00:55:29,650
We start out with keeping a null pointer now and then we signed it.

446
00:55:32,150 --> 00:55:42,309
I want to go back and go back to the last example to repeat, to explain why we didn't change the people.

447
00:55:42,310 --> 00:55:53,740
Still, we got the update. So for us, for line ten oh, going from like line nine to line 11.

448
00:55:54,430 --> 00:56:16,690
Okay. So the P and so P, yeah, so p0p, its value is the address where once we did this assignment, so the value of P is the address where B is stored.

449
00:56:16,870 --> 00:56:21,760
Okay. That's its value when we do this P of zero.

450
00:56:24,930 --> 00:56:28,200
That that gives us the.

451
00:56:30,640 --> 00:56:33,890
The value of the thing that's stored at that address.

452
00:56:33,900 --> 00:56:41,340
So like the like the value of P itself is this address, 0x7f, whatever.

453
00:56:42,240 --> 00:56:48,390
So that's like a location of memory that the value that stored at that location of memory is two.

454
00:56:49,080 --> 00:57:00,390
So that's kind of what that means. And this and this line, when we do P equals three, that's basically changing the value stored at the address.

455
00:57:03,020 --> 00:57:09,140
Basically the change, the number that's stored at this this address here that ends in 94.

456
00:57:10,970 --> 00:57:16,580
So that's why this is when you print out P, the address doesn't change.

457
00:57:16,580 --> 00:57:27,450
But since we did this B equals three, the value stored at this address is different than any other.

458
00:57:31,080 --> 00:57:39,979
Question. Probably, you know, to fix the formatting.

459
00:57:39,980 --> 00:57:44,209
I think converting it to PDF messed it up. I'll try to fix that.

460
00:57:44,210 --> 00:57:51,080
But yeah, I think that it's probably good to go through the example if it's if it's not 100% clear.

461
00:57:52,460 --> 00:57:58,610
Okay. So here, I think I already said that pointers and arrays are strongly related.

462
00:57:58,610 --> 00:58:06,080
Well, in a sense, an array is, is a pointer, but, uh, but when you declare an array,

463
00:58:06,320 --> 00:58:15,800
you kind of make sure it ensures that things and neighboring locations of memory are kind of what you wanted.

464
00:58:16,250 --> 00:58:24,500
But an array itself is actually a pointer, so we can see that.

465
00:58:24,500 --> 00:58:31,130
So whenever, like if you just use the name of the array itself or the name of the array, a variable itself,

466
00:58:31,550 --> 00:58:42,560
whenever you use it in any type of an expression, it's really converted into a pointer for its first element.

467
00:58:43,640 --> 00:58:50,840
It's really used it's really converted into like a pointer of its first element.

468
00:58:50,840 --> 00:58:58,630
So it's it stores the the value that it stores is a is an address for the first element of that.

469
00:59:00,560 --> 00:59:05,299
So hopefully you can see that here.

470
00:59:05,300 --> 00:59:09,500
If we do a see out with any you kind see that.

471
00:59:10,100 --> 00:59:15,830
So here we're declaring an array with three elements. It's called a ah, it's an integer array.

472
00:59:18,110 --> 00:59:27,020
If we declare another variable. So this is if we declare a pointer actually we're calling a P here, we're just declaring a pointer to that array.

473
00:59:27,740 --> 00:59:31,330
So this is that this is going to.

474
00:59:32,600 --> 00:59:34,850
So you can declare a pointer to an array.

475
00:59:35,540 --> 00:59:46,700
So when you do that, it actually by default it just the address that it store is just the the address of the, the, the first element of that array.

476
00:59:46,760 --> 00:59:50,090
It's actually what it does when you declare a pointer to an array.

477
00:59:51,560 --> 00:59:59,630
So you can see that we do this statement. So for you see out of air will actually just print out an address.

478
01:00:01,740 --> 01:00:06,490
What you see out of it also. I mean, I think that's a little bit more clear why that's true.

479
01:00:07,990 --> 01:00:12,760
If you do see out of Pete, it'll print out an address of a zero.

480
01:00:17,750 --> 01:00:22,060
Yeah, if you run this yourself, I mean, just run this ad, man.

481
01:00:22,660 --> 01:00:26,550
If you print out the name of an array, it just prints out an address.

482
01:00:26,560 --> 01:00:31,570
It doesn't. I think we saw that before. It doesn't print out like the list of elements of an array.

483
01:00:32,320 --> 01:00:46,930
And unless you're doing print out like a special percent character array with these values stored by the array itself is just it's just an address.

484
01:00:46,930 --> 01:00:49,690
And then what do you do kind of brackets of that it knows to.

485
01:00:50,320 --> 01:01:01,420
If it's bracket zero it kind of extracts the value at just the memory that the array is storing.

486
01:01:02,400 --> 01:01:10,540
If you do the bracket of one and kind of looks at what's stored at the neighboring location of memory, etc., etc.,

487
01:01:10,540 --> 01:01:23,709
if you do like a ah bracket, to that extent, the memory stored by the I guess the value of the array looks kind of to memory locations over.

488
01:01:23,710 --> 01:01:28,480
So that's kind of the way that's the way arrays work. Okay.

489
01:01:30,520 --> 01:01:34,629
I think that yeah, that example just showed that.

490
01:01:34,630 --> 01:01:43,540
But I think that we can use kind of the, the, the name of an array and a pointer kind of interchangeably.

491
01:01:45,070 --> 01:01:48,330
I think this just more examples would show that a little bit.

492
01:01:48,340 --> 01:01:54,970
So here I think it's a similar word declaring an array first called A and then we declare a pointer to that array.

493
01:01:55,570 --> 01:01:59,470
And here we're just printing out our well, this,

494
01:01:59,650 --> 01:02:07,000
these first two print statements where it's printing out the variable itself and then we're printing

495
01:02:07,000 --> 01:02:14,290
out kind of the components of that variable for the kind of the components using this this notation,

496
01:02:14,410 --> 01:02:21,100
I guess we're basically D referencing in a sentence.

497
01:02:21,100 --> 01:02:25,420
And so remember you can think of a zero or P zero as D referencing.

498
01:02:25,990 --> 01:02:37,270
And then when you use a one and a two, that's kind of D referencing in a sense, but d referencing neighboring values of a zero or p zero.

499
01:02:38,260 --> 01:02:43,120
So this should actually print out these two print statements should print out the exact same thing.

500
01:02:43,900 --> 01:02:53,200
So it's kind of declaring an array or using a pointer to that array is pretty much the same thing to see that also here,

501
01:02:53,200 --> 01:03:01,870
if we change the value of and so what does that so this change the value.

502
01:03:02,410 --> 01:03:24,550
So if we do p one equals 23, that just means that the value stored at the memory one over from from p value stored by p should be 23.

503
01:03:25,290 --> 01:03:30,219
Okay. So maybe that's 100% clear.

504
01:03:30,220 --> 01:03:33,580
But now you can see that here.

505
01:03:33,580 --> 01:03:37,240
In both cases, they they turn out the exact same thing.

506
01:03:37,810 --> 01:03:48,850
So even if we change, we do this P one equals 23 that modifies the value stored at that address.

507
01:03:49,210 --> 01:03:54,760
Okay. So you can pick a P a story.

508
01:03:54,760 --> 01:04:02,710
Well, P itself just stores a single address and then P of one.

509
01:04:02,740 --> 01:04:10,870
Basically what that does is kind of it looks at the what's stored at the address one.

510
01:04:11,860 --> 01:04:19,780
One address over from P and it kind of changes the value at that address location.

511
01:04:20,020 --> 01:04:27,280
Okay. And since the array an array is really the value is really just an address itself.

512
01:04:27,280 --> 01:04:40,510
So when we print that out, it'll print out the the values stored at the address so that a one and P one, they kind of refer to the same thing.

513
01:04:41,140 --> 01:04:51,320
So since that the value of that at that address has been changed, when we do have one, there should also be a should also be 23 now.

514
01:04:51,970 --> 01:04:58,240
It should also be changed. Right? So yeah.

515
01:04:58,240 --> 01:05:02,380
Hopefully. Yeah. Yeah. I think I'll mostly finish with that.

516
01:05:02,420 --> 01:05:09,010
Yes. Maybe. Hopefully the picture makes it a little more clear than if the verbal description was 100% clear.

517
01:05:09,430 --> 01:05:18,100
Okay, so here's the list I tried to get the picture in, which is clear as to what's going on.

518
01:05:18,100 --> 01:05:21,340
So here we're declaring this array with three elements.

519
01:05:23,290 --> 01:05:29,670
Okay, so the name of this array is a the value of array.

520
01:05:29,680 --> 01:05:35,860
The array to think of it as just an address. Well, it does have its own address.

521
01:05:36,790 --> 01:05:41,590
So that was really important for this, for this example.

522
01:05:42,100 --> 01:05:50,110
So the value of this array and address and then you could see what are the values stored at the this address.

523
01:05:50,230 --> 01:05:57,850
Okay. So the value stored at this address is 40 to the value stored at the U.

524
01:05:58,690 --> 01:06:03,450
So the value stored at the address value of the array is 42.

525
01:06:03,460 --> 01:06:08,320
Since it's the first element, the neighboring elements in kind of memory.

526
01:06:08,320 --> 01:06:18,260
If you think of memory as kind of a series of locations next to each other at the neighboring element is is 1024.

527
01:06:18,290 --> 01:06:22,690
Since that's the second element of the array and then the next one is six.

528
01:06:23,770 --> 01:06:29,320
Since that's kind of the third element in the array. So this is kind of what's going on when we declare this.

529
01:06:29,330 --> 01:06:32,560
So this is kind of a depiction of what's going on.

530
01:06:32,710 --> 01:06:42,230
You just do this array declaration. So the next thing that happened is we declared this pointer p.

531
01:06:42,850 --> 01:06:49,270
It's pointing to a. Okay. So P is a it's a pointer.

532
01:06:49,270 --> 01:06:53,470
All it stores is an address and it actually just stores.

533
01:06:53,890 --> 01:06:59,980
It would probably be stored at in it. So the address of the pointer would be stored somewhere else.

534
01:06:59,980 --> 01:07:05,630
But the value of the pointer is the exact same value as the array.

535
01:07:06,040 --> 01:07:11,410
Okay. So both the pointer to the array and the array itself, they have the same value.

536
01:07:11,810 --> 01:07:24,880
Is kind of the way to think about it. So the kind of point to this is same thing here.

537
01:07:26,530 --> 01:07:32,800
The address that they have points to the same address here and the value stored in that address is 42.

538
01:07:33,160 --> 01:07:36,520
Okay. So P it's a pointer.

539
01:07:36,610 --> 01:07:47,200
Its value is an address. The address is the exact same address that that's that's that the array stores.

540
01:07:47,260 --> 01:07:50,739
Okay. It's kind of it's kind of what's going on.

541
01:07:50,740 --> 01:07:59,440
When we first just declared the array and then a pointer to that array, which was the next thing I wanted to say.

542
01:07:59,480 --> 01:08:05,170
Okay, so here is what happened when we did P.

543
01:08:05,590 --> 01:08:10,810
I think the only other thing we modified was saying P one equal 23.

544
01:08:12,460 --> 01:08:17,130
Okay. So really nothing changed with the array.

545
01:08:17,140 --> 01:08:20,590
I mean, the nothing really changed with the array itself.

546
01:08:20,800 --> 01:08:30,610
I mean, if we think of the array as just a name and a and a values stored somewhere.

547
01:08:31,120 --> 01:08:41,290
So this address didn't changed. So if you think of the address as the value of the array, that didn't change, the value of the pointer did not change.

548
01:08:41,440 --> 01:08:52,180
That's all the same. The only thing that changed was what's stored here in the second second, I guess component of the.

549
01:08:53,050 --> 01:08:57,490
The thing that's stored at this memory address. So this is now 23.

550
01:08:59,020 --> 01:09:03,040
That's the only thing that changed when we do this this type of assignment.

551
01:09:04,630 --> 01:09:10,330
So that's why I'm not sure. Oh, that's why when you did that print statement of both,

552
01:09:10,990 --> 01:09:16,899
like the components of it and the components of I guess P or if you want to call them components,

553
01:09:16,900 --> 01:09:23,140
but they're the D reference components of P only to P of zero, p one, etc. That's why they're,

554
01:09:23,300 --> 01:09:29,440
they're exactly the same because, you know, they still have the same address.

555
01:09:29,860 --> 01:09:34,299
Nothing changed. We print a zero. It still prints this one.

556
01:09:34,300 --> 01:09:42,630
We do a of one, it prints this. I have two, it prints this and we do p of zero and prints this p of one and then two.

557
01:09:43,460 --> 01:09:44,320
It's kind of way.

558
01:09:47,090 --> 01:10:00,560
If this type of modification is kind of in a sense it affects both P because all A and P are storing is just this just an address, really?

559
01:10:03,850 --> 01:10:04,149
Okay.

560
01:10:04,150 --> 01:10:18,930
So here I know this is super important for this class, but it's just a little note on how iterator has some similarity to pointers or is there not?

561
01:10:19,060 --> 01:10:25,959
It's not exactly the same thing in the sense that these arrays and pointers are in some sense the exact same thing.

562
01:10:25,960 --> 01:10:32,470
But there's a lot of similarity, similarity between integrators and pointer.

563
01:10:32,470 --> 01:10:42,100
So I guess they're, they're similar in the sense that I guess integrators really point, point to the elements of a container.

564
01:10:43,270 --> 01:10:50,200
So points means this really just stores the address of some kind of value stored inside of a container.

565
01:10:50,210 --> 01:10:54,040
So a container is just something like a map or a vector or a set.

566
01:10:54,880 --> 01:11:03,730
So an iterator is just it's just something that stores the address of something that's stored inside of a container.

567
01:11:05,950 --> 01:11:09,189
So iterator is not a pointer. Exactly.

568
01:11:09,190 --> 01:11:13,540
But you can still kind of use a lot of the as a lot of similarity to a pointer.

569
01:11:13,540 --> 01:11:24,040
And you can use you can use some of the same properties of a pointer, I guess like you can still do deep referencing, right.

570
01:11:24,370 --> 01:11:32,410
So I t in this example is an iterator. So remember we said that integrators are like a separate type somewhere today defined here.

571
01:11:34,030 --> 01:11:42,670
Oh, I guess I only defined it inside of this. So I inside of this loop I t it is, it has an iterator type.

572
01:11:45,280 --> 01:11:57,970
So I guess in this example, yeah, you can, you can de reference kind of an iterator to see what's, what's, what's kind of stored inside of that.

573
01:12:01,200 --> 01:12:05,640
Addressed at the iterator represents spirit.

574
01:12:06,030 --> 01:12:10,049
I just want to show the screenshot so I use an iterator.

575
01:12:10,050 --> 01:12:17,760
The way an interior works is in some sense I have this container of what do we have?

576
01:12:17,760 --> 01:12:23,639
In this example? We have a set that's a type of container.

577
01:12:23,640 --> 01:12:30,209
It's a character set. It's called C-H. So that remember, that's an unordered container.

578
01:12:30,210 --> 01:12:35,910
But you can still iterate over the kind of the contents of a set using an iterator.

579
01:12:36,630 --> 01:12:48,420
I guess the way it works is really when you kind of look at the beginning of, of a set, it really just gives it an address like these.

580
01:12:48,900 --> 01:12:57,000
The iterator is really a pointer to a certain address, which is kind of the address of kind of one component of this set.

581
01:12:58,830 --> 01:13:12,600
And so when you do this, I guess we're not going to talk about the path exactly how it it you can increment the value of an iterator,

582
01:13:12,600 --> 01:13:16,169
but it's kind of the way to think of it.

583
01:13:16,170 --> 01:13:22,560
It's kind of moving over a different memory addresses for this set.

584
01:13:22,620 --> 01:13:34,650
Okay. Here we can see here we're just turning out the values, the values stored by the I.T.

585
01:13:35,370 --> 01:13:41,010
Yes. So it's really just pointing to a certain address.

586
01:13:41,460 --> 01:13:45,330
When we do reference it, it should print out like an element of this set.

587
01:13:45,740 --> 01:13:48,810
So here you can see that here it prints out he okay.

588
01:13:49,500 --> 01:13:57,000
So it's not really necessarily in the same order that we entered to since sets are on order.

589
01:13:57,000 --> 01:14:04,979
I guess it did it did some kind of placement in certain memory locations,

590
01:14:04,980 --> 01:14:15,020
but in the order in that the iterator iterates over the set is not really the order that you necessarily entered it in, right?

591
01:14:15,070 --> 01:14:22,470
Since there doesn't have to be there's no real specific ordering of a set.

592
01:14:22,620 --> 01:14:31,290
And just the way the order in which this prints out is kind of related to how it started, how it stores these characters in memory.

593
01:14:31,740 --> 01:14:41,520
So here it just prints out each element. So in this example, the the only components of this center here just prints it out in this order.

594
01:14:44,520 --> 01:14:54,350
It's. That's all I wanted to talk about today.

595
01:14:57,200 --> 01:15:08,529
Yeah. So that's that's it's, you know, it's it's so there's no there's no class on Wednesday.

596
01:15:08,530 --> 01:15:11,950
So I think I'll see you after the break.

597
01:15:12,610 --> 01:15:17,530
In the other the other questions are about the work or anything.

598
01:15:18,410 --> 01:15:28,780
Would you be able to have the obviously our the Monday after Thanksgiving posted the homework is due on Tuesday and so we are not happy.

599
01:15:28,810 --> 01:15:37,030
Oh, since we're not having um. Yeah, I can do that. I can have an extra set of or an extra office hours.

600
01:15:38,350 --> 01:15:42,790
Ongoing is 3 p.m. work for you already.

601
01:15:45,820 --> 01:15:55,060
Okay. I was just like at the same time. Yeah. I'll have office hours on, on, on 3 p.m. most of whatever that is, like the 20/28.

