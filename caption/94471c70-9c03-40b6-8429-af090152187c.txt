1
00:00:03,250 --> 00:00:14,120
I was just. All right.

2
00:00:15,650 --> 00:00:22,700
Just go ahead and get started. This is coast to coast.

3
00:00:22,880 --> 00:00:35,700
And she like there's a homework we need to freely do online.

4
00:00:35,720 --> 00:00:40,430
Please do not leave. I just told you.

5
00:00:40,880 --> 00:00:54,340
Yes, this is homework. One thing. But if the main things that are playing out with you in terms of trying to do it on the

6
00:00:54,350 --> 00:01:09,229
canvas is a file that has the only R function written on it and the show which prints

7
00:01:09,230 --> 00:01:18,350
out when you run them on King's commands and the order comes out in pasted in a single

8
00:01:18,350 --> 00:01:24,950
file before it's just basically a function definition and kind of what is what.

9
00:01:24,950 --> 00:01:33,230
For example, we run the same thing for a problem to solve, which is to write a function and then run it.

10
00:01:33,380 --> 00:01:45,980
And we are console is the only other thing is now you don't you can list for not for this homework assignment you don't have to worry about kind of.

11
00:01:47,090 --> 00:01:50,239
How to handle incorrect inputs.

12
00:01:50,240 --> 00:01:57,650
So you can assume that the input acts like in this example are both numbers.

13
00:01:57,920 --> 00:02:05,450
You don't have to write something in your function that handles wrong input.

14
00:02:05,450 --> 00:02:14,870
Like if they can draw a character or something, you can use them. You as a student inside your function and X and vice are just are both numbers.

15
00:02:17,130 --> 00:02:24,680
Same thing. Well yeah, these x and y are both vectors.

16
00:02:25,760 --> 00:02:38,040
Numeric vectors, although you can assume that x can also have any values that either contain numbers or in it.

17
00:02:38,060 --> 00:02:44,240
You don't have to worry about other things. So we'll talk about vectors in a today.

18
00:02:47,020 --> 00:02:52,000
All right. So in. Pretty clear any question about that?

19
00:02:54,110 --> 00:02:58,880
So you just submit it through canvas with the upload a file.

20
00:03:00,230 --> 00:03:05,200
I could use the quiz for the quiz.

21
00:03:05,210 --> 00:03:12,080
Yeah, let's just do September 15 at the end of the day, September 15.

22
00:03:12,920 --> 00:03:19,040
Hopefully it's pretty clear once you kind of open up your because let's just have ten questions.

23
00:03:19,160 --> 00:03:23,220
So what you're doing is turning around.

24
00:03:23,360 --> 00:03:30,710
I mean, you are fine or you want to get under format or you can turn that as a green dot or file.

25
00:03:31,370 --> 00:03:35,630
What you're asking. Yeah, yeah, yeah.

26
00:03:35,660 --> 00:03:49,410
Either a dot or file or even I think it's easier to kind of copy and paste the function and, and the output into like a regular text file.

27
00:03:49,410 --> 00:03:54,650
And it's also fine. We can just as long as they're going to.

28
00:03:55,460 --> 00:04:02,990
Are we going to be coding for something or something for the quiz are going to be what quiz are we going to have to write.

29
00:04:03,650 --> 00:04:09,310
Oh no, you don't have to write any code. It's mostly it's really all the same.

30
00:04:09,320 --> 00:04:14,629
There's I mean, there are a couple of things. It's like asking, what is the promise?

31
00:04:14,630 --> 00:04:19,160
Our code, what is it? I don't know. Yeah, you don't have to write anything.

32
00:04:21,210 --> 00:04:32,540
That's clear when you run into.

33
00:04:36,620 --> 00:04:42,440
If you're Mitt Romney. Or send me an email or phone me.

34
00:04:45,680 --> 00:04:56,510
Okay. So when you start for today, the reminders of the big things, whether it be just to keep in mind for next week.

35
00:04:57,410 --> 00:05:12,640
Okay. So yesterday for the financial functions, really the main thing that we cover with default arguments and functions and how to do that.

36
00:05:14,690 --> 00:05:19,940
You talk about comments and are or this is a pretty short section is how to write comments.

37
00:05:19,940 --> 00:05:29,700
In our case, the last and the big topic are our vectors and they don't even do all of the material on next week.

38
00:05:29,750 --> 00:05:33,270
Hopefully most of it. Okay.

39
00:05:33,290 --> 00:05:40,790
So the function stuff that we did, so I guess this is just the reviews to remind us what we did last time.

40
00:05:40,790 --> 00:05:48,240
I think just this is just the format for writing functions in our just there's a

41
00:05:48,290 --> 00:05:55,759
function name and we have an assignment and a keyword function and you kind of write

42
00:05:55,760 --> 00:06:03,510
out the parameters that are needed in your function parameters or arguments to the

43
00:06:03,530 --> 00:06:09,200
things that are the terms that you should think of as input to your function.

44
00:06:09,200 --> 00:06:13,819
And then you need to return something.

45
00:06:13,820 --> 00:06:25,970
I mean, you don't have to explicitly use the return keyword, but if you think about it, you should know what your function is returning.

46
00:06:26,900 --> 00:06:33,139
Okay, so this is just an example of this is a function that is the square of a number.

47
00:06:33,140 --> 00:06:39,140
And sometimes the result is just a reminder what we did last time.

48
00:06:39,140 --> 00:06:46,850
So the thing that we didn't cover was default default values using default values and functions.

49
00:06:47,810 --> 00:07:03,350
So these are basically values for your arguments that are taking view.

50
00:07:03,350 --> 00:07:07,640
If you don't if you don't provide those inputs when you call functions.

51
00:07:10,310 --> 00:07:21,230
So for example, you can write a function that has two arguments, but you only have to give it one or one argument when you call the function.

52
00:07:21,710 --> 00:07:27,260
And if you don't give it the second argument, there is this default values that it uses.

53
00:07:27,860 --> 00:07:33,710
It's really an example of using the default value basically for if you if you use a default value,

54
00:07:34,370 --> 00:07:41,659
if the argument is you provided in the function call, that's the one that it uses.

55
00:07:41,660 --> 00:07:47,540
Right? And so if you give it a value for that argument, that's the one that's used.

56
00:07:48,080 --> 00:07:52,130
But if you don't give it a value, there is kind of some default value that takes.

57
00:07:55,970 --> 00:07:59,750
In general the way we'll see some examples.

58
00:07:59,760 --> 00:08:10,520
I mean, in general, the way to write this, if you have some if you have some kind of arguments that do not have default values,

59
00:08:10,520 --> 00:08:18,230
you usually put those first and then we put the arguments with default values kind of after that.

60
00:08:19,030 --> 00:08:30,110
That's the way I use my function, I think is generally the recommended way to do it, know, although you don't absolutely have to.

61
00:08:30,380 --> 00:08:34,160
This is actually a difference between one difference between our pipeline.

62
00:08:34,160 --> 00:08:43,370
The pipeline kind of forces you to write it from arguments with default and non default values in a certain way,

63
00:08:43,370 --> 00:08:47,479
but or you can write them an arbitrary way,

64
00:08:47,480 --> 00:08:57,350
but I think it's generally less confusing if you put your in the function definition, put the non default,

65
00:08:58,180 --> 00:09:03,140
or there's the arguments without default values before the arguments with default values.

66
00:09:04,120 --> 00:09:10,370
So. Maybe it's just more clear if we look at some examples.

67
00:09:10,380 --> 00:09:25,580
So this is this is an example of a function with to I guess to arguments without in default values two and three is a function of X, Y and Z, X and Y.

68
00:09:26,150 --> 00:09:29,710
You basically don't have any default values, but Z does.

69
00:09:29,720 --> 00:09:32,750
This is what this is what you mean by default.

70
00:09:33,140 --> 00:09:36,380
So the default value in this example is zero.

71
00:09:37,610 --> 00:09:44,810
So this function is just basically to return this because some of these $3 is going to be as numbers.

72
00:09:48,440 --> 00:09:50,820
And that's all value zero zero.

73
00:09:50,840 --> 00:10:01,370
So you don't actually have to always give this function three numbers as in you can do that two numbers as input when you when you call the function.

74
00:10:01,970 --> 00:10:10,549
So as an example, if we do add three and we give it the values one and two, it's just going to give us the sum of one, two, one, zero.

75
00:10:10,550 --> 00:10:13,760
So it should be one plus two plus zero.

76
00:10:16,700 --> 00:10:22,460
We can act. We can actually give Z the numbers zero explicitly when we call it.

77
00:10:23,000 --> 00:10:27,710
So that should also return three. But you could give Z a different number.

78
00:10:28,190 --> 00:10:31,280
So if we give it a different number, we will take that.

79
00:10:31,610 --> 00:10:37,159
So if you add three of one, two and three, that should be the sum of one, two and three.

80
00:10:37,160 --> 00:10:45,410
So that should be six. So the way to interpret this is the default value.

81
00:10:45,410 --> 00:10:54,670
It takes that value if we don't input this number, we of a function, but if we do input, if we call the function,

82
00:10:54,830 --> 00:11:02,510
it takes it takes that input rather than the default, then that's how the following values work.

83
00:11:02,510 --> 00:11:10,680
And again, like I would say, this is the better way to run functions if you're doing if you're using default values.

84
00:11:10,910 --> 00:11:23,790
But the arguments with do not have default values first and then it close with default values after that you.

85
00:11:26,120 --> 00:11:31,040
All right. Oh, so here's just so there's a keyword argument.

86
00:11:31,040 --> 00:11:39,439
This is fewer arguments are really just they don't have anything to do with writing functions.

87
00:11:39,440 --> 00:11:41,299
It's basically how you call the function.

88
00:11:41,300 --> 00:11:50,810
It's just that it's an alternative way of calling functions that's in many cases, it's, it's more clear to call a function using keyword arguments.

89
00:11:53,450 --> 00:11:59,000
So I guess before we've kind of been calling functions just using the right order.

90
00:12:03,650 --> 00:12:15,390
We call it in this way. This one goes to X, two, goes to Y and zero goes to Z because that's their order in the in the function definition.

91
00:12:15,940 --> 00:12:21,690
But you can also call them by name and you can even kind of switch the order if you're, if you're calling them by name.

92
00:12:22,590 --> 00:12:29,820
So you can see that here. If you do well, I'll first mention.

93
00:12:32,110 --> 00:12:42,930
If you use these key words here, if we put like X equals to Y equals two equals one, that's the that's the same thing as doing two, two and one.

94
00:12:43,170 --> 00:12:55,909
Okay. This is probably not the best example to show this because I guess it doesn't matter the order that you add three numbers,

95
00:12:55,910 --> 00:13:01,970
but in general it's still the same type of function call.

96
00:13:02,570 --> 00:13:09,250
Like if you switch this around, y equals two. But I put that first and then x equals two as equals one.

97
00:13:10,820 --> 00:13:17,510
That's really equivalent to doing this function call. It just it just the name is what matters.

98
00:13:20,560 --> 00:13:24,200
If you're putting everything in names, it's the ten.

99
00:13:24,200 --> 00:13:32,260
The names that you give in the function call it matters nothing more.

100
00:13:33,890 --> 00:13:40,490
Now, I usually try to keep the same order if there's really no benefit in switching things around, but you can if you want.

101
00:13:41,210 --> 00:13:50,990
So I think, I mean, the main benefit of using keywords, I think it's you make your code a little bit easier to interpret,

102
00:13:50,990 --> 00:13:54,950
especially if you have a function with quite a few arguments.

103
00:13:56,600 --> 00:14:00,130
If you're looking over your code, it's hard to remember that the.

104
00:14:01,390 --> 00:14:02,990
The first argument debates,

105
00:14:02,990 --> 00:14:11,299
the fifth argument for responding to this sense that makes the code a little bit more readable if you use a keyword argument,

106
00:14:11,300 --> 00:14:15,920
because it kind of helps you to remember, I guess.

107
00:14:19,180 --> 00:14:24,770
What? You know what that is what the purpose of that argument is in the function.

108
00:14:24,930 --> 00:14:36,480
If you if you get it, if you give it a good name. So maybe this this example is a little more clear.

109
00:14:36,990 --> 00:14:44,540
So. Ah, so this. Oh, so this is an example of reason.

110
00:14:44,940 --> 00:14:49,010
Yeah. This is an example of a function with default values.

111
00:14:49,860 --> 00:14:54,690
And I think on the next slide, I also give some examples of calling it with keywords.

112
00:14:55,290 --> 00:15:04,290
So this this is a function called foo. We have two of the arguments that have default values and two that don't.

113
00:15:04,320 --> 00:15:11,820
So again, I put the the two without default arguments before the two with the default arguments.

114
00:15:11,820 --> 00:15:18,900
So I say if w that is just saying if this is true or false.

115
00:15:21,030 --> 00:15:28,860
So if w we do this kind of calculation, it w is not true to do this in this calculation.

116
00:15:31,530 --> 00:15:39,900
So I didn't put the actual in this example. I didn't put the keyword return and usually do.

117
00:15:39,930 --> 00:15:49,020
But just to show that the function is going to return, kind of all the value of the last thing it executes.

118
00:15:49,020 --> 00:15:51,299
So we run this function here.

119
00:15:51,300 --> 00:16:02,010
If W is true, it's going to return this value here in the first part of the if statement, if if it's false, it's going to return.

120
00:16:02,010 --> 00:16:07,860
This is not that kind of corresponds to the last part of the AFL statement.

121
00:16:07,980 --> 00:16:15,230
Okay. So I guess we can see that with the first example we have full of 935 and true.

122
00:16:15,270 --> 00:16:18,840
So we actually kind of gave it all of the arguments.

123
00:16:19,830 --> 00:16:23,300
Okay. So we have nine, so X is nine. Okay.

124
00:16:23,370 --> 00:16:28,020
So first of all, I guess the first thing to notice is that W is true in this example.

125
00:16:28,530 --> 00:16:37,469
So we're going to go here and the F part is going to have a thousand times nine, x is nine,

126
00:16:37,470 --> 00:16:47,160
so it's 9000 plus, other times three 300 plus ten times Z 50 since the is five.

127
00:16:47,520 --> 00:16:53,340
So it should return 9350. Okay, so that's what's going on there.

128
00:16:54,940 --> 00:16:56,550
And you can see here,

129
00:16:57,480 --> 00:17:09,629
this is basically going to give us the same result as if we did not put in true here because it's we just omit w it's going to take its default value.

130
00:17:09,630 --> 00:17:18,420
True. So it gives us kind of gives you the same thing we all made both Z and W, w is still true.

131
00:17:18,420 --> 00:17:26,190
So we, we're going to execute this part of the false statement, but now Z is zero instead of five.

132
00:17:26,340 --> 00:17:29,520
Okay? So just going to be 9000 plus 300.

133
00:17:31,620 --> 00:17:38,250
That's that's what's going on with this function. Let's see, you can do the same thing.

134
00:17:38,460 --> 00:17:43,350
This is not quite the same thing as this. And we can do X and Y.

135
00:17:47,820 --> 00:17:53,130
You can call the function using keyword. So your x is going to be nine and y is five.

136
00:17:54,030 --> 00:18:03,749
That's going to return 9500. It's actually equivalent to doing this, although there's really no reason the reason to do it.

137
00:18:03,750 --> 00:18:07,940
But you can switch the order when you call it. We can.

138
00:18:08,070 --> 00:18:12,030
If we just do, why was five and x equals nine? Then it gives you the same thing.

139
00:18:14,880 --> 00:18:20,790
So actually this it's actually the same thing. Is this so y is equal to five.

140
00:18:21,630 --> 00:18:28,740
You don't need to specify that. You don't have to specify the first argument.

141
00:18:29,010 --> 00:18:37,960
You can automatically treat that as x. Same thing here is going to automatically treat that treat.

142
00:18:38,040 --> 00:18:48,359
The first argument has x and then it will treat z as three and y is five, even though we kind of switch the order of Y and Z.

143
00:18:48,360 --> 00:18:56,339
So here is 915, so and Z is 30.

144
00:18:56,340 --> 00:19:07,050
So that should be 9000 plus 500 plus three since 9530.

145
00:19:09,840 --> 00:19:17,130
Again, I in general, I don't really switch the order around.

146
00:19:18,180 --> 00:19:24,419
Even if I'm using keywords just as a feeling, it's more confusing that it needs to be.

147
00:19:24,420 --> 00:19:38,530
But you can do that in or if you want to, it's still it's really the keyword that matters and determines what is capacity, the function words.

148
00:19:38,880 --> 00:19:48,720
Okay. All right.

149
00:19:48,730 --> 00:20:06,550
We want to see what's going on with this question. So you have this function that has one non one argument with no default value and two, with.

150
00:20:07,750 --> 00:20:14,650
So we call it the so excellent point. So both areas, one is going to be false, right?

151
00:20:17,110 --> 00:20:29,019
And then X is going to be 1.3. Okay. Since I guess the first thing to notice here when we call it so all of our one is false and X is 1.3.

152
00:20:29,020 --> 00:20:38,470
So you can tell from this false statement this is this entire and logical expression is automatically false.

153
00:20:39,250 --> 00:20:44,680
Right over one is false. It kind of doesn't matter what Boulevard two is.

154
00:20:45,220 --> 00:20:48,220
So we're going to go into the last part of the default statement.

155
00:20:52,180 --> 00:20:57,360
So we're going to go down here and then we have like an if statement within this part.

156
00:20:57,370 --> 00:21:02,220
So we have it for right. So well, that's false again, actually.

157
00:21:04,360 --> 00:21:09,940
So Boockvar one also, we do not execute this code, so it just returns this.

158
00:21:12,310 --> 00:21:19,450
So you don't execute this. So just returning to the line that you started with this every half of the function.

159
00:21:20,080 --> 00:21:25,940
So it should return zero. You should return zero.

160
00:21:28,430 --> 00:21:34,490
Because this logical expression is false, and then this logical expression is false.

161
00:21:35,480 --> 00:21:46,200
So you just return the lie that we started off in. It's just another example of.

162
00:21:48,150 --> 00:22:01,420
Oh, yes. Real quick.

163
00:22:03,230 --> 00:22:07,430
So this is a function, I guess you can actually probably do it a number of different ways.

164
00:22:07,430 --> 00:22:20,810
I guess the easiest way is to have, I guess for least five conditions and it fails if changed.

165
00:22:21,470 --> 00:22:25,100
So something like this right here real quick.

166
00:22:25,100 --> 00:22:31,910
So we have like. So functions go to function.

167
00:22:32,510 --> 00:22:42,950
There's only, like, one orange juice, so it'll be.

168
00:22:46,330 --> 00:22:50,350
Oh, there's two arguments. I think there's like, money.

169
00:22:53,260 --> 00:23:06,650
I think it was just. Early.

170
00:23:12,160 --> 00:23:16,780
It was important to you to do something else if.

171
00:23:18,600 --> 00:23:23,910
So if y is equal to one looks.

172
00:23:31,000 --> 00:23:46,410
You could yeah you could also write this as a nested if statement all time that there was like y equal to zero and x is not equal to.

173
00:24:04,310 --> 00:24:11,570
I if serve were zero and zero.

174
00:24:20,260 --> 00:24:26,040
And then that is probably the most straightforward way else.

175
00:24:29,170 --> 00:24:33,640
When you can return something in each case. So.

176
00:24:38,250 --> 00:24:47,690
Do we really determine times x?

177
00:24:47,690 --> 00:24:53,110
If I remember right. The term also the.

178
00:24:59,160 --> 00:25:11,910
Turn your mind. Turn, one turn and return.

179
00:25:13,440 --> 00:25:21,390
This is one way to write the functions of the year.

180
00:25:23,910 --> 00:25:35,340
Okay, so like, if you look back at the it was like if y equals two, that y equals one, you can take the absolute value if.

181
00:25:37,660 --> 00:25:40,770
Why is equal to zero? An x is not equal to zero one.

182
00:25:44,830 --> 00:25:52,680
Which is. Okay.

183
00:25:52,690 --> 00:26:04,390
So that's and then I think the only other case is if Y is equal is not equal to zero or not equal to one, it's not equal to either zero one or two.

184
00:26:04,410 --> 00:26:08,310
We return in a okay. Is it just one way to write it?

185
00:26:10,740 --> 00:26:18,399
You could do some kind of other investigative double statement, just kind of multiple ways of what it is.

186
00:26:18,400 --> 00:26:23,940
It's kind of one way to do it with just a full defensive change,

187
00:26:27,150 --> 00:26:38,280
like was to return our squared one and then the case where Y is not equal to zero one or two, that's kind of covered by this.

188
00:26:39,300 --> 00:26:51,810
If it's not equal to 012 is it's not going to go into any of these other parts.

189
00:26:55,760 --> 00:27:01,370
The other components of the assault of change look and automatically go here.

190
00:27:01,370 --> 00:27:05,209
So the return, it'll return.

191
00:27:05,210 --> 00:27:08,570
In a sense, this is one way of doing it.

192
00:27:11,300 --> 00:27:17,700
So that's one example. Let's see, maybe we'll do this later.

193
00:27:17,720 --> 00:27:23,299
I think it could. This is just another exercise that you can do on your own.

194
00:27:23,300 --> 00:27:30,140
So you could do this one with a thing you could do with a bunch of it statements.

195
00:27:30,150 --> 00:27:36,710
There's probably an easier way to do this. Or there is a lot easier way to do this with using vectors.

196
00:27:37,960 --> 00:27:41,560
Is quickly, infinitely vectors.

197
00:27:41,840 --> 00:27:48,680
So it's kind of an easy way. Like one line within the function that does that.

198
00:27:49,670 --> 00:27:53,600
So I guess the next topic is this.

199
00:27:54,140 --> 00:27:58,280
Oh, it's just something brief. Just briefly mentioning comments.

200
00:27:58,280 --> 00:28:06,209
I mean, I've already had a lot of comments in the R code, so then I would figure it out already,

201
00:28:06,210 --> 00:28:12,320
like just to make sure we know what, what comments are and how to use them.

202
00:28:12,320 --> 00:28:16,220
So comments are just comments you write.

203
00:28:18,380 --> 00:28:25,880
I guess in human language, they're just like notes to yourself or notes to other people if you're sharing your code.

204
00:28:27,260 --> 00:28:36,950
We're basically just notes that kind of, you know, pieces of text that the computer ignores so that the computer ignores it.

205
00:28:37,220 --> 00:28:45,290
It doesn't treat it as our code. Okay. So our code comments are just useful to explain what your code is doing.

206
00:28:45,830 --> 00:28:52,310
I think it's good to have some to use comments somewhat at least, especially if you're happy as your code is.

207
00:28:52,970 --> 00:28:58,430
If it starts to become more complex, it kind of makes your code a lot more readable.

208
00:28:58,950 --> 00:29:02,750
So that explains what your code is doing.

209
00:29:03,620 --> 00:29:07,819
It's helpful for you if you use your code later on.

210
00:29:07,820 --> 00:29:15,139
If you if you can reuse your code after a few weeks or if you're sharing a code, you're sharing a code with others,

211
00:29:15,140 --> 00:29:24,740
I think it's really necessary to write comments and have to explain what the purpose of each piece of code is.

212
00:29:25,520 --> 00:29:27,319
So the code to write comments,

213
00:29:27,320 --> 00:29:41,900
you just write the hash mark the symbol at the beginning and kind of everything on the line following this hash mark is ignored.

214
00:29:41,930 --> 00:29:46,310
So this this is basically an example of a comment I have for the hash mark.

215
00:29:47,820 --> 00:29:53,020
Symbol. And then you write some sentence and you know,

216
00:29:54,360 --> 00:30:03,150
this is a number this kind of this line is not treated as just like something written in human language that might explain something.

217
00:30:03,210 --> 00:30:10,140
Okay. That's the purpose of the comment.

218
00:30:10,140 --> 00:30:16,620
So the comments in are actually just a single line and you don't have multi-line

219
00:30:16,620 --> 00:30:21,540
comments and are so you have to do a separate hash mark for each line.

220
00:30:23,010 --> 00:30:31,620
So there's not like a well, I think there are some tricks you can do to kind of force it to do what you want to one.

221
00:30:32,060 --> 00:30:40,320
But for like a block if you want to write a like a paragraph from the usual

222
00:30:40,320 --> 00:30:45,840
way is just to put a hash mark symbol at the beginning of each of each line.

223
00:30:49,010 --> 00:30:57,919
So here you can see this is an example of comments about our science x the value 42 and I do the same thing,

224
00:30:57,920 --> 00:31:03,979
but I put it after a hash mark a signal that still has the value for it.

225
00:31:03,980 --> 00:31:13,670
This is totally ignore this line. So that's we've seen kind of hash marks in some of the previous hour code.

226
00:31:16,220 --> 00:31:21,680
Those are just comments. So everything so the right of the hash mark is just the comment that's ignored.

227
00:31:22,010 --> 00:31:31,450
Okay. Here's just an example. So you could even have if our code and a comment on the same line up here I have x,

228
00:31:31,760 --> 00:31:36,710
I assign x the value 42 I can put in comments on the same line to the right.

229
00:31:37,280 --> 00:31:40,549
So it's just basically going to ignore everything to the right.

230
00:31:40,550 --> 00:31:45,170
And so you can Chashma Okay. Right.

231
00:31:45,800 --> 00:31:52,250
So I think just the brief comments about comments, you see,

232
00:31:52,270 --> 00:32:06,620
you know what they are and so you can use them when you're writing our code in question before moving on to this collection of functions.

233
00:32:12,690 --> 00:32:19,170
So it's the next yeah, the next big topic is vectors.

234
00:32:21,180 --> 00:32:34,979
So this kind of the main kind of data structures in our view are vectors, view matrices, list and data frames solution for more topics.

235
00:32:34,980 --> 00:32:42,330
Those are kind of the paper which covers the order, although I think we're the only groups in the middle.

236
00:32:42,530 --> 00:32:51,900
Briefly. So the main topics are events and thinking factors is probably the one we spend the most time on.

237
00:32:52,740 --> 00:32:58,620
So I'd say it's kind of the most it's really like the most basic data type in our is the factor.

238
00:32:58,710 --> 00:33:07,560
Okay. So I think I, as I mentioned maybe in the first lecture, even if you kind of try to create a.

239
00:33:09,060 --> 00:33:15,480
A variable that looks like a number are basically automatically treated as a vector.

240
00:33:16,210 --> 00:33:23,700
Right. So if we do this assignment like X assign a value 40 to are automatically treats that as a vector.

241
00:33:23,700 --> 00:33:26,790
It's a factor the vector of the length of one.

242
00:33:27,030 --> 00:33:31,660
Okay. Yeah.

243
00:33:32,440 --> 00:33:35,790
So I just put this here.

244
00:33:35,790 --> 00:33:40,619
This is kind of just to be technically correct.

245
00:33:40,620 --> 00:33:47,070
I guess there's. So it's technically kind of the ah terminology there.

246
00:33:47,810 --> 00:33:54,959
There are really two kinds of factors and ah there's a timing vectors and the list, the lists are technically vectors.

247
00:33:54,960 --> 00:34:03,930
But I think what people normally when people are only use the words the atomic vector is

248
00:34:03,930 --> 00:34:11,610
basically the fact that people just say vectors and are usually talking about atomic vectors.

249
00:34:11,610 --> 00:34:23,250
Atomic vectors are just factors that are homogenous, meaning they have all had the same type of they they, they it's for the same data type.

250
00:34:24,030 --> 00:34:30,210
So you can think of a vector as just simply a collection of objects of the same type.

251
00:34:30,450 --> 00:34:39,989
So the earliest atomic vectors are kind of a collection of things of the same type, so that a vector can store kind of a several numbers,

252
00:34:39,990 --> 00:34:44,280
but they all have to be numbers or they can source several characters,

253
00:34:44,280 --> 00:34:52,530
but they all have to be cherished because they have to have numbers and half characters in your vector.

254
00:34:55,050 --> 00:34:57,720
Mr. Little We'll see that a little later.

255
00:34:57,720 --> 00:35:06,830
List kind of a thing for storing heterogeneous, heterogeneous data types so they can contain both numbers and characters first.

256
00:35:07,230 --> 00:35:19,620
So but in this course, or probably in a lot of other course in the vector is going to be this will just be referred to as vectors.

257
00:35:19,710 --> 00:35:33,300
Okay. So this was just a table borrowed from this this book just kind of outlines the

258
00:35:34,860 --> 00:35:39,450
main different data types are just so you can see how everything fits together.

259
00:35:40,200 --> 00:35:51,360
So the vector, the atomic vector effectors, as we'll call it, that's like one dimension that's just kind of like a factor in linear algebra.

260
00:35:51,930 --> 00:35:57,620
It's just you can treat it as kind of a this the numbers and it's.

261
00:36:01,260 --> 00:36:06,190
And ah, one thing to note about it is it's homogenous, the traditional typologies.

262
00:36:06,500 --> 00:36:09,710
So they all have to be all numbers are all characters, for example.

263
00:36:10,570 --> 00:36:15,620
Hence the header. The list is kind of a heterogeneous version of a vector in a sense.

264
00:36:16,280 --> 00:36:27,610
So it kind of contains a a a collection of objects, but they can be heterogeneous data type.

265
00:36:27,630 --> 00:36:37,300
So you can have half numbers, half characters, for example, kind of the data types that have I want to use some more table structure.

266
00:36:37,310 --> 00:36:45,050
So there's two dimensions. So kind of a two dimensional version of a regular vector is just the matrix.

267
00:36:45,500 --> 00:36:54,500
So you have rows and columns, kind of the two dimensional and data frame is actually technically a list.

268
00:36:54,510 --> 00:37:05,260
But the way you kind of visualize a data frame is kind of just as a table and it has rows and columns.

269
00:37:05,270 --> 00:37:10,850
So this is kind of a, you know, I say the best way to think about, you know,

270
00:37:10,910 --> 00:37:15,590
the purpose, I guess, of each of each of the main data structures in order.

271
00:37:17,750 --> 00:37:28,400
Okay, so let's get into the vector. So the first thing you need to know about vectors, I guess, is just how to create them.

272
00:37:29,780 --> 00:37:38,510
And I think the kind of the most straightforward way to create vectors in R is just using the C functions.

273
00:37:39,260 --> 00:37:46,249
And as a function that's just a single letter, C and R and that's used to create vectors.

274
00:37:46,250 --> 00:37:55,879
So it stands for concatenated. So you can kind of at least kind of put it one thing after another in a single vector.

275
00:37:55,880 --> 00:38:01,550
And so that just puts a group of values together in a single word.

276
00:38:01,760 --> 00:38:13,280
So if we do, if we assign the variable X C of wanting to increase, let's just say it's just a single vector with the elements one, two and three.

277
00:38:13,280 --> 00:38:18,110
So the element one is kind of the first element of the vector.

278
00:38:18,860 --> 00:38:25,340
A number two is the second element of the vector, and then the number three is the third element of the vector.

279
00:38:25,760 --> 00:38:31,340
So that's the way to interpret that. Okay. So it's kind of in order when you create a vector.

280
00:38:32,690 --> 00:38:39,940
So you can also kind of be seen as kind of pretty flexible.

281
00:38:39,950 --> 00:38:43,729
You can add stuff to an existing vector, for example.

282
00:38:43,730 --> 00:38:52,730
So if I create a vector column called Y and I do see an x, so x is already a vector and I just add numbers to it.

283
00:38:52,730 --> 00:38:57,260
So that's going to kind of return a new vector.

284
00:38:57,260 --> 00:39:05,669
But it has the as the vector X with extra numbers attached at the ends of it to the vector x.

285
00:39:05,670 --> 00:39:14,000
So it's going to have the original vector x, which is one, two, three, and it's going to add four and then five to consider.

286
00:39:14,080 --> 00:39:19,940
You can see here the vector X, vector y has the values.

287
00:39:19,940 --> 00:39:27,260
One, two, three, four, five. So you can even do characters or logic calls with C,

288
00:39:27,860 --> 00:39:35,000
you don't have to be numbers so we can create a character vector here with C with

289
00:39:35,010 --> 00:39:39,980
the contaminate function here the first element is can second elements dog.

290
00:39:40,700 --> 00:39:43,910
And then the third element is the kind of character type.

291
00:39:44,480 --> 00:39:50,690
So the value hamster and then you can also create a vector of logical sense.

292
00:39:50,690 --> 00:40:04,969
Also not a problem through is in falsies. Okay, so let's, let's see, I guess that's basically it for, for, for how to use the technique function.

293
00:40:04,970 --> 00:40:11,900
You just kind of put all the stuff that you want in the vector and you separate the elements of the vectors by carbons.

294
00:40:11,900 --> 00:40:21,530
Okay. So I'd say these and the second useful thing to know for creating vector is this is called an operator.

295
00:40:22,910 --> 00:40:31,040
So that's really used if you're creating numeric that. It's numeric vectors.

296
00:40:32,090 --> 00:40:36,230
So you can create this kind of general form.

297
00:40:36,920 --> 00:40:42,710
If you start, it's the starting value.

298
00:40:43,860 --> 00:40:57,820
But if you put the starting value of your vector at this from and then you put a Coleman and then you put the value that we want to be in.

299
00:40:57,830 --> 00:41:02,330
It doesn't necessarily have to be the last value of your vector,

300
00:41:02,330 --> 00:41:09,470
but it's kind of I would say usually we'll see some examples where it's not the exact copy itself.

301
00:41:10,100 --> 00:41:13,360
It's basically where you want the value that you want and your capital.

302
00:41:14,240 --> 00:41:19,940
And then it kind of fills the vector and it's just like increasing by increments of one.

303
00:41:20,990 --> 00:41:26,780
So you can create the vector like one, one, two, three, four, five by just doing one code five, for example.

304
00:41:29,150 --> 00:41:32,059
Or you can do the vector 22, 23,

305
00:41:32,060 --> 00:41:45,950
24 all the way up to 28 by just doing 22 colon 28 So this is useful for creating a vector that's fairly long of hundred elements.

306
00:41:45,950 --> 00:41:52,609
For example, you don't have to type all of that in inside of the C function, inside of the contracting function,

307
00:41:52,610 --> 00:41:59,600
you just do where it starts the colon and then where it ends when it's that's a lot easier.

308
00:42:01,310 --> 00:42:04,550
You can even do decreasing values.

309
00:42:06,140 --> 00:42:16,250
So it's the second number is usually larger than most people write code like you can you can do a decreasing vector.

310
00:42:16,250 --> 00:42:22,160
So if we do zero, the first number is negative five.

311
00:42:23,560 --> 00:42:29,389
It'll go from, you know, decrease by zero, negative one negative to what really matters.

312
00:42:29,390 --> 00:42:39,250
But as I said before it, the second number, it doesn't necessarily have to be the last number in your vector,

313
00:42:39,290 --> 00:42:43,430
although I would say usually is the way most people write articles.

314
00:42:44,090 --> 00:42:54,010
It'll just increment by one up until like the largest values is less than this number, then it'll stuff.

315
00:42:54,020 --> 00:42:59,899
So here we're starting with 2.3 and then going up to 6.8.

316
00:42:59,900 --> 00:43:06,830
So there's no way to have the last element, the 6.8 if we're increasing each element by one.

317
00:43:06,830 --> 00:43:15,410
So that's not possible. But here it will just increase by one up until kind of the largest value, that's still less than 6.8.

318
00:43:15,770 --> 00:43:22,190
So that's that's the way it handles these cases where we have something where

319
00:43:22,190 --> 00:43:27,990
it's kind of not something that can't be reached by increments of one thing.

320
00:43:28,700 --> 00:43:32,929
So that's how it handles that. Yeah.

321
00:43:32,930 --> 00:43:42,260
Here's just a warning. Sometimes people it's easy to make a mistake like this if you're careless.

322
00:43:45,900 --> 00:43:53,490
So in some cases you want to do a common way to and one up to like the value of some variable minus one.

323
00:43:55,290 --> 00:44:03,320
So if we do, we do this kind of notation, it's not going to be one out to be minus one.

324
00:44:03,330 --> 00:44:10,620
It's going to be it's going to create the one, the factor one ought to be, and then it's going to subtract one from everything.

325
00:44:11,100 --> 00:44:14,900
So it's really going to start at 001, two, three, four, five.

326
00:44:16,980 --> 00:44:25,710
Here is what you would want to do if you wanted to create a vector that starts at one and goes all the way up to B minus one.

327
00:44:26,130 --> 00:44:35,070
So this is this is just a note to be careful with with parentheses if you're doing this, if you're creating vectors in this type of way.

328
00:44:37,500 --> 00:44:43,330
So that's the colon. So there's another function that's useful called C.

329
00:44:46,290 --> 00:44:53,290
I mean, you can do it to create the same types of vectors as the as a colon operator, I would say seek.

330
00:44:53,920 --> 00:45:00,240
This gives you a little bit more flexibility than with the colon. So the way it works is that you just give it the first.

331
00:45:02,080 --> 00:45:09,410
I mean, just like a sequence of numbers and stores in the background, you get the first number that you give it is where it starts.

332
00:45:10,190 --> 00:45:17,630
And then the last number is where it ends or where you want it to end before that.

333
00:45:18,170 --> 00:45:20,630
And then this by argument is kind of the increment.

334
00:45:21,560 --> 00:45:31,320
So to know how much everything is, how much the elements of the vector increase kind of at each position.

335
00:45:31,340 --> 00:45:40,290
Okay. So if we can speak of one up to 11 and then by two it's going to create a vector starting at one,

336
00:45:40,320 --> 00:45:46,670
then for each element is going to increase by two from the previous self.

337
00:45:46,820 --> 00:45:51,260
So it's going to be one, three, five, seven, nine, up to 11.

338
00:45:54,140 --> 00:46:01,910
You can give it an argument that it's not necessarily going to be the last element of the vector, but it's again, it's going to stop.

339
00:46:02,870 --> 00:46:07,530
It's going to give you the largest value, kind of less than that last value.

340
00:46:07,550 --> 00:46:11,300
So we give it a ten. It's going to go one, three, five, seven, nine.

341
00:46:11,480 --> 00:46:24,920
Okay, here, a nice thing you can also you can kind of increase by a non integer amount on this sequence from 1 to 11, increasing by 2.54, for example.

342
00:46:25,820 --> 00:46:31,520
We can do it that way. Okay.

343
00:46:31,520 --> 00:46:41,450
So that's, that's one way to specify a sequence using the by kind of the by argument.

344
00:46:41,450 --> 00:46:44,750
There's another way which is also popular, which we use.

345
00:46:45,380 --> 00:46:50,120
You specify the length of the sequence. So this is kind of useful.

346
00:46:51,500 --> 00:47:01,580
Like for example, if I want to create its vector from 0 to 1 with ten equally spaced points,

347
00:47:03,260 --> 00:47:07,610
you can just go from zero one and give it the kind of the length of it.

348
00:47:09,320 --> 00:47:12,470
And so to do that, given that you do this length start out.

349
00:47:13,160 --> 00:47:14,990
So if I want to go from 1 to 11,

350
00:47:17,060 --> 00:47:29,660
it's a well length 11 that's going to be really the same thing is doing body was one but you know it's often useful more useful when.

351
00:47:32,700 --> 00:47:39,989
It's kind of not as obvious what the buy pregnant should be in at least 51 with an equal sequence.

352
00:47:39,990 --> 00:47:47,399
Right? So if we don't want to go from 21.5 and 48.2 and I kind of want the five equally spaced points,

353
00:47:47,400 --> 00:47:51,690
I don't have to worry about doing the division and working that out.

354
00:47:52,110 --> 00:48:00,230
I just do my start out equals five and that's that'll give us five kind of equally spaced points in a single factor,

355
00:48:00,240 --> 00:48:04,200
starting from 21.5, it goes up to 48.2.

356
00:48:06,270 --> 00:48:13,169
So it's kind of convenient for these times in case you don't have to worry about what the correct increment is,

357
00:48:13,170 --> 00:48:19,440
at least, at least if you want like equally equally spaced know points in your factor.

358
00:48:19,980 --> 00:48:25,770
Okay, so the increment is its constant. Let's, let's see.

359
00:48:25,770 --> 00:48:32,010
So we had like a C is like the basic, basic function to know for creating vectors.

360
00:48:33,030 --> 00:48:40,320
Colon C are pretty useful for reading vectors with certain patterns.

361
00:48:41,310 --> 00:48:49,980
I would I think this is the last one that I mentioned and for now for for creating vectors.

362
00:48:49,980 --> 00:48:54,450
So the last I would say a very useful function is the rep function.

363
00:48:54,450 --> 00:49:03,479
So this stands for replicate. This is very useful if you kind of if you want to create factors that have a certain kind of repeating pattern.

364
00:49:03,480 --> 00:49:10,680
So you still think of rep as kind of useful for creating factory with any kind of repeating.

365
00:49:11,090 --> 00:49:16,020
This is just useful, useful in those in those situations.

366
00:49:16,020 --> 00:49:22,200
So the basic form of rep is rep of x comma.

367
00:49:22,770 --> 00:49:27,720
There's this times argument you can actually well I'll show an example later.

368
00:49:27,730 --> 00:49:39,150
You can, you know, there's an alternative argument you can give which is each instead of times foundation that in a few slides.

369
00:49:39,810 --> 00:49:47,100
But I would say the kind of the default if you give it a second argument as to Mr.

370
00:49:47,100 --> 00:49:54,060
treated as the times argument this is the way rep works is it basically repeats.

371
00:49:56,000 --> 00:49:59,850
Whatever you give it an X times number of times.

372
00:49:59,870 --> 00:50:07,550
So like it two times equals three and just repeat whatever x is three times and it returns that has it back.

373
00:50:07,950 --> 00:50:15,620
So yeah, any kind of repeating pattern you put like the basic pattern text and you say

374
00:50:15,620 --> 00:50:20,270
how many times you want that pattern to repeat it is kind of the way it works.

375
00:50:20,870 --> 00:50:28,219
So for example, if I do of seven, comma three, that's just going to repeat seven three times.

376
00:50:28,220 --> 00:50:36,770
And in order to return that as a vector, so just returns the vector seven, seven, seven, you have something else like two,

377
00:50:36,770 --> 00:50:45,650
four, six is going to repeat the pattern to four, six, three, nine, three times and then return that as a vector.

378
00:50:45,950 --> 00:50:50,600
Actually, it'll just return the vector to 46246246.

379
00:50:51,200 --> 00:51:01,250
So this is kind of very useful if there's any kind of repeating pattern you don't really need to do, you'll have to retype something a bunch of times.

380
00:51:02,900 --> 00:51:09,080
All right. Okay. So you can even this is just an example,

381
00:51:09,200 --> 00:51:18,420
I guess the flexibility of our to kind of combine these different is different functions in certain and different ways like we can do.

382
00:51:18,440 --> 00:51:25,309
We can combine the C and the colon and write in kind of a single line.

383
00:51:25,310 --> 00:51:38,450
So like in this example we have C ten oh and 12 and then kind of the second argument in the C function is read two, four, six three.

384
00:51:38,450 --> 00:51:47,060
So what's that? But that's going to do is it's going to return the vector ten column 12, which is ten, 11, 12.

385
00:51:47,600 --> 00:51:54,230
And then it's just going to append this part to the end of the 1011.

386
00:51:54,740 --> 00:52:07,280
It's going to return in ten, 11, 12 and it's going to append this, this rep stuff basically, which is 246246246.

387
00:52:07,280 --> 00:52:16,519
So you can, you can combine C and column in breath and seek in a bunch of different ways.

388
00:52:16,520 --> 00:52:28,190
You could even have a you can even name another comma here if you wanted to and put another vector after this red pen to kind of that,

389
00:52:28,910 --> 00:52:34,160
that vector out after this is the last six here.

390
00:52:34,760 --> 00:52:38,540
Okay. So you kind of mix, mix all these functions together.

391
00:52:41,000 --> 00:52:49,310
So there here there's an alternative way to use rep, which is using the keyword each rather than.

392
00:52:51,840 --> 00:52:54,330
These are kind of the times argument.

393
00:52:54,900 --> 00:53:07,920
So what each does is it repeats each element of the the X factor of the, you know, each number of times before moving on to the next element.

394
00:53:08,610 --> 00:53:15,540
Hopefully, maybe this example makes it more clear. So if you have read both, see of this vector two, four,

395
00:53:15,540 --> 00:53:26,640
six and we have each four times basically what it does is it returns a vector where it repeats the first element of this four times,

396
00:53:27,210 --> 00:53:33,360
so repeats the first element of two, four, six, four times, and then it moves on to the next time.

397
00:53:33,470 --> 00:53:39,150
So the next element is four and repeats that four times and then six.

398
00:53:40,410 --> 00:53:42,809
That's the last one and all the repeats that are four times.

399
00:53:42,810 --> 00:53:53,250
So that's kind of all sometimes this is useful that you have this type of pattern that you want to create rather than 246246246.

400
00:53:53,250 --> 00:53:59,370
You want to repeat kind of each element X number of times before you move on to the next element.

401
00:54:00,000 --> 00:54:06,360
So that's one possible way of using the rent function.

402
00:54:07,380 --> 00:54:17,670
All right. So that's I think those are all the was probably the most useful functions for creating factories, at least when you get started.

403
00:54:17,670 --> 00:54:26,040
So the C Koven seek S and Q and then then ramp.

404
00:54:26,850 --> 00:54:33,440
So you're probably probably the most important thing is to know first off and then like in this example you can even kind of.

405
00:54:35,160 --> 00:54:38,730
You could combine them in a single statement in many cases.

406
00:54:40,080 --> 00:54:43,950
So that's creating vectors.

407
00:54:44,220 --> 00:54:50,700
I guess the next probably useful thing to know is how to extract particular elements of the vector.

408
00:54:51,300 --> 00:54:54,090
So the way you do that is just this kind of bracketed notation.

409
00:54:54,090 --> 00:55:06,480
So like in this example, if we kind of assign this vector X this to X, this vector here one, three, five, 100.

410
00:55:07,470 --> 00:55:11,320
So this X is a vector with four elements one, three, five and 100.

411
00:55:12,000 --> 00:55:19,469
If you just want to extract what is what is the second element of actually do X bracket to extract the

412
00:55:19,470 --> 00:55:29,280
second element which here is three indices and also our way are indexing works and starts from one so x.

413
00:55:30,840 --> 00:55:37,079
So the first element of X is one. It's not the zero element.

414
00:55:37,080 --> 00:55:43,410
So element one is one, element two it's three and element three is five.

415
00:55:45,580 --> 00:55:49,980
You can see here except for is 100.

416
00:55:50,190 --> 00:55:55,560
Okay. So that's how you extract individual elements from a vector.

417
00:55:59,610 --> 00:56:05,970
You also extract kind of subsets so you don't have to do one at a time.

418
00:56:07,140 --> 00:56:15,050
So in this example, you have this vector with five elements.

419
00:56:15,060 --> 00:56:20,580
X is actually 135 150.

420
00:56:21,000 --> 00:56:28,500
You just want to extract the first and third elements in a single kind of a single ah statement.

421
00:56:28,500 --> 00:56:31,510
If you're just, you can give it a vector of indices.

422
00:56:31,530 --> 00:56:36,989
So if I do x bracket and then I give it this vector C one, three,

423
00:56:36,990 --> 00:56:45,390
that's like a vector of indices and it'll extract a vector length two with kind of the values of X.

424
00:56:47,010 --> 00:56:58,950
The first element in the third element. Okay. And, you know, as long as this will work, as long as what whatever is inside the brackets,

425
00:56:58,950 --> 00:57:06,140
as long as this is a kind of a valid factor, here are a valid vector of indices that should work.

426
00:57:06,150 --> 00:57:11,070
So you can even use alternative ways of creating vector.

427
00:57:11,070 --> 00:57:18,780
So if I do recall in five that I'll extract the elements three, four or five, I'm just smack in the middle.

428
00:57:19,500 --> 00:57:26,969
You can even use a wrapper, a C function, as long as those are kind of valid elements.

429
00:57:26,970 --> 00:57:35,080
Like, but you give it an index that's outside of the kind of the range in American.

430
00:57:35,430 --> 00:57:42,420
Like if I did tax brackets seven, I should get an error message because there's only five elements here.

431
00:57:42,990 --> 00:57:47,630
X has no there's no seventh element of X.

432
00:57:47,640 --> 00:57:54,130
But as long as you these are kind of valid, you give it a vector valid indices,

433
00:57:54,150 --> 00:58:03,150
it will return a vector with kind of the corresponding elements of X apples and indices.

434
00:58:04,140 --> 00:58:15,650
So let's go on probably to fix this, to put it as a number list as the option, but it's kind of confusing and it showed up.

435
00:58:15,660 --> 00:58:18,680
So this is an option one, option two, option three.

436
00:58:22,530 --> 00:58:27,480
So let's say we define the vector X as 1 to 10.

437
00:58:28,560 --> 00:58:39,340
So what is the what is this vector? Sure.

438
00:58:39,730 --> 00:58:44,500
Well, maybe I'll just put the like x is one, two, three, four, five, six, seven, eight, nine, ten.

439
00:58:44,500 --> 00:58:55,510
And then the sequence is what? 2010 by two.

440
00:59:04,920 --> 00:59:08,720
It's sequels like you can write it this way.

441
00:59:08,750 --> 00:59:16,630
See one. Five seven.

442
00:59:18,510 --> 00:59:21,990
Right. So acts of.

443
00:59:36,210 --> 00:59:40,630
So this is equal to both since X itself is like 1 to 10, right?

444
00:59:41,520 --> 00:59:53,219
X is 1 to 10. This will actually be the same thing as this since it's the first element of of 1 to 10 is one, the third element is three and so forth.

445
00:59:53,220 --> 01:00:03,510
So it's actually the same thing. So this is actually like C one.

446
01:00:04,170 --> 01:00:11,110
This is much better. This was a decision.

447
01:00:12,580 --> 01:00:18,750
This is one, three, five. Seven nine.

448
01:00:19,570 --> 01:00:23,850
So you can actually you can actually do it all in a single line.

449
01:00:23,860 --> 01:00:28,150
You can extract certain elements you don't have to define. You don't have to define it first.

450
01:00:28,690 --> 01:00:33,360
And then extracting elements and actually do all kind of all of these things in a single line.

451
01:00:33,370 --> 01:00:44,050
So if I write it, I write it this way or on and I.

452
01:00:48,480 --> 01:00:52,920
Should be, but I think so. This should be called five.

453
01:00:55,320 --> 01:00:58,200
So it's basically the third element of this factor.

454
01:01:10,030 --> 01:01:18,769
He can cut off hours pretty flexibly to kind of write a lot of these things in a single line so you can kind of extract this.

455
01:01:18,770 --> 01:01:23,120
Is this part of the code is extracting the file itself,

456
01:01:23,900 --> 01:01:33,620
it's creating this vector seat and then it's kind of extracting the subset from X and then this part as a vector.

457
01:01:33,620 --> 01:01:36,710
Then again, you're extracting an element from that.

458
01:01:37,310 --> 01:01:42,100
That's some setbacks. And you can do all of these things in a single line if you want to.

459
01:01:44,300 --> 01:01:54,510
So. Like yourself, but I'm pretty sure the answer here is five option.

460
01:01:57,550 --> 01:02:03,280
Okay. So yes, the next useful thing is how to update vector elements.

461
01:02:03,280 --> 01:02:10,000
Are I just basically changing the value of certain elements of your vector?

462
01:02:10,010 --> 01:02:20,530
So the way to do that is just to assign assign that element a new value.

463
01:02:20,980 --> 01:02:25,900
So like if I create the vector x here to update the second element,

464
01:02:25,900 --> 01:02:36,880
I just do x bracket to I just assign at the value x and now instead of being one three, five, 100, it's x, it's 165, 100.

465
01:02:36,940 --> 01:02:40,260
So the second element is X. Okay. Okay.

466
01:02:40,270 --> 01:02:44,020
So that's all you have to do to update the value of certain elements.

467
01:02:44,920 --> 01:03:03,350
You can even do this type of thing. With multiple elements like you could do a subset and reassign the values of a subset.

468
01:03:03,650 --> 01:03:11,690
So if I do, x of 1 to 3 is equal to the rest and three all the first three elements will be equal.

469
01:03:12,290 --> 01:03:15,170
Like the first three elements will equal the vector. Ten, ten, ten.

470
01:03:15,860 --> 01:03:24,349
You can also do a subset if you assign it kind of a single value, all it'll assign kind of all of those elements that value.

471
01:03:24,350 --> 01:03:31,070
So this is actually equivalent to doing X of one column three is assign the value ten.

472
01:03:31,190 --> 01:03:32,600
We will actually do the same thing.

473
01:03:33,370 --> 01:03:49,430
If you kind of assign a subset, a single number, add a little sign of every element in that subset, that same single value.

474
01:03:49,580 --> 01:03:53,170
Okay. Okay.

475
01:03:53,510 --> 01:04:04,250
So I just that's basically it for updating vector elements and it is just kind of random and useful methods for vectors.

476
01:04:04,260 --> 01:04:13,190
I mean, I think you'll become more familiar with a lot of these as you do more R programing.

477
01:04:13,670 --> 01:04:19,790
These are you tend to think them and the main ones you might want to know when you're first starting off.

478
01:04:19,790 --> 01:04:28,330
So. Length is an important thing. So if you want to know the length of your vector, basically it's just how many elements are in your vector.

479
01:04:28,340 --> 01:04:36,919
You can just through the length of the parentheses, close parentheses and put the name of the vector there so that in this case,

480
01:04:36,920 --> 01:04:53,120
the length of our vectors, ten as ten elements type of is sometimes useful telling kind of the type of the kind of components of your vector.

481
01:04:53,660 --> 01:05:00,980
So here these are integers, some as useful as that just takes the sum of all of the elements of your of your vector.

482
01:05:02,390 --> 01:05:05,490
Okay. Yeah.

483
01:05:05,540 --> 01:05:09,770
These are just think there's yeah. These are just other useful functions to know I think,

484
01:05:10,610 --> 01:05:22,430
or has it quite a few other functions that compute of summary statistics from vectors that if you have your vectors as containing numeric data,

485
01:05:22,940 --> 01:05:26,839
I guess these are the kind of the main ones you should know starting out.

486
01:05:26,840 --> 01:05:31,249
So the mean value of the values in your vector is important.

487
01:05:31,250 --> 01:05:36,800
So that's just the mean function. The function var is just the variance.

488
01:05:37,450 --> 01:05:42,680
It's the variance of the elements of your vector and SD is the standard deviation.

489
01:05:43,240 --> 01:05:51,410
Okay, the standard deviation, I guess max min and median are also probably pretty useful.

490
01:05:54,050 --> 01:05:55,100
I guess I didn't mention here.

491
01:05:55,100 --> 01:06:06,250
There's also a function called summary to use summary of x that I'll give the gives a median and it'll get kind of like that.

492
01:06:06,770 --> 01:06:16,940
And the percentiles like the thing is the men in the max and like the 25th and 75th percentile.

493
01:06:17,390 --> 01:06:25,520
So it kind of returns all of that with one function return like five number summary of your data.

494
01:06:26,240 --> 01:06:33,810
So that's also useful. So a summary of X. Okay.

495
01:06:34,460 --> 01:06:37,880
So what did I want to say here?

496
01:06:37,880 --> 01:06:50,800
So this is and this is more related to how our might convert different data types from one to another.

497
01:06:53,840 --> 01:06:59,959
So I think as you mentioned before, kind of a key property of vectors is that they all have to have the tender elements,

498
01:06:59,960 --> 01:07:11,150
all have to have the same data type, right? Doesn't matter if it's number or characterological as long as they're all the same.

499
01:07:11,360 --> 01:07:17,780
Okay. So you can have a factor of all the numbers vector of all characters in a vector in a logical reason.

500
01:07:18,770 --> 01:07:28,430
So that's kind of a key property of vectors. However, you may notice you can kind of you can,

501
01:07:28,610 --> 01:07:40,580
you can type in a factor of different data types and it will run in or it will, or in many cases it will go.

502
01:07:41,240 --> 01:07:50,060
In some cases it will give you an error message. So that that's still that doesn't mean that it's creating a vector of mixed data types.

503
01:07:51,190 --> 01:07:55,890
It just means that kind of car is automatically doing some type of conversion.

504
01:07:55,920 --> 01:07:59,380
And when you try to do that, when you type these things out. Okay.

505
01:08:01,780 --> 01:08:05,049
So you can see that here in the second example here,

506
01:08:05,050 --> 01:08:17,290
if I try to do I type in X equals kind of C or as a sign the value C, true comma false complex you would have no run in.

507
01:08:17,290 --> 01:08:20,410
Or if you run that line of code.

508
01:08:21,090 --> 01:08:28,840
That's, that's not violating the property, that factors have to have the same data types.

509
01:08:30,460 --> 01:08:37,720
It's not violating that because kind of are kind of automatically will do some sort of conversion so that when it sees this,

510
01:08:37,720 --> 01:08:45,100
it'll automatically convert all of the elements to the American value.

511
01:08:45,100 --> 01:08:55,340
So the way it converts numeric value, logical into numeric values, is that it converts trues into ones and is into zero.

512
01:08:57,550 --> 01:09:02,740
So this is kind of pretty standard as well across other programing languages.

513
01:09:03,820 --> 01:09:09,640
True converts and it's converted into one or false is converted to zero.

514
01:09:13,180 --> 01:09:14,710
Here's another example of that.

515
01:09:14,720 --> 01:09:26,200
If you type in kind of this line of code, if I assign the X to the vector C one coming to comma three in print in quotation marks.

516
01:09:26,200 --> 01:09:31,420
So three is a character now so that all that will run without any errors,

517
01:09:34,390 --> 01:09:41,910
but still doesn't mean that the vector has these days times on means is that kind of r is automatically doing some type of conversion.

518
01:09:41,920 --> 01:09:46,720
So it's it's basically going to convert all of these elements into characters.

519
01:09:46,750 --> 01:09:54,370
So if you look at X, the first column is the character one.

520
01:09:54,670 --> 01:09:57,850
The second element is the kind of the character to.

521
01:09:58,750 --> 01:10:07,150
The third element is the character three before, as we had before. So it's not, it's not treating these as just kind of mixed types.

522
01:10:07,450 --> 01:10:13,100
Basically, when we run this, this is kind of a vector with all character values.

523
01:10:13,120 --> 01:10:19,960
Okay. So you can run these types of statements if you want,

524
01:10:20,920 --> 01:10:29,560
but are still going to treat vectors as it's going to force it to have kind of all of the same the same type.

525
01:10:31,750 --> 01:10:33,909
So here's an example that actually works as well.

526
01:10:33,910 --> 01:10:44,319
If we try to do a logical, numeric character all in the same vector, in this case, it's going to convert everything to character.

527
01:10:44,320 --> 01:10:51,430
So this is actually works as well, but it just automatically kind of converts everything into character values.

528
01:10:59,710 --> 01:11:12,820
This slide was probably. All right.

529
01:11:12,920 --> 01:11:15,980
Well, I guess I put examples where it doesn't work as well.

530
01:11:16,010 --> 01:11:22,880
If it was probably more natural to Twitter, for example, that doesn't work right after that.

531
01:11:25,610 --> 01:11:35,479
Yeah. So the way you can convert types, you know, from one vector to another as far as these as dark functions.

532
01:11:35,480 --> 01:11:39,980
So you can convert a vector into a kind of another form.

533
01:11:41,060 --> 01:11:47,540
You using these as a dot function. So if I want to convert a numeric factor into logical,

534
01:11:47,540 --> 01:11:55,099
I can just do as that logic and kind of put the vector of interest as the main argument to as dot logical.

535
01:11:55,100 --> 01:12:01,790
So if I do see a vector 0123, I want to convert that into logical.

536
01:12:02,300 --> 01:12:03,800
I can just do as that logical.

537
01:12:03,800 --> 01:12:16,560
So the way our does conversion from logical to numeric just treats zero as follows kind of every non-zero number as true in that sense.

538
01:12:16,840 --> 01:12:32,389
You see that here you could go the other way from logical to the numeric set before going from logical to numeric and trues are going to be converted.

539
01:12:32,390 --> 01:12:35,630
That one is and false is will be converted to zero.

540
01:12:36,560 --> 01:12:41,360
I can convert from numbers to character using as that character.

541
01:12:42,100 --> 01:12:46,000
So here in this case, it just puts everything basically inside.

542
01:12:47,540 --> 01:12:52,880
That's all it's done. We're converting from numbers to characters you can go from.

543
01:12:54,960 --> 01:13:06,410
It can go from numbers to characters, from characters to numbers, if it can be kind of interpreted.

544
01:13:06,590 --> 01:13:14,360
Okay. So in many cases, you could have characters that can't be interpreted as numbers.

545
01:13:14,900 --> 01:13:23,600
So you can see that as in this example. So if we have eyes that Americans see, we have the vector kind of one, two, three.

546
01:13:24,470 --> 01:13:29,120
12.3. And then you have this one, two, three, a in the last entry.

547
01:13:29,990 --> 01:13:35,660
So you can't really there's no way to convert that into a number in any reasonable sense.

548
01:13:35,660 --> 01:13:44,210
So it still works. But for for these for these elements, there's no way to do a sensible conversion.

549
01:13:44,810 --> 01:13:49,850
It just returns and a value. Same thing here.

550
01:13:49,850 --> 01:13:53,570
If we want to do a if we want to convert kind of this character.

551
01:13:53,670 --> 01:14:00,680
Well, this is really kind of a mixture of characters and numbers that we want to convert this into logical.

552
01:14:01,190 --> 01:14:05,570
It doesn't work just because of. Well, it's.

553
01:14:08,820 --> 01:14:12,480
She wanted rationalism. So the fourth element doesn't convert.

554
01:14:13,410 --> 01:14:24,130
Oh, I see why. So it's. I guess you could program it in a way that it could make sense, but it doesn't make sense here.

555
01:14:24,150 --> 01:14:31,830
So what this what this is doing with a C function, it's converting this into a character vector.

556
01:14:32,400 --> 01:14:36,230
So C character vector through false T yeah.

557
01:14:36,280 --> 01:14:40,830
And then the character's zero and then it's converting that into logical.

558
01:14:41,310 --> 01:14:52,560
Okay. So you can't convert a something in quotes ATF into a logical and no sense related to at least the way

559
01:14:52,560 --> 01:15:00,990
this is for where we can't convert the you can't convert a zero in quotation marks into logic as well.

560
01:15:01,560 --> 01:15:05,100
You can convert it to zero if into a logical.

561
01:15:05,100 --> 01:15:13,580
But since you're running kind of the C function first, it's kind of creating a vector where this is this is a character first.

562
01:15:15,330 --> 01:15:17,610
So that's why the last two entries are in here.

563
01:15:19,050 --> 01:15:29,550
Same thing here in the last example is one, two, three and counting can't be converted into a number for any sensible.

564
01:15:29,910 --> 01:15:46,350
So we're just going to think we're the one or two more.

565
01:15:46,350 --> 01:15:49,950
I think this is I think we'll do more examples with this later.

566
01:15:49,950 --> 01:15:53,730
But I think this is an important thing to know now.

567
01:15:53,740 --> 01:16:00,660
I mean, this is very useful to know how to do it, which is some setting biological expression.

568
01:16:02,460 --> 01:16:05,820
So I mean, before in kind of a previous examples,

569
01:16:05,820 --> 01:16:18,620
we did like a kind of subset where the vector really specified like the vector of the actual numbers of the indices that we wanted to extract.

570
01:16:21,120 --> 01:16:31,190
So that's perfectly fine. In many cases, though, it's a lot more convenient to subset based on the logical expression.

571
01:16:31,200 --> 01:16:38,819
So here this is basically kind of the syntax that you use X and then bracket and then

572
01:16:38,820 --> 01:16:45,780
you give it kind of a logical expression and the extraction and x rate of eight.

573
01:16:45,810 --> 01:16:51,990
What that does is it extracts all the elements of X where X is greater than eight.

574
01:16:52,200 --> 01:17:01,470
Okay? And that's all it does. And then this here extracts all the elements of X where X is greater than 12.

575
01:17:01,890 --> 01:17:10,620
So you can see that here. All the elements of X that are greater or exit greater than eight are ten, 21, 15.

576
01:17:11,280 --> 01:17:15,260
And then where it's greater than 12 is just 2115.

577
01:17:15,270 --> 01:17:22,560
So you can see here, why is it why is it ten 2115 and Z is 2415?

578
01:17:23,500 --> 01:17:32,040
I think what it's really doing this expression here where we have this logical expression inside of the brackets,

579
01:17:32,700 --> 01:17:38,850
what it's really doing is it's, it has this vector of logic calls inside the brackets here.

580
01:17:41,040 --> 01:17:46,709
It's like c a true, false, true, true. And then we put that inside of the brackets.

581
01:17:46,710 --> 01:17:55,560
It's extracts all of the elements of X where this logical vector is true.

582
01:17:55,560 --> 01:18:00,810
So here it's going to the first, third and fourth.

583
01:18:01,460 --> 01:18:07,590
It's kind of what's really going on is that the logical factor inside the brackets?

584
01:18:07,590 --> 01:18:10,919
And it's all extracting the elements of X.

585
01:18:10,920 --> 01:18:18,950
What kind of where kind of the corresponding elements of the logical factors are true?

586
01:18:19,050 --> 01:18:22,260
It's true that what's going on.

587
01:18:28,250 --> 01:18:37,639
And I just finish up with this. This is another function that I think is is pretty useful as to which function.

588
01:18:37,640 --> 01:18:43,940
It just tells you kind of indices where a condition is true or where a condition is satisfied.

589
01:18:44,420 --> 01:18:55,700
So if we define this vector X 10 to 2115, in many cases, you just want to see where the you know, especially if this is a really long vector.

590
01:18:55,700 --> 01:19:00,800
You just want to see where, you know, the indices, where a certain condition is true.

591
01:19:00,840 --> 01:19:13,729
So if I want to see indices where X is greater than 20 degrees to which of X which the logical expression X is greater than one, and it'll return.

592
01:19:13,730 --> 01:19:17,990
For me, that just means that the third element of X is greater than one.

593
01:19:19,820 --> 01:19:23,870
If it's satisfied at multiple indices, it will return a vector.

594
01:19:23,870 --> 01:19:36,300
So if we have which X is greater than 12, you know, return three for you, this might help to see what's really going on with it.

595
01:19:36,360 --> 01:19:43,999
What it's really doing is it's kind of evaluating a logical expression and returning them a logical vector.

596
01:19:44,000 --> 01:19:53,210
And all the all the which function is doing is returning the indices of where that kind of logical vector is is true.

597
01:19:54,640 --> 01:20:02,710
So you could even type this in directly into. So if I do, I type the statement directly into R which of C false?

598
01:20:03,100 --> 01:20:08,690
True or false? It just returns the index of kind of where this logical vector is true.

599
01:20:08,710 --> 01:20:14,470
So here the second index of this logical vector is true.

600
01:20:14,590 --> 01:20:21,669
So that's why it returns true. That's kind of one way if it helps to interpret that which function this way,

601
01:20:21,670 --> 01:20:26,409
but kind of in practice that the most common way to use that which function,

602
01:20:26,410 --> 01:20:39,370
if you just want to see kind of where all that which indices is your vector greater than weighted in some value or something like that.

603
01:20:39,400 --> 01:20:42,670
It's kind of confirms common use of the which function.

604
01:20:45,610 --> 01:20:54,700
Okay. Well, yeah, this post we'll start there next time kind of with the mathematical operations.

605
01:20:55,270 --> 01:21:15,250
And then one day I was looking for a vector.

606
01:21:22,220 --> 01:21:23,950
Here. They have nothing to.

