1
00:00:00,060 --> 00:00:06,600
So one thing, I'm probably going to change the homework assignments slightly.

2
00:00:09,360 --> 00:00:19,050
Not just the just the arguments that you have to give it kind of realize that it depends the way you wrote it.

3
00:00:19,200 --> 00:00:23,070
It may make it getting weird results.

4
00:00:24,780 --> 00:00:31,290
Let's see. I mean, I think it's going to be the same thing.

5
00:00:31,290 --> 00:00:44,369
I'm just going to change it to you can give it numbers instead of a list like a new can be like a like new zero comma,

6
00:00:44,370 --> 00:00:47,790
mew one and then sigma zero come sigma one.

7
00:00:50,400 --> 00:00:57,660
So it'll be like two numeric arguments instead of two, I guess, four numeric arguments instead of two lists.

8
00:00:59,070 --> 00:01:03,500
Just depending on the way you wrote it, you may get to getting some weird results.

9
00:01:04,260 --> 00:01:08,280
I think it has to do. It didn't really I don't think we're going to cover it in a lot of detail.

10
00:01:08,280 --> 00:01:16,979
But there's some we'll cover this concept, I guess more if you take the C++ course.

11
00:01:16,980 --> 00:01:23,170
I think it has to do with a. List kind of create.

12
00:01:28,050 --> 00:01:31,500
They don't always create local copies, I guess, is the way to say it.

13
00:01:32,010 --> 00:01:37,409
So some of the times you can have this type of behavior, I don't I didn't really mention it.

14
00:01:37,410 --> 00:01:41,309
And you don't really have to know this for this or this module.

15
00:01:41,310 --> 00:01:54,030
But if you do something like this in Python, I define a list to to say Y is equal to X and they say y, z, y of one is equal to five.

16
00:01:54,840 --> 00:02:02,250
That actually changes the value of x, x, x and y are actually just two names for the same thing.

17
00:02:03,540 --> 00:02:15,720
So if I run this code and if you print X and even though you didn't modify X, it's still.

18
00:02:20,010 --> 00:02:30,749
It's still in modified the kind of the value associated with x ray those just something you know maybe to be aware of if you're

19
00:02:30,750 --> 00:02:39,630
doing more python coding in the future but I don't think I'm going to test I didn't mean to test for that in this course.

20
00:02:40,290 --> 00:02:53,400
I think depending on how you wrote your function, it may cause some weird I mean, it may not depending on how you look,

21
00:02:53,730 --> 00:03:00,960
you know, like if you just took the R module or at least factors don't they don't have that property.

22
00:03:01,560 --> 00:03:13,230
Like if you do X is equal to the factor to two in the way of the attacks the modify the second element of Y it doesn't it doesn't affect X right so.

23
00:03:16,240 --> 00:03:18,340
We're not actually still the original acts.

24
00:03:18,380 --> 00:03:30,430
I'll make something out of B where I'll I'll I'll post that I'll pop up I'll post the updated homework tonight.

25
00:03:34,270 --> 00:03:36,610
Again. I don't I don't think if you already did it, I don't think you.

26
00:03:37,120 --> 00:03:41,890
Well, I guess, you know, you could probably keep the original one submitted, but if.

27
00:03:45,960 --> 00:03:50,190
If you want to submit with the new version, I don't think you really have to change the code much.

28
00:03:50,640 --> 00:03:54,570
It's just going to have numbers here and instead of lists for you and Sigma.

29
00:03:55,080 --> 00:03:59,340
So I think that's probably a less confusing way of doing a problem.

30
00:03:59,870 --> 00:04:09,900
Okay. Yeah, you have. So what was the difference between the first one and the second one that you showed us here, like Python versus R.A.?

31
00:04:10,160 --> 00:04:13,590
Oh, wait. Oh, did you have the other one in arm?

32
00:04:14,310 --> 00:04:20,730
Oh, yeah. This is our. Oh, okay. Okay. So this is Python C, so that like.

33
00:04:21,240 --> 00:04:27,930
Well, if you do print X and y, it's the same thing. But here, like X and y are not the same thing, so.

34
00:04:32,810 --> 00:04:37,970
Yeah. We didn't really get into this feature list too much.

35
00:04:41,280 --> 00:04:47,040
And just yeah. And this module, I guess it has there's some advantages and disadvantages.

36
00:04:49,300 --> 00:04:52,660
Disadvantages is that I guess I just the.

37
00:04:55,360 --> 00:05:03,310
But yeah, you don't have to. I'm not going to test that on you, on the quiz or any of the other homework.

38
00:05:03,320 --> 00:05:06,700
So it's just for your own information.

39
00:05:08,620 --> 00:05:12,370
Any other questions? It's.

40
00:05:19,770 --> 00:05:26,000
All right, let's keep going. Let's try to update the homework pretty soon.

41
00:05:26,010 --> 00:05:36,420
Later tonight. So you have the homework and quiz or do it, I guess, on Saturday, the first online quiz.

42
00:05:37,290 --> 00:05:45,180
So I guess today we're going to talk about tuples, loops and then sets and dictionaries.

43
00:05:48,420 --> 00:05:51,989
So, yeah, that's about it.

44
00:05:51,990 --> 00:05:58,350
I think next time and next week we'll get it to finish dictionaries and get into kind of arrays.

45
00:05:59,370 --> 00:06:11,130
So yeah, this is just kind of a little bit of a review of this would be like if you wanted to use a list in a function,

46
00:06:14,850 --> 00:06:18,989
you know, if you had kind of two parameters in your function,

47
00:06:18,990 --> 00:06:24,720
one is a list and one is a positive integer and you kind of give the parameters,

48
00:06:24,900 --> 00:06:38,340
integer parameters on and the length of the list is greater than four kind of return of some of the first and third elements as the return result.

49
00:06:38,370 --> 00:06:50,280
If you're integers, even the length of the list is greater than four and then return the sum of second and fourth elements in the list.

50
00:06:51,690 --> 00:06:56,759
Otherwise return to zero basically if the length of the list is less than four.

51
00:06:56,760 --> 00:06:59,579
So this is kind of how you might do that.

52
00:06:59,580 --> 00:07:14,880
And I just the syntax for doing that, we have we have a list as the first parameter and then the second parameter is like a positive integer.

53
00:07:15,690 --> 00:07:16,259
Basically,

54
00:07:16,260 --> 00:07:27,569
this is mostly just to kind of review the different types of syntax like l l l chain and then this modulus operator which basically if you're testing,

55
00:07:27,570 --> 00:07:31,950
if it's even or not or, or really if it's odd or not.

56
00:07:31,950 --> 00:07:39,120
So this is testing if it's odd and the length of the list is greater than for that's kind of first condition.

57
00:07:39,120 --> 00:07:47,970
You return the sum of the first and third elements or those index zero into some kind of oh,

58
00:07:49,050 --> 00:07:53,160
that's what I'm referring to as the first and third elements.

59
00:07:53,880 --> 00:07:58,920
The other cases, if it's even and the list is the length of the list is greater than four,

60
00:07:58,920 --> 00:08:05,940
you return the sum of the second and third element for the second and fourth moments.

61
00:08:06,660 --> 00:08:11,280
If you start counting for one, and then otherwise you return zero.

62
00:08:13,420 --> 00:08:17,550
Okay. So here we were returning.

63
00:08:21,720 --> 00:08:24,930
One, one plus two and then three plus five.

64
00:08:25,380 --> 00:08:33,360
And then here, the length the length of the list is less than four sort of return zero.

65
00:08:33,570 --> 00:08:44,490
Okay. So that's just an example. So here is just another kind of review of, I guess, things that are useful to know with lists like the that.

66
00:08:48,790 --> 00:08:54,909
And it's the kind of excess individual elements and kind of the slicing notation.

67
00:08:54,910 --> 00:09:04,450
So here, if we define x one as X colon two, that will be the first two elements of X, right?

68
00:09:05,170 --> 00:09:11,230
If we define X two as X minus one, that's the that will just return the last element of x.

69
00:09:13,330 --> 00:09:22,989
If we define x three as x 2 to 4, that'll be the two components of x, which are index two and three,

70
00:09:22,990 --> 00:09:32,730
but not including for the elements three and basically three and four.

71
00:09:33,430 --> 00:09:38,259
So that if we do Y is equal to X and then say, why do we do this?

72
00:09:38,260 --> 00:09:45,639
Replacement Y should have the value index two and three.

73
00:09:45,640 --> 00:09:52,900
It should have the value of five and six. And then actually, as I did in an example before this, this replacement,

74
00:09:52,900 --> 00:10:00,460
this will actually change if we print it out the value x later on this lecture, we kind of change the the values of the elements of X.

75
00:10:03,160 --> 00:10:11,140
So you can see here, if we print out x one, it should be kind of the first two elements of x.

76
00:10:12,160 --> 00:10:16,840
If we print out x two, it should be the last element of x, which is which is one.

77
00:10:18,310 --> 00:10:30,610
If we print out x three, it should be the second and third out of the elements index two and three, which in this case is three, comma four.

78
00:10:30,610 --> 00:10:35,889
So that's what's printed out. Then if we print out y should be same thing as x.

79
00:10:35,890 --> 00:10:42,100
We're just replacing those at index two and three with five and six.

80
00:10:42,670 --> 00:10:49,330
Okay. So it should be like one, two, five, six, three, two, one.

81
00:10:49,750 --> 00:10:55,240
Okay. I think that's what's printed here. It's one, two, five, six, three, two, one.

82
00:10:55,540 --> 00:10:55,840
Okay.

83
00:10:56,620 --> 00:11:08,710
So let's just kind of a little bit of a review of these two, probably the most important types of things when you're accessing the elements of lists.

84
00:11:10,720 --> 00:11:14,650
So I guess the next topic is our tuples.

85
00:11:19,060 --> 00:11:26,260
Okay. So tuples are basically they're they're kind of similar to list.

86
00:11:26,260 --> 00:11:33,640
I guess the main difference is that you can't change like the elements of the of a tuple like once it's been defined.

87
00:11:34,240 --> 00:11:42,100
I mean you can create kind of a totally, completely new tuple if you want to have different values for the elements.

88
00:11:42,100 --> 00:11:48,639
But for a single tuple that is defined, you cannot change that the values of the elements.

89
00:11:48,640 --> 00:11:59,070
Okay. So it's really, I would say that pretty much the main difference between two opposing lists, but otherwise they're pretty much the same.

90
00:11:59,080 --> 00:12:03,460
There's, you know, they're an ordered collection of items.

91
00:12:04,150 --> 00:12:11,920
Two, both can store different variable types so they can get numbers and strings, for example.

92
00:12:12,580 --> 00:12:15,850
And then like list indexing starts from zero.

93
00:12:18,000 --> 00:12:25,390
You pretty much everything, python indexing starts from zero and then you can access the elements of a tuple basically the same way.

94
00:12:26,170 --> 00:12:35,500
So just with this bracket notation, so if you and says, hey, I might be doing this bracket notation.

95
00:12:38,750 --> 00:12:42,380
Okay. I would say they're really useful.

96
00:12:42,980 --> 00:12:47,690
At least I would use the one. You have kind of connected pieces of information in a sense.

97
00:12:47,690 --> 00:13:00,590
So where like basically the interpretation of the the elements of the tuple, as you know, is such that, you know,

98
00:13:01,280 --> 00:13:08,479
changing one component of the tuple would mean that you would really want to change a bunch of other components of the tuple.

99
00:13:08,480 --> 00:13:16,070
So you don't want to really allow any changes in individual components of the tuple by itself,

100
00:13:16,070 --> 00:13:20,210
just because you kind of you would have to change everything else at the same time.

101
00:13:22,850 --> 00:13:28,610
So you often will see maybe a tuple as a as the return value of a function where the

102
00:13:28,610 --> 00:13:36,589
function kind of returns a bunch of numbers that have some kind type of dependance.

103
00:13:36,590 --> 00:13:49,010
So maybe one element of the list or the tuple is like weighting kilograms and one is like a weight and pounds.

104
00:13:49,070 --> 00:13:52,729
So you kind of their dependent on each other.

105
00:13:52,730 --> 00:13:55,850
So you don't really want to change one element by itself.

106
00:13:56,420 --> 00:14:01,610
Okay. Okay. So it's create a two bullet sort of similar to a list.

107
00:14:01,610 --> 00:14:08,600
You just use parentheses instead of the brackets. So this is how you would create a tuple.

108
00:14:09,660 --> 00:14:14,450
It's just one. Do you want to create a tuple with three numbers?

109
00:14:14,450 --> 00:14:20,180
It's just one comma, two, common three. Everything is surrounded by parentheses.

110
00:14:21,200 --> 00:14:27,980
You can define it without the parentheses. I mean, I would say I usually don't do it that way, but you can.

111
00:14:28,700 --> 00:14:37,069
I guess the only way this wouldn't work is that it is when you have or if you're trying to define and people like a tuple within a tuple.

112
00:14:37,070 --> 00:14:47,209
This kind of syntax doesn't work, but otherwise it's fine.

113
00:14:47,210 --> 00:14:54,260
But I usually created tuple just using a parentheses with comma service separating the elements of the tuple.

114
00:14:56,660 --> 00:15:07,040
And then as I said before, you can access like specific elements of a to the exact same way you would access elements of a list.

115
00:15:08,930 --> 00:15:16,400
But the main difference is that you cannot change the elements of a tuple after its first been created.

116
00:15:17,000 --> 00:15:24,770
Let's say we like if you ran this code up on the top where I created the tuples, if I created the tuple this way.

117
00:15:25,400 --> 00:15:31,550
And then after that, if I tried to run this piece of code here.

118
00:15:34,880 --> 00:15:39,710
If you tried to run. This is the point here.

119
00:15:40,340 --> 00:15:43,520
If you try to use run this piece of code down here.

120
00:15:46,810 --> 00:15:52,620
Like if I tried to change the element next to you,

121
00:15:53,010 --> 00:15:58,600
you'll get some kind of error message and something like you know, the tuple does not support assignment.

122
00:15:59,310 --> 00:16:10,990
Basically this doesn't work. I said, you cannot change the values of the individual elements of the tool.

123
00:16:13,480 --> 00:16:21,160
If you want to do multiplication and if you want to tools, it's basically does the same thing as lists.

124
00:16:21,730 --> 00:16:24,910
So the issue is simple.

125
00:16:24,910 --> 00:16:35,020
Those concatenation, if I add these two tuples, if I add this 2.2468 to the tuple to and to car,

126
00:16:35,470 --> 00:16:41,350
it's just going to add the second elements of the second tuple to the to the first tuple.

127
00:16:41,350 --> 00:16:52,660
So that just does concatenation. If you do multiplication with an integer, it's basically going to repeat the tuple several times.

128
00:16:53,500 --> 00:16:56,140
Basically how many times you multiply it with itself.

129
00:16:57,310 --> 00:17:04,390
So if I multiply it to four times three, it just kind of repeats the tuple, the original tuple, three times.

130
00:17:08,850 --> 00:17:15,089
You can take you can do at least some of the basic type of summary statistics,

131
00:17:15,090 --> 00:17:20,160
like the sum or the maximum or the minimum of a tuple, like the same way you can do with lists.

132
00:17:20,580 --> 00:17:23,340
I mean, at least if the list contains all the numbers,

133
00:17:23,940 --> 00:17:31,990
so you can take the sum of a numeric tuple so that that works the same way with it as with list.

134
00:17:32,010 --> 00:17:42,410
Basically you can slice to, I mean, if you're accessing kind of multiple things with tuples, you can use the same type of slicing notation.

135
00:17:42,420 --> 00:17:51,320
So if you want to access the elements with index zero zero and one, so not including two, you would just do it this way.

136
00:17:51,360 --> 00:18:02,189
It would be zero colon to. You could do the land function with two poles to get a length, the length of a two policy,

137
00:18:02,190 --> 00:18:10,820
you can basically do most of the same type of operations with two poles that you can do with the strip, with with lists.

138
00:18:11,960 --> 00:18:23,930
So most of the things that we've talked about, about the operations with tuples, with with lists, you can do with two poles as well.

139
00:18:26,990 --> 00:18:33,799
One thing that's sometimes useful is to just it's called unpacking the lists, I guess.

140
00:18:33,800 --> 00:18:48,200
So you can start unpacking a tuple. You can kind of, I guess extract the individual elements from a tuple and assign them to individual variables,

141
00:18:48,800 --> 00:18:51,140
at least with kind of with a single line of code.

142
00:18:51,710 --> 00:19:01,370
So if we defined this tuple here, you could do this, you could do this type of assignment and X, Y, Z is equal to the two.

143
00:19:02,240 --> 00:19:09,709
And then then you'll have a variable called X, which is equal to the first element of the two.

144
00:19:09,710 --> 00:19:14,180
Both you'll have a variable Y, which is equal to the second element of the tuple,

145
00:19:14,630 --> 00:19:18,800
and then you'll have a variable Z, which is equal to the third element of the tuple.

146
00:19:21,020 --> 00:19:27,509
Okay. You could actually do.

147
00:19:27,510 --> 00:19:32,760
I didn't think we mentioned this with list, but I'll mention mention it.

148
00:19:32,760 --> 00:19:36,250
Now you can basically do the same thing with lists.

149
00:19:36,270 --> 00:19:41,100
Actually, you just you just put in brackets instead of instead of parentheses.

150
00:19:41,640 --> 00:19:55,410
And then I'll actually unpack a list like you will assign the values of a list to two individual variables, kind of within a single line of code.

151
00:19:55,950 --> 00:20:01,070
Okay. So this is this is called unpacking.

152
00:20:01,080 --> 00:20:11,430
So it's sometimes useful if you just want to kind of assign individual components of a list to kind of specific variables.

153
00:20:14,250 --> 00:20:19,920
Okay. So let's see.

154
00:20:24,580 --> 00:20:30,670
And this is one way to kind of extract the results of a function that returns a tuple results.

155
00:20:30,670 --> 00:20:34,510
So this is just an example of a function that returns a tuple.

156
00:20:35,260 --> 00:20:39,399
So this is a function I'm calling in Back Square.

157
00:20:39,400 --> 00:20:47,290
So this takes a like a list argument and then it returns the,

158
00:20:50,800 --> 00:20:59,950
it returns the minimum of that list squared and then maximum that of that list squared and it returns it as a tuple.

159
00:21:00,790 --> 00:21:09,369
Okay. So, so this returned result as a tuple,

160
00:21:09,370 --> 00:21:17,230
the first element is the minimum of the list and then the second element of the tuple is the maximum of the input list.

161
00:21:17,910 --> 00:21:28,450
Okay. So, you know, one way of extracting the, the result is to do this kind of notation.

162
00:21:28,450 --> 00:21:34,830
If I say X come a Y, or I could, I could have done this course.

163
00:21:35,680 --> 00:21:42,190
You could have done it in parentheses as well. But you can, as we said, the tuples, you can do it without parentheses.

164
00:21:43,990 --> 00:21:46,240
I just say X, comma Y is equal to this.

165
00:21:46,240 --> 00:21:58,120
That's going to, I guess, assign the first element of the return tuples an X and then the second element of the returned tuple to Y.

166
00:21:58,270 --> 00:22:05,440
Okay. So that's just kind of way of extracting the results of a return tuple.

167
00:22:05,520 --> 00:22:11,530
In many cases, you want to assign each number to this different variables.

168
00:22:11,530 --> 00:22:21,550
So you can see that here. If I if I print out the result, I will say X equals four basically, and then y is equal to 25.

169
00:22:21,790 --> 00:22:28,900
Okay, so that's. One way you can unpack.

170
00:22:29,140 --> 00:22:36,790
Unpacking it too may be useful. Okay, so I think that's I think that's basically it for two things.

171
00:22:36,790 --> 00:22:48,069
I mean, I think pretty much most of the operations are the same as lists that we didn't mention unpacking,

172
00:22:48,070 --> 00:22:53,020
which I don't think we mentioned before when we talked about lists.

173
00:22:53,590 --> 00:23:03,910
Really, the only thing I remember about tuples is that, you know, they're not you could not change the elements of the tuple once it's been defined.

174
00:23:04,510 --> 00:23:13,240
That's really the difference. Otherwise you can do a lot of the same things that you did with lists, with tuples.

175
00:23:14,440 --> 00:23:18,759
Okay, so I guess the next topic is loops.

176
00:23:18,760 --> 00:23:22,659
I mean, I just put it in the middle a little bit.

177
00:23:22,660 --> 00:23:25,930
I think at some point we do need to talk about loops.

178
00:23:26,650 --> 00:23:29,680
So loops are used. I mean,

179
00:23:30,310 --> 00:23:37,660
pretty much every programing language has some capability for loops somewhere and it

180
00:23:40,180 --> 00:23:46,420
so loops are basically used when you want to repeat some computation many times.

181
00:23:46,600 --> 00:23:55,919
Okay. Um, the two main types of loops in python are going to be the for loop.

182
00:23:55,920 --> 00:24:11,470
And the while loop for loop is typically going to be used in a situation where you know exactly how many times you need to do a calculation.

183
00:24:12,220 --> 00:24:19,660
So if you know, for example, that you know that you have to do some calculation a thousand times, it's really.

184
00:24:22,490 --> 00:24:33,410
The way to write that with a photo loop is pretty direct okay for a while loops that's usually it's kind of

185
00:24:33,410 --> 00:24:40,970
set up to be in situations where you want to repeat the calculation until some conditions are satisfied.

186
00:24:41,000 --> 00:24:48,710
So if you want to do some calculation, you're going to repeat it until, you know, some number is less than 0.013.

187
00:24:49,190 --> 00:24:53,690
That's really kind of the way that the syntax of a while loop is set up.

188
00:24:55,770 --> 00:24:58,790
Okay. So those are basically those are the two main types of loops.

189
00:24:59,750 --> 00:25:11,790
So we'll just mention for loops first. So this is just kind of the general kind of notation you have to use to write a for loop in Python.

190
00:25:11,810 --> 00:25:19,760
So usually the way you would write it in the first line is like four K in some type of sequence that you've defined.

191
00:25:21,560 --> 00:25:27,350
So oftentimes it's like, you know, one, two, three, four, five, up to some number.

192
00:25:27,350 --> 00:25:31,010
For example, it's kind of a classic way to set up a loop.

193
00:25:31,190 --> 00:25:36,899
You can use other sequences, but that's kind of the most common.

194
00:25:36,900 --> 00:25:44,450
That's usually like a number, an integer sequence from I you'd start from zero zero up to some large number.

195
00:25:45,680 --> 00:25:49,450
And then here, I guess I'd call it the body of the loop where you do the inventing.

196
00:25:50,540 --> 00:25:55,250
So it could be a single line, but it could be a bunch of lines.

197
00:25:56,270 --> 00:25:59,839
So that's basically the body of the loop.

198
00:25:59,840 --> 00:26:05,120
Is that the it's the code that repeats the calculation a bunch of times.

199
00:26:09,570 --> 00:26:21,680
And I guess sequence is kind of any type of mean, any type of things that has, I guess, a bunch of elements.

200
00:26:21,680 --> 00:26:26,900
I guess in general you would call it an iterable, iterable object.

201
00:26:28,610 --> 00:26:40,940
So basically anything that has a collection of values, so your examples include lists, tuples, sets, dictionaries, things like that.

202
00:26:45,420 --> 00:26:47,549
So basically what this for loop is going to do,

203
00:26:47,550 --> 00:26:57,960
it's going to repeat the calculation or I guess the computation expressed in the body of the for loop, I would say capital T times.

204
00:26:58,680 --> 00:27:02,550
So capital T times is just basically the length of this sequence.

205
00:27:03,110 --> 00:27:16,950
Okay. So each time the code each time I guess that the code here is executed is kind of K is using a different value of J.

206
00:27:16,980 --> 00:27:21,480
So K is set to two one elements in this sequence.

207
00:27:21,540 --> 00:27:29,190
Okay. It's basically the way a for loop works. So maybe just an example to make it more clear.

208
00:27:29,970 --> 00:27:42,390
So like, if I just want to do something five times or print out some sequence of five numbers, this is how you would do it with a four.

209
00:27:43,770 --> 00:27:53,640
So I would say for I in this sequence, this is basically I'm using a list.

210
00:27:54,480 --> 00:27:57,890
So I'll say with the time,

211
00:27:57,900 --> 00:28:12,510
the terminology I will use is that I is kind of the iterating variable kind of does it changes each time you do a new iteration of your loop.

212
00:28:14,070 --> 00:28:26,460
So I can. I guess what's going on is that, you know, the first time we go inside the loop, I has the volume one.

213
00:28:27,300 --> 00:28:31,640
Okay, so it executes the body of the for loop turning up one.

214
00:28:32,250 --> 00:28:33,960
The next time we go inside the loop,

215
00:28:34,680 --> 00:28:42,060
I has the next value in the sequence so I is equal to two and then it prints out that value and so forth and so forth.

216
00:28:42,930 --> 00:28:50,280
And it keeps going until we run out of we kind of use all of the numbers in the sequence up here.

217
00:28:50,310 --> 00:29:01,440
Okay. So that's kind of what's going on. Each time we go inside the loop, it has a different value from the sequence out here.

218
00:29:02,160 --> 00:29:08,030
This is kind of the way the loops work and this is the syntax in part.

219
00:29:09,510 --> 00:29:16,860
Okay, so here's a maybe a slightly more useful oh, oh yeah, this works.

220
00:29:16,890 --> 00:29:20,040
So slightly more useful examples.

221
00:29:20,040 --> 00:29:26,730
So this is kind of writing a loop that can return the mean of a list.

222
00:29:27,420 --> 00:29:39,180
So here I've defined a numeric list. If you wanted to define or if you wanted to write a loop that calculates the mean directly, you could do it.

223
00:29:39,180 --> 00:29:42,510
This way you can first create a variable that is equal to zero.

224
00:29:43,050 --> 00:29:48,960
Then each time we go inside the loop, we're going to add a number to two total.

225
00:29:50,730 --> 00:29:55,020
So when you're finished with this loop, it has basically is the total sum, really.

226
00:29:55,380 --> 00:29:57,510
And then we're going to divide by five at the end.

227
00:29:58,140 --> 00:30:11,610
So you can see here, each time we go inside, the loop total is equal to the previous total plus the the next, the next value in the list.

228
00:30:11,730 --> 00:30:15,540
Okay. And then we we're starting from the index is zero.

229
00:30:15,580 --> 00:30:28,170
Okay. So the first time we go inside the loop, I has the value zero and it's adding zero plus the kind of the first element, the numeric list.

230
00:30:28,900 --> 00:30:31,110
And then the next time we go inside the loop,

231
00:30:31,650 --> 00:30:44,310
I has the value one and then it's adding the number to kind of the previous value of of five in the list that's stored in total.

232
00:30:44,680 --> 00:30:48,059
Okay. So when you've finished this list, it's going to have the total sum.

233
00:30:48,060 --> 00:30:51,120
And then if you just divide by five, that gives you that mean.

234
00:30:54,130 --> 00:31:06,310
Okay. Okay. So here is just an example that just saying that, you know, this sequence, you're controlling the looping variable.

235
00:31:06,310 --> 00:31:12,820
If you think it's either these EI or the K or the fruit here is come up because think of this,

236
00:31:13,000 --> 00:31:16,569
I'll call it the looping variable or the iterating variable.

237
00:31:16,570 --> 00:31:22,330
But the sequence here in a for loop does not have to be numeric.

238
00:31:22,720 --> 00:31:31,450
I mean, it can I would say it usually is, but it doesn't have to be kind of any any sequence will work here.

239
00:31:31,450 --> 00:31:35,980
I could just have a list made up of strings.

240
00:31:36,550 --> 00:31:47,680
And then here, if we kind of iterate over that list each time we go inside the loop, fruit takes on a value from that list.

241
00:31:47,920 --> 00:31:54,690
Okay. So the first time you go inside that list, fruit is equal to apples.

242
00:31:55,420 --> 00:31:59,170
The second time you go inside the list, fruit is equal to pears and so forth.

243
00:31:59,800 --> 00:32:06,700
So kind of any kind of iterate iterable object works and then you can have a list of strings.

244
00:32:07,210 --> 00:32:16,870
I would say usually it's a kind of a list or something like that, composed entirely of numbers, but it doesn't it doesn't have to be okay.

245
00:32:16,870 --> 00:32:25,030
So here is kind of a useful notation to know.

246
00:32:26,410 --> 00:32:36,280
So, you know, oftentimes with a, with a for loop, you want to iterate over a sequence of consecutive numbers,

247
00:32:36,820 --> 00:32:45,100
maybe for example, zero, one, two, three, you all the way up to 100 or something like that for those types of things.

248
00:32:45,100 --> 00:32:58,150
It's, it's useful to use the range function. So you don't have to kind of specify the full list of all the numbers from 0 to 100.

249
00:32:59,740 --> 00:33:07,899
So you can use something like this if you want to loop over all the elements and a list,

250
00:33:07,900 --> 00:33:14,170
for example, you can use a range and then input to range is just integers.

251
00:33:14,170 --> 00:33:18,130
So you can in this case, you might want to look at the length of the list.

252
00:33:19,680 --> 00:33:34,059
Okay. So for example, if I wanted to print out all the numbers in a list that has like five, I can just use this kind of syntax.

253
00:33:34,060 --> 00:33:37,390
I just do for I in range five.

254
00:33:38,170 --> 00:33:42,820
So range five is really I mean, range is it doesn't return.

255
00:33:43,360 --> 00:33:50,079
It's not exactly a list. The thing that it returns, I think there's a special like range type of variable,

256
00:33:50,080 --> 00:34:02,260
but it essentially acts as if it were a list like you could think of range five as just kind of doing the same thing as a list of zero one,

257
00:34:02,260 --> 00:34:09,810
two, three, four. Okay. Basically the same way it's acting in the same way as a list of the numbers zero

258
00:34:09,970 --> 00:34:15,970
comma one to come up three times for me to you think of it doing it that way.

259
00:34:15,970 --> 00:34:23,190
So if I just want to print out all the elements of a list with five numbers, you can just do it this way.

260
00:34:23,200 --> 00:34:36,700
You could say four I in range five and just print out each number I could just print novelist I guess it's a range is kind of very useful.

261
00:34:36,700 --> 00:34:41,500
I think it's pretty common. It's a pretty common thing to see in Python code.

262
00:34:43,180 --> 00:34:47,860
So the basic way you use range is to give it a single integer.

263
00:34:47,860 --> 00:34:55,020
But you can give it. Extra numbers.

264
00:34:55,030 --> 00:34:58,110
Let's give it, actually. I think you.

265
00:35:00,150 --> 00:35:05,550
Oh, I think I'll give it some examples later. I didn't see examples here.

266
00:35:10,270 --> 00:35:16,900
I think as I usually and most common application, you just give the range function a single integer.

267
00:35:17,500 --> 00:35:23,739
I think as I said before, the range there's a specific range data type, so it's not exactly a list.

268
00:35:23,740 --> 00:35:27,670
But I would you could think of it as basically returning a list.

269
00:35:33,090 --> 00:35:43,409
If you give it a single integer, basically you can think of it as returning the values zero up to that integer minus one.

270
00:35:43,410 --> 00:35:53,100
So if I give it like range five, that's going to return basically something like a list of the numbers zero one, two, three, four.

271
00:35:53,550 --> 00:36:02,070
If I give it an input integer 11, that that'll you could think of that as returning basically a list of the numbers zero one,

272
00:36:02,070 --> 00:36:05,280
two, three, four and all the way up to ten. Okay.

273
00:36:05,940 --> 00:36:10,500
So that's the way range works if you just give it a single integer.

274
00:36:13,060 --> 00:36:27,670
I think that here. I guess we could run through this quickly.

275
00:36:27,670 --> 00:36:30,800
This is just like it's a little question. I put it in the middle.

276
00:36:31,660 --> 00:36:35,980
Let's say if we looked at this, ah, this python code with this print out.

277
00:36:36,940 --> 00:36:45,159
So I think this is just saying. If I had this list of strings.

278
00:36:45,160 --> 00:36:49,960
And then if you create this list here, this is actually just an empty list.

279
00:36:50,770 --> 00:37:02,370
This is going to. This is a four loop that basically adds is basically adding things to a list each time we go inside the room.

280
00:37:03,880 --> 00:37:12,450
So you can think of this, it's going to only add things in the loop if I is less than three.

281
00:37:12,460 --> 00:37:16,180
So it's basically going to only add things to the list.

282
00:37:16,180 --> 00:37:20,760
If I is equal to zero, is equal to one or an I is equal to two.

283
00:37:20,820 --> 00:37:24,370
So it's only going to add things kind of three times.

284
00:37:25,610 --> 00:37:34,390
So the first thing, the first time we go inside the list, it's going to add these two components like.

285
00:37:37,130 --> 00:37:47,660
The first and second elements of fruit. So the kind of first time we go inside the list, it's going to add the components, apple and orange.

286
00:37:50,900 --> 00:37:57,990
The second time we go inside the list, it'll add orange and banana, right?

287
00:37:58,040 --> 00:38:02,120
Because that's the components one and two.

288
00:38:02,750 --> 00:38:06,979
And the third time we go inside the list, it'll add banana pair.

289
00:38:06,980 --> 00:38:11,810
So it should be kind of apple orange from the first iteration,

290
00:38:12,350 --> 00:38:17,990
an orange banana from the second iteration, and then banana pear from the third iteration.

291
00:38:18,560 --> 00:38:29,220
So I think the answer is option two. Answer and some answers.

292
00:38:29,230 --> 00:38:34,420
Option two, just because it's kind of adding to strings every time we go inside the list.

293
00:38:39,130 --> 00:38:53,390
All right. So that's kind of just an example of using range and combining gift statements and the fact that adding list does concatenation,

294
00:38:53,650 --> 00:38:59,170
you just kind of just kind of a review of a few concepts.

295
00:39:00,160 --> 00:39:05,080
So let's see. Just to finish up the discussion of range, I mean, I think, like I said before,

296
00:39:05,080 --> 00:39:14,500
like I'd say most common way range is used is just a single integer, but, and you can give it up to three integer arguments.

297
00:39:14,500 --> 00:39:24,430
So if you do, if you give it to integer arguments, it creates kind of a list of integers that go from X to Y minus.

298
00:39:24,670 --> 00:39:34,300
So if I give it the number X and comma wide, it's going to give us like basically a list starting from X all the way up to Y minus one.

299
00:39:36,380 --> 00:39:45,500
So if I give it like the numbers 20 and 27, it's going to give us a list of numbers starting from 20 all the way up to 26.

300
00:39:46,170 --> 00:39:56,600
Okay. So it goes all the way up to the basically the largest integer that's still less than Y.

301
00:39:56,660 --> 00:40:01,290
So it goes all the way up to Y, but it doesn't it doesn't include the number of Y.

302
00:40:01,310 --> 00:40:05,209
So that's how you that's what branch returns.

303
00:40:05,210 --> 00:40:13,070
If you give it to integers, you can give it three integers and that'll be basically it.

304
00:40:13,370 --> 00:40:17,630
The third argument gives it kind of like entrapment, basically.

305
00:40:18,290 --> 00:40:23,030
So if I guess like for example, if I give it 525,

306
00:40:23,720 --> 00:40:34,220
it will give us kind of a a sequence starting from five and it'll go up to 20 and it'll increase by steps of five.

307
00:40:34,760 --> 00:40:36,829
So it'll be like five, ten, 15.

308
00:40:36,830 --> 00:40:48,160
So note that it will never include the value 20 it'll basically go out to kind of the largest allowable value that does not include.

309
00:40:48,700 --> 00:40:51,620
So in this case, it'll be five, ten, 15.

310
00:40:53,930 --> 00:41:07,760
If I give like 521 comma five, that'll do five, ten, 15 and now it'll include 20 just to be cut because 20 is, is less than 21.

311
00:41:10,520 --> 00:41:17,479
Here's another example. You could actually go down. It doesn't you don't have to you just have to do an increasing sequence.

312
00:41:17,480 --> 00:41:28,670
Like if I do two negative ten and stuff like negative two, it'll go in, I'll start from two and then it'll decrease at every kind of step.

313
00:41:29,300 --> 00:41:32,120
So to zero negative to negative four.

314
00:41:32,780 --> 00:41:43,250
Negative six negative me doesn't kind of go all the way to negative ten start stops at the time that the value just before negative ten.

315
00:41:44,450 --> 00:41:50,179
Okay. So that's how range can work with either two arguments or three arguments.

316
00:41:50,180 --> 00:41:58,219
So the second to get it to arguments, it basically doesn't necessarily start from zero to give it three arguments,

317
00:41:58,220 --> 00:42:06,080
it doesn't necessarily have a step increment of one.

318
00:42:06,500 --> 00:42:10,340
So you can have different magnitudes of increments.

319
00:42:12,530 --> 00:42:18,180
Okay. So let's. Do another example.

320
00:42:19,630 --> 00:42:31,830
So yeah, I would say loops are often useful for creating lists, at least lists that may not have an easy pattern to create.

321
00:42:32,370 --> 00:42:37,190
So let's say you wanted to create a list of the first in squares.

322
00:42:37,290 --> 00:42:41,440
Basically that just means the first element is one square.

323
00:42:41,460 --> 00:42:46,560
The second element is two squares. The third element is three squared and so forth.

324
00:42:51,120 --> 00:42:54,150
You could do that with a four loop pretty directly.

325
00:42:54,690 --> 00:43:00,809
Especially if you're using the iPad two method. So one way to do it is this way.

326
00:43:00,810 --> 00:43:06,030
I can just first create an empty list. To create an empty list you just to open closed bracket.

327
00:43:07,110 --> 00:43:12,720
And then in the loop I can go from four I in range 1 to 7.

328
00:43:13,380 --> 00:43:19,380
So this is going to create kind of a list of one, two, three, four, five, six.

329
00:43:19,560 --> 00:43:28,140
Right. And then kind of each time we go inside the list, we just append.

330
00:43:29,050 --> 00:43:35,190
We just remember append just adds a single number to the existing.

331
00:43:35,310 --> 00:43:42,210
So the first time we go inside the loop, it's going to add the number one to the list askew list.

332
00:43:42,840 --> 00:43:46,319
Second time it's going to add the number for a third time.

333
00:43:46,320 --> 00:43:55,530
It's going to add the number nine. Okay. And so you can see here at the end, we have the list with numbers one, four, nine, 16, etc., etc.

334
00:43:58,990 --> 00:44:03,480
Okay. Yeah.

335
00:44:03,490 --> 00:44:10,360
So again, I think, as I said before, I think range is useful if you don't.

336
00:44:11,680 --> 00:44:24,540
Well. I guess if you don't know how long are I guess if you don't want to type, you don't know the length of the list,

337
00:44:24,540 --> 00:44:31,649
at least in the sense that you don't know how long it will always be when you when you're

338
00:44:31,650 --> 00:44:38,910
doing this basically might take an input list and you look at the length of that,

339
00:44:39,150 --> 00:44:49,770
you can extract the length of that list. So let's say you wanted to compute the summer squares and a numeric list.

340
00:44:50,310 --> 00:44:53,670
And the numeric list is like an input argument and a function.

341
00:44:56,030 --> 00:45:03,410
The way to do that is just put the land of the lists inside of range.

342
00:45:04,430 --> 00:45:09,190
So here we have a numeric list to do total.

343
00:45:09,230 --> 00:45:11,540
If I want to compute the total sum of squares,

344
00:45:11,540 --> 00:45:21,020
I can just give an initial initial value of zero and then just keep a running sun and add the number every time we go inside the list.

345
00:45:21,670 --> 00:45:25,670
Okay. And so here I'm just using range other than the length of the list,

346
00:45:25,670 --> 00:45:34,160
that's just going to give us a sequence of numbers starting from zero all the way up to the but not including that of the length of the list.

347
00:45:34,430 --> 00:45:40,550
Okay. So this this will compute the total sum of squares of the components of that list.

348
00:45:41,480 --> 00:45:44,900
Looks. Okay.

349
00:45:44,900 --> 00:45:51,389
So the last thing I'll mention, I think about loops is about nested loops.

350
00:45:51,390 --> 00:45:54,320
So basically just if you have a loop inside of another loop.

351
00:45:57,790 --> 00:46:04,840
So basically, if you have this set up, this kind of thing on the furthest to the left that has no indentation,

352
00:46:05,320 --> 00:46:07,810
that'll usually be referred to as the outer loop.

353
00:46:08,650 --> 00:46:16,540
And then kind of this second for loop that's kind of has some indentation that's usually referred to as the inner loop.

354
00:46:17,170 --> 00:46:24,400
So basically the way it works for a nested loop is that for kind of each like each time you go inside the outer,

355
00:46:24,700 --> 00:46:31,600
so each iteration of the outer loop, kind of the entire inner loop is executed.

356
00:46:31,900 --> 00:46:37,800
Okay. So basically you are going to have, let's say,

357
00:46:38,640 --> 00:46:44,070
tee times p iterations in total wear like the length of the sequence for the

358
00:46:44,070 --> 00:46:50,600
outer loop is length T and the length of the sequence for the inner loop is P,

359
00:46:51,160 --> 00:46:57,930
and the total number of iterations that you execute is T times P, so you just see that here.

360
00:46:57,930 --> 00:47:04,049
So for each time we go inside the outer loop, we execute the entire inner loop.

361
00:47:04,050 --> 00:47:07,950
So the first time we go inside the outer access, the value one.

362
00:47:08,940 --> 00:47:16,290
So here we execute the entire. Enter, which is where Y goes from 1 to 3.

363
00:47:16,780 --> 00:47:23,820
So you can see here the first three things are that are printed out x as the value of one y goes from 1 to 3.

364
00:47:24,510 --> 00:47:33,420
Then after that's done a set, that's why you're doing the second iteration, the outer loop where X has the value two.

365
00:47:33,870 --> 00:47:45,060
Then you run through the entire Y values 1 to 3, the third iteration of the outer loop access the value three.

366
00:47:45,450 --> 00:47:54,570
Then you run through the the Y values there. So for each kind of iteration of the outer loop, the entire inner loop is executed.

367
00:47:55,210 --> 00:48:01,540
It's kind of the way that a nested for the works this.

368
00:48:04,100 --> 00:48:08,570
It's too complicated for this. Okay.

369
00:48:08,580 --> 00:48:14,000
So let's see. This was just kind of a little bit of an example.

370
00:48:20,150 --> 00:48:27,070
Oops. Okay.

371
00:48:27,130 --> 00:48:33,020
So let's see. Oh, I see.

372
00:48:33,800 --> 00:48:42,570
I kind of split it in two parts. I forget that I did that. So this is just a way to write code that computes kind of all the prime numbers up to 60.

373
00:48:42,590 --> 00:48:48,649
So this first this first slide doesn't do the whole computation.

374
00:48:48,650 --> 00:48:53,450
So this is just an example. So a number, if you remember, it's prime.

375
00:48:53,450 --> 00:48:59,260
It's basically prime as it's kind of the only divisor is itself in one.

376
00:48:59,270 --> 00:49:03,890
There's no there's no other number, that kind of.

377
00:49:05,630 --> 00:49:08,810
Where you do television and ends up with an integer. Okay.

378
00:49:09,980 --> 00:49:14,120
So basically we're saying about the python syntax.

379
00:49:14,660 --> 00:49:30,740
An integer is prime. If X modulus y is not equal to zero, at least for any y between, that's greater than or equal to two and less than x.

380
00:49:30,750 --> 00:49:41,810
So if you go from all the numbers from two up to x minus one is that modulus is zero or is not zero, that means it's prime.

381
00:49:42,350 --> 00:49:45,440
So it's just kind of a way of doing that in Python.

382
00:49:47,110 --> 00:49:53,740
So let's say you wanted to just write Python code that checks if the number 13 is prime or not.

383
00:49:54,730 --> 00:49:58,180
This is the way you could do it. You could say first x is equal to 13.

384
00:49:58,810 --> 00:50:05,890
And then to go from all the numbers. Let's say Y going from A to X minus one.

385
00:50:05,950 --> 00:50:17,890
That's what we're doing here. And then I'm just going to say, if x modulus y is zero, I'm going to increase count divided by one.

386
00:50:19,810 --> 00:50:23,950
So if it's prime, you should never go inside this F statement, right?

387
00:50:24,790 --> 00:50:29,470
If it's prime, you should never have x modulus y equals zero.

388
00:50:30,370 --> 00:50:39,640
Okay. So if you run this whole loop count device should still equal zero because you've never gone inside this thing.

389
00:50:42,360 --> 00:50:50,880
You can see that here. When I run this code, I, I had it stated here at the bottom, if count device equals 0%, this number is prime.

390
00:50:51,560 --> 00:50:55,860
Okay. So this is basically saying that 13 is prime.

391
00:50:56,760 --> 00:51:00,270
I think, you know, I'm sorry, 13 is a prime number.

392
00:51:02,760 --> 00:51:12,690
So you can kind of put this inside of a bigger loop if you wanted to determine like all the prime numbers up to 60, for example.

393
00:51:12,700 --> 00:51:17,040
I mean, you could do you could do even more pretty easily.

394
00:51:18,690 --> 00:51:22,790
But this is just so kind of all the numbers print out. Okay.

395
00:51:22,800 --> 00:51:26,570
So here we're just going to do the same logic that we had on the previous slide.

396
00:51:26,580 --> 00:51:32,370
We're just going to put kind of all of this stuff within like a larger loop.

397
00:51:32,850 --> 00:51:38,190
So this this will be kind of like an inner loop part inside of an outer loop.

398
00:51:40,680 --> 00:51:41,009
Okay.

399
00:51:41,010 --> 00:51:52,860
So here are the way I'm going to do that is going to start with a list that just has the number two, because I think that's the first prime number.

400
00:51:52,860 --> 00:51:59,670
And then we're just going to add more numbers to the list if if we determine if the prime or not.

401
00:52:02,020 --> 00:52:08,580
Okay. So here in the outer loop, I'm going to look at numbers starting from three all the way up to 60.

402
00:52:08,590 --> 00:52:12,549
So, you know, including the number 60.

403
00:52:12,550 --> 00:52:16,990
So three, four, five all the way up to 60, so not including 61.

404
00:52:17,830 --> 00:52:26,709
And then we're going to do that. Basically, the same logic that we had before we're going to do this count of is equals zero.

405
00:52:26,710 --> 00:52:28,630
And then we do this same type of for loop.

406
00:52:29,470 --> 00:52:39,270
And then I'm going to say if count DAVIES is still zero after running test for this for loop here, I'm going to append that to the existing prime.

407
00:52:39,430 --> 00:52:44,980
So I'm just going to basically add that to our existing prime.

408
00:52:45,070 --> 00:52:58,060
So a few so as X is prime, it's just going to be added west and then we're going to do that for kind of for all X between three and 60.

409
00:52:58,780 --> 00:53:04,660
Okay. So you can in the nested loop terminology, this this will appear as an inner loop.

410
00:53:05,590 --> 00:53:10,570
And then kind of this this part here is the outer loop.

411
00:53:11,290 --> 00:53:11,589
Okay?

412
00:53:11,590 --> 00:53:22,060
So the only thing really that's going on in the inner loop is we are just testing if X modulus is equal to zero or not and then we're doing this,

413
00:53:22,690 --> 00:53:31,570
adding count of this by one. And this if statement is really the only thing that's part of the only computation that's going on with the interval.

414
00:53:32,350 --> 00:53:38,890
I would say this is this if statement here is kind of part of the outer loop.

415
00:53:39,130 --> 00:53:47,200
And then also this really resetting the count of is to zero is part of the outer loop as well.

416
00:53:49,630 --> 00:53:56,210
Okay. So, okay, so this this turns out the full list of numbers from our prime numbers from two

417
00:53:57,080 --> 00:54:06,230
close to 60 of all of the prime numbers from 2 to 660 since the start of the year.

418
00:54:06,250 --> 00:54:10,420
Okay. So that's four loops.

419
00:54:10,440 --> 00:54:13,290
So the other main type of loop is a while loop.

420
00:54:13,950 --> 00:54:22,320
So the basically the logic of a wild loop is it keeps executing a piece of code as long as a certain condition is.

421
00:54:25,300 --> 00:54:35,980
So the general kind of formula or the general form of a while loop is you have a while keyword while and then you have some type of condition here,

422
00:54:36,730 --> 00:54:41,139
which is usually a boolean expression. And then you have the code chunk underneath,

423
00:54:41,140 --> 00:54:49,450
which is the thing that gets as the chunk of code that gets executed kind of every for every iteration of the loop.

424
00:54:50,140 --> 00:54:57,340
And usually you'll update something related to condition somewhere in this code.

425
00:54:57,610 --> 00:55:04,420
Just so initial condition should eventually become false at some point.

426
00:55:05,200 --> 00:55:17,050
Okay. So that the code chunk inside of here basically gets repeated until kind of this Boolean expression condition becomes false.

427
00:55:17,560 --> 00:55:27,340
And in that case the loop stops. Okay. So the whether or not the loop keeps running or not depends on whether or not condition is true or false.

428
00:55:29,050 --> 00:55:32,370
Okay. Okay.

429
00:55:32,370 --> 00:55:41,090
So this is a bit of an example of a wire loop that can print out the first five numbers, basically.

430
00:55:41,100 --> 00:55:44,880
So I'm going to have to start with count equals one.

431
00:55:45,500 --> 00:55:56,190
And I'm just going to say, while count is lesser than or equal to five, each time you go inside a loop for now count and increased by one every time.

432
00:55:57,120 --> 00:56:01,350
But this will terminate whenever a count becomes six.

433
00:56:02,180 --> 00:56:12,690
So that's the first time you get inside the loop town is one it prints count and then it increases count two checks.

434
00:56:12,690 --> 00:56:16,499
This condition is still true. So go inside the loop again.

435
00:56:16,500 --> 00:56:26,760
And then it keeps doing that until kind of a final case where we count as equals five and then we say count is equal to count plus one.

436
00:56:26,760 --> 00:56:35,280
So it's six and it kind of goes back up here and it checks to this condition and it sees that count is equal to six.

437
00:56:35,280 --> 00:56:43,499
And so everything is kind of terminated. So after the fifth iteration, it sees that count as equals six.

438
00:56:43,500 --> 00:56:49,780
And so the entire loop is terminated. Here's just an example.

439
00:56:49,790 --> 00:56:53,420
If you run this card, this doesn't print anything out.

440
00:56:54,080 --> 00:57:02,260
So if you say count, if you say count as equal to 6/1, it just doesn't put anything out in the first place.

441
00:57:02,270 --> 00:57:11,510
The loop checks this condition. It says it's false, so it doesn't even go inside the loop even once.

442
00:57:11,720 --> 00:57:19,380
Okay. I saw a few one or two examples.

443
00:57:20,790 --> 00:57:34,379
Okay. So here's an example. Or writing a function that finds the first match, the first index where a list matches an input string.

444
00:57:34,380 --> 00:57:35,920
So this actually does the first.

445
00:57:36,780 --> 00:57:45,780
Basically does the same thing as like the index method that we talked about before last time where it finds the first index of the first match.

446
00:57:45,780 --> 00:57:51,150
But here we're kind of just writing a function ourselves that can do the same thing.

447
00:57:52,560 --> 00:57:54,990
So one way to do this is with a Y loop.

448
00:57:55,740 --> 00:58:06,150
So basically when you're if you're writing this with a while loop, you're just going to keep looping through until you've found a match.

449
00:58:06,990 --> 00:58:11,310
And then whatever that matches value to the while loop will stop.

450
00:58:11,550 --> 00:58:16,350
Okay. So here I've done done it in this function.

451
00:58:16,350 --> 00:58:20,370
So I've written a function called Find Match Index.

452
00:58:21,000 --> 00:58:26,220
We have an input string as one argument and an input list as another argument.

453
00:58:32,720 --> 00:58:40,850
So I'm initialized count as equal to negative one and the condition.

454
00:58:46,490 --> 00:58:51,140
For the while loop is going to update this boolean variable called match underscore found.

455
00:58:51,830 --> 00:58:55,250
So I'm going to initially initialize that as false.

456
00:58:56,300 --> 00:58:59,390
So really what we're going to check is while not match found.

457
00:58:59,390 --> 00:59:12,140
So I guess you could have done this in a different way, but you want to keep going until a match is found.

458
00:59:12,740 --> 00:59:19,130
Okay. So when we start off, match is not found.

459
00:59:19,190 --> 00:59:23,370
So we should say match found is equal to false. Okay.

460
00:59:23,420 --> 00:59:30,770
So basically all we have to do is check the condition inside the wild and we just say match

461
00:59:30,770 --> 00:59:42,770
found as it is given by the boolean expression input list count is equal to the input string.

462
00:59:45,390 --> 00:59:54,840
So the input string is just like a signal strings. You can think of it as a word and then we're just checking as to this element of the string is.

463
00:59:59,770 --> 01:00:06,579
Is equal to that. Okay. Okay. And so here, I guess we could have started the index some other way,

464
01:00:06,580 --> 01:00:13,240
but I just start at negative one and I didn't count equals count plus one kind of before the first test.

465
01:00:13,780 --> 01:00:16,120
That's just because indexing starts at zero.

466
01:00:17,320 --> 01:00:27,910
And I guess this the way I've written this function in this example is I assume that I assume that there is there is a match somewhere.

467
01:00:28,330 --> 01:00:36,819
I think otherwise you're going to run into an error somewhere just because I think you're going to have a value account,

468
01:00:36,820 --> 01:00:40,480
which is kind of longer than the length of the input list.

469
01:00:41,050 --> 01:00:49,360
But this should run without an error as long as there there is a match between the somewhere between the input string and the input list.

470
01:00:49,930 --> 01:00:52,510
Okay. So here's just an example of this.

471
01:00:52,990 --> 01:01:00,550
If I define this fruit list that has these components and then I just want to find the match index where I put the input,

472
01:01:01,360 --> 01:01:05,349
the input string as peach that should be able to find a match.

473
01:01:05,350 --> 01:01:18,100
So that's indexed to. The first magic index or really the only matching index is that index to of this list.

474
01:01:18,160 --> 01:01:21,870
So it's peach, which is an index too. Okay.

475
01:01:21,880 --> 01:01:27,790
So this is how you can. Kind of a natural way of using a while.

476
01:01:27,790 --> 01:01:31,270
If you keep you keep running the loop until a match is found.

477
01:01:36,360 --> 01:01:39,900
Okay. So here is just a review a little bit.

478
01:01:44,580 --> 01:01:47,600
The answer 16. I think this is just this.

479
01:01:47,600 --> 01:02:03,750
She can write it down. It's just more of a way of counting values and making sure you see when exactly the filing terminates.

480
01:02:05,370 --> 01:02:15,120
So I would say in the first and the first iteration, you know, after this Code X is three and Y is.

481
01:02:16,200 --> 01:02:21,030
So it's not a problem. We go back and check this condition.

482
01:02:21,600 --> 01:02:28,589
The second time we go in X is six and Y is eight after executing that.

483
01:02:28,590 --> 01:02:32,610
So that goes in the third time.

484
01:02:33,330 --> 01:02:39,030
After executing this, x is going to be nine and Y will be equal to 12.

485
01:02:41,040 --> 01:02:47,700
We'll go back here and check. So that's still not a problem because X is lesser than or equal to ten.

486
01:02:48,420 --> 01:02:52,120
That's because we're doing the boolean expression based on or so.

487
01:02:52,140 --> 01:02:54,030
You only need one of these to be true.

488
01:02:54,030 --> 01:03:05,190
So you're going to go back another time, a fourth time, and in that case X will be equal to 12 after executing this code while the equal of 16.

489
01:03:06,300 --> 01:03:09,420
And then it'll when you go back here and check this condition.

490
01:03:09,420 --> 01:03:15,810
Now both of these conditions are false so that that will basically terminate the loop.

491
01:03:16,470 --> 01:03:25,830
So when you print this here and you'll be 16, so Y will have the value 16 and X will have the value 12.

492
01:03:26,520 --> 01:03:30,000
So I guess the answer to this questions is 16.

493
01:03:35,440 --> 01:03:42,970
Okay. So I think one maybe final example with loops, I just think this is kind of an example,

494
01:03:43,900 --> 01:03:51,370
a common example if you're doing any type of direct but implementing any type of computation yourself.

495
01:03:52,390 --> 01:04:01,180
So one way to like one numerical method define the square root of a number is to use this kind of iteration.

496
01:04:02,290 --> 01:04:09,159
So let's say you want to find the square root of a number, or at least get a close approximation of the square root of a number.

497
01:04:09,160 --> 01:04:12,850
A You can use this type of iteration.

498
01:04:13,540 --> 01:04:19,390
Okay. So you choose some initial value for X zero, for example,

499
01:04:19,960 --> 01:04:28,180
and then you just keep updating that the values of the X sequence using this kind of

500
01:04:28,180 --> 01:04:35,080
formula here x in plus one is equal to one half times x ten plus eight divided by access.

501
01:04:35,460 --> 01:04:46,210
Okay. So I think a nice way to do this with a y a loop of I guess a nice way to use it to implement this is with a while loop.

502
01:04:47,500 --> 01:04:51,130
So here you can kind of create variables called Excel.

503
01:04:51,160 --> 01:04:57,280
The next move I think you'll explode is storing the value of X and adding x.

504
01:04:57,280 --> 01:05:00,430
New is storing the values of x plus one.

505
01:05:01,030 --> 01:05:08,149
And then you basically just terminate this iteration whenever kind of the x and plus one an x and are very small,

506
01:05:08,150 --> 01:05:11,350
which kind of just means kind of everything is converged.

507
01:05:11,350 --> 01:05:17,920
And it should be it should be pretty close to the tree, to the actual square root that you're interested in.

508
01:05:19,170 --> 01:05:22,840
Okay. So that the way to implement this in Python.

509
01:05:23,410 --> 01:05:29,950
Let's say you wanted to find the square root of the numbers 713.

510
01:05:31,780 --> 01:05:37,290
I'll just create an initial value for X because we think of this as X one.

511
01:05:37,300 --> 01:05:42,010
If you're starting the sequence from x one, I'll just started from 50, that'll be two.

512
01:05:42,310 --> 01:05:52,270
That's like a first guess. And then kind of the second number in the sequence is just 0.5 times X all plus a divided by Axel.

513
01:05:53,530 --> 01:05:58,450
And then I'll just have a, I'll just basically do the same thing inside the while.

514
01:05:58,770 --> 01:06:07,330
And the thing that I'm going to check with the Y loop is if the absolute value of Excel minus X new is greater than 0.001.

515
01:06:07,990 --> 01:06:11,650
So this basically just keeps iterating as long as this is true,

516
01:06:12,370 --> 01:06:19,390
and then it will terminate when this absolute value becomes lesser than or equal to 0.001.

517
01:06:19,960 --> 01:06:24,730
So that's what I've said here. So kind of each time I go inside the loop,

518
01:06:24,730 --> 01:06:36,200
I just say X old is the previous value of x new and then the new value of X new is based on this update condition on Excel.

519
01:06:36,340 --> 01:06:44,230
And then the next iteration I say excellent was the previous value of x new and then x new is this update of x old.

520
01:06:44,320 --> 01:06:51,670
You just keep doing that over and over again until this condition is is no longer true.

521
01:06:52,360 --> 01:06:55,420
Or is this. Yeah, this condition is false.

522
01:06:56,560 --> 01:07:01,510
So this is what you get if you run it and then print the result.

523
01:07:01,510 --> 01:07:06,790
I think this is probably pretty close to the the square root,

524
01:07:09,240 --> 01:07:15,790
at least the square root that you would get if you kind of did it directly with the square root function.

525
01:07:17,320 --> 01:07:20,440
All right. So that's it for.

526
01:07:31,950 --> 01:07:35,380
Well, I definitely don't want to get into dictionaries.

527
01:07:36,040 --> 01:07:48,020
And I'll mention a little bit about said so I said. Somewhat similar to lists that face the main differences like they're not orders like.

528
01:07:48,980 --> 01:08:00,920
It just depends on the actual values in the in the set select the the set that's you would write it out as 1 to 3 is the same as the set 3 to 1.

529
01:08:01,640 --> 01:08:06,560
Okay so there's no it doesn't depend on kind of how you order them when you create the set.

530
01:08:08,600 --> 01:08:11,900
The other thing is that there's no duplicates in a set,

531
01:08:12,350 --> 01:08:19,220
so it's kind of similar to this to set the usual set definition maybe in mathematics that you may have seen.

532
01:08:20,120 --> 01:08:26,689
So like if you try to create a set that has the value with the numbers, one, two, three, comma, three,

533
01:08:26,690 --> 01:08:37,640
like you do duplicate it three it will basically remove the extra three you're only going to have three once.

534
01:08:37,850 --> 01:08:41,120
Okay. So they're useful I guess if.

535
01:08:45,070 --> 01:08:53,670
I like the membership tests. You may want to test if a variable is contained within some collection of of quantities.

536
01:08:54,330 --> 01:09:01,190
What you're not really concerned about ordering are whether those things have duplicates or not.

537
01:09:01,200 --> 01:09:06,409
You just want to test if a number, for example, is is a member of some sense.

538
01:09:06,410 --> 01:09:12,090
So you may have a like a set of ID numbers, for example,

539
01:09:12,090 --> 01:09:17,970
and you may just want to test that this new ID is a member of that collection of ideas or not.

540
01:09:19,680 --> 01:09:24,960
And it's also useful when you really only care about working with a unique set of values.

541
01:09:26,570 --> 01:09:33,260
And there's often many cases where you want to use the money to do a union intersection.

542
01:09:33,260 --> 01:09:38,980
Those types of calculations, those types of things.

543
01:09:39,060 --> 01:09:43,340
Sets are useful for. Okay.

544
01:09:43,340 --> 01:09:48,569
So. Sets can be created in a couple of ways.

545
01:09:48,570 --> 01:09:53,430
Basically, just with the function itself or with the curly brace is.

546
01:09:53,430 --> 01:09:57,660
So if I say this variable S1, I just say set.

547
01:09:59,520 --> 01:10:10,590
And then I put kind of a a list notation inside of parentheses that will create a set of the elements three, four and five you could do.

548
01:10:10,620 --> 01:10:17,699
Yeah. But also, you know, if I try to create an asset with duplicates,

549
01:10:17,700 --> 01:10:24,600
like if I say three comma for a comma five and then three again twice, it just basically ignores those extra threes.

550
01:10:25,170 --> 01:10:28,590
And there's you're not allowed to have duplicates with sets.

551
01:10:29,130 --> 01:10:33,840
It'll just it'll still create the same set. Three, comma, four a comma, five.

552
01:10:37,070 --> 01:10:46,820
And the other way to create a sense is just you put everything inside of curly braces, like all the elements of the set that are separated by commas.

553
01:10:52,340 --> 01:11:00,079
Okay. So maybe I'll just. Yeah, I just mentioned how to do unions and intersections.

554
01:11:00,080 --> 01:11:01,760
I'll just stop there.

555
01:11:01,760 --> 01:11:10,159
So the way to do intersection, I mean, sorry with union like union, you're just looking at if you're doing the union of two service,

556
01:11:10,160 --> 01:11:15,230
you're talking at the collection of elements that are in either of the two sets.

557
01:11:15,950 --> 01:11:20,030
You basically do that with the the vertical bar.

558
01:11:21,860 --> 01:11:27,679
So if I want to, if I create these two sets, S1 and S two, if I want to compute the union of that,

559
01:11:27,680 --> 01:11:33,740
I can just do S1 vertical bar as to that computes the union of those two sets.

560
01:11:38,790 --> 01:11:43,389
Another way to do it is just to use that union method on one of the sets and then

561
01:11:43,390 --> 01:11:49,380
you give it that new a new set as kind of an argument in the in the function.

562
01:11:50,850 --> 01:11:58,920
So if I create these two sets, S1 and S2, I could do S1 dot union and then put S2 inside of the parentheses.

563
01:11:59,670 --> 01:12:04,230
That's another way of doing it. That's totally fine. Either way is okay.

564
01:12:04,530 --> 01:12:12,540
You could also do S1. I mean, you could also have as two dot union S1 that's an equivalent way of doing it.

565
01:12:18,170 --> 01:12:22,460
And the other main operation was set is intersection.

566
01:12:24,260 --> 01:12:29,150
So the way to do intersection instead of vertical bar is to use this ampersand.

567
01:12:29,900 --> 01:12:36,200
So if I said if I create two sets, S1, it has to run the S1 ampersand as two.

568
01:12:37,130 --> 01:12:38,630
And you see the intersection.

569
01:12:38,630 --> 01:12:47,300
In this case, the intersection is five as the only element in both sets of the intersection just gives you the elements that are in both sets.

570
01:12:49,130 --> 01:12:57,770
You can use the intersection operator or the intersection method is the way to say it, basically the same way you use union.

571
01:12:58,430 --> 01:13:04,400
So if I do S1 intersection S2, that's basically the equivalent way of doing it.

572
01:13:05,660 --> 01:13:08,870
You know, you could also just do s to that intersection.

573
01:13:08,870 --> 01:13:14,210
S1 doesn't really matter. The order doesn't matter when you're taking the intersection.

574
01:13:14,960 --> 01:13:19,520
So these are both valid reason to do that. So let's see.

575
01:13:20,330 --> 01:13:25,730
Yeah, I think we'll just stop there and we'll just come back.

576
01:13:27,560 --> 01:13:41,830
There's not a lot to say about sets where you can do a review of sets and these extra two points about how to work with sense.

577
01:13:41,840 --> 01:13:45,650
And I guess the main thing we'll do next time is dictionaries.

578
01:13:51,350 --> 01:13:59,000
Yeah, I think that's it for today. I'll, I'll try to do an update on the homework assignment later later this evening.

579
01:13:59,840 --> 01:14:04,610
I think that'll be just keep in mind that that's due this weekend.

580
01:14:04,610 --> 01:14:08,269
And because we don't have any we don't have any class on Monday.

581
01:14:08,270 --> 01:14:11,450
Right? Yeah. So you seem a little.

582
01:14:11,540 --> 01:14:18,920
Yeah, I have a little bit of a break after this. So I guess we'll start with like.

583
01:14:22,090 --> 01:14:30,959
I'm just going on. Oh yes.

584
01:14:30,960 --> 01:14:40,260
We'll start yeah. We'll start on on Wednesday. The next class question you're meeting.

