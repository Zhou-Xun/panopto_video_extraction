1
00:00:27,160 --> 00:00:35,710
So, uh. Let's get started this session.

2
00:00:35,900 --> 00:00:43,640
Valerie So. Probably better to replace it now than later.

3
00:00:43,880 --> 00:01:12,200
Just give me a second. This. Okay.

4
00:01:13,460 --> 00:01:18,140
Can you hear me? Okay, so let's get started.

5
00:01:18,890 --> 00:01:33,290
Uh, I. I had technical difficulty in joining, uh, my office, our room in the first 15 minutes or so.

6
00:01:33,290 --> 00:01:40,519
So if you joined office hours. So I eventually joined, but some I don't know if I lost anyone.

7
00:01:40,520 --> 00:01:46,399
I didn't get an email that someone could enjoy join, but if you couldn't join them, so sorry about that.

8
00:01:46,400 --> 00:01:50,720
And feel sorry for those who had to wait yesterday.

9
00:01:51,290 --> 00:02:04,150
So my apologies. Uh, so I got a question about homework one and, uh, because, uh,

10
00:02:05,030 --> 00:02:12,979
humor one problem one is, uh, it, it, it is not straightforward to derive the equation.

11
00:02:12,980 --> 00:02:19,610
And uh, many, you know, I wasn't surprised, but the many people are having, uh,

12
00:02:21,230 --> 00:02:27,530
you know, challenges with getting them, you know, getting to that, uh, derivation.

13
00:02:27,530 --> 00:02:36,450
So I would like to, you know, so, so as I said, getting the derivation improving, you know,

14
00:02:36,500 --> 00:02:42,530
coming up with the derivation, proving that this is a correct is not the path that we're trying to evaluate.

15
00:02:42,530 --> 00:02:48,679
We're trying to evaluate whether you can implement the idea in the actual software.

16
00:02:48,680 --> 00:02:53,650
So if there is a given, it's probably good to implement.

17
00:02:53,660 --> 00:03:01,220
I, I do recommend to, uh, you know, for to talk with others in work what would be the right algorithm to use.

18
00:03:02,570 --> 00:03:07,550
But if you couldn't come up with that equation, oh, here's my suggestion.

19
00:03:08,480 --> 00:03:15,440
So I told the GSA, uh, to help with this derivation more actively.

20
00:03:15,440 --> 00:03:22,790
So, uh, from this week, I believe that the Friday of this hour will be in person.

21
00:03:23,120 --> 00:03:33,739
Okay, so for there's a two hour, so there is a four hour GSA office hours and two two hour is a is in zoom in 12 is a hybrid.

22
00:03:33,740 --> 00:03:38,930
So you can you can join by June because there's a Friday and that everyone is on campus.

23
00:03:38,930 --> 00:03:43,230
But you can join by Zoom. So, okay.

24
00:03:43,250 --> 00:03:49,819
So you can do it in person maybe, you know, getting help is easier in person if you write a post, write something.

25
00:03:49,820 --> 00:04:02,980
But I'll try to, uh, give a heads up to the GSA un so to, to help with this, uh, common problem where actually, okay,

26
00:04:03,440 --> 00:04:09,450
so that if you have trouble with that deriving, I think you can show substantially more in,

27
00:04:10,180 --> 00:04:13,580
uh, to how to come up with the creation that, that should help.

28
00:04:15,350 --> 00:04:25,700
Uh, yeah. So that's one way you can also request a meeting with the GSA if you, if you have a conflict with the office hours or if you need more,

29
00:04:25,710 --> 00:04:29,450
all your help that are in the day that where there's no forced hours.

30
00:04:30,470 --> 00:04:42,590
I do have time today after meeting so I can also talk to you if you if you don't have immediate class right after.

31
00:04:42,590 --> 00:04:46,610
So I can I can help in the we can we can discuss in the office.

32
00:04:47,700 --> 00:04:51,169
Uh, okay. So that's that's the help.

33
00:04:51,170 --> 00:04:52,129
I would recommend that.

34
00:04:52,130 --> 00:05:08,180
And please try to, you know, make sure you maximize your your you have access to GSA in with in my office hour two so try to use those time by eight.

35
00:05:08,540 --> 00:05:13,999
So far you don't see many guests in my office hours in my GSA.

36
00:05:14,000 --> 00:05:22,100
I don't either. I know that that's totally fine. But, um, I think that's the right way to approach, to address the challenges.

37
00:05:22,730 --> 00:05:32,270
Okay, so and so I also got some questions about how do I how do I prove these?

38
00:05:32,270 --> 00:05:40,400
Because I do it in the whiteboard and maybe someone didn't couldn't see them clearly or forgot what the derivation was.

39
00:05:41,030 --> 00:05:50,810
So I know this is kind of important because the now of one is very close to West table which so humor one has a more sort of trickier part.

40
00:05:50,900 --> 00:05:58,310
So I, I would I would yeah. I'll mention that probably in the Monday, you know, if, if many people struggles with it.

41
00:05:58,820 --> 00:06:09,320
But the more tricky part but if you can prove the if you can derive the West algorithm for the variance part, then it's a it's quite close.

42
00:06:09,320 --> 00:06:13,300
So you, you probably can. The drive. They started with Jim as well.

43
00:06:13,740 --> 00:06:22,090
Okay. So this is a Western question, right? So the part that that we really are curious is how how do you show this?

44
00:06:22,090 --> 00:06:28,030
How do you prove this? Well, I had a proof here, but the proof is very messy.

45
00:06:28,540 --> 00:06:31,960
Right. And we we came we went through this.

46
00:06:32,350 --> 00:06:39,540
But more problem is, how do you come up with this equation? I understand this is correct, but you need to come up with the equation now.

47
00:06:39,920 --> 00:06:46,680
Right. So how do you derive this? So that that that is a question is a very clear question.

48
00:06:46,700 --> 00:06:49,450
I think you you could you can ask.

49
00:06:49,900 --> 00:07:02,050
So now if you look at the page, I had this link basically that should direct you to this derivation of the West Buddhism here.

50
00:07:03,220 --> 00:07:10,090
Okay. So I'm explaining how, how sorry this is.

51
00:07:11,680 --> 00:07:16,900
This is not what I. Okay.

52
00:07:16,920 --> 00:07:24,210
So so I have a I try to be as detailed as possible for each of the step.

53
00:07:24,570 --> 00:07:27,629
So if there are I just wrote this this morning.

54
00:07:27,630 --> 00:07:31,440
So if you find any errors, please them, you know.

55
00:07:32,910 --> 00:07:37,620
But these proof for the mean should be easy, I think.

56
00:07:37,900 --> 00:07:42,270
And I just wrote a thing here about proof for the various part here.

57
00:07:42,270 --> 00:07:46,600
I said a n, which I define as of this quantity.

58
00:07:46,620 --> 00:07:50,850
So basically A of n divided by minus one is a bit variance.

59
00:07:50,990 --> 00:07:56,010
Okay. So then you can you can you can derive this.

60
00:07:56,370 --> 00:08:05,850
Let me go through this quickly. So basically, you need to show these the creation, that this is all the part that is in the West algorithm.

61
00:08:06,780 --> 00:08:13,140
And what you can do, too, if you want to derive this, you need to subtract them.

62
00:08:13,230 --> 00:08:16,890
Right? If you subtract them, you have this this equation.

63
00:08:17,310 --> 00:08:20,310
Okay. So. Well,

64
00:08:20,520 --> 00:08:33,900
the difficult part is that you have three terms X of N and a mean of X mean of X at the time of n is a mean of a mean of x where with a n minus one,

65
00:08:33,920 --> 00:08:38,820
the first observation. Right. So then you need to get rid of one of them.

66
00:08:39,180 --> 00:08:43,110
So my. If you get rid of this X of NN.

67
00:08:43,140 --> 00:08:47,190
So how how do you get rid of this? You have this equation.

68
00:08:47,880 --> 00:08:52,710
So this is a publication. One is something you may want to use for your homework too.

69
00:08:53,010 --> 00:09:03,210
Okay. So you can represent X of, you know, the mean of x as a function of mean of x minus one.

70
00:09:03,990 --> 00:09:10,870
So mean of mean of x12x in as a function of mean of x one to x minus one.

71
00:09:10,920 --> 00:09:14,510
And the last observation, and you can do vice versa.

72
00:09:14,520 --> 00:09:17,999
So you can also represent this value as a function of these.

73
00:09:18,000 --> 00:09:21,150
And it's a it's a matter of which which variable I want to use.

74
00:09:21,160 --> 00:09:25,710
I want to get rid of one of these three variables. So what, what do I want to do?

75
00:09:25,740 --> 00:09:28,879
So then if you decide that I want to get rid of this.

76
00:09:28,880 --> 00:09:38,580
So in this case, I decide to get rid of this. Then you replace this variable into this representation and keep doing the calculation.

77
00:09:38,580 --> 00:09:42,560
This calculation looks it it is not trivial.

78
00:09:42,570 --> 00:09:53,610
It is it is a quite a bit of work. But if you grouped them into same term and cancel out all, all the other values,

79
00:09:53,610 --> 00:09:59,610
what you will have eventually is that you have these n minus one over n vectors.

80
00:09:59,970 --> 00:10:05,520
But so everything has a coefficient of n minus one over n.

81
00:10:06,240 --> 00:10:20,430
Then you have this. So you can represent this as a sum square of x of n minus the mean mean of x sum up to the point of n, minus one observation.

82
00:10:21,230 --> 00:10:28,410
Okay. So this is how you derive with the West region and you can do pretty much a similar thing,

83
00:10:28,410 --> 00:10:32,370
but there is a some additional tweaks that you may not, you know.

84
00:10:33,360 --> 00:10:39,540
Yeah. So and there is one, there is a multiple of multiple possible way to derive it.

85
00:10:40,350 --> 00:10:48,080
So because a, you have a multiple variables in here, so you don't have to use an of X of PN and minus one.

86
00:10:48,090 --> 00:10:54,690
Oh, I don't want to use X or y minus y I, I want to just running mean of two and observation so you can do it.

87
00:10:55,140 --> 00:11:01,740
The equation becomes slightly different. One equation is more numerically stable and the other equation is less stable.

88
00:11:01,750 --> 00:11:09,659
So the the reason why we're struggling chose this is because there is no multiplication involved inside here.

89
00:11:09,660 --> 00:11:13,200
So it's a little less operation you need to do.

90
00:11:13,650 --> 00:11:17,459
So that's why this formation is the preferred.

91
00:11:17,460 --> 00:11:19,950
So if you want it to be really absolutely perfect,

92
00:11:20,280 --> 00:11:28,950
then you can try multiple different way to derive and pick the one that uses the least amount of arithmetic operations.

93
00:11:29,370 --> 00:11:33,030
But that's probably really advanced, and you probably don't need that.

94
00:11:33,270 --> 00:11:33,550
Okay.

95
00:11:34,500 --> 00:11:41,489
And while you're doing this so because there are multiple different way to implement this, I just wanted to make sure that we didn't miss anything.

96
00:11:41,490 --> 00:11:49,080
So if you. Find that you think your solution is correct, but it doesn't work.

97
00:11:49,470 --> 00:12:00,390
Please send me the code by email. Don't share with anyone else and ask me to troubleshoot and add at GSI in your email so we can look at it together.

98
00:12:00,390 --> 00:12:04,740
If if that's actually correct code or not, we will decide.

99
00:12:04,770 --> 00:12:11,339
So sometimes our evaluation code may be too stringent and we can we can change the leniency.

100
00:12:11,340 --> 00:12:23,580
So those are all possible to discuss. Okay. So that is my brief, you know, preamble before before the before today's lecture.

101
00:12:23,610 --> 00:12:32,969
Any questions? So looks like a not many people have started to work on the homework problem that's that's my

102
00:12:32,970 --> 00:12:40,290
impression because I only got a few guests yesterday but I strongly encourage you to do so.

103
00:12:40,380 --> 00:12:48,450
I know that you have a lot of homework and this is not necessarily fun homework, especially for my one because it's a numerical precision.

104
00:12:48,720 --> 00:12:52,620
Even if your A to write the code may not work as expected.

105
00:12:52,620 --> 00:13:04,229
So it is. It is. It could be frustrating. So it may take much more time than you think if you if you end up digging some rabbit holes.

106
00:13:04,230 --> 00:13:10,320
So yeah. Don't, don't, don't try to do that forever and try to get get a help.

107
00:13:10,320 --> 00:13:14,940
Yeah. I'll put derivations of those and the questions to them.

108
00:13:14,990 --> 00:13:18,170
Very. Problem.

109
00:13:18,170 --> 00:13:22,940
Three, three questions, two and three questions. Help with derivation for questions.

110
00:13:22,970 --> 00:13:26,240
Yeah. Question two and three. There is no like, I mean.

111
00:13:28,240 --> 00:13:32,680
So yeah, you can you can ask for derivation for question two and three.

112
00:13:32,860 --> 00:13:38,710
I think question two is basically, I, you know, I can, I can pull up the problem.

113
00:13:39,640 --> 00:13:48,930
Uh, so. So a question to this question to is if you see.

114
00:13:49,530 --> 00:13:52,740
So if you don't know how to solve this regression problem.

115
00:13:53,130 --> 00:13:57,750
So if you. So it comes down to it takes a lot of time to understand the problem.

116
00:13:57,750 --> 00:14:12,270
But if you look at the question to problem two, this is not very complicated regression problem actually, because all beta g is a function of beta.

117
00:14:12,270 --> 00:14:16,430
So beta two is a function of beta one. Beta three is a function of beta two.

118
00:14:16,450 --> 00:14:22,260
So on. So it is it is eventually just a function of beta one and beta zero.

119
00:14:22,530 --> 00:14:29,099
So it's a very simple regression. This you can look up the equation from Wikipedia or any anywhere.

120
00:14:29,100 --> 00:14:32,120
Just using the simple is a simple linear regression.

121
00:14:32,130 --> 00:14:35,310
You can, you can find the equation for it.

122
00:14:36,240 --> 00:14:40,080
So that's my advice. Yeah. Sorry. Fable spoiler.

123
00:14:41,940 --> 00:14:45,880
And this one. This one is.

124
00:14:46,150 --> 00:14:49,750
Yeah, this one is. There is no derivation really required.

125
00:14:49,760 --> 00:14:57,130
I think the thing you need to know is to how to normalize this value because it says that this is only proportional.

126
00:14:57,550 --> 00:15:03,700
So you need to normalize with the summation of this, right. So that that's what you're expected to do.

127
00:15:03,700 --> 00:15:10,779
And there is a this one is also because it involves a lot a lot of explanation here.

128
00:15:10,780 --> 00:15:19,989
So there there's got to be a way that you keep the precision better than just doing the normal, just a linear square calculation.

129
00:15:19,990 --> 00:15:27,190
So that's something you need to do about mathematical representation for solution for this.

130
00:15:27,190 --> 00:15:33,190
And this is it should be very straightforward about the different you can ask to just say and for me,

131
00:15:33,820 --> 00:15:41,920
if you have a you know, you have trouble with getting the, you know, what kind of education I need to implement.

132
00:15:42,370 --> 00:15:53,670
Okay. Yeah, I wouldn't say that derivation is not always the requirement, but the problem one,

133
00:15:54,810 --> 00:16:00,620
I just think that the derivation is a little tricky, especially as the first problem of homeworks.

134
00:16:00,630 --> 00:16:05,550
I just wanted to make sure that that, you know, nobody gets lost.

135
00:16:06,300 --> 00:16:10,070
Okay. Okay.

136
00:16:11,600 --> 00:16:15,320
Okay. So let me then go through the problem.

137
00:16:15,730 --> 00:16:18,830
The problem in lecture three.

138
00:16:19,130 --> 00:16:28,790
So we talked about this generate tower. Okay, so we watch this video and we, we, uh, we stopped here.

139
00:16:28,940 --> 00:16:34,669
Okay, so, uh, Panopto problem.

140
00:16:34,670 --> 00:16:49,840
Just to remind everyone, you have, uh, you have, you have a set of disk disks, and you need to move these disks to one row to the other road.

141
00:16:50,810 --> 00:16:58,360
So when you try to solve this problem, uh, you can use it encouraging, uh,

142
00:16:58,640 --> 00:17:04,790
which is a recursion is just another word of a mathematical induction if in the case that wasn't clear.

143
00:17:05,300 --> 00:17:10,610
So you can use a sort of inductive formula to, uh.

144
00:17:11,880 --> 00:17:13,950
To define your solution.

145
00:17:13,960 --> 00:17:27,210
So and to do that, you need to pretend, okay, so this is a difficult part of the sometimes if you if you are not familiar with the equation,

146
00:17:27,540 --> 00:17:31,169
you don't have really solution except for, you know,

147
00:17:31,170 --> 00:17:40,380
how to solve just one disk and you pretend that I'm I pretend I know the to how to solve or all the end minus one disk.

148
00:17:40,920 --> 00:17:44,100
And I'm not going to implement that part because I know the solution.

149
00:17:44,520 --> 00:17:49,140
Okay. And I'm going to focus on how to move the largest disk.

150
00:17:49,320 --> 00:17:55,050
So that's how you should think about this problem. And that that is very strange.

151
00:17:56,190 --> 00:18:04,709
So how do you do it? Well, if I know how to move PN minus one disk from one power to the other tower,

152
00:18:04,710 --> 00:18:15,540
then I can say oh and minus one disk from the left power to middle power first and move the largest disk to the left tower,

153
00:18:15,540 --> 00:18:22,200
to the right tower and move the end minus one disk again from the middle cover to the right power.

154
00:18:22,290 --> 00:18:28,980
Okay, if, if I assume that I know how to move and minus one disk from any power to any power, I can do that.

155
00:18:29,190 --> 00:18:33,150
Okay. So that's the solution you can implement.

156
00:18:33,570 --> 00:18:43,020
Okay. But so this is well, this is a very similar to the mathematical induction, except that this is not a quantity.

157
00:18:43,020 --> 00:18:47,129
This is not a equation. Right. This is a procedure you are running.

158
00:18:47,130 --> 00:18:51,510
Some algorithm is instead of like a a over an equal something, right?

159
00:18:51,510 --> 00:19:02,910
So instead of doing that, you can just use the you use this a function, just call this function recursively.

160
00:19:02,970 --> 00:19:07,379
So how does this work? Okay, so this is the idea.

161
00:19:07,380 --> 00:19:10,650
So again, this is an algorithm. This is not actually working code.

162
00:19:10,650 --> 00:19:17,820
And this is this kind of represent the representation is called as pseudocode because this is not a specific languages,

163
00:19:17,820 --> 00:19:22,680
but you can conceptualize your algorithm. So this is a good way to write high volume.

164
00:19:22,680 --> 00:19:30,810
There's no stent, no necessarily like specific way that how how you need to you need to write your algorithm.

165
00:19:31,320 --> 00:19:36,590
But this is one way to just write your article.

166
00:19:36,620 --> 00:19:40,320
And so you define what's my input. So this is my data.

167
00:19:40,410 --> 00:19:43,770
Well, I have number of disk, okay?

168
00:19:44,400 --> 00:19:56,010
And I, I need to know which power I need to start with, which tower I need to go to and which tower is the middle tower I can use as a bridge.

169
00:19:56,140 --> 00:20:03,600
Right. So source se is a source I is a intermediate and this is a destination node power in this case.

170
00:20:05,040 --> 00:20:16,589
And so basically you are and moving and this from as two D so you can define this a recursively

171
00:20:16,590 --> 00:20:21,300
and when you type in a substantive recursion always has permanent terminating condition.

172
00:20:22,080 --> 00:20:31,690
You can make a terminating constraint two different ways. One is so you can define what to do if and equal one, or you can define more.

173
00:20:31,690 --> 00:20:37,320
Usually, if any calls, you know, it's even easier if you don't have any disk, don't do it.

174
00:20:37,570 --> 00:20:41,730
Right. So an equal G2? Nothing. So that's. That's my permanent condition.

175
00:20:42,660 --> 00:20:45,870
Okay, then. Otherwise, what do I do?

176
00:20:45,930 --> 00:20:50,130
Well, I call power of energy.

177
00:20:50,430 --> 00:20:54,330
This function for moving in minus one disk two.

178
00:20:54,840 --> 00:20:58,860
So here. So this order is important.

179
00:20:59,880 --> 00:21:06,600
So I'm moving all in minus one disk from source to the intermediate with the middle power.

180
00:21:06,870 --> 00:21:18,240
Okay. Left to the middle power. Okay. And I move and disk from s to these so left to the right power in that you temple and again.

181
00:21:18,720 --> 00:21:26,820
So then you can then the all the end minus on disk should be in the middle power.

182
00:21:26,940 --> 00:21:33,000
Right. So then I'm moving those again from the middle tower to the right tower.

183
00:21:33,120 --> 00:21:37,620
So that's what, that's what it does. So this looks like too good to be true.

184
00:21:37,680 --> 00:21:41,460
This is three lines of code, basically. Does this really work?

185
00:21:41,940 --> 00:21:46,570
Okay. That that argument was very complicated.

186
00:21:46,620 --> 00:21:56,780
If you if you remember and if you if you see Tower of Hanoi, I, I, you know, if you really want if you if you have time to,

187
00:21:57,560 --> 00:22:02,379
to to look at the YouTube videos and stuff, I think there is a I,

188
00:22:02,380 --> 00:22:09,050
I encountered like is recently there's a guy there's a channel three blue brown channel.

189
00:22:09,410 --> 00:22:16,310
They they actually talk about this really deeply in a connect with the all these different ah, fractals and stuff.

190
00:22:16,400 --> 00:22:23,150
So it, it is very interesting but that that's really long video and it does the end 1200 is only part of that but that

191
00:22:23,150 --> 00:22:32,060
that is ah probably worth looking at if you wanted to understand the recorded recording a lot more deeply.

192
00:22:33,020 --> 00:22:37,489
Okay. So here is my attempt to visualize how this works. So this is very mysterious.

193
00:22:37,490 --> 00:22:43,010
Again, I, I understand the many of you are having a problem with recording, but this is how it should work.

194
00:22:43,610 --> 00:22:50,090
So what I want to do, let's say I want to move three disk from left power to the right power.

195
00:22:50,270 --> 00:22:54,950
Okay. So then you call the disk cannot function with this parameters.

196
00:22:54,960 --> 00:22:55,280
Right?

197
00:22:56,600 --> 00:23:10,460
Then if you follow this algorithm, what you need to do is, well, to do this I need to move and minus one is true disk from left to middle power.

198
00:23:10,850 --> 00:23:16,490
Okay, I want to move and I want to move something.

199
00:23:17,400 --> 00:23:26,870
The largest disk from the left tower to the right tower. And I need to move that to disk from the middle tower to the right tower.

200
00:23:26,870 --> 00:23:33,829
So that's what you should do. But once once you call that, you're calling this function first, then disk function.

201
00:23:33,830 --> 00:23:41,840
Cause another function. What is what is it? You are me now I, I'm trying to move to disk from the left tower to the middle tower.

202
00:23:42,440 --> 00:23:48,740
So that means that you need to move one disk from the left tower to the right tower first.

203
00:23:49,880 --> 00:23:53,180
Okay. And to do that, what do you need to do?

204
00:23:53,810 --> 00:23:57,050
You need to move zero disk from the left tower to the middle tower.

205
00:23:57,380 --> 00:24:00,540
Okay, well, this is what they do.

206
00:24:00,630 --> 00:24:05,620
Do nothing. Nothing. Okay. And so this part was done.

207
00:24:05,630 --> 00:24:12,020
So let's let's talk about this of three, then your the next thing you need to do is, oh,

208
00:24:12,290 --> 00:24:20,630
now I have the largest, my largest is in this subtree is just disk one of the for disk one.

209
00:24:20,930 --> 00:24:29,270
I move the disk one from the left power to the right power because of my object is moving, moving everything from left to right.

210
00:24:29,420 --> 00:24:33,530
Right power. So move the disk one to let left how to write tower.

211
00:24:33,980 --> 00:24:43,370
And after that now I can call the remaining part Move that move zero disk from middle tower to the right tower.

212
00:24:43,580 --> 00:24:49,399
But this doesn't do anything because of your moving disk. Okay, so this is this is a sequence.

213
00:24:49,400 --> 00:24:52,490
Okay, now this is done. Which means.

214
00:24:52,490 --> 00:24:57,200
And now I move the one disk from the left tower to the middle tower.

215
00:24:57,530 --> 00:25:00,860
Right. So left tower to the right tower.

216
00:25:01,460 --> 00:25:07,340
So now I need to move this the largest disk, which is disk to from the tower to the middle tower.

217
00:25:07,460 --> 00:25:10,460
Okay. So that's what it does.

218
00:25:10,730 --> 00:25:17,270
Okay. And, and after that, I need to call it, I need to move the this one,

219
00:25:17,270 --> 00:25:23,240
the remaining this one disk again from the middle tower to the left tower to the middle tower.

220
00:25:23,300 --> 00:25:27,260
Okay, so this so sorry. Right, power to the middle tower.

221
00:25:27,350 --> 00:25:36,830
So basically because your destination is the middle tower here, I'm moving left first, moving, moving from left out to the right tower.

222
00:25:37,190 --> 00:25:45,200
And after moving the order of the largest disk and moving again from the right tower to the middle power because my destination is middle tower.

223
00:25:46,130 --> 00:25:50,420
So then then this do the pretty much the same thing.

224
00:25:50,600 --> 00:25:56,900
So zero disk don't do anything. And after that disk one should be moving from the right tower to the middle tower.

225
00:25:57,530 --> 00:26:04,580
Okay. And zero zero this closer then. Okay, now this is done.

226
00:26:05,030 --> 00:26:14,479
This function called ended, which means that now if this works successfully, that means that my two disk should have.

227
00:26:14,480 --> 00:26:18,140
Should be moving from left towards the middle tower.

228
00:26:18,230 --> 00:26:22,970
Right? So now the next thing I need to do is a large disk with disk three.

229
00:26:23,090 --> 00:26:25,340
Move from the left tower. Totally tower. Okay.

230
00:26:26,030 --> 00:26:35,660
And after that, you, you move, you move these two disk from middle tower to the right tower to completely.

231
00:26:35,870 --> 00:26:43,069
Okay, this part is a pretty much working the same, except that the first ones are left out to the middle tower now.

232
00:26:43,070 --> 00:26:51,080
Middle. How to write power. So all the parameter changes. So if you if you try to keep track of which parameter was what, this is really complicated.

233
00:26:51,080 --> 00:26:59,090
So human, you know, from human I oh, this, this is very hard to keep track of, but, you know, computer doesn't care like how.

234
00:26:59,450 --> 00:27:05,179
So it just switch around automatically and they cause the right parameter and it should work like this.

235
00:27:05,180 --> 00:27:13,940
So if you look at the actual sequence that needs to happen, this one, so you can imagine this three power,

236
00:27:13,940 --> 00:27:24,090
100 power this 1/1 go to the left and right this to left to the middle, this disk one from the right to the middle disk.

237
00:27:24,510 --> 00:27:28,069
Then then you have a two, now you have two disk in the middle tower.

238
00:27:28,070 --> 00:27:33,200
Now you can move this tree and the if you, if you keep doing that, you can realize that,

239
00:27:33,200 --> 00:27:38,270
oh, this doesn't violate any rule in the tower and it gives the right solution.

240
00:27:38,600 --> 00:27:43,070
So you can generalize this by adding more tree in the above level.

241
00:27:43,580 --> 00:27:48,920
And then you can do like in the, in the YouTube algorithm.

242
00:27:49,180 --> 00:27:56,299
So you to you to have a video, they have like 88 disk and a 2055 moves.

243
00:27:56,300 --> 00:28:01,700
You can you can replicate that with this. Okay.

244
00:28:02,910 --> 00:28:09,690
So this kind of algorithm is called. Divide and conquer ultimatums.

245
00:28:14,010 --> 00:28:23,220
So what is divide and conquer? So divide and conquer algorithm is an algorithm that solves the problem recursively.

246
00:28:24,600 --> 00:28:34,920
So let me try to solve it. Excuse me.

247
00:28:37,260 --> 00:28:41,010
Okay. Divide and conquer, which means of solving a problem recursively.

248
00:28:41,070 --> 00:28:44,850
Applying this three steps in each of those.

249
00:28:45,300 --> 00:28:49,890
Each of the equation. So how do we do it?

250
00:28:50,130 --> 00:28:55,800
You divide a problem into some problems in the problem.

251
00:28:55,810 --> 00:29:02,200
You divide the problem to resolve problems. One is a moving and minus one disk from the left to the middle in a.

252
00:29:02,880 --> 00:29:07,830
And the second problem is a moving the largest disk.

253
00:29:08,130 --> 00:29:15,120
And a third problem is moving in minus one disk from the middle to the right.

254
00:29:15,120 --> 00:29:18,269
But the sub problem, I'm talking about the smaller problem.

255
00:29:18,270 --> 00:29:25,679
So moving in minus one disk is kind of smaller problem. So you basically divide the problem into smaller problem.

256
00:29:25,680 --> 00:29:38,100
I need to move a minus one disk, but instead of doing that, I want to formulate this problem ism as a moving end minus one disk twice plus alpha.

257
00:29:38,160 --> 00:29:38,430
Right?

258
00:29:39,600 --> 00:29:51,210
And after that divide, that's a device step concor step is concourse step is basically you just assumes a conquest of you don't need to do anything.

259
00:29:51,300 --> 00:29:58,080
Concourse That means that you just call those problems and pretend the problem is solved.

260
00:29:58,430 --> 00:30:07,440
Okay. In this case and minus one disk, you need to implement something to the solve the problem for n minus on this,

261
00:30:07,440 --> 00:30:14,849
could you just assume that there are solved in the so if the small and you need to define the terminated condition.

262
00:30:14,850 --> 00:30:19,770
So the problem is really small. You need to give the term in Indian condition.

263
00:30:20,280 --> 00:30:23,660
I assume that this was solved in a straightforward manner. Okay.

264
00:30:24,360 --> 00:30:33,330
And after that, even if you have a sub problem solved, you need to combine those problems to in the right sequence to solve the larger problem.

265
00:30:33,660 --> 00:30:36,810
You need to define that how to solve the larger problem.

266
00:30:37,110 --> 00:30:48,749
Okay. So that's the combine step. Okay. So this is this is how divide and conquer which works so in power with no problem, how does this work?

267
00:30:48,750 --> 00:30:55,950
So you basically divided the problem into three different pieces like this and

268
00:30:55,950 --> 00:31:00,480
after that conquer steps to basically assume that those two problems are solved.

269
00:31:00,690 --> 00:31:07,020
Okay, concourse step. You don't need to do anything. You just need to define the terminal condition and come by step.

270
00:31:07,980 --> 00:31:16,890
Just put the sequences together into a into our solution for the larger problem you wanted to solve.

271
00:31:17,520 --> 00:31:23,760
Okay, so still this. Okay, I get what it what this means, but how does it really work?

272
00:31:23,970 --> 00:31:31,170
Okay, so well before we were going through the implementation, let's try to do the proof so.

273
00:31:31,170 --> 00:31:33,870
Well, I'm not going to prove the correctness.

274
00:31:34,020 --> 00:31:40,680
Okay, so correctness is a no because the induction is a if you if you believe in induction, it should work.

275
00:31:41,370 --> 00:31:45,000
Okay. So time complexity. Okay.

276
00:31:45,450 --> 00:31:52,770
How does how how much does does does how much or how much longer?

277
00:31:53,040 --> 00:31:57,119
How much longer? Yeah, how much more operation? In this case time complex.

278
00:31:57,120 --> 00:32:01,859
You can think of how many disk I need to move but you can each of them usually computation

279
00:32:01,860 --> 00:32:08,159
operations you need to do and some competition operations are more expensive than others,

280
00:32:08,160 --> 00:32:11,879
like switching the element between the two element in array.

281
00:32:11,880 --> 00:32:16,170
You need to do memory operation that's much more expensive than CPU operation.

282
00:32:16,170 --> 00:32:20,040
So you can, you can define like a, what's my computation cost?

283
00:32:20,220 --> 00:32:29,370
Okay. So moving zero disk doesn't, doesn't require anything for moving and disk basically how many move do you need?

284
00:32:29,370 --> 00:32:34,259
You need to move number of moves to move and minus one disk.

285
00:32:34,260 --> 00:32:40,950
But you need to do it twice. Okay. And plus one move to the move the largest disk let's that's the total number of move you need.

286
00:32:41,520 --> 00:32:45,000
Okay then if you know how to do this, solve the induction.

287
00:32:45,180 --> 00:32:54,690
This is a very familiar form I think that you've done probably in high school and T of n is a two to the n minus one.

288
00:32:54,870 --> 00:33:05,009
Okay. So that means that if you I didn't explain the legend but there's a legend that that some king some some some some guys said,

289
00:33:05,010 --> 00:33:08,729
oh, I, you know, I want the worst.

290
00:33:08,730 --> 00:33:15,540
I want to yeah, I want to meet your daughter and did that the king didn't want to give the daughter

291
00:33:15,540 --> 00:33:22,439
to to the to to the person because he he he thought it was not not very smart.

292
00:33:22,440 --> 00:33:25,649
So so he gave these challenges.

293
00:33:25,650 --> 00:33:28,710
So we have this high power. You have 64 disk.

294
00:33:29,070 --> 00:33:33,270
If you move everything this way, then well, I'll give you.

295
00:33:33,890 --> 00:33:37,820
Keep in mind that I'll allow you to marry my daughter.

296
00:33:37,820 --> 00:33:44,600
And if you need to do 64 days, then the number of operation you need is this much,

297
00:33:44,900 --> 00:33:50,450
which is, you know, one one mile per second, meaning that the 585 billion years.

298
00:33:50,960 --> 00:33:54,980
So that's that's that's that's a one polite way to say it.

299
00:33:54,980 --> 00:33:58,580
But I don't know if it polite or cruel, but the one way to say no.

300
00:33:59,600 --> 00:34:05,850
Okay. So. So this is what we want to do.

301
00:34:06,060 --> 00:34:14,370
So I want you to take time to open the collab page and try to implement on your own because a week we had,

302
00:34:14,370 --> 00:34:21,180
we went through all the pseudocode about trying to work with working with the actually working our code is a little tricky.

303
00:34:21,480 --> 00:34:25,710
And in, in Colette, we cannot really physically move the desk.

304
00:34:25,830 --> 00:34:27,899
So what we are going to do is a printing instruction.

305
00:34:27,900 --> 00:34:36,360
So to move this desk, pretend so then if you print out the instruction, then if someone follows this instruction, it should work.

306
00:34:36,360 --> 00:34:42,360
So at least that you will come up with a correct hybrid. Okay, so we want to implement this type Talabani function.

307
00:34:42,870 --> 00:34:46,620
Okay. So that should be here.

308
00:34:51,230 --> 00:34:56,059
Just to do. So this is the yeah, there's a spoiler.

309
00:34:56,060 --> 00:35:00,140
Right, right below. So you can if you need a spoiler, you can go there.

310
00:35:00,710 --> 00:35:06,240
But let's try to fill this in. Okay. So you need to do something here, okay.

311
00:35:06,440 --> 00:35:16,069
To make this work. And if you think so, if you think you are going to correct everything, implementing it, run this and run this power one algorithm.

312
00:35:16,070 --> 00:35:23,150
If you couldn't figure it out on your own, you can you can use the code block below.

313
00:35:23,750 --> 00:35:30,830
So I'll give you like 3 minutes to sew it so you can try and see.

314
00:35:31,270 --> 00:35:36,830
You can compare with what you have implemented with the what, what's given in this notebook.

315
00:35:38,480 --> 00:35:44,180
And yeah, please start. And in the meantime, if you have any questions, I'm happy to take this.

316
00:35:44,540 --> 00:37:56,400
Take the questions. Okay.

317
00:37:57,120 --> 00:38:05,510
Let's try to look at it. So maybe you want to compare your solution with the solution that are here.

318
00:38:05,520 --> 00:38:09,030
So it's a basically full line. Okay. What does it do?

319
00:38:09,540 --> 00:38:14,129
Well, it has to start with if the statement where and this is greater than zero.

320
00:38:14,130 --> 00:38:19,880
So the intention is that, you know, this this defines the terminated condition.

321
00:38:19,890 --> 00:38:30,420
So if in this case a zero, then do nothing, right? And if end this case are greater than zero, then you basically call them twice.

322
00:38:31,020 --> 00:38:42,360
Okay. But also you print out the messages that move disk to from the from the beginning to end power.

323
00:38:42,510 --> 00:38:45,600
Okay. So that's how it was implemented.

324
00:38:45,600 --> 00:38:50,910
I don't know what what what's the difference between your implementation and this version?

325
00:38:51,380 --> 00:38:56,580
But, you know, if you if you can compare it, that'll be a good lesson for you.

326
00:38:58,620 --> 00:39:06,460
Okay. So let's try to run it. So now your friend.

327
00:39:07,570 --> 00:39:10,750
So then let's look at the run.

328
00:39:10,810 --> 00:39:14,680
This Tower 103. Then it gives the sequence.

329
00:39:14,700 --> 00:39:21,550
And if you try to follow the sequence, you will know that this is a valid way to solve the heart pulmonary problem.

330
00:39:22,600 --> 00:39:28,290
And in this problem, you can change the change the number of days cause you are changing the name of the tower.

331
00:39:28,300 --> 00:39:35,800
So that's flexible. So if you can in this case, it's the solving for power.

332
00:39:36,370 --> 00:39:42,190
You can do 255 as a you can do like eight powers if you want.

333
00:39:42,580 --> 00:39:46,870
Just don't try 64 towers. It'll take it'll it'll just take four forever.

334
00:39:47,120 --> 00:39:55,420
Okay. So, so, but it's, it's a little hard to understand what's happening, right?

335
00:39:56,170 --> 00:40:00,310
So inside. So let's try to comment this line out.

336
00:40:01,270 --> 00:40:05,290
Okay. To print the message whenever a function is called.

337
00:40:05,380 --> 00:40:16,030
And let's try to see what happens. Okay. Then this this situation is exactly the same as the situation that that is in the slide.

338
00:40:16,060 --> 00:40:27,250
So. So the sled, sled, sled I'm talking about is this this sequence of sequence of operation.

339
00:40:27,260 --> 00:40:31,870
So it should print every print the message every time when when this function is called.

340
00:40:32,170 --> 00:40:36,310
So you will know which sequence of operation was performed.

341
00:40:36,820 --> 00:40:40,000
And if you do that, then it basically does this.

342
00:40:40,460 --> 00:40:45,730
Okay. So this function is called when this function is called. It calls the functions of functions.

343
00:40:45,730 --> 00:40:49,510
Of functions of function. And when this was called, it doesn't do anything.

344
00:40:49,750 --> 00:40:53,850
And after that, it considers that the sub problem was solved then.

345
00:40:53,860 --> 00:40:57,900
Now you can move the disk one and assume this problem was solved.

346
00:40:57,910 --> 00:41:07,750
So if you if you understand. So basically I would say that you, you master this problem.

347
00:41:09,370 --> 00:41:16,390
If you can predict what kind of message it will be printed without actually seeing them.

348
00:41:16,570 --> 00:41:22,120
Okay. So then if you can predict that the you understand how this algorithm is actually working.

349
00:41:23,230 --> 00:41:28,240
Okay. Any questions so far?

350
00:41:30,600 --> 00:41:39,550
Okay. So now let's work on some other problem sorting.

351
00:41:39,940 --> 00:41:42,909
Okay. So we're going to get back to the Divide and conquer program.

352
00:41:42,910 --> 00:41:47,920
But let's talk about so forget about divide and conquer now and let's stop talking about sorting.

353
00:41:48,580 --> 00:41:52,150
So you have a bookshelf, you have a lot of books here.

354
00:41:53,620 --> 00:41:56,590
You like to sort them from the small.

355
00:41:56,740 --> 00:42:04,420
You know, if you have, you know, some some obsession, you may want to say I want to sort them from the smallest to the largest.

356
00:42:04,930 --> 00:42:12,940
Okay. How do you do it? So think about how you actually how your brain does.

357
00:42:13,480 --> 00:42:18,100
There is very common you don't you don't think. Right. So it's a very natural thing.

358
00:42:18,550 --> 00:42:24,190
You know, analyze your brain a little bit and try to see what kind of organism your brain is using.

359
00:42:24,340 --> 00:42:27,840
Everyone may be using different things. Okay.

360
00:42:29,560 --> 00:42:34,090
You know, why does the computer prefer to use? And that's something you may want to think about.

361
00:42:36,070 --> 00:42:42,479
So. So let's say you simplify it.

362
00:42:42,480 --> 00:42:46,709
You have this four numbers. The task is a task you're given to.

363
00:42:46,710 --> 00:42:52,920
You is sorted. So these numbers from the smallest, the large number, how do you do it?

364
00:42:53,640 --> 00:42:59,820
Well, it's intuitive, like pick ten either, you know, there's no algorithm.

365
00:43:00,150 --> 00:43:03,810
What do you talk about? This is ten, 11, 15, 20.

366
00:43:04,050 --> 00:43:10,440
Okay. Not that I can do so, but think about a little bit more like computer.

367
00:43:10,950 --> 00:43:16,890
So you had some you skipped some steps when you when you say that.

368
00:43:17,310 --> 00:43:21,299
Oh, how did you choose ten? How did how did she do that first?

369
00:43:21,300 --> 00:43:22,720
How did you just learn first?

370
00:43:23,100 --> 00:43:35,590
There's something you need to describe more specifically what kind of the you know, the unit operation you're using to do the sorting algorithm.

371
00:43:35,640 --> 00:43:43,730
So you cannot tell, you know, when you when you say that you're telling computer what to do and say, oh, no.

372
00:43:44,130 --> 00:43:49,440
Just to pick the one that is smallest, intuitively, that doesn't work.

373
00:43:49,530 --> 00:43:55,230
You you need to you need to describe the steps a little more in detail.

374
00:43:55,440 --> 00:43:59,470
You could. And so.

375
00:43:59,650 --> 00:44:03,580
So that's that's the thing we're going to work with. Okay.

376
00:44:04,030 --> 00:44:12,820
So computers are not as smart as you. So you you only need to use let's say you need to use a pairwise competition and swap operations.

377
00:44:13,000 --> 00:44:17,260
You can switch between the elements. And how would you do it?

378
00:44:17,770 --> 00:44:21,060
Okay. You can only compare and switch. How would you do it?

379
00:44:24,390 --> 00:44:28,890
So there's there's there's like, a lot of algorithms you can do.

380
00:44:29,400 --> 00:44:39,210
I just want you to think about I'm not saying there is a right way to do it, but you've got to be able to describe one correct way that you prefer.

381
00:44:50,410 --> 00:44:54,310
I'm going to I, I can I can ask some someone, but I,

382
00:44:54,330 --> 00:44:59,889
I'm pretty sure that pretty much everyone have some solution that, that that's kind of reasonable.

383
00:44:59,890 --> 00:45:03,610
So I'm going to skip and I'd try and try to describe a problem.

384
00:45:04,210 --> 00:45:09,190
Okay. So in general, this I mean, you pay for numbers, you probably need an algorithm,

385
00:45:09,190 --> 00:45:16,749
but you have a sequence of large numbers and you need to reorder these elements.

386
00:45:16,750 --> 00:45:20,710
So it just you just swap. You can, you can switch the element, for example,

387
00:45:21,070 --> 00:45:30,270
and so that you can you can reorder them so that this is a increasing order or you could be decreasing whatever.

388
00:45:30,280 --> 00:45:34,270
Let's say we're sorting over the increasing order. Okay, this is a problem.

389
00:45:34,360 --> 00:45:42,069
Okay. Input it outputs. Usually when this algorithm is called, you're making a making the inside of black box and that is ah,

390
00:45:42,070 --> 00:45:47,140
the black box, there's the input, there's output. Okay, so this is, this is what you would expect.

391
00:45:47,350 --> 00:45:56,470
Good. And to do that there's so many different ah equations you can use to do solve this sorting problem.

392
00:45:56,860 --> 00:46:00,300
Okay. Some algorithms are similar to each other.

393
00:46:00,310 --> 00:46:06,100
You could roughly. That's lovely, you know, as efficient as others.

394
00:46:06,100 --> 00:46:15,940
Some regions are more efficient than others. So we're not we don't you know, we can easily spend like multiple weeks to go through these arguments.

395
00:46:15,940 --> 00:46:20,170
But we're going to talk about only two algorithms here. Okay.

396
00:46:20,830 --> 00:46:23,980
Is this still working? I haven't checked it. Okay.

397
00:46:24,430 --> 00:46:35,320
It works. Okay. So this website, uh, visualizes some of the, some of the sorting out volumes how they work.

398
00:46:35,560 --> 00:46:47,650
Okay. So, uh, and we're going to, we're going to actually talk about insertion certain margin sort for, for our lecture.

399
00:46:47,650 --> 00:46:58,990
But you can, you can look at everything and the sequence could be randomly, randomly sorted or it's almost daily sorted or sorted, sorted, reverse.

400
00:46:58,990 --> 00:47:03,940
Then you need to reverse the order. So there could be many different cases.

401
00:47:04,420 --> 00:47:09,220
So if you wanted to see how this work, you can just run it and see how each are working.

402
00:47:09,940 --> 00:47:17,050
And if you have, you know, 24 brain or 32 brains, then you can understand everything at once.

403
00:47:17,380 --> 00:47:29,170
If you cannot, then you can try to re re redo in a try to try to see the animation and you can try to figure out what this urbanism is trying to do.

404
00:47:29,500 --> 00:47:35,920
So by looking at how this is sorted and that this is how in such a sort is working.

405
00:47:36,400 --> 00:47:42,490
Okay, so I'm going to play this in such a short multiple times, okay?

406
00:47:42,940 --> 00:47:48,430
Just so that you actually can understand. So let me let me make it even bigger.

407
00:47:49,150 --> 00:47:55,120
Okay? So I'm going to play this multiple times and try to figure out what this algorithm is trying to do.

408
00:47:55,330 --> 00:48:04,890
Okay. I'm going to play five times as of the second time.

409
00:48:24,260 --> 00:48:37,370
Last. So my question is, can you describe in the word what these are, what you're doing?

410
00:48:37,850 --> 00:48:44,570
Okay. And second, can you write, describe, decided what you can you write this article in working quote.

411
00:48:45,350 --> 00:48:48,590
Okay. So that is my question. If you can do it.

412
00:48:48,800 --> 00:48:52,160
If I need to. The rest of the lecture for the for the U.S. story.

413
00:48:52,670 --> 00:48:57,050
What what does this what does it what does this I really miss doing?

414
00:48:58,600 --> 00:49:01,840
What do you think? Anyone want to describe in words?

415
00:49:07,610 --> 00:49:13,410
It is still mysterious how many people on it. If you think you understand how this works.

416
00:49:13,920 --> 00:49:18,580
Raise your hand. You get. I think I can describe. I'm not going to.

417
00:49:18,600 --> 00:49:23,370
I'm not going to ask you. So you could you can reach it if you think I understood you, at least in my brain.

418
00:49:23,670 --> 00:49:27,180
How this are is working. So I can, you know, any.

419
00:49:27,180 --> 00:49:30,500
Any other input I can try to, uh.

420
00:49:31,500 --> 00:49:34,710
I'm sorry. This is a selection. Uh.

421
00:49:36,040 --> 00:49:41,889
Okay. Yeah, I if you, if you have any other input.

422
00:49:41,890 --> 00:49:45,640
Oh, I understand how this works. Raise your hand if you, if you, if you think so.

423
00:49:46,510 --> 00:49:50,650
So looks like many people didn't, didn't quite get how this works.

424
00:49:50,800 --> 00:49:57,430
Okay. I mean, this is. Yeah, I. I have a hard time to understand just by looking at it, so it's totally fine.

425
00:49:58,030 --> 00:50:02,439
But you get that at least that there's a read the part that is like a sort of anchor.

426
00:50:02,440 --> 00:50:15,640
So a key and moving up, right? So it looks like it's trying to sort something, you know, so it's trying to sort the first, first and elements.

427
00:50:16,060 --> 00:50:21,040
So when it's move up, everything gets sorted. So when when this.

428
00:50:21,550 --> 00:50:23,350
I can start this. Okay. When?

429
00:50:23,950 --> 00:50:33,790
When this red, red triangle goes up to the up to the up all the way up, at least a part of those arrays are totally sorted.

430
00:50:33,910 --> 00:50:37,540
So if you see that that you've got the idea a little bit.

431
00:50:37,750 --> 00:50:44,900
Okay. So. Oh, sorry.

432
00:50:46,840 --> 00:50:50,190
I. What happened?

433
00:50:51,980 --> 00:50:54,990
So. Okay.

434
00:50:55,350 --> 00:51:03,620
Yeah. So. So this is such a short is basically this is a key idea.

435
00:51:03,960 --> 00:51:13,620
Okay. So this is not divide and conquer algorithm, but it's sort of similar is the sort of there is some inductive idea here.

436
00:51:14,280 --> 00:51:19,170
So you assume that all my previous element is sorted.

437
00:51:19,920 --> 00:51:24,409
Okay. And. What you need to do.

438
00:51:24,410 --> 00:51:27,590
I have a key. So I have a read those. Write a triangle.

439
00:51:27,890 --> 00:51:31,250
So now I have a new element I need to sort.

440
00:51:31,940 --> 00:51:39,200
Then if you assume that everything below before is already sorted, what you need to do is a you just need to find the right place.

441
00:51:39,590 --> 00:51:43,940
Right. So to find the right place, what it does is it goes up, up and up.

442
00:51:44,300 --> 00:51:53,460
And books keep switching that element. Until you find something that is smaller than this.

443
00:51:53,530 --> 00:51:58,220
Okay. If you find the element that is smaller than my element, that means that I found the right place.

444
00:51:58,710 --> 00:52:06,020
Otherwise, if it if my element is smaller than my element below, that means it's not sorry that I keep sort of keep keep switching.

445
00:52:06,320 --> 00:52:09,800
So that's the idea of the insertion sort. Does this make sense?

446
00:52:10,660 --> 00:52:17,640
Okay. So do you think this are what would work? Or do you do you find any holes in this logic?

447
00:52:23,610 --> 00:52:32,069
Well, we'll see. Okay. So if you a large if you actually try, you can you can do it or you can mathematically try to prove it both ways.

448
00:52:32,070 --> 00:52:35,230
We can do it. So let's try to implement the algorithm.

449
00:52:35,250 --> 00:52:43,290
Okay. So let's say you have all sorted list from one through end and then you what the outcome you expect is of your list.

450
00:52:44,070 --> 00:52:50,280
You want the list to be sorted. How do you do it? You start from the second element.

451
00:52:50,580 --> 00:52:53,459
Okay. J j is a two to end.

452
00:52:53,460 --> 00:53:01,110
So try from the second element because the first element you don't need to sort of sort that you already have the one element already sorted.

453
00:53:01,740 --> 00:53:07,530
So start from the second element to the last element. And my key is my current element.

454
00:53:08,070 --> 00:53:12,300
Second, if j equal to the second element, there is a third element or so on.

455
00:53:13,080 --> 00:53:16,770
And I define a new index I which is j minus one.

456
00:53:16,780 --> 00:53:28,859
So I'm going right below and while so you're doing the loop going up I'm I'm while my a of I so my current

457
00:53:28,860 --> 00:53:38,280
element that I'm looking at is greater than the key my key element which I want to place if you do it.

458
00:53:38,310 --> 00:53:42,510
Actually this outcome is not suite. Not not quite switching.

459
00:53:42,510 --> 00:53:46,200
It's a switch because switching switching requires unnecessary operation.

460
00:53:46,200 --> 00:53:50,160
So you actually just copy the element.

461
00:53:50,760 --> 00:53:57,150
So what you do is you copy the current element to the bottom, to the next element.

462
00:53:58,080 --> 00:54:00,180
Okay, so I store the key here.

463
00:54:00,240 --> 00:54:11,070
So this means that, oh, if you go to then if a first element was so j equal one Jake or two in the beginning I will become one, right?

464
00:54:11,130 --> 00:54:20,790
So, so this means that if second element is smaller than the first element, I'm going to copy the first element into the second element.

465
00:54:20,790 --> 00:54:26,190
So you have a two duplicate element, but you keep doing it. So you're sort of shifting everything to the bottom.

466
00:54:27,780 --> 00:54:33,060
And I keep moving. I the decreasing ISO you're moving I to the up.

467
00:54:33,840 --> 00:54:38,970
And after doing that, you have one part that that has two duplicate elements.

468
00:54:39,450 --> 00:54:45,149
And I find the right place where to copy my current key value to the right place.

469
00:54:45,150 --> 00:54:51,540
Then everything is sorted because you just got rid of those duplicate elements and replaced it with your key.

470
00:54:53,130 --> 00:54:57,590
Sorry. So that's the that's the algorithm.

471
00:54:58,130 --> 00:55:04,930
Do you think this argument would work? Out of.

472
00:55:08,590 --> 00:55:12,370
My class is not cooperating today. Sorry about that.

473
00:55:16,540 --> 00:55:20,050
Okay. So. Well, let's prove it. This works.

474
00:55:20,240 --> 00:55:30,850
Okay. So. At the start so you can prove correct this mathematical you don't need to prove mathematically all the algorithms but that's you know,

475
00:55:31,510 --> 00:55:44,380
that's a reliable way to do it. So at the start of each iteration, we can so we know that these all the elements from the all previous elements,

476
00:55:44,400 --> 00:55:51,610
as my keys are in the exchange and all the previous elements from I to J, minus one is loop in there.

477
00:55:51,710 --> 00:55:59,390
So we say loop invariant. It is this is just definition. If this is are still the same set of elements.

478
00:55:59,410 --> 00:56:03,969
This is a one way permutation of original element and if it's a sorted order,

479
00:56:03,970 --> 00:56:12,910
so I call them as a loop invariant, then our proved our strategy to correctness is that, well, it's a loop.

480
00:56:13,210 --> 00:56:17,740
You basically show that this is a loop embedded for all the elements prior to the index.

481
00:56:17,740 --> 00:56:24,430
So if it's it will be invariant, invariant if there's only in the first iteration because there's only one element.

482
00:56:25,200 --> 00:56:28,630
Okay. So it's a PRI element is or sorry.

483
00:56:29,380 --> 00:56:32,590
So, so in a you try to maintain it.

484
00:56:32,590 --> 00:56:36,760
So if the loop invariant is true at the start of iteration, you know,

485
00:56:37,390 --> 00:56:42,280
after running this Darwinism, you can prove, you can show that this is still sorted,

486
00:56:42,370 --> 00:56:46,600
this is still roughly better that that's a maintenance maintenance and terminate this basically,

487
00:56:47,200 --> 00:56:55,120
you know after that after so it keeps getting the variance after all the iteration.

488
00:56:55,120 --> 00:56:58,810
And if for equal end, then everything is sorted.

489
00:56:58,930 --> 00:57:02,080
That's what that's the outcome. You want that determination. Okay.

490
00:57:03,460 --> 00:57:09,130
So you can prove that I mean, this is not very formal way, but this is for now.

491
00:57:09,130 --> 00:57:16,980
But I think this is a this is good enough. So when j equal to this is a loop invariant because there's only one element before

492
00:57:16,980 --> 00:57:23,410
us and that's all this sorted maintenance basically you if you're all J minus one

493
00:57:23,410 --> 00:57:30,430
element is a loop and be invariant you can say that oh all the element from the J plus

494
00:57:30,430 --> 00:57:37,750
one through n is on unmodified because I didn't touch anything bottom of my key.

495
00:57:37,760 --> 00:57:46,350
So this part is definitely you know just the unmodified the one true I which is the part that I didn't even touch it.

496
00:57:46,360 --> 00:57:53,130
So these are all is going from J to j j to j minus one James to and is top somewhere.

497
00:57:53,260 --> 00:58:00,040
If you find a element that is smaller than the key element, the before, then it's not even touching it.

498
00:58:00,040 --> 00:58:07,629
So this part remains solid because it was all sorted and apart from the I plus two to J remain

499
00:58:07,630 --> 00:58:11,920
sorted because of you originally has sorted that equation and you are shifting by one,

500
00:58:12,100 --> 00:58:19,750
right? So you're moving. Moving everything down is still sorted and you are putting your key element to the a plus one.

501
00:58:20,170 --> 00:58:28,720
So this of a of I a of a plus one a of a plus two still remain sorted because you

502
00:58:29,080 --> 00:58:35,440
use the required when so the last statement ends when when this is violating.

503
00:58:35,440 --> 00:58:40,730
So you still. You know, making making them sorry.

504
00:58:40,770 --> 00:58:44,270
So this is a sort of rigorous way to prove that always is correct.

505
00:58:44,510 --> 00:58:48,890
I don't recommend it every time, but this is a good practice to do at least a few times.

506
00:58:50,360 --> 00:58:57,769
So when the loop terminates one day and plus one, that means, you know, doping variant is still for them.

507
00:58:57,770 --> 00:59:01,190
Is that all the chain, all the elements is sorted.

508
00:59:04,130 --> 00:59:12,980
Okay. So you can analyze the quality of the algorithm in the rigorous way this way, or you can usually try to find important cases.

509
00:59:13,010 --> 00:59:16,190
Oh, do we have a country with tempo in that? Does this really work?

510
00:59:16,190 --> 00:59:19,310
So you can have your own way to show that this work.

511
00:59:19,400 --> 00:59:22,610
These are written works before running in the in the actual data.

512
00:59:23,450 --> 00:59:31,700
So make sure that even if it appears to be correct that there might be some corner cases or you shouldn't always assume that,

513
00:59:31,940 --> 00:59:35,149
oh my, my, I wouldn't work with a some some of few example data.

514
00:59:35,150 --> 00:59:36,530
So my average must be correct.

515
00:59:36,530 --> 00:59:44,989
But that's that could be very well wrong assumption that you you will only find that when you have to develop to about the later.

516
00:59:44,990 --> 00:59:48,360
So yeah. Try to find the court cases. Okay.

517
00:59:49,220 --> 00:59:58,370
So and at that time complexity wise, so this is a very comprehensive way to do the time complexity analysis.

518
00:59:58,370 --> 00:59:59,930
You don't have to do that every time.

519
01:00:00,410 --> 01:00:09,350
But I'm just saying that here, let's say each algorithm takes some amount, some amount of time c1c to see three C, four C fives each step.

520
01:00:09,350 --> 01:00:14,630
Let's say there's a there's a time cost for that. You can calculate because this is a loop.

521
01:00:14,960 --> 01:00:19,010
You can calculate the how many times this actually part is running.

522
01:00:19,010 --> 01:00:26,840
So this first part is running end times. This part is running end minus one times and this part is a double loop.

523
01:00:27,080 --> 01:00:34,240
So it's the this is the summation of all the g equal to 2aj is two to end two.

524
01:00:34,490 --> 01:00:37,910
Yeah. So two plus three plus in the to the end.

525
01:00:37,910 --> 01:00:42,260
This is, this is the amount of operation. So you can try to calculate everything.

526
01:00:42,710 --> 01:00:50,660
And if you calculate the time, what you will have eventually is that this is a very well B squared term.

527
01:00:50,670 --> 01:00:56,060
So you have a sum squared term, you have some linear term and you have a sum constant term, right?

528
01:00:56,630 --> 01:01:00,950
So then basically this is a polynomial equation with degrees of two.

529
01:01:00,950 --> 01:01:03,150
So this is a basically quadratic algorithm.

530
01:01:03,440 --> 01:01:14,390
So it doesn't matter, you know, what the individual costs are when you just want to, to know the time complexity in the in this asymptotic setting.

531
01:01:14,510 --> 01:01:21,160
And then you only care about the very largest, largest term.

532
01:01:21,650 --> 01:01:24,910
The term. The yeah. The order of the largest.

533
01:01:27,350 --> 01:01:38,430
Okay. So let's try to implement this or in this case, the implementation is almost given.

534
01:01:38,720 --> 01:01:45,670
So there's no sophisticated part. So on the part that you need to do is try to, you know,

535
01:01:46,070 --> 01:01:54,200
change this pseudo code into our code because it also code doesn't fall into that doesn't conform to our our syntax.

536
01:01:54,200 --> 01:01:57,889
So you just translate idea into some other languages.

537
01:01:57,890 --> 01:02:00,460
So that's good practice.

538
01:02:00,470 --> 01:02:08,090
So even though I just show this algorithm, I'm not going to go into the details because this is a pretty straightforward translation.

539
01:02:08,570 --> 01:02:14,299
But I strongly encourage you to not to look at it and add a code here and you try

540
01:02:14,300 --> 01:02:17,810
to implement your acquisition on your own and see whether that are going to work.

541
01:02:17,810 --> 01:02:22,880
So usually, you know, you will, you know, you're really, really good.

542
01:02:23,180 --> 01:02:30,800
Either you're a really, really good programmer or you are very lucky if you are first implementation works out of the box, right?

543
01:02:30,830 --> 01:02:36,409
So usually there is something wrong and that's where you actually learn from the examples.

544
01:02:36,410 --> 01:02:43,370
So if you I know you all be this, I'm not equating this, but if you we are really willing to learn how to implement the algorithm.

545
01:02:43,790 --> 01:02:49,309
You trying this on your own is highly, highly recommended and the Google CoLab gives a very good setting for it.

546
01:02:49,310 --> 01:02:56,360
So you to do that. Okay, so you have a session of sorts implemented and let's say I'm running it,

547
01:02:56,360 --> 01:03:04,069
so I'm just sending us a random seed so that everyone has a you could actually reproduce the whole thing.

548
01:03:04,070 --> 01:03:12,560
Otherwise if you use a random function like a sample or a random function, your you may not have the exact same, same output.

549
01:03:13,340 --> 01:03:19,790
So I'm using the same sample. So a simple function is basically generate the permutation of some sequence.

550
01:03:20,630 --> 01:03:25,280
So then what it does is that this is the original sequence.

551
01:03:25,430 --> 01:03:28,430
And so this sequence looks like this so assumes work.

552
01:03:28,760 --> 01:03:32,870
Okay, so any questions about insertion sort?

553
01:03:35,890 --> 01:03:41,920
Okay. Good. Now let's move on to the larger sort.

554
01:03:42,730 --> 01:03:49,420
Okay. Before going to merger thought, let's recap the divide and conquer divisions that we had just talked about.

555
01:03:49,420 --> 01:03:54,160
The divide and conquer with them is a dividing the problem, larger problem into some problems.

556
01:03:54,730 --> 01:04:03,580
And concourse tabbies just, you know, rely on this in the inductive rule that, you know, you assume that every problem was solved and combined,

557
01:04:03,580 --> 01:04:12,370
you just focus on the, you know, so combining the solution from the sub problems to solve the larger problem.

558
01:04:12,870 --> 01:04:19,970
Okay. So can you think about sorting problem?

559
01:04:20,750 --> 01:04:24,980
But you are trying to solve the sorting problem using divide and conquer.

560
01:04:25,280 --> 01:04:28,890
I would. Okay.

561
01:04:29,850 --> 01:04:32,430
Can you think about how how you do it?

562
01:04:54,960 --> 01:05:08,420
There are multiple versions of the U.S. divide and conquer arguments about the argument that the easiest to understand is so this.

563
01:05:10,780 --> 01:05:13,860
Is a merger sort. So we're going to go through the merger thought.

564
01:05:14,490 --> 01:05:24,690
Okay. So I'm going to show this example multiple times again and see whether you understand this are with.

565
01:05:25,060 --> 01:05:32,490
Okay. This makes sense.

566
01:05:35,780 --> 01:05:42,400
So this is how much research is doing. And this is a using this is using divide and conquer algorithm.

567
01:05:43,170 --> 01:05:48,100
Have lots more. Okay.

568
01:05:48,350 --> 01:05:55,750
Let's look at other examples. Let's look at other examples.

569
01:06:00,480 --> 01:06:06,670
Mr. Gorbachev. Do you get how these are even worse?

570
01:06:07,540 --> 01:06:11,580
Sort of. So it's a very hard to follow, right?

571
01:06:11,600 --> 01:06:22,130
So if you understand how these are written works, then you you have a very good understanding of recursive how the divided country going work.

572
01:06:22,140 --> 01:06:24,900
So I guess that that that is a good, good thing.

573
01:06:25,350 --> 01:06:31,290
It's a it's normal if you don't understand how this works, actually, just by looking at how this works.

574
01:06:31,860 --> 01:06:37,290
Because it's the easiest thing to follow from the computer perspective by human perspective.

575
01:06:37,290 --> 01:06:44,820
Human is not, you know, very good at solving this interview by the code margin, but this is the one that I read about.

576
01:06:45,420 --> 01:06:51,420
Okay. Do you have so you have a problem of sorting and elements, right?

577
01:06:51,970 --> 01:06:56,670
Okay. So let's divide the problem to the lovely half.

578
01:06:56,800 --> 01:07:04,770
Okay. So and the PN element and elements or or, you know, you can you can make if it's odd, number one,

579
01:07:04,980 --> 01:07:11,910
one one element one set will have a smaller one slightly smaller value than the others.

580
01:07:11,910 --> 01:07:13,590
I mean, such a small number of elements.

581
01:07:14,760 --> 01:07:23,040
And so that's the device that I'm going to instead of solving one sorting problem, I'm going to solve a two sorting problem with the smaller elements.

582
01:07:23,650 --> 01:07:27,090
Okay. What does a concourse that don't do anything?

583
01:07:27,450 --> 01:07:30,570
So that's the beauty. I'm not going to actually start.

584
01:07:31,200 --> 01:07:36,530
I'm going to assume that all boards of elements are automatically magically sorted because of what?

585
01:07:36,690 --> 01:07:39,360
That's what. Dividing corporate, which means of good. Okay.

586
01:07:39,900 --> 01:07:48,900
So because I'm going to define how to solve larger problem, all the small problem, I already must have a solution to solve the problems.

587
01:07:48,900 --> 01:07:52,020
I'm not going to worry about it like a fundamental problem,

588
01:07:52,230 --> 01:07:57,080
but I don't need to worry about how to move it in minus one disk if I know how to solve disk.

589
01:07:57,390 --> 01:08:02,010
Right. So then combine combines.

590
01:08:02,010 --> 01:08:05,220
That is not very straightforward now. So in how do we power problem?

591
01:08:05,250 --> 01:08:10,610
Well we now combining it just move over minus one will move this disk.

592
01:08:10,620 --> 01:08:17,790
So combining step is straightforward. Now you have two sorted elements get to solid arrays.

593
01:08:18,420 --> 01:08:22,590
How do I make one sorted out? How they combine them into one sorted array?

594
01:08:22,950 --> 01:08:26,280
That's the thing. It's not totally straightforward.

595
01:08:28,850 --> 01:08:33,020
Good. But this is how you solve it. So do you think this will work?

596
01:08:35,060 --> 01:08:39,200
If we if we implement something with the divide and conquer and combine way.

597
01:08:40,310 --> 01:08:48,370
So that's what we're going to do here. So let's go for start.

598
01:08:49,810 --> 01:08:52,820
So. Well, how do you implement this?

599
01:08:54,160 --> 01:08:58,360
You implement the algorithm. Okay. In this way.

600
01:08:59,110 --> 01:09:04,420
Okay, more. Just sort of more just Socrates, basically.

601
01:09:04,900 --> 01:09:08,830
You need to have a terminating condition. This is a recursive recursive algorithm.

602
01:09:09,820 --> 01:09:15,760
So if the length of X is greater than one. I apply this divide and conquer algorithm.

603
01:09:16,630 --> 01:09:20,890
But if not, if you have one element or zero element, don't do anything.

604
01:09:21,070 --> 01:09:30,940
Just return it. Okay. So and when you when you have a more than one element, you find the midpoint.

605
01:09:31,150 --> 01:09:35,100
When you find the midpoint, it could be odd number and even number.

606
01:09:35,110 --> 01:09:42,370
So what I'm doing is that I'm going to find I'm going to divide the length by two and a find the ceiling that that's the index of midpoint.

607
01:09:42,850 --> 01:09:48,700
Okay. So I'm I'm dividing the element from one through this midpoint.

608
01:09:49,000 --> 01:09:54,940
So and the another is amid me the point to me the point plus one to the length of X.

609
01:09:55,090 --> 01:10:04,630
Right. So is a two part. Okay. So I'm sorting I'm sorting one of them and return the returned elements into a so

610
01:10:05,600 --> 01:10:11,140
so our doesn't have a good way to do the in-place substitution of the argument.

611
01:10:11,150 --> 01:10:15,040
So you need to create a new array and the return. So that's the bad part.

612
01:10:15,040 --> 01:10:18,490
But that's this is our specific constraint. Okay.

613
01:10:18,820 --> 01:10:25,630
So and if you need if you need to work in a Python or C++, you actually don't have to return it.

614
01:10:25,640 --> 01:10:32,530
You can just call them and make them make I assume that those elements are actually sorted.

615
01:10:32,710 --> 01:10:39,100
Okay. So but in our you cannot make that happen unless using your global operator.

616
01:10:39,110 --> 01:10:42,200
So we're using this way.

617
01:10:42,220 --> 01:10:48,640
So it's a little bit hacky and not as efficient because you need to copy everything, but we'll just do it this way.

618
01:10:50,080 --> 01:10:55,380
So yeah, a call merge sort and B converges sort.

619
01:10:55,390 --> 01:11:06,160
You solve the two body sort of problem and you have to sort it arrays sorted vectors you have now you need to merge them,

620
01:11:07,330 --> 01:11:10,450
you have to sorted things and how do I merging?

621
01:11:11,350 --> 01:11:19,600
So those are merging part is complicated. So I separated it into a another function.

622
01:11:20,060 --> 01:11:25,750
Okay. What is more. You actually have a two to sorry.

623
01:11:25,750 --> 01:11:29,810
The result of I think in this case it will be good to write something here.

624
01:11:30,610 --> 01:11:38,200
So let's say you have some numbers like you have three, nine, ten, 12, 13, 15.

625
01:11:38,500 --> 01:11:47,530
Okay. And you have another 14, 11, 14, you know, 16, 17, something good.

626
01:11:48,430 --> 01:11:52,810
So then you need to create and create a vector that combines this.

627
01:11:53,130 --> 01:11:57,010
Okay. How they do it. Okay. So these are examples.

628
01:11:57,010 --> 01:12:05,530
So look at this. Are what you see what, what, what I'm doing here. So you have a two, A and B, two, two arrays.

629
01:12:06,130 --> 01:12:14,330
Right. And you have index Y and James are equal one G for 1.3.

630
01:12:14,560 --> 01:12:20,620
Right. So then you have index of k k equal one.

631
01:12:21,250 --> 01:12:24,580
So I said, okay, right. So just think of it.

632
01:12:26,080 --> 01:12:32,200
So what do you do here? Is that check this, this this looks complicated.

633
01:12:32,250 --> 01:12:41,379
What my does is that if J is greater length of B, meaning that the J is all the way down, that then you you don't have anything to copy.

634
01:12:41,380 --> 01:12:45,070
So this is a this is a boundary condition. So don't worry about it.

635
01:12:45,700 --> 01:12:53,580
This this part. So basically the same thing I use less than that length of things the way that's about the conditions.

636
01:12:53,790 --> 01:13:00,930
What, what, what I care about is this if a of which one is smaller and this is smaller.

637
01:13:01,020 --> 01:13:05,849
So you copy this. Okay then because I copy this.

638
01:13:05,850 --> 01:13:10,680
I ap i in to to your update, I.

639
01:13:11,910 --> 01:13:15,000
Okay. And I. I don't need the cable, too.

640
01:13:15,390 --> 01:13:19,800
Okay. Then next time you compare these and this.

641
01:13:20,250 --> 01:13:27,389
Okay. Eventually smaller 11 is more. So now I hope to j go to and copy these.

642
01:13:27,390 --> 01:13:30,450
So it's a combination of the first stage of dinging. Okay.

643
01:13:31,110 --> 01:13:34,740
So I'll keep doing this. So this.

644
01:13:35,010 --> 01:13:38,330
You copy. Copy. 12.

645
01:13:38,380 --> 01:13:41,700
Here I becomes three. You compare this and this.

646
01:13:41,910 --> 01:13:46,290
Still, this is smaller. So you copy 13 here.

647
01:13:47,010 --> 01:13:51,210
Okay. And move by to poor.

648
01:13:51,510 --> 01:13:57,230
Okay. And you look to keep.

649
01:13:57,240 --> 01:14:00,260
So in the next round, the other 14 and 15.

650
01:14:00,260 --> 01:14:04,040
So 14 smaller. So copy 14 here. Okay.

651
01:14:04,170 --> 01:14:09,479
And J becomes three and now you have 15 is 16.

652
01:14:09,480 --> 01:14:13,130
So copy 15 here equals six. Good.

653
01:14:14,640 --> 01:14:21,210
And now I because but right now you have you have a violating this condition.

654
01:14:21,600 --> 01:14:30,480
I is greater than the length of a. So in that case, because eyes are of bounds, you always now copy from the second part.

655
01:14:30,710 --> 01:14:35,370
Okay. So here because because you don't have any element.

656
01:14:35,550 --> 01:14:38,550
Don't compare it. I'm going to copy from copy this.

657
01:14:40,020 --> 01:14:45,860
And copy, you know, at increased increase.

658
01:14:45,870 --> 01:14:51,270
J And a copy of your getting an increased increase.

659
01:14:51,870 --> 01:14:54,900
J Again, in both I and J becomes five.

660
01:14:55,580 --> 01:15:01,799
Okay, then it's done. So you're, you know how many elements you need to copy so you don't need to even compare.

661
01:15:01,800 --> 01:15:05,640
So I'm going to total number of expected lengths.

662
01:15:05,670 --> 01:15:10,770
I of combine the combined rate and return the combined the rate that's there with.

663
01:15:12,850 --> 01:15:15,940
Okay. So this is the more the algorithm is not as straightforward.

664
01:15:15,940 --> 01:15:21,940
Sometimes when you do the divide and conquer solving the problem, you know, it's good to quit,

665
01:15:21,940 --> 01:15:26,260
not to think about how to solve some problem, but how to think about how to combine it.

666
01:15:26,740 --> 01:15:39,970
It's not may not be necessary. So now you have this algorithm here, and I wonder how many of you now think that this makes sense.

667
01:15:41,930 --> 01:15:45,590
Okay. That's. So you see, the last step is to combine step.

668
01:15:46,110 --> 01:15:49,760
Okay. So you have a22 Saudi Arabia are combining them.

669
01:15:50,030 --> 01:15:53,420
Okay. Like this. These are going to be supplied. Okay.

670
01:15:57,830 --> 01:16:02,890
Okay. Any questions? Yep.

671
01:16:03,530 --> 01:16:11,090
So when people do and the people who are going in compared to to change people

672
01:16:12,440 --> 01:16:19,600
when they go to that in this case when people to you are from my community.

673
01:16:20,090 --> 01:16:26,180
So I became to Jane still is one the in combining between comparing this with this and this.

674
01:16:26,390 --> 01:16:29,440
And 11 is smaller. So that's why this was copied.

675
01:16:30,230 --> 01:16:35,280
Okay. Okay.

676
01:16:37,680 --> 01:16:49,049
So let's run this and let's see whether the more distort but previous the X was the randomly shuffled the valuable 1 to 20 and

677
01:16:49,050 --> 01:16:57,120
looks like it's working okay so now for 3 minutes I'm going to talk about the efficiency of these these three algorithms.

678
01:16:57,510 --> 01:17:03,510
Okay. So I have time, complexity.

679
01:17:04,170 --> 01:17:09,480
The slide I'm going to go through through the next lecture.

680
01:17:10,020 --> 01:17:13,860
But just wanted to show how this works.

681
01:17:14,940 --> 01:17:18,360
I have 10,000 elements. Okay.

682
01:17:19,290 --> 01:17:22,830
And I have now two sorting out wisdom. Which one do you think is a faster.

683
01:17:25,740 --> 01:17:31,440
Well, if you have an educated guess, that might be very right.

684
01:17:31,440 --> 01:17:39,330
But if you don't know, you can try. Okay. So I'm sorry, 10,000 elements takes 44.3 seconds.

685
01:17:40,410 --> 01:17:43,440
I'm using more research. How much does it take?

686
01:17:44,220 --> 01:17:47,580
Only 0.1 3 seconds. It's a huge difference, right?

687
01:17:48,450 --> 01:17:55,860
Why? Why? That's what we are going to learn next lecture.

688
01:17:56,790 --> 01:18:10,650
By the way, this is still a lot. If if you use the use the sort algorithm in the in of our implementation is much much faster is not because of it.

689
01:18:10,830 --> 01:18:13,979
It has a better time complexity. It has a better implementation.

690
01:18:13,980 --> 01:18:18,330
So the actual software is implemented for trend and it does.

691
01:18:18,480 --> 01:18:22,110
Then implementing in our loop is still very slow.

692
01:18:22,140 --> 01:18:29,580
So this this is not the difference in the time complexity, but these differences are due to time, complexity difference.

693
01:18:29,880 --> 01:18:35,430
Okay. So if you if you try a smaller example, you may not notice the difference,

694
01:18:35,430 --> 01:18:42,630
but when your input becomes larger and larger, one algorithm is quadratic, one algorithms and Logan.

695
01:18:42,660 --> 01:18:47,340
That's why you see the difference. Okay. So we already saw that time.

696
01:18:47,340 --> 01:18:50,730
Complexity of the is such a sort is a quadratic.

697
01:18:51,090 --> 01:18:54,280
We all get started. Okay, so now what?

698
01:18:54,300 --> 01:18:58,720
What I'm going to show in the next lecture.

699
01:18:58,770 --> 01:19:05,430
So I'm going to go through this slide. You basically have a time come over and Logan.

700
01:19:06,930 --> 01:19:10,590
So and Logan is very similar to linear.

701
01:19:11,490 --> 01:19:15,569
Logan is very small number usually. So you can bound the Logan to certain cost.

702
01:19:15,570 --> 01:19:19,670
And so and Logan is not much slower than the linear beam.

703
01:19:19,680 --> 01:19:27,360
So it is a huge difference. But the quadratic to going down to then the when and well well I'll explain why

704
01:19:27,360 --> 01:19:33,980
this is and the way nobody then by going through this like again in money.

705
01:19:34,440 --> 01:19:38,280
Right. Okay. That's the end of today.

706
01:19:38,700 --> 01:19:42,840
Any other questions? If not, yeah.

707
01:19:44,130 --> 01:19:48,640
Let's stop here. And if you have questions regarding your homework.

