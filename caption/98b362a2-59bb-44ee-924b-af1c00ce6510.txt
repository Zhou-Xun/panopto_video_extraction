1
00:00:00,420 --> 00:00:10,170
My testimony test. And let's get started.

2
00:00:10,620 --> 00:00:26,200
So for the delay. So today we're going to start a sports matrix, which will be a necessary part to solve the problem.

3
00:00:26,220 --> 00:00:39,910
Three, I believe. So before getting started this these warm are not not that easy so I recommend

4
00:00:40,900 --> 00:00:48,370
to start as early as possible if you have any questions I'm happy to answer.

5
00:00:49,060 --> 00:01:01,450
So just giving some to give some hint, this one's basically you need to use a roller skating competition,

6
00:01:02,500 --> 00:01:09,790
but there are some tricks you need to use in the case where P is greater than N.

7
00:01:10,180 --> 00:01:17,380
Okay, so otherwise the your choice commission is not going to be accurate and it's not not going to be test first either.

8
00:01:19,150 --> 00:01:23,320
And so, yeah, that's the part you need to figure out how to do it.

9
00:01:23,320 --> 00:01:35,050
There are multiple possible ways to address that, but that there's something you need to keep in mind and.

10
00:01:37,870 --> 00:01:44,770
So problem two is if if you did it, if you don't know what the mark of.

11
00:01:45,840 --> 00:01:48,850
Uh, Cheney's. Don't worry about it.

12
00:01:48,870 --> 00:01:52,250
This is a you know, as long as you know that this.

13
00:01:52,390 --> 00:01:55,950
This is a condition you need to find the you.

14
00:01:55,950 --> 00:02:01,979
You really don't need anything to know about the Markov chain.

15
00:02:01,980 --> 00:02:09,270
So just to use the equation, and if you have any problems in understanding the problem, let me know.

16
00:02:09,840 --> 00:02:13,740
My guess is the problem too should be more straightforward.

17
00:02:14,940 --> 00:02:23,330
Uh, problem three, uh, you know, you need to, you need to finish the today's part.

18
00:02:24,360 --> 00:02:28,430
Uh, so I'm going to yeah.

19
00:02:28,440 --> 00:02:33,089
So you need to use pass matrix basically. So that's the him taking you.

20
00:02:33,090 --> 00:02:41,330
Now problem four is going to be challenging if you two to make it fast enough.

21
00:02:41,340 --> 00:02:54,870
So one thing I wanted to make sure is that in homework one, it's my mistake, but I, I meant to say that the time limit is 10 seconds.

22
00:02:54,870 --> 00:03:02,759
I think I, I said in in word here, but, you know, the problem wasn't updated properly.

23
00:03:02,760 --> 00:03:16,739
So it's the one minute. But, you know, so I, I was surprised to know that many people actually were didn't get a full credit.

24
00:03:16,740 --> 00:03:18,690
I mean, not that too many people,

25
00:03:18,690 --> 00:03:28,959
but there are there are quite a lot of quite quite a large number of people who who didn't get who actually took more than 10 seconds.

26
00:03:28,960 --> 00:03:38,670
So I, I was I was very surprised to see that because a problem, I mean, the all the problem is homework wise should finish in 0.1 seconds.

27
00:03:38,670 --> 00:03:45,219
Right. So it shouldn't be really there is no reason to take even more than 1/2.

28
00:03:45,220 --> 00:03:49,110
And if it took almost a minute,

29
00:03:49,470 --> 00:03:56,700
then that that's a that suggests that there is something very silly mistakes or

30
00:03:56,700 --> 00:04:01,590
there is a some serious algorithmic problems in terms of the time complexity,

31
00:04:02,650 --> 00:04:09,000
if it is so well, if I didn't, you know, I really didn't want to give a full credit.

32
00:04:09,000 --> 00:04:14,460
But, you know, because the problem says so, you know, I didn't want to override that.

33
00:04:15,000 --> 00:04:23,490
But really, if you took that much of time, if you were upgrading to really like a more than a second in the previous problem,

34
00:04:24,060 --> 00:04:29,700
you really need to be careful about this time, especially for a problem for when you have.

35
00:04:33,130 --> 00:04:39,560
When you have a very large input, you're going to probably you're going to basically will have a time complex issue.

36
00:04:39,570 --> 00:04:45,810
So you need to solve that. You need to make sure that you you maintain these two two conditions.

37
00:04:46,800 --> 00:04:52,630
One is that you need to. Yeah.

38
00:04:52,870 --> 00:04:57,850
What? What is that? You need to make the complexities of quadratic times or faster.

39
00:04:58,120 --> 00:05:02,110
So otherwise it's not just going to run fast enough.

40
00:05:02,530 --> 00:05:09,220
But even if your time complex image there, you know, if you see the my color page.

41
00:05:09,910 --> 00:05:15,730
So my implementation took 12 seconds. So it's not, you know, the limit is 20 seconds.

42
00:05:16,150 --> 00:05:19,900
So you need to make sure that you're implementing fast enough.

43
00:05:20,440 --> 00:05:25,270
So don't try to put unnecessary steps.

44
00:05:25,510 --> 00:05:35,830
And the the criteria we're going to use is that if you are going to finish it in the in 20 seconds in the call up page,

45
00:05:36,190 --> 00:05:45,219
then we're going to say that this is okay. So I mean, each evaluation platform evaluation platform slightly have a different efficiency.

46
00:05:45,220 --> 00:05:47,379
So we are going to give some leeway.

47
00:05:47,380 --> 00:05:55,900
But if you're if your argument doesn't finish in 20 seconds, in that testing page, in extra test page, that is a red flag.

48
00:05:56,110 --> 00:06:01,900
You might get a not get a full criteria, even if your algorithm says is correct.

49
00:06:02,110 --> 00:06:07,450
So this time, please make sure of that so that you get a full credit.

50
00:06:08,410 --> 00:06:13,270
If even so, in the case your implementation is not fast enough, you're not going to get a zero.

51
00:06:13,570 --> 00:06:19,960
Obviously you are going to probably get a deduct deducted only the subset of problem that has a large input size.

52
00:06:20,470 --> 00:06:25,810
But you know, you can you can see those five examples and see how fast you are going to miss.

53
00:06:27,430 --> 00:06:33,640
Okay. So that's that's what I wanted to talk about.

54
00:06:35,200 --> 00:06:39,460
And just so some of the some of the issues I saw.

55
00:06:41,910 --> 00:06:50,330
In the. So. Excuse me.

56
00:06:50,570 --> 00:06:59,570
Okay. So some of the some of the issues I've seen in in the submissions is that so

57
00:06:59,570 --> 00:07:05,510
many people maintain the matrix matrices are very weak matrix for the problem.

58
00:07:06,350 --> 00:07:10,169
Uh. To the toes.

59
00:07:10,170 --> 00:07:14,549
A second problem, the constraint.

60
00:07:14,550 --> 00:07:18,000
The constraint, the polynomial fitting, which is okay.

61
00:07:18,060 --> 00:07:27,690
It's using a lot of memory unnecessarily, but that's okay. But, and you can see what the what the design the solution is.

62
00:07:27,990 --> 00:07:33,149
If you see the, if you see the home page now, now the solution is posted.

63
00:07:33,150 --> 00:07:39,480
So if you haven't seen it, you can see the solution and see what what the was what the suggested solution is.

64
00:07:41,350 --> 00:07:55,489
But. Okay, so. So some people I saw maintain the matrix and make updates so they basically the way how they maintain

65
00:07:55,490 --> 00:08:03,470
the matrix to create a matrix and add one column at a time whenever you add a new new observations.

66
00:08:04,130 --> 00:08:11,210
That's extremely inefficient because you're copying the matrix and making new matrix, these MBP matrix.

67
00:08:11,600 --> 00:08:18,950
So it's a really, really inefficient way. If you do that, you probably didn't didn't notice that those are the where we implement that.

68
00:08:18,950 --> 00:08:23,929
We didn't notice that this this is going to increase your time a lot.

69
00:08:23,930 --> 00:08:27,530
But that that was the main reason why is this why it took so long.

70
00:08:28,070 --> 00:08:36,060
So those are those are the things you need to make sure that you're are not introducing unnecessary inefficiency.

71
00:08:36,080 --> 00:08:42,910
So even if your algorithm is in the right time, complexity sometimes if your implementation has some very,

72
00:08:45,380 --> 00:08:55,190
very unnecessary part that to increase your time, it could take quite a minute, quite of the time, and it may fail some of the evaluation.

73
00:08:56,200 --> 00:09:01,520
Okay. So that's that's all I can say about the homework before we get started.

74
00:09:01,650 --> 00:09:06,470
Any other questions? Okay.

75
00:09:06,810 --> 00:09:18,450
So this today, part two, they were going to start with Sports Matrix and this will be a relatively short part of the lecture.

76
00:09:18,450 --> 00:09:27,210
So we might get into like two six. Let's see. So, uh, so what is the sports matrix?

77
00:09:27,390 --> 00:09:30,750
Well, sports the matrix is a matrix that has a lot of zeros.

78
00:09:30,750 --> 00:09:38,610
That that that's that's how we define it. There's the matrix is a matrix that most of the elements are non-zero.

79
00:09:38,610 --> 00:09:41,920
So there is no clear cut between the sparse and dense matrix.

80
00:09:41,940 --> 00:09:46,440
This is a relative thing. Some matrix can be sparser than the other.

81
00:09:47,130 --> 00:09:54,630
But you know, the amount of sparsity in terms of cut out which one you call a sparse matrix or not, that's a subjective.

82
00:09:55,050 --> 00:10:08,100
Okay, so there are a lot of, uh, applications recently, increasingly more and more, that uses large,

83
00:10:08,100 --> 00:10:17,940
sparse matrices in many applications so that that includes a text the mining, natural language processing, spatial epidemiology these days.

84
00:10:17,940 --> 00:10:29,429
Patient actually, spatial spatial genomics is a quite, quite a quite a bit of area that usually needs a lot of sparse matrix,

85
00:10:29,430 --> 00:10:32,640
single cell genomics as well, and genetics and imaging,

86
00:10:33,000 --> 00:10:39,149
a lot of cases that there are many applications you can leverage this past matrices and to leverage the

87
00:10:39,150 --> 00:10:49,410
computational computational advantages of API by using these spatial properties of a spatial sparse matrices.

88
00:10:51,030 --> 00:11:02,520
So sparse matrix matrices are completely expensive to represent sometimes in a if you work with these parts matrix representations,

89
00:11:04,200 --> 00:11:13,499
even though they're as they're dense, you will need a lot of unnecessary operation just to do very, very unnecessary thing.

90
00:11:13,500 --> 00:11:21,630
Like zero plus zero is always zero, but you're doing their operation unnecessarily so you can avoid that kind of operations.

91
00:11:22,650 --> 00:11:31,229
So so are what are in Python they use a they they offer quite a lot of special packages

92
00:11:31,230 --> 00:11:36,600
to deal with a sparse matrices and it has a very good packages built in already.

93
00:11:36,600 --> 00:11:42,810
So that's that's what we are going to learn how we can leverage the sparsity when we do the matrix operations.

94
00:11:44,520 --> 00:11:47,940
Okay. So how do we define a sparsity?

95
00:11:48,400 --> 00:11:57,360
Okay. So Sparsity you define as a how many elements in your matrix has that zero element?

96
00:11:57,570 --> 00:12:01,950
So a number of zeros divided by total number of elements is a sparsity.

97
00:12:02,130 --> 00:12:09,060
Okay. So in a matrix, density is a one minus sparsity.

98
00:12:09,060 --> 00:12:14,430
You can you can say that. So if you have a two by five matrix here.

99
00:12:14,880 --> 00:12:19,260
Okay. And here there is a5075 non-zero.

100
00:12:19,260 --> 00:12:22,170
So the sparsity of a is a 0.5.

101
00:12:24,870 --> 00:12:41,160
So let's say you have a paint banded matrix by independent matrix is end by end matrix where if all the diagonal element is non zero.

102
00:12:41,850 --> 00:12:45,180
Right. No actually.

103
00:12:45,420 --> 00:12:49,140
So this is a, this is a blended matrix. So it is.

104
00:12:49,860 --> 00:12:54,130
So, so diagonal element is.

105
00:12:54,180 --> 00:12:58,680
So because this is defined as j, diagonal element is all zero actually.

106
00:12:59,550 --> 00:13:02,970
And of diagonal element. Just the one.

107
00:13:04,410 --> 00:13:09,570
One up and one down. Basically, you have you have to do what you want to do here.

108
00:13:10,140 --> 00:13:16,110
Okay. You have one, one one, one, one, one, one, one, one, one, one.

109
00:13:16,530 --> 00:13:20,550
And everything else is zero. And here is a general. Here is a, you know. Okay.

110
00:13:21,000 --> 00:13:24,870
So that's that's how you can define a.

111
00:13:26,970 --> 00:13:29,820
So this is how we define a banded metrics here.

112
00:13:30,420 --> 00:13:39,450
So, I mean, this is just one instance of bending metrics, obviously, and metrics is a general term, so don't be confused.

113
00:13:39,810 --> 00:13:48,360
This is one way to generate the mandate metrics. But these metrics are basically you have some limit of having done your element from

114
00:13:48,360 --> 00:13:53,669
the diagonal and a certain area from the diagonal can have a non-zero element.

115
00:13:53,670 --> 00:14:00,300
And in this case, it looks like this. So if you have something like this, what is the sparsity of these metrics?

116
00:14:00,720 --> 00:14:09,040
Lovely. How many elements do they have total?

117
00:14:11,360 --> 00:14:19,300
If you if it is examined by emitters. And my in good care.

118
00:14:19,720 --> 00:14:22,930
How many? How many? Zero.

119
00:14:23,200 --> 00:14:31,770
So how many non-Jews do you have? Two and minus one times two.

120
00:14:32,370 --> 00:14:42,059
Right. Okay. So if you subtract one minus one from this one, this is a sparsity of the matrix.

121
00:14:42,060 --> 00:14:45,540
Right? So so how sparse is this?

122
00:14:48,070 --> 00:14:53,300
If any call hundred, roughly 98% is rate no.

123
00:14:54,390 --> 00:15:04,920
No. Uh, yeah. 98%. If you put the a hundred, if you just approximate this, the numerators and this is 98%.

124
00:15:05,010 --> 00:15:09,389
If it's 80,000, then this is 99.8% and so on.

125
00:15:09,390 --> 00:15:13,220
So it when N becomes larger, it gets passed this person.

126
00:15:15,910 --> 00:15:23,820
Okay. So. So logic matrix usually requires a lot of memories.

127
00:15:24,960 --> 00:15:29,310
But if the matrix is sparse, we can save memory.

128
00:15:29,580 --> 00:15:38,410
Okay. So for example. So many so.

129
00:15:40,550 --> 00:15:46,450
So. So the. The most common use case.

130
00:15:46,450 --> 00:15:54,220
One of the most common use case of these sports matrix is a text representing the text data.

131
00:15:54,910 --> 00:16:04,420
If you have a text data, one way to represent the text data is you can represent a text as a as a bag of words.

132
00:16:04,660 --> 00:16:15,670
So it's a collection of words. If you just ignored the actual order of the words, then you can represent them as a as a sort of matrix.

133
00:16:16,300 --> 00:16:23,530
So where so let's say you can you can represent as a represent the document as

134
00:16:23,530 --> 00:16:28,600
a N by p matrix where any number of documents and PS and a number of words.

135
00:16:29,440 --> 00:16:36,820
And whenever you you see these number ones, you can put in one the most of the words you to see them.

136
00:16:37,030 --> 00:16:47,589
Right. And some of the words you see twice, three times and so on, so that you can represent a document in one row of these matrix.

137
00:16:47,590 --> 00:16:51,490
And if you have a multiple document, you can represent it this way.

138
00:16:51,520 --> 00:16:57,910
So so you have in English word there is a 273,000 words.

139
00:16:58,120 --> 00:17:02,949
So the P is basically 27,000 or 30,000 columns.

140
00:17:02,950 --> 00:17:12,009
But most of them, you know, most of the document most of the short, short document doesn't doesn't contain that many words,

141
00:17:12,010 --> 00:17:19,810
which means that most of this matrix will have will have a very large amount of sparsity.

142
00:17:20,860 --> 00:17:28,960
So similarly, brain, if you have a brain data, you have MRI data, you have a lot of different parts of brain that are connected to each other.

143
00:17:29,530 --> 00:17:32,890
Or you can represent a graph in a similar way social network.

144
00:17:33,460 --> 00:17:44,350
The to those have only a limited subset of non-zero elements or connections between the between the node or the foxholes of vertices.

145
00:17:45,100 --> 00:17:47,410
So they, they will be very sparse too.

146
00:17:48,820 --> 00:18:00,280
So all link matrix of all websites, you have billions of websites and each website links some other websites to those are very, very large data.

147
00:18:00,280 --> 00:18:04,390
So those are can be also represented lies post matrix.

148
00:18:04,460 --> 00:18:12,490
So as you probably can guess, there are many a data that looks like a graph you can represent.

149
00:18:12,490 --> 00:18:22,540
This graph actually can be a good candidate to leverage it is city and it can be stored efficient through this parts matrices.

150
00:18:23,590 --> 00:18:29,230
Okay. So how much memory does it cost for storing a sparse matrix, though?

151
00:18:29,410 --> 00:18:34,480
Well, if you if you have a dense matrix, if you have a by end matrix,

152
00:18:34,870 --> 00:18:42,159
that you have to store each of them in a separate each of the elements in a separate place in the memory.

153
00:18:42,160 --> 00:18:51,490
So it requires a m m times in the order of time, some constant amount of memory.

154
00:18:51,820 --> 00:18:56,890
So if you store, for example, in a double is double takes a lot of eight byte.

155
00:18:57,010 --> 00:19:04,420
So eight times and bytes will be needed. For example, if you are integer instead of eight, you can use four.

156
00:19:05,880 --> 00:19:13,860
So if you have a sports matrix, it doesn't really matter how big an end is.

157
00:19:14,010 --> 00:19:26,340
Lovely. If you have a sparse matrix is a tune and your elements, those are order of a Q and A, where usually Q is a much smaller than M times in.

158
00:19:31,890 --> 00:19:44,590
So. Yeah. So how then then obviously you know I understand that there were those can be made threes

159
00:19:44,590 --> 00:19:52,330
can has can save a lot of memory but how is actually sparse matrix stored actually.

160
00:19:52,840 --> 00:19:58,280
So there are multiple ways to store these sparse matrix.

161
00:19:58,280 --> 00:20:06,460
So these are some examples. Okay. So basically the idea is that you can ignore all the zero values and you can store down your value.

162
00:20:06,470 --> 00:20:09,640
So when you store under values you don't know,

163
00:20:10,570 --> 00:20:18,160
you cannot predict when the non-zero values will occur in most of cases unless you you have obvious parents like this.

164
00:20:18,400 --> 00:20:28,180
So if you wanted to use a general representation, you need to store the value that is non-zero.

165
00:20:28,180 --> 00:20:33,850
But also you need to tell where in the matrix have non-zero values.

166
00:20:34,060 --> 00:20:42,940
So there are multiple different ways to do it. One is that you can make a dictionary of keys.

167
00:20:43,090 --> 00:20:48,819
So what? What I meant is that you can make some dictionary structure.

168
00:20:48,820 --> 00:20:55,470
So our does not provide a native dictionary structure.

169
00:20:55,840 --> 00:21:01,290
Kind of does in some other languages does so.

170
00:21:01,290 --> 00:21:05,920
So dictionary is basically you have. Instead of.

171
00:21:07,590 --> 00:21:12,180
Is instead of in the instead of orate or whatever you call it, have.

172
00:21:14,880 --> 00:21:18,240
I already have or they have a consecutive memory space.

173
00:21:18,240 --> 00:21:25,510
But dictionary is basically you have some key and values, the key and value pairs.

174
00:21:25,750 --> 00:21:29,800
Okay. So key could be any types. Could it be string?

175
00:21:29,820 --> 00:21:42,330
Could it be numbers? But in this case, let's say the number. So, for example, if you have if you if you have this, you don't.

176
00:21:49,160 --> 00:21:56,150
If you have a pool. Three times.

177
00:21:56,210 --> 00:21:59,740
Turn. Okay. She told everyone.

178
00:22:00,240 --> 00:22:03,720
One. Zero zero.

179
00:22:05,440 --> 00:22:10,080
Every one. Nobody wanted Georgia to get.

180
00:22:10,120 --> 00:22:20,530
Let's say let's say you have this matrix, not quite sparse, but this can be rapidly dispersed way that lets you go to all non use while you can.

181
00:22:20,560 --> 00:22:25,840
What you can do is that oh this. This is a row one in column two.

182
00:22:26,440 --> 00:22:31,300
So you can say I'm going to store, I'm going to have.

183
00:22:32,750 --> 00:22:35,959
So I'm going to store some values like this.

184
00:22:35,960 --> 00:22:50,630
So this is a one and had the low one has strong values okay and low two can have some some some values like this key value pairs.

185
00:22:51,050 --> 00:22:58,160
What kind of values do you need? Well, you can you can do in this case.

186
00:22:58,160 --> 00:23:02,930
Q. Q one so well, let let me let me try.

187
00:23:03,020 --> 00:23:07,310
Sorry, let me let me try try one more. But let's do the some easier way first.

188
00:23:08,180 --> 00:23:14,390
Like I said, the key and value pairs can be, uh, can be different types.

189
00:23:14,420 --> 00:23:20,489
So you can, let's say I define a key as a pair of numbers, rows and columns.

190
00:23:20,490 --> 00:23:31,760
So one way to represent this is that I represent these as you key and value pairs as a key is a low and low location one one common two.

191
00:23:32,180 --> 00:23:35,600
Okay. And the values, a negative one.

192
00:23:35,870 --> 00:23:44,839
Okay. You can say one comma, three values one and two comma one negative one to commit.

193
00:23:44,840 --> 00:23:55,840
Two values negative. That is negative one again and to come up five so you can have a key value pairs like this.

194
00:23:56,000 --> 00:23:59,460
Okay. So this is one way to store it. Okay.

195
00:23:59,470 --> 00:24:02,980
I actually let's say I don't really want to store.

196
00:24:04,540 --> 00:24:12,550
These pair of numbers. And then you instead of sorting these parent numbers, you can you can just a linear rise orders.

197
00:24:12,820 --> 00:24:20,420
So let's say all users are calling first order. So instead of seeing one one using one two, you can say this.

198
00:24:21,190 --> 00:24:28,210
So you can, you can you can you can make the index of, you know, one, two, three, four, five, six, seven, eight, nine.

199
00:24:28,750 --> 00:24:32,800
So this this is index one. So index one minus one.

200
00:24:32,860 --> 00:24:39,620
This is an extra index to. Oh, actually, sorry.

201
00:24:39,630 --> 00:24:46,350
I used the one based index. I'm sorry about that. So let's say one, two, three, four, five, six, seven, eight, nine, ten.

202
00:24:46,440 --> 00:24:51,450
So index two is negative one in three is negative one.

203
00:24:51,720 --> 00:24:55,470
Index four is also negative one. Index five is one.

204
00:24:55,920 --> 00:25:01,360
Index ten is two. Okay. So you can you can have a key value pairs like this.

205
00:25:01,370 --> 00:25:06,150
So you just restoring these key value pair using the dictionary structure.

206
00:25:07,380 --> 00:25:12,750
An art does not have picture this structure natively supports, but this can be used to store this.

207
00:25:13,830 --> 00:25:21,180
You can also store a a list of list, so which means that you can store this.

208
00:25:21,360 --> 00:25:27,120
So like a tree. So you have you can say, oh, I have a role one in two.

209
00:25:28,000 --> 00:25:31,799
Okay. So in row No.

210
00:25:31,800 --> 00:25:34,870
One, I have no idea.

211
00:25:35,040 --> 00:25:50,069
I want in the in the column two and column three here I have not yet available to the column one, column two and column five and column two.

212
00:25:50,070 --> 00:25:56,610
I have negative one. Column three, I have one corner of the road load to cover one.

213
00:25:56,610 --> 00:26:05,339
I have negative one, level one and two. So you can store in this way and then you can implement this list of list.

214
00:26:05,340 --> 00:26:22,470
And so basically the same list because they both equal one and value equals again list in a column economically one and so.

215
00:26:26,860 --> 00:26:32,180
But in this case, economics. Okay.

216
00:26:33,540 --> 00:26:39,420
I actually. Yeah.

217
00:26:40,230 --> 00:26:53,100
So let's just do this canonical two because I don't want anybody to copy the complicated canonical two and value equal minus one and you have

218
00:26:53,100 --> 00:27:06,230
one underneath canonical three and value equals one and you can just concatenate them in the head as a as a has a value stored in this way.

219
00:27:06,240 --> 00:27:15,899
I forgot what the what the comment was to domain make this concatenated but I'm sure that you can do that using actual

220
00:27:15,900 --> 00:27:21,780
dataframe is better to do this but those those are like actual structure doesn't matter because this is just an example.

221
00:27:22,170 --> 00:27:27,690
So you can store and store in this way in order to other languages are a little easier.

222
00:27:27,960 --> 00:27:36,690
Okay. So and another way to do it is that you can just store a trip to triplets.

223
00:27:36,690 --> 00:27:45,630
So basically you can let's say there's a few non-zero elements, then you can store this a Q by three matrix basically.

224
00:27:45,870 --> 00:27:50,040
Okay, if you wanted to store is matrix. So Cuba three matrix two.

225
00:27:50,040 --> 00:28:01,919
What I meant is that you store end column here and in the value low column values so this is a two so it's the same it's sort of like this.

226
00:28:01,920 --> 00:28:09,210
But instead of representing as a dictionary, you can represent the matrix and by the Q by three matrix.

227
00:28:09,540 --> 00:28:14,190
That's another way to do it. So this is a coordinate list, a representation.

228
00:28:16,050 --> 00:28:29,580
Okay. So but there are some standards to store this parts matrices and it's actually none of it's not exactly the same as any of those.

229
00:28:30,300 --> 00:28:33,390
So there are two new representations we're going to learn.

230
00:28:34,140 --> 00:28:42,240
One is a compress. The roll oriented representation called the CSR get compress as possible.

231
00:28:42,600 --> 00:28:48,420
And so it's a transpose representation to compress parts column.

232
00:28:48,780 --> 00:28:53,700
And the third way is actually the same, same to this way.

233
00:28:53,700 --> 00:29:04,110
So let me go through the CSR first. So the CSR stores The Matrix in this way.

234
00:29:05,230 --> 00:29:10,680
Okay. So it is. So you don't have to memorize this.

235
00:29:10,720 --> 00:29:21,670
You just need to understand this because that that that would be that would be useful to decide whether I want to use these CSR representations.

236
00:29:21,670 --> 00:29:37,060
Just see a representation of a C representation. So, so in this case, what it does is it each, each of the row vectors you are storing.

237
00:29:39,190 --> 00:29:46,600
So each of the rows in a, in a, in a compressed format.

238
00:29:46,630 --> 00:29:50,000
So what I meant is that here. Okay.

239
00:29:50,530 --> 00:29:55,480
So this one is basically you have a two by five matrix, right?

240
00:29:55,490 --> 00:29:58,920
So in the matrix we're going to store, it is always the same.

241
00:29:58,930 --> 00:30:03,520
So let me just rewrite that matrix and then start from there.

242
00:30:04,920 --> 00:30:10,950
So you have. You a?

243
00:30:12,170 --> 00:30:15,900
What is your draw? Minus one. Minus one.

244
00:30:17,260 --> 00:30:23,980
In U.S., too. So you're storing this matrix.

245
00:30:24,250 --> 00:30:27,870
Okay. So. And, uh.

246
00:30:28,980 --> 00:30:33,059
This representation. This is not our specific.

247
00:30:33,060 --> 00:30:37,860
So it uses a general base index so that that is a little complication.

248
00:30:38,820 --> 00:30:43,560
So basically, this one is trying to keep track of each of the row.

249
00:30:43,710 --> 00:30:51,100
So row one. Okay. And Road to Road three.

250
00:30:52,440 --> 00:30:56,550
And so on. Okay, so Road won it.

251
00:30:57,030 --> 00:31:01,500
So what is it? It keeps track of these three values.

252
00:31:01,620 --> 00:31:05,579
One is the roll pointer. And a second is a column index.

253
00:31:05,580 --> 00:31:10,900
And third is a bunch of values. So no pointer, basically.

254
00:31:12,030 --> 00:31:18,600
So low pointer points. The index of the main index of this matrix.

255
00:31:18,690 --> 00:31:26,990
Okay. In this in this case. It's so, so sorry.

256
00:31:27,210 --> 00:31:30,750
Let me. Let me try to track back. Okay.

257
00:31:31,260 --> 00:31:39,840
So. Here. Let's try to think about how many non geometric elements you have first here.

258
00:31:40,410 --> 00:31:45,450
So we have a negative one, one, negative one, negative one, negative two.

259
00:31:45,480 --> 00:31:49,630
So this is not irrelevant, right? Under.

260
00:31:49,640 --> 00:31:56,450
Everyone's right. So this will be stored up here.

261
00:31:57,270 --> 00:31:59,690
Okay. So this part, that would be easier, right?

262
00:32:00,320 --> 00:32:07,030
So but if you only have non-zero values, you cannot be construct this matrix because you don't know where it is.

263
00:32:07,040 --> 00:32:13,340
Right. So it you need to store the row in Roy column.

264
00:32:14,120 --> 00:32:18,859
But if you you don't need to store Roy in every row, row,

265
00:32:18,860 --> 00:32:24,709
column pairs because when you have a very large matrices, usually the same row appears multiple times.

266
00:32:24,710 --> 00:32:35,150
So you don't want to repeat the same numbers. So that's the idea. So in the row pointer, you just need to keep track of where each row occurs.

267
00:32:35,300 --> 00:32:41,420
So no one? No. So this number belongs to row one, right?

268
00:32:41,570 --> 00:32:47,030
So the first element. So I said this is a zero base index.

269
00:32:47,030 --> 00:32:51,110
So first element is belongs to law one.

270
00:32:51,290 --> 00:32:55,910
Okay. And the second the second element belongs to no one, too.

271
00:32:55,940 --> 00:32:59,210
So this index index is that you don't want to three, four.

272
00:32:59,420 --> 00:33:06,620
Okay. Because it's using database index. Okay. And this negative one is belongs to second row.

273
00:33:06,950 --> 00:33:12,620
Okay. So this means that the load two starts at index two.

274
00:33:12,910 --> 00:33:16,310
Okay. That's what it's trying to store.

275
00:33:16,850 --> 00:33:21,770
Okay. And row three. Well, there's not three rows.

276
00:33:21,800 --> 00:33:30,560
No, wrote three. So if you go to the end of this index, this this just indicates that this matrix doesn't have rule three.

277
00:33:30,590 --> 00:33:34,670
So this is because it reaches the end of the under elements.

278
00:33:35,630 --> 00:33:40,640
So you only have a000 and two as a22 rows.

279
00:33:40,820 --> 00:33:48,410
Okay. So that's what it store. So if there's a rows, there's low point, there's there's N plus one, values will be stored.

280
00:33:48,800 --> 00:33:54,340
Okay. So and this column in this is good.

281
00:33:56,480 --> 00:34:03,920
So then, then because you have a row pointers now you kick, you know that these belongs to row one.

282
00:34:04,160 --> 00:34:15,180
This belongs to the row to. Right. So what you need to know now is that I just need to know which column these belongs to.

283
00:34:15,230 --> 00:34:19,400
So this one belongs to column second columns or column one.

284
00:34:20,840 --> 00:34:25,580
The third column column to this is the first column column, you know.

285
00:34:25,820 --> 00:34:29,930
Second column, column to one in a last column column for good.

286
00:34:30,410 --> 00:34:35,510
So that's what it's going to be stored. Okay, so these three sets of values are stored.

287
00:34:35,720 --> 00:34:41,030
One is always the same size. This is always the number of rows.

288
00:34:41,870 --> 00:34:48,020
Plus the one values will be stored and the column indices will be same as the number of non-zero elements.

289
00:34:48,500 --> 00:34:53,150
And non-zero values will be the same as our developments. Elements. Okay.

290
00:34:53,430 --> 00:34:58,530
So this is one way to represent the department.

291
00:35:03,800 --> 00:35:16,640
Okay. And this is a second way to represent the sparse matrices column, a column compressed compress, past column inches CSC.

292
00:35:17,450 --> 00:35:24,500
So this looks confusing, but this is actually exact opposite of the previous representation.

293
00:35:25,280 --> 00:35:31,070
So instead of in a story thought starting from row, let's start from the column.

294
00:35:31,540 --> 00:35:34,549
Okay. So a column, column.

295
00:35:34,550 --> 00:35:38,270
One, two, three, four, five, column six insulin.

296
00:35:39,430 --> 00:35:52,479
So. And in this case, because you are storing from storing in the column made to order what you are now is the in accounting the column

297
00:35:52,480 --> 00:36:05,800
column first order so non-zero the one element is negative one one one negative one negative one negative one one,

298
00:36:06,700 --> 00:36:10,900
negative two. Okay. So these are these are the non-zero ones.

299
00:36:11,860 --> 00:36:15,729
Okay. So column one and this this negative one.

300
00:36:15,730 --> 00:36:19,420
Below is the column. Column one. So this is, as you know.

301
00:36:19,540 --> 00:36:24,190
So again, this is confusing because in general based in general based representation.

302
00:36:25,000 --> 00:36:28,180
But this this is the column one, column one.

303
00:36:28,180 --> 00:36:32,770
So this this is, you know, column two starts with these elements.

304
00:36:33,070 --> 00:36:36,520
Right. So this is one. Okay.

305
00:36:36,690 --> 00:36:40,750
Because second column, three stars.

306
00:36:40,840 --> 00:36:45,430
So this is you know, that this belongs to column one is below the column.

307
00:36:46,150 --> 00:36:52,690
Column to well, I second column and this belongs to 30 kilometers, belongs to the last column.

308
00:36:52,780 --> 00:36:56,559
Right. So third column starters, index three.

309
00:36:56,560 --> 00:37:02,350
So this is three. Okay. And fourth column, there's nothing.

310
00:37:03,330 --> 00:37:07,530
Right. So four in in this case, fourth column.

311
00:37:07,530 --> 00:37:12,970
There's nothing. So. So anything. Anything that after that comes right after the third column.

312
00:37:12,990 --> 00:37:16,920
I'm just pointing it because it doesn't have anything.

313
00:37:17,290 --> 00:37:25,530
I know the third column has one element. The fourth column should start the fourth in the fourth, but there's no element actually in the column.

314
00:37:25,620 --> 00:37:32,340
So fifth column also starts at four because it is this is is 11.

315
00:37:32,350 --> 00:37:40,590
Below is the fourth column. And after that sixth column, the all the five element was use.

316
00:37:40,740 --> 00:37:45,540
So you stored this value. So this is how the column pointer was is stored.

317
00:37:47,060 --> 00:37:50,780
And no index the same?

318
00:37:51,080 --> 00:37:56,120
Pretty much the same. It's just the opposite way. So now you have a 0 to 2 in minus one.

319
00:37:56,120 --> 00:38:00,110
So this is a oh, no index is one.

320
00:38:00,360 --> 00:38:05,930
Okay. Whichever in the in the in the second row is the one we have in the first row.

321
00:38:05,960 --> 00:38:10,070
It will have a zero. Okay. So there's only two, two rows, right.

322
00:38:10,070 --> 00:38:16,920
So you know, one zero. One, zero, one and zero and one.

323
00:38:17,940 --> 00:38:23,130
So this is how your story. So this is a CSG representation.

324
00:38:24,660 --> 00:38:31,130
So the difference is that you you can't you can't do everything from column columns over there.

325
00:38:31,150 --> 00:38:39,120
So in fact if you just transpose this matrix, it's exactly same as a, as a how you represent the CSR representation.

326
00:38:39,810 --> 00:38:47,940
So if you are, if, if you're unsure how this works, just transpose the matrix and represent the CSR representations and see.

327
00:38:53,070 --> 00:38:56,549
Okay. Third representation, triple representation.

328
00:38:56,550 --> 00:39:00,570
This is also see all representation coordinate wise representation.

329
00:39:01,080 --> 00:39:06,090
This is a probably easier to understand because you just store everything as a triplet.

330
00:39:06,300 --> 00:39:13,230
So in this case, also low index and column index index is just a database index.

331
00:39:13,230 --> 00:39:21,750
That's the that's just the standard. So here. So and it doesn't meant in this case, the order doesn't actually matter.

332
00:39:22,350 --> 00:39:28,409
So you can you can do this way or this way. But the are actually stores the always columns over there.

333
00:39:28,410 --> 00:39:31,440
So are not just this way, but order doesn't really matter.

334
00:39:31,440 --> 00:39:40,560
So you have three values negative one, negative one, negative one, one, two, and you store the low end column.

335
00:39:41,380 --> 00:39:45,270
So this is a second. This is second row first column.

336
00:39:45,270 --> 00:39:48,660
So 10110 negative one.

337
00:39:49,530 --> 00:39:53,550
This first row second columns that you draw, you know, one.

338
00:39:54,080 --> 00:39:56,520
Okay. And this is the one one.

339
00:39:58,110 --> 00:40:09,030
And this is, you know, load, you know, in the column, second column that you wrote to and this row on the column for 014.

340
00:40:09,360 --> 00:40:12,540
I know it's a conflicting because one, it's not one base index database.

341
00:40:13,110 --> 00:40:18,480
It is a database index. Yeah, but other than that, it should be strict.

342
00:40:18,720 --> 00:40:20,220
Pretty straightforward. Good.

343
00:40:21,120 --> 00:40:30,179
So the reason why I just emphasize the database index is that this is how actually these values are stored in actual format.

344
00:40:30,180 --> 00:40:33,270
That is common format that is used across different languages.

345
00:40:34,290 --> 00:40:41,620
But when when I tried to try to load it, it, it, it does a transformation needed time.

346
00:40:41,650 --> 00:40:45,040
So sometimes it uses one base index, sometimes digital based index.

347
00:40:45,040 --> 00:40:49,530
So you just need to be aware of that difference.

348
00:40:49,750 --> 00:40:55,440
So make sure that this if this is a values actually zero base index or one base index.

349
00:40:55,590 --> 00:40:59,700
So I'll actually show that, actually. Okay.

350
00:41:01,450 --> 00:41:10,570
Any questions so far? Okay, so this is a little tedious, but it could be hard to understand from the slide itself.

351
00:41:10,580 --> 00:41:13,780
So I just wanted to explain a little bit more. Okay.

352
00:41:14,680 --> 00:41:21,570
So the matrix packaging is the packaging you want to use to deal with this parts matrix.

353
00:41:21,580 --> 00:41:30,100
There are other packages by matrix packages. Great. And a lot of our packages that leverage sparse matrix, that depends on this matrix package.

354
00:41:31,210 --> 00:41:42,780
So you can also store integer and complex values, but let's let's focus on the storing, just the real value matrix.

355
00:41:43,060 --> 00:41:52,180
In that case, you can, you can represent this as a so t sparse matrix in the C sparse matrix and our sparse matrix.

356
00:41:52,360 --> 00:41:59,180
Okay. So this pass matrix is basically this triplet representation which is C representation.

357
00:41:59,620 --> 00:42:03,310
So the C sparse matrix is CSC representation.

358
00:42:03,910 --> 00:42:14,550
Okay. This made this representation so r because it's our duty or is using the C the column major uploader.

359
00:42:14,560 --> 00:42:18,670
So this is, this is the format I feel most comfortable with.

360
00:42:19,300 --> 00:42:30,540
Okay. And the CSR representation, which is this, this is a Python user row based representations of Python pre first stage of CSR.

361
00:42:30,550 --> 00:42:37,180
So it's internally so about R and you don't need to know the details now.

362
00:42:37,180 --> 00:42:46,960
But if you just if you use R and if you need to choose one or the other, maybe using CCS is usually most fast.

363
00:42:47,290 --> 00:42:52,720
Implementation is, uh, is a is a probably well calibrated.

364
00:42:54,430 --> 00:43:08,200
So if you use a real numbers, there's a specific that this is just a type name so you don't need to actually remember what exactly it is,

365
00:43:08,200 --> 00:43:11,829
but you need to use this keyword sometimes to use to represent.

366
00:43:11,830 --> 00:43:22,510
I want this type. Exactly. So if you say digit metrics, this means that I'm using that and storing this double digit means a double precision.

367
00:43:22,750 --> 00:43:26,680
Okay. And a key metrics is a coordinate representation.

368
00:43:26,800 --> 00:43:35,770
The GC matrix is a quick double precision and the called the CSC representation DSC is a single precision.

369
00:43:36,520 --> 00:43:42,370
Sorry, this is a DSC is a this is symmetric, sparse, a representative.

370
00:43:42,370 --> 00:43:46,300
So G is a general, general sparse matrix.

371
00:43:46,810 --> 00:43:55,450
And that s means that the symmetric version so symmetric version is when you have some matrix that are symmetric,

372
00:43:55,450 --> 00:43:59,319
it doesn't duplicate those symmetric to put the numbers.

373
00:43:59,320 --> 00:44:02,140
So it is a little bit specialized version.

374
00:44:02,740 --> 00:44:11,710
I'm not going to explain how this is actually stored, but this basically stores a diagonal and I think about triangular part only.

375
00:44:11,950 --> 00:44:15,189
Okay. And the also are similar.

376
00:44:15,190 --> 00:44:23,080
You can represent this triangular sparse matrix if you believe that your matrix says are all zeros in other part of the.

377
00:44:24,930 --> 00:44:28,500
The other half of these off diagonal elements.

378
00:44:28,990 --> 00:44:38,129
Okay, so those are the keyword you can use. But I think most of the cases you either want to use a digital matrix and you see matrix on this,

379
00:44:38,130 --> 00:44:42,210
you have to deal with the symmetric or triangular version in specific circumstances.

380
00:44:43,410 --> 00:44:51,690
Okay. That's, uh, that's for the, for the a slide.

381
00:44:51,690 --> 00:44:56,600
And then let's try to do some examples in this lecture.

382
00:44:58,860 --> 00:45:06,929
So to use the library, we are now first loading this nonstandard library.

383
00:45:06,930 --> 00:45:11,819
So this is matrix library. This is the external library that is not that loaded by default.

384
00:45:11,820 --> 00:45:18,450
So you need to load them. I'm going to also load that you are to just to visualize something later.

385
00:45:18,870 --> 00:45:29,399
Okay. And the G plot, too, if you don't know, this is a great visualization tool that is available in R and Python has a different than plot name.

386
00:45:29,400 --> 00:45:33,750
But those are those are also possible. Okay.

387
00:45:34,960 --> 00:45:44,140
So this one is just showing these metrics, our packages to how how actually this matrix is shown.

388
00:45:44,650 --> 00:45:48,230
So this matrix is like the same matrix like this. Okay.

389
00:45:48,940 --> 00:45:52,870
And you can represent. So this is how.

390
00:45:53,080 --> 00:45:56,170
This is a based matrix. So this is a regular density matrix.

391
00:45:56,560 --> 00:46:02,320
If you wanted to convert them into sparse representation, you can use this as function.

392
00:46:02,470 --> 00:46:11,110
And I'm I'm casting this amid this matrix into our sparse matrix, C sparse matrix or T sparse matrix.

393
00:46:11,110 --> 00:46:19,210
So that should be good enough. Okay. So then if you actually shows what is actually stored here.

394
00:46:19,510 --> 00:46:24,760
So this is the. This is exactly the same as what is what is showing the slide.

395
00:46:25,210 --> 00:46:29,620
So this is actually the value stored in the CSR representation.

396
00:46:30,610 --> 00:46:35,980
And this is the value that is stored in the CSC representation.

397
00:46:36,190 --> 00:46:39,920
And this looks the same as the second slide I showed.

398
00:46:40,960 --> 00:46:46,030
And this is triple L representation used here store.

399
00:46:46,060 --> 00:46:49,540
These are these row in column. Okay.

400
00:46:50,260 --> 00:46:55,930
And the non-zero values. Okay. So you may notice that.

401
00:46:55,930 --> 00:47:04,470
But this these are the sign is a spatial way to this.

402
00:47:04,480 --> 00:47:14,500
This matrix is actually implemented in a form called class in a we you may many of you don't know how to make a class in R.

403
00:47:14,740 --> 00:47:25,750
It's okay but this is basically this these sparse matrix object has a member variable and this is the way to access member variable in r.

404
00:47:26,680 --> 00:47:36,340
So there are three member variable in CSR representation p means that row pointers jamie is a column index and X is the A non-zero values.

405
00:47:36,730 --> 00:47:47,110
And it's just you have a p, p is a pointer to the columns column pointers and then you store the row indexes, which is R, I and X is actually value.

406
00:47:47,830 --> 00:47:54,940
And in the triple L presentation, you have a row index and column index and J and X non-zero values.

407
00:47:55,120 --> 00:48:01,390
Okay. So that's how it's stored. So if you. So it is a good exercise if you want it to.

408
00:48:01,690 --> 00:48:08,670
I want to comment this out and I'm going to use a little, little bit more complicated a representation like this.

409
00:48:08,680 --> 00:48:12,370
If you really want to understand whether I actually understand this format,

410
00:48:12,970 --> 00:48:18,580
you can actually rerun this and try to predict what's going to happen in these values.

411
00:48:19,150 --> 00:48:24,219
And you can match your expectation and the numbers there are shown here.

412
00:48:24,220 --> 00:48:31,920
So I'm not going to go into that detail because I think I explained enough, but that's the small exercise I encourage you to do.

413
00:48:31,930 --> 00:48:35,590
So if you wanted to make sure that you understood the format well.

414
00:48:37,050 --> 00:48:45,920
Okay. So okay, that's that's that's the part that I wanted to cover up to here.

415
00:48:46,190 --> 00:48:58,219
Okay. So the second part is going to include they're going to look at the example to perk up the memory cost or sports matrices.

416
00:48:58,220 --> 00:49:03,350
But before doing that, you learn these three matrix robot representations.

417
00:49:03,350 --> 00:49:08,810
Yes, A, C, CSR and a zero or a three player representation.

418
00:49:09,050 --> 00:49:14,090
Okay. Which one do you think is the best in terms of memory efficiency?

419
00:49:14,240 --> 00:49:18,350
So one of the region is to stored save the memory.

420
00:49:18,830 --> 00:49:32,280
Okay. So which one would save the memory the best? Raise your hand if you think this is a CSR represented the best.

421
00:49:34,660 --> 00:49:38,880
Raise your hand if you think it's just sees the best. Okay.

422
00:49:39,350 --> 00:49:42,890
Raise your hand if you think the people I represented in the past.

423
00:49:44,190 --> 00:49:51,480
Interesting many of you actually said that Caesar the best that that was interesting.

424
00:49:51,690 --> 00:49:59,819
So that that is true in terms of computation because a sister representation is a most natural to are so

425
00:49:59,820 --> 00:50:08,520
as I mentioned that is most recommended way but CSR and CC those are those are sort of principles form.

426
00:50:08,530 --> 00:50:17,189
So in terms of in terms of memory savings sometimes well CSR insists is a kind of equivalent,

427
00:50:17,190 --> 00:50:24,629
but sometimes CSR is better, sometimes just seems better. So in this particular examples here, which one use the most memory?

428
00:50:24,630 --> 00:50:28,800
Which one? So among these three representations, which one uses most memory?

429
00:50:29,310 --> 00:50:36,270
If you just count how many elements you need to store, this one requires a 15 numbers to store.

430
00:50:36,870 --> 00:50:42,180
This one requires a 16 this. This one requires 13.

431
00:50:42,900 --> 00:50:50,160
So in this particular example, CSR is the best in terms of saving them, saving the memory and the sees the worst.

432
00:50:51,780 --> 00:50:58,350
Obviously this is just one examples. So in general, the answer is that there's you know, it varies.

433
00:50:58,440 --> 00:51:03,240
The answer is varies. I tricked you. Sorry about that, but there is no right answer.

434
00:51:03,570 --> 00:51:06,930
Okay, so let's see.

435
00:51:07,080 --> 00:51:15,690
So in actual examples. So I'm going to create a very large matrix 10,000 by 10,000 matrix.

436
00:51:16,560 --> 00:51:21,510
But these numbers is basically how many non zero element will I have.

437
00:51:21,540 --> 00:51:24,930
Normally I will have a 5000 non-zero elements.

438
00:51:25,320 --> 00:51:28,890
Okay, so let me, let me show how I going to do it.

439
00:51:29,490 --> 00:51:37,410
So two, you can, you can make different ways, but I'm going to use just triple add up and do this because these are easy to understand for human.

440
00:51:38,520 --> 00:51:45,209
So the what I'm what I'm trying is that I'm going to pick the raw index from this first dimension,

441
00:51:45,210 --> 00:51:54,090
which is between one to 1 to 10000 with the replacement, I'm going to pick the location of the column same way.

442
00:51:54,270 --> 00:52:02,070
Okay. You know, if you are very unlucky, I think you may have a duplicate value by and J, but it's okay.

443
00:52:02,700 --> 00:52:09,120
And X is the values that that you're going to actually have.

444
00:52:11,120 --> 00:52:14,420
The I'm just picking the randomly from these four values.

445
00:52:14,850 --> 00:52:21,290
So that that's the values I'm creating a matrix that is a sparse matrix.

446
00:52:21,290 --> 00:52:25,429
So one one way to generate a sparse matrix directly.

447
00:52:25,430 --> 00:52:31,030
So you don't want to do this when you actually make a sparse matrix usually because a,

448
00:52:31,040 --> 00:52:35,509
you generate a dense matrix first and convert the sparse, which is what's the point.

449
00:52:35,510 --> 00:52:37,010
You don't want to do it usually.

450
00:52:37,790 --> 00:52:48,019
So the way you can do it is that you can make a sparse matrix like this and give the triple A representation, or you can use other representation.

451
00:52:48,020 --> 00:52:54,200
But this is a this is a triple A representation. You can given that those are mostly common, the way to generate the sparse matrix.

452
00:52:55,190 --> 00:53:05,509
And but if you generate it without any indication what kind of format you want to use,

453
00:53:05,510 --> 00:53:13,330
it uses a C format by default because this is the this this is the RS preferred way to store it.

454
00:53:14,210 --> 00:53:26,780
So this this is a storing is a key format or has a very useful way to tell how logic memory does it memory on objectives using.

455
00:53:27,170 --> 00:53:35,710
So we're going to use this object a size it says that uses 99.1 km km right.

456
00:53:37,220 --> 00:53:43,430
And you can, you can convert this matrix to our sparse matrix format using the SE function.

457
00:53:43,430 --> 00:53:46,969
So you don't need to use always like dense representation.

458
00:53:46,970 --> 00:53:51,380
You can use one per representation to convert into another sparse representation.

459
00:53:52,130 --> 00:53:57,590
So if you do this then this is also using the same amount of memory.

460
00:53:58,400 --> 00:54:06,530
Y is the same. Well, it might be slightly different, but because we did random and it's a The Matrix, so it's lovely.

461
00:54:07,430 --> 00:54:13,580
Same amount. Okay. And let's use the C, the triple representation.

462
00:54:13,940 --> 00:54:21,950
Okay. Triple representation is a 79.6 kilo face is actually using the least.

463
00:54:23,390 --> 00:54:32,000
Can you guess y can you can you have explanation. Why does it use a of a smaller amount of memory.

464
00:54:37,020 --> 00:54:41,620
Okay. How about this? This matrix.

465
00:54:41,770 --> 00:54:44,950
This matrix uses 762 megabytes.

466
00:54:45,340 --> 00:54:50,380
Okay, let's hold on. Hold on to that thought, because I'm going to show other examples.

467
00:54:50,770 --> 00:55:00,430
Okay. So just remember, in this case, a 99, 99, 79, roughly, that's the memory that that that consume this to store this.

468
00:55:01,240 --> 00:55:07,750
What if I actually increase the number of non-zero element by tenfold?

469
00:55:08,170 --> 00:55:18,970
Okay. How does it change? Good. So now the the new data uses 626 kick quiz.

470
00:55:19,540 --> 00:55:29,810
Okay if you use a 50,000 non-zero limits, if you use our specific this is a pretty much the same.

471
00:55:30,110 --> 00:55:35,420
Okay. If you use a triple digit digital now this triple represents you use more memory.

472
00:55:37,130 --> 00:55:52,780
Do you have explanation? What's happening?

473
00:56:01,220 --> 00:56:04,160
So what's happening is this.

474
00:56:06,100 --> 00:56:16,780
So, uh, so in this case, this, this example we had is the case where triple representation use the least amount of memory.

475
00:56:16,960 --> 00:56:21,160
Well, I mean, the sorry, the just the middle.

476
00:56:21,460 --> 00:56:29,260
So it was in the middle and the the low CSR actually use the less time on the memory system.

477
00:56:29,260 --> 00:56:33,940
See, use the more amount of memory. Right. The reason is that there are so many columns here.

478
00:56:35,200 --> 00:56:43,960
And each column can store average on average and, you know, on only just one element or less.

479
00:56:44,290 --> 00:56:48,910
Okay. No, not irrelevant. So you need to store.

480
00:56:49,060 --> 00:56:58,390
So compared to the actual number of non-zero values, you need to spend quite a lot of storage to store this column pointers.

481
00:57:00,640 --> 00:57:07,840
And in this case, each it all contains a multiple of elements of non-zero elements.

482
00:57:07,840 --> 00:57:15,020
So you don't you don't have a much redundancy. So you don't have a well, you don't have much waste of the space here.

483
00:57:15,040 --> 00:57:19,119
So 0 to 5 you stores just three numbers here.

484
00:57:19,120 --> 00:57:22,610
You store at your one, three, four, four, four was redundant here.

485
00:57:22,620 --> 00:57:28,420
Right. So that's that's the part that that makes the slightly more efficient or less efficient.

486
00:57:28,430 --> 00:57:39,820
So if you have. Well, so here basically what you can predict is that if you have a more number of rows then more number of columns,

487
00:57:40,270 --> 00:57:50,770
then actually you should use to see, okay, if you use it, if you have a more number of columns than the number of rows, you should use CSR.

488
00:57:51,760 --> 00:58:03,580
But if the if the matrix is really sparse, so you expect a less than one element per row or per column, then your representation most efficient.

489
00:58:04,450 --> 00:58:18,010
But if you, if you have a slightly more, uh, slightly less sparsity okay then triple representation can easily, quickly become very inefficient.

490
00:58:18,160 --> 00:58:32,080
So I can, I can show you like, let's say you, you use instead of instead of doing the 50,000, they say now try to fit 500,000.

491
00:58:32,230 --> 00:58:36,280
Now this this is a 5.8 megabytes huge used here.

492
00:58:36,940 --> 00:58:45,370
This one is using a lot more. So it increasingly more and more redundant because of us storing the potential row index and column index.

493
00:58:45,730 --> 00:58:50,890
But many of the row index and column index are redundant because that's that's what's happening.

494
00:58:52,330 --> 00:58:57,850
And yeah, if you wanted to see the case there or what, what if I have a small,

495
00:58:58,360 --> 00:59:06,700
relatively smaller number of rows compared to the larger number of columns, then you can do this and you would now see this.

496
00:59:06,700 --> 00:59:18,880
It's a this representation CSC represented slightly the less efficient in CSR representations because it's a C same region with a damper slide.

497
00:59:19,330 --> 00:59:20,830
Okay. You can you can do vice versa.

498
00:59:20,830 --> 00:59:28,390
So you can change the numbers and try to understand what's the expected of my memory and which representation is more efficient or not.

499
00:59:29,050 --> 00:59:29,890
And and obviously,

500
00:59:29,890 --> 00:59:37,150
this is not the end of the world if you don't understand the very carefully because of the differences that are actually very small.

501
00:59:37,150 --> 00:59:46,410
And at the end of the world, end of the day, you, you either use A, C, C representation or just ac0 representation.

502
00:59:46,420 --> 00:59:49,899
So the the deciding factor here is the memory.

503
00:59:49,900 --> 00:59:59,680
Memory difference is usually small. So what you care about is, oh, you know, CSC representation is the most efficient in the computation.

504
00:59:59,680 --> 01:00:08,080
Most computation are based computation. So I'm going to store in this CSC representation or three triple opportunities is easy to understand.

505
01:00:08,350 --> 01:00:13,000
So I'm going to stick to the test, see representation.

506
01:00:13,010 --> 01:00:22,120
So those are those are one of the two decision you want to make. By the way, it's way more efficient than storing the test matrix.

507
01:00:22,120 --> 01:00:31,850
That's the most important part. Okay. Okay.

508
01:00:34,140 --> 01:00:37,320
So now. Now we have two more parts.

509
01:00:37,680 --> 01:00:40,740
Okay. Now let's think about the computation.

510
01:00:41,130 --> 01:00:49,380
Okay. So do you think it's possible this computation is more efficient or less efficient than this matrix operation?

511
01:00:52,120 --> 01:00:55,960
Less. Less efficient or more efficient? Less, less efficient.

512
01:00:56,380 --> 01:01:02,800
Okay. Because. So you think that decimate this operation is faster because you'd use a blessing like packing stuff, right.

513
01:01:03,580 --> 01:01:11,410
So. But the sparse matrix, if it's a really sparse, even if you make a very inefficient algorithm,

514
01:01:11,860 --> 01:01:16,480
you couldn't make it faster because you can skip a lot of operations that involve zeroes.

515
01:01:17,110 --> 01:01:20,840
Right. So. So.

516
01:01:21,890 --> 01:01:22,850
So there are two parts.

517
01:01:23,060 --> 01:01:33,230
One is that personally, P&G is really efficient, so it's very hard to beat the default metrics library, but library metrics, the library packaging,

518
01:01:33,410 --> 01:01:43,400
the metrics packaging is actually providing a lot of efficient routine to do this first metrics operation as fast as those.

519
01:01:44,150 --> 01:01:51,799
So that that one plus and the other pluses that you get to leverage the fact that you

520
01:01:51,800 --> 01:01:55,940
don't have to deal with all the zeros so you can be a lot more efficient sometimes.

521
01:01:56,090 --> 01:02:00,820
So you will see that. Okay.

522
01:02:01,120 --> 01:02:07,630
So. So I'm going to make a very silly examples here.

523
01:02:08,040 --> 01:02:13,070
Okay. So. So here I am still using the tent out.

524
01:02:13,090 --> 01:02:18,460
Well, let's let's get back to 10,000 by 10,000 just to to be to the.

525
01:02:19,870 --> 01:02:26,520
So I'm going to go back to these 5000 examples because that's what I square started that.

526
01:02:27,070 --> 01:02:29,800
So. And. Okay.

527
01:02:31,420 --> 01:02:44,170
So ultimate so here dimension two is just 10,000 because I made a 10,000 matrix, I'm actually making a new new vectors, the vector one or 10,000 ones.

528
01:02:44,300 --> 01:02:57,700
Okay. And I'm I'm going to try to do this calculation, so I'm going to just make multiply matrix of the made the factor of one.

529
01:02:57,700 --> 01:03:02,950
So basically calculating the raw sums. Right. So and what happens?

530
01:03:03,250 --> 01:03:08,950
Okay. So if you do this and this is how much how much time it takes.

531
01:03:09,220 --> 01:03:15,100
Okay. So the pretty much all to the representation are very, very fast.

532
01:03:15,550 --> 01:03:18,940
But if you use 10/10, representation is much slower.

533
01:03:19,390 --> 01:03:23,680
Why? Because you're doing just simple multiplication.

534
01:03:23,680 --> 01:03:30,730
When you do the multiplication, if you have one, one of them zero, you can just skip them and just do the addition by skipping them.

535
01:03:31,240 --> 01:03:35,350
And that's what is implemented in this matrix packages.

536
01:03:35,350 --> 01:03:40,200
So even if you don't know the detail, I'm just pretending that I'm using the matrix operation.

537
01:03:40,210 --> 01:03:44,080
It knows how smartly it doesn't have to convert into this matrix.

538
01:03:44,080 --> 01:03:49,810
It does use this keeps this power structure by doing the right calculation.

539
01:03:50,350 --> 01:03:55,839
So you see a lot of efficiency here is a actually vector of like hundreds.

540
01:03:55,840 --> 01:04:03,750
If you if you just take this number as face value, how about the matrix?

541
01:04:03,760 --> 01:04:09,220
Open matrix multiplication. So it is multiplication diffuse across product.

542
01:04:09,790 --> 01:04:14,370
It it does X transpose times Y, right?

543
01:04:14,950 --> 01:04:19,929
If you do the cross product with the one argument, it just do the x transpose times x.

544
01:04:19,930 --> 01:04:24,640
So that's what it does. So let's do the just the cross product and see what happens.

545
01:04:25,000 --> 01:04:29,920
Okay, so then this is how much it takes.

546
01:04:30,460 --> 01:04:38,020
C So because it is so sparse, you have really, really quick calculations here.

547
01:04:38,590 --> 01:04:45,630
And unfortunately, the 10,000 by 10,000 net is multiplication.

548
01:04:45,770 --> 01:04:49,750
It takes a really long time and I doubt that it finishes very quickly.

549
01:04:51,550 --> 01:04:56,290
I actually don't remember how to take, but it probably will take about about a minute or so.

550
01:04:57,460 --> 01:05:06,550
So until until it finishes. So if you wanted to change this value into different level about this sparsely,

551
01:05:07,030 --> 01:05:17,439
you will you will experience that if you change these two for 50,000 or 500,000, this is going to be slower and slower for this person.

552
01:05:17,440 --> 01:05:21,370
Matrices. But then SPURGEON wouldn't change. So that's what I would expect.

553
01:05:21,790 --> 01:05:25,550
See, this took a 40 seconds, so this is a huge difference now.

554
01:05:25,570 --> 01:05:30,309
So you understand that sometimes using sparse matrix is really useful and that

555
01:05:30,310 --> 01:05:34,540
you are going to see that c y probably doing the homework three as well.

556
01:05:34,900 --> 01:05:41,590
Okay. And Matrix, the competition is also very fast if you use a sparse matrix.

557
01:05:41,590 --> 01:05:49,510
So I'm going to just explain how you can do the matrix, the competition for policy choices,

558
01:05:49,640 --> 01:05:56,680
the competition when you do the Chelsea competition because we calculated this X transpose X already,

559
01:05:57,130 --> 01:06:02,050
you can you can do the tallest decomposition for this because this is a symmetric matrix.

560
01:06:02,770 --> 01:06:06,160
But the competition will not make.

561
01:06:07,420 --> 01:06:10,870
Will not run very well if this is not a full rank matrix.

562
01:06:10,870 --> 01:06:17,200
If there's a you know, I evaluate if it's an it's not going to run well, so I'm going to just add a diagonal matrix.

563
01:06:17,410 --> 01:06:22,389
So if you add a diagonal, you know, none of these eigenvalues will be zero.

564
01:06:22,390 --> 01:06:26,980
So it is those solecki decomposition can be calculated more easily.

565
01:06:26,980 --> 01:06:30,910
So I'm going to do that and let's see how how fast it runs.

566
01:06:31,900 --> 01:06:38,620
So again, this takes really fast four for these three versions.

567
01:06:39,670 --> 01:06:45,570
This test matrix again takes a lot of time. I don't remember how it broke.

568
01:06:45,750 --> 01:06:52,050
This is a first in the matrix multiplication. That's good. So that's how they told us how fast the conversion is, actually.

569
01:06:52,710 --> 01:06:56,850
But still, it's much slower than the sparse representation.

570
01:06:57,120 --> 01:07:05,220
Okay. Any questions so far? Okay.

571
01:07:06,540 --> 01:07:15,150
So the last example which you probably need for the homework is how to solve the linear system with a sparse matrix.

572
01:07:15,440 --> 01:07:21,519
Okay. So and that's actually there's one more example, right?

573
01:07:21,520 --> 01:07:24,740
So to the real world example. So we're actually paid on time.

574
01:07:24,840 --> 01:07:35,370
I went to sleep, I guess. So this is the one way to utilize, uh.

575
01:07:36,400 --> 01:07:44,000
Just. So utilize the ritualistic, ritualistic decomposition to solve the linear system very efficiently.

576
01:07:44,010 --> 01:07:54,120
So let's try this. So let's if you are solving this, the y y equal, you know, X speed plus, you know.

577
01:07:55,040 --> 01:08:02,960
So. Absolutely. So if you if you sold this a linear model to just sort of feeding the Y y into X beta,

578
01:08:03,980 --> 01:08:10,930
then the actual calculation of calculating data you get, if you use a statistic decomposition,

579
01:08:10,940 --> 01:08:19,159
you can multiply X transpose in the beginning and you can make A and B and and you can represent these speechmatics

580
01:08:19,160 --> 01:08:29,750
is a is a function of U and you can do the best solving for solve for the solve index of two to solve this equation.

581
01:08:29,780 --> 01:08:34,790
So we've we've gone through this. So you can do exactly the same thing here.

582
01:08:35,660 --> 01:08:38,240
But except that you are using the sparse matrix.

583
01:08:39,230 --> 01:08:47,030
But in fact, you don't need to though even you are doing the sparse matrix because in this case you need to calculate x, transpose x, right?

584
01:08:47,270 --> 01:08:57,620
So yeah, I'm doing the cross product here. And you are calculating this test was y doing the cross propagation and doing ritualistic conversion.

585
01:08:57,620 --> 01:09:03,740
But once if you pass this person matrix, the X and y are sparse matrix.

586
01:09:03,920 --> 01:09:07,640
It does sparse operation just without even knowing it.

587
01:09:07,880 --> 01:09:15,380
Right. And same thing here. So you can do the false so and pixel, you can actually do exactly the same thing.

588
01:09:15,380 --> 01:09:25,730
So this this equation, this whole equation works really well for the tensor matrix if you give a dense matrix text and why it works.

589
01:09:26,390 --> 01:09:30,830
But if, if you give us passive matrix, it also works much faster.

590
01:09:31,850 --> 01:09:34,100
Okay. So that's a good part of the.

591
01:09:34,100 --> 01:09:44,030
Ah, so and I think it's also bad part because if you don't know how actually internal, how it works literally sometimes you can.

592
01:09:44,270 --> 01:09:46,790
I thought this was a sparse representation,

593
01:09:46,790 --> 01:09:52,040
but somehow it was changed to density representation and you didn't know it, it became really, really slow.

594
01:09:52,040 --> 01:09:58,730
It could happen, but at least it's a seamless. So no matter whether you give a sparse matrix symmetric, this works.

595
01:09:58,820 --> 01:10:10,620
So that's that's that's a good part. Okay. So this one, we're doing pretty much a similar thing as before that,

596
01:10:10,640 --> 01:10:18,620
but now we're making a lot more a lot bigger matrix just to show that this still works.

597
01:10:18,950 --> 01:10:27,650
So now we're trying to 1 million rows and thousand columns and ten of them has not your elements.

598
01:10:27,960 --> 01:10:32,780
Okay. So in actual values. Okay. And so your design matrix is it.

599
01:10:32,780 --> 01:10:38,980
But your design matrix is extremely sparse here. So the way how I'm going to make is this.

600
01:10:38,990 --> 01:10:42,290
So you're making the the.

601
01:10:43,660 --> 01:10:48,310
You can make our sparser matrix here with a look.

602
01:10:48,520 --> 01:10:51,399
And this is number of rows. Number of columns.

603
01:10:51,400 --> 01:10:59,770
And if if you do kn j this is just your feeling the num num num negative element with this the specified amount.

604
01:10:59,780 --> 01:11:04,900
So this is a special way to generate, it's just, just some random matrix.

605
01:11:05,620 --> 01:11:10,389
So I'm going to use that in the beta is that this is through beta.

606
01:11:10,390 --> 01:11:19,630
So I have non zero beta for a first ten elements and I have all zero beta four for these 909 elements.

607
01:11:20,560 --> 01:11:25,960
And after that and I'm calculating mu sigma and generate this.

608
01:11:27,870 --> 01:11:34,170
The way value and try to see whether beta is estimated correctly.

609
01:11:34,800 --> 01:11:39,720
So if you run this. So this is the extreme fast.

610
01:11:39,740 --> 01:11:44,240
Why? This is a 1 million by 2000 matrix.

611
01:11:45,440 --> 01:11:49,820
But this the the the only number of natural amount is 10,000.

612
01:11:50,630 --> 01:11:54,080
Okay, so this is extremely fast.

613
01:11:54,470 --> 01:11:58,720
Okay. And, you know, as you see and well, I.

614
01:11:58,750 --> 01:12:04,160
I should you I should have tried to make sure that this is actually that is correct.

615
01:12:05,090 --> 01:12:08,540
So I don't know how correct it is of this. Let's see.

616
01:12:09,140 --> 01:12:12,710
Oh, sorry, Peter. You just want to know.

617
01:12:13,010 --> 01:12:16,790
Let's look at the 1 to 20. Okay, so I wanted 20.

618
01:12:16,790 --> 01:12:19,850
I would expect that the first ten values will have.

619
01:12:21,000 --> 01:12:25,070
Non-zero values. Oh, the.

620
01:12:25,520 --> 01:12:28,950
The the the the. There must be something wrong.

621
01:12:29,010 --> 01:12:38,110
I guess. So if you look at the actual data.

622
01:12:41,380 --> 01:12:44,680
Oh. So this is why. Yes.

623
01:12:45,460 --> 01:12:50,320
So all data was zero, apparently. Uh.

624
01:12:53,620 --> 01:12:57,760
There must be something wrong because I.

625
01:12:58,150 --> 01:13:04,000
Last time I tried it is this worked out? So I really don't know what happened.

626
01:13:05,450 --> 01:13:10,200
So can I revisit this slide again?

627
01:13:10,210 --> 01:13:13,900
Because I don't think we have enough time to to fix this.

628
01:13:14,470 --> 01:13:19,780
And I'm going to just rerun this part. But this is basically Peter is not correct.

629
01:13:19,780 --> 01:13:25,870
So I can I can do this. Let's say theta equals, let's say represent.

630
01:13:26,140 --> 01:13:29,440
I'm just making a making a very simple Peter here.

631
01:13:29,440 --> 01:13:41,160
So one so let's say let's say one five, one five, nine zeros and probably this is a 990 zeros.

632
01:13:41,350 --> 01:13:46,690
I think this should work. Okay. This time. Do they work?

633
01:13:46,900 --> 01:13:51,910
Okay, this time it worked. Okay. So I don't know what happened with this this code.

634
01:13:51,960 --> 01:13:57,280
I'll, I'll, I'll fix this a code. But in this case,

635
01:13:57,280 --> 01:14:02,920
the first five values are close to 1/2 five values are close to negative one and this work

636
01:14:03,160 --> 01:14:08,320
right and to data is this so these these actually work but still very very fast right.

637
01:14:08,710 --> 01:14:14,710
So sorry about the confusion, but this code itself actually works and it's really efficient.

638
01:14:17,840 --> 01:14:23,530
Okay. So last example is just the area.

639
01:14:23,580 --> 01:14:31,310
I'm, I'm using the sparse matrix when I, when I use this and this is an area of the single cell genomics.

640
01:14:31,490 --> 01:14:44,990
I, I didn't mean to that you understand all this thing, but it's actually pretty useful to understand what actual, real, real data looks like.

641
01:14:45,290 --> 01:14:52,310
So this is a, this is actually the single cell data is actually represent usual way to represent a single cell data.

642
01:14:52,970 --> 01:14:55,640
So this is called the matrix market format.

643
01:14:56,030 --> 01:15:02,390
So a matrix market format is basically is a triple A presentation where there's some some sort of head heading.

644
01:15:02,690 --> 01:15:11,659
So you have this heading and this means that you have a 20, 40 roles and 80 columns and you have 448 what, 14 elements that are non zero.

645
01:15:11,660 --> 01:15:21,290
So they're not you can expect how many non non-zero limit you will have and this is just the one base index actually 2 to 1 and actual

646
01:15:21,290 --> 01:15:29,510
value and that is this is how you can represent the sparse matrix and this basically contains a redo count for the single cell data.

647
01:15:30,620 --> 01:15:39,919
So if you can you can read this, this data and you can also read the information about each of the each of the columns,

648
01:15:39,920 --> 01:15:47,270
each of each of the well in each of the each of the third row rows a jean and the column is a cell actually.

649
01:15:48,800 --> 01:15:59,840
So then, so this is what the data looks like and you can use this function read M function in the actually the matrix package has that.

650
01:16:00,440 --> 01:16:06,089
So this means that you can use this is a standard format to represent those parts matrix.

651
01:16:06,090 --> 01:16:09,510
So this is a matrix market format read, read it.

652
01:16:09,510 --> 01:16:14,450
Mm. Actually with this format and the just format is a sparse matrix.

653
01:16:14,450 --> 01:16:22,640
So this is if you want to exchange your sparse matrix data into some human readable form, this is one way to do it.

654
01:16:23,330 --> 01:16:29,389
So you can read this data, okay, and try to understand how this looks like.

655
01:16:29,390 --> 01:16:38,060
So this is a dimension of the data, 240 roles and 80 columns and the change in column,

656
01:16:38,060 --> 01:16:44,240
just to have a raw information, to just let data show which correspond to each of each of the rows.

657
01:16:44,690 --> 01:16:48,680
This is actual data how, how it's represented.

658
01:16:49,040 --> 01:17:01,820
Okay. So, so then you can, you can show summary of the how how the data is represented is just showing the show, showing actual values.

659
01:17:01,940 --> 01:17:13,400
Sorry. So should we be hearing actual representation of these data in space matrix in the triple representation?

660
01:17:13,730 --> 01:17:24,690
One caveat here is that this this particular summary has a one based, one based index rather than the general based index.

661
01:17:24,690 --> 01:17:31,250
So it's a little confusing, but that's what it is. And this is just information.

662
01:17:32,120 --> 01:17:36,649
So this part is just you don't need to know what what the plan looks like.

663
01:17:36,650 --> 01:17:39,799
But this is actually one way to visualize this pass matrix data.

664
01:17:39,800 --> 01:17:45,890
So this is actually what it looks like. So in this case, this is all the genes.

665
01:17:46,220 --> 01:17:48,500
So this is the rows, actually, all the genes.

666
01:17:48,500 --> 01:17:58,310
And this is all the all the columns, all individual cells and shows, shows, shows the red part if they they contain non-zero elements.

667
01:17:58,910 --> 01:18:05,340
So if you see this is the one practical example of the real world as, as matrix data,

668
01:18:05,350 --> 01:18:10,219
then you see that there are a lot of sparsity, but there are a lot of parents here.

669
01:18:10,220 --> 01:18:18,320
So you can cluster this data with this some parents because the towards the express this part are all the same kind of cell types.

670
01:18:18,320 --> 01:18:28,430
But these are I think these are probably B cells. And so so this is just a real world, people, just to connect you with what we have learned today,

671
01:18:29,060 --> 01:18:36,650
we the actual the the real world application and that this is just one example among the impossible.

672
01:18:38,510 --> 01:18:48,379
Okay. So I think we've gone through all the examples and these discussion topics I can revisit in our next lecture briefly,

673
01:18:48,380 --> 01:18:52,370
and then we can move on to the next topic. But any questions?

674
01:18:53,510 --> 01:18:58,310
So we have office hour right after. So if you have questions, feel free to come by.

