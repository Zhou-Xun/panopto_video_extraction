1
00:00:11,640 --> 00:00:17,290
See. Students.

2
00:00:21,080 --> 00:01:26,160
See, I tell you what, I'm not sure what exactly was started.

3
00:01:29,150 --> 00:01:37,520
Okay. Yeah, this is just a. Yes, yes, yes.

4
00:01:37,540 --> 00:01:49,060
You didn't finish the first one. First of all, it includes two incidents today and two things are due next Wednesday.

5
00:01:50,150 --> 00:01:55,070
So I just posted homework three earlier this afternoon.

6
00:01:57,040 --> 00:02:00,040
I can see that it's due out next Wednesday.

7
00:02:01,120 --> 00:02:07,420
Okay. So and then the only thing to do after this is just the final assignment.

8
00:02:08,590 --> 00:02:20,950
Okay. So I think probably the next big topic is just talking about integrating an C++ with its really synchronous.

9
00:02:23,990 --> 00:02:32,780
RCP package. There is a integrating C and R has been around for a while,

10
00:02:32,780 --> 00:02:44,120
but integrating ANSI plus plus has kind of been made easier with this RCP package that came out, I don't know, maybe ten years ago.

11
00:02:44,990 --> 00:02:52,370
Okay. So there's actually even like our kind of base.

12
00:02:52,370 --> 00:03:00,919
R It's really a lot of it is actually uses as c c code.

13
00:03:00,920 --> 00:03:08,870
Basically if you kind of look at the power and the details of the implementations of a lot of our functions,

14
00:03:08,870 --> 00:03:18,139
they actually have actually called C code. So it's basically this is actually this dot com function is what allows you to do that.

15
00:03:18,140 --> 00:03:26,090
So if you looked in a lot of the basic ah functions of for example there's this,

16
00:03:26,720 --> 00:03:36,500
this little dot fit function and r which actually kind of does the fitting part must have a numerical parts of the loop function to align functions,

17
00:03:36,500 --> 00:03:41,030
but it's like basic linear models like does regression.

18
00:03:41,030 --> 00:03:48,350
So kind of the numerical part of that is implemented by the L in fit fit function.

19
00:03:49,440 --> 00:03:56,660
Now if you were to look at like the inside of the dot fit function, ah, there's this, there's this line of code that you'll see.

20
00:03:57,350 --> 00:04:01,160
So it's, it's the dot dot com l type of thing.

21
00:04:01,820 --> 00:04:08,590
So. Basically it has this form.

22
00:04:09,550 --> 00:04:18,250
This is I guess this line of code is really doing a lot of the numerical work that goes into fitting a linear regression.

23
00:04:18,250 --> 00:04:27,500
So I think this C underscore CD to our class is like the name of the C function that's kind of doing B a lot of

24
00:04:27,500 --> 00:04:35,680
the implementations I think you are as it is and a lot of it's based on a Q R decomposition and things like that.

25
00:04:36,220 --> 00:04:45,400
So you'll see this. This is an example in the dot fit function for you'll see it and a lot of the other kind of basic ah functions.

26
00:04:48,430 --> 00:05:07,959
So kind of the, I guess the, the, I guess the original way to interact C and R is with this by using this special type called an S expression.

27
00:05:07,960 --> 00:05:19,510
So there's various objects from R that you can like pass to C or C++ using this special type S expression.

28
00:05:20,200 --> 00:05:27,700
However, I think it's, you know, it's, it's fine. It's probably good to at least know a little bit how to, how to work with this.

29
00:05:27,700 --> 00:05:31,569
But I think it's I think it's pretty challenging to use.

30
00:05:31,570 --> 00:05:34,690
There's kind of a lot of details that you have to that you have to know.

31
00:05:34,690 --> 00:05:44,590
And I think a lot of the kind of more recent a lot of the more recent are packages that you see that use C++, a lot of them use RCP.

32
00:05:45,250 --> 00:05:54,010
So some of the a lot of the older code, let's say before 2010, you have a lot of times you see this s expression type of thing.

33
00:05:54,580 --> 00:05:57,190
But I think in the last ten years,

34
00:05:57,190 --> 00:06:06,760
maybe using our computers has become a lot popular just because I think it's a lot it's a lot more convenient to use.

35
00:06:09,760 --> 00:06:18,520
So RCP, it's really just an R package that enables you to integrate R code in C++ code.

36
00:06:20,500 --> 00:06:24,340
I guess it's just, you know, it's think of it,

37
00:06:24,340 --> 00:06:36,309
it's basically get tickets to kind of give you a set of kind of data structures for the Common R data types.

38
00:06:36,310 --> 00:06:42,490
So I think in that sense, it's, it's kind of similar to the like the standard template library.

39
00:06:42,490 --> 00:06:50,470
However, it has a lot of nice data structures packaged for you for you to use like vectors or maps or strings.

40
00:06:52,930 --> 00:06:57,759
Same thing with with kind of RCP kind of packages.

41
00:06:57,760 --> 00:07:12,850
The data structures that have kind of the same format as the R data structures like vector are vectors, are matrices, then list and then.

42
00:07:17,180 --> 00:07:25,630
This one, you there's a lot of features that I guess automate the process of kind of compiling code and then kind of loading those functions into.

43
00:07:26,510 --> 00:07:30,770
Okay. So we'll talk about this a little bit later.

44
00:07:30,770 --> 00:07:45,470
But with RCP, there's also also allows you to use certain, I guess, ah, types of functions in particular to talk about things like the.

45
00:07:49,390 --> 00:07:50,890
Random number generation,

46
00:07:50,890 --> 00:08:00,040
like there's an ah norm function and ah there's other functions that allow you to compute the distribution function and things like that.

47
00:08:00,040 --> 00:08:01,470
That's kind of what I mean by this.

48
00:08:01,480 --> 00:08:11,440
There's a lot of kind of nice built in functions and ah that you can, there's kind of a C++ version of that that you can use automatically.

49
00:08:11,440 --> 00:08:15,430
So that's kind of another, another nice feature of RCP.

50
00:08:16,300 --> 00:08:22,140
Okay. So I think so I guess.

51
00:08:22,450 --> 00:08:27,730
Yeah. To start off with you, you have to install the RC package if you haven't done it already.

52
00:08:28,330 --> 00:08:35,330
So the way you do that is just install that packages in scenario and kind of one can miss a message.

53
00:08:35,650 --> 00:08:43,060
She didn't have like X Tools and Matt and Mac or the ah tools installed I think.

54
00:08:44,560 --> 00:08:46,420
Yeah. I don't know if it's installed on this computer.

55
00:08:46,420 --> 00:08:59,290
I think, I think we the latest versions of our studio, I think if it's not everything is not install I think it kind of prompts you to do it.

56
00:09:00,190 --> 00:09:09,799
Like if I try to open a C++ file, I thinking, I mean I already have everything installed in my own computer at home.

57
00:09:09,800 --> 00:09:18,220
But I think if, if you follow this like it gives you a prompt to install all the necessary tools.

58
00:09:18,220 --> 00:09:22,570
So if, if you follow that, it should work.

59
00:09:22,570 --> 00:09:33,639
Okay. But I guess this computer doesn't have everything installed yet, so I don't want to use it right now, but once you install everything,

60
00:09:33,640 --> 00:09:46,780
you should be able to use RCP directly so that once kind of everything's installed and you have like the RCP package installed,

61
00:09:46,780 --> 00:09:50,680
you should be able to do everything kind of on these slides.

62
00:09:53,650 --> 00:10:02,709
So once that is what's installed, there's, I guess there's basically two main ways to use RCP.

63
00:10:02,710 --> 00:10:15,580
So you can actually write C++ code and like ah code in the same, really in the same script file for that type of thing, you can use the CPP function.

64
00:10:16,810 --> 00:10:26,500
Basically the way this works is you kind of place all the C C for like the C++ code inside of these parentheses

65
00:10:26,920 --> 00:10:33,280
and then you run that and then you can the functions that are defined inside of these parentheses,

66
00:10:34,030 --> 00:10:39,129
you can use them and you can use them as if they were regular ah functions.

67
00:10:39,130 --> 00:10:43,690
You can just call them directly from here. So that's kind of one way to do it.

68
00:10:43,690 --> 00:10:55,929
The other way is just to write everything in like a separate file or I guess a separate C.P C++ file and then in a separate file,

69
00:10:55,930 --> 00:11:08,680
that's your R script, for example. You just run this source copy and then the name of the file that has the C++ code and that kind of loads in the C,

70
00:11:09,830 --> 00:11:16,180
the functions that you have in your in your external C++ file.

71
00:11:18,070 --> 00:11:22,180
Okay. So actually, I mean, we're not really going to use this in this class,

72
00:11:22,180 --> 00:11:31,389
but if you if you know how to use R markdown, you can actually have RCP in an R markdown file as well.

73
00:11:31,390 --> 00:11:43,060
You just have to be when you if you know how you have blocks in RCP and R markdown, like if you have our code, you can do the same thing.

74
00:11:43,060 --> 00:11:47,500
You just have to do this, this RCP inside of these curly braces.

75
00:11:48,130 --> 00:11:54,640
That's how you kind of start off up a block of RCP code in it and an R markdown document.

76
00:11:55,720 --> 00:12:03,040
All right. So this is maybe just an example, just makes it makes it more clear exactly what we're doing.

77
00:12:03,040 --> 00:12:13,780
So if you were to use like CP function, like you're writing a C++ functions and using that function and are in the same file,

78
00:12:14,210 --> 00:12:21,790
the way you could do it is, is the following. So, you know, you could just open this file, look at our script,

79
00:12:21,790 --> 00:12:35,290
and as I'm loading the RCP package and then I'm just writing a C++ function inside of this SIP function type of thing.

80
00:12:35,290 --> 00:12:47,410
So just to get a definition of the C++ function inside of there, so this is just pretty simple C++ function, just a double.

81
00:12:48,210 --> 00:12:55,520
Function then returns a double, which is the square number. So I figured to find that you can basically run it in R inside of R,

82
00:12:55,520 --> 00:13:01,140
you could run the function square as if they were just a regular kind of R function.

83
00:13:01,190 --> 00:13:04,220
So that just works perfectly fine. Okay.

84
00:13:04,760 --> 00:13:10,760
So this is kind of if you ever want to kind of write your.

85
00:13:13,900 --> 00:13:17,229
Some C++ code in our code in the same file.

86
00:13:17,230 --> 00:13:23,140
So I just took a screenshot. This is, this is the actual like our script.

87
00:13:23,920 --> 00:13:32,799
This is what it looks like if it's in our studio. So it's just in our C++ code and the R code that calls it in the same file.

88
00:13:32,800 --> 00:13:36,910
So this you should work. Okay.

89
00:13:37,840 --> 00:13:41,770
So it's a definition and it's execution or in the same file.

90
00:13:43,360 --> 00:13:48,549
Okay. So that's one way does you see the CPU function.

91
00:13:48,550 --> 00:13:53,770
So that's one way of using RCP to integrate R and C++.

92
00:13:53,770 --> 00:14:02,100
The other way, though. The other way that I mentioned was using source CP where you save like a C++ file and another file.

93
00:14:02,110 --> 00:14:11,610
So. So the way I mean, you're using our studio the way I do, this is the easiest way to do this is as well.

94
00:14:11,620 --> 00:14:14,800
I guess first you want to create a new C++ file system.

95
00:14:15,640 --> 00:14:23,110
If you go to the left and go to like create file, just go down here and click on C++ file.

96
00:14:24,010 --> 00:14:31,000
So if you do this and that's how you kind of open, open up a new or create a new C++ file.

97
00:14:31,510 --> 00:14:37,300
And then in this separate C++ file, you write down the C++ code that you want.

98
00:14:37,330 --> 00:14:52,600
So I just wrote down the same function here, and then you save this and then you see if it's yeah, if you want this to be made available to R,

99
00:14:52,600 --> 00:15:07,450
you have to, you have to include this at least this, this, this thing here is double forward slash and RCP, double code export.

100
00:15:07,450 --> 00:15:11,799
So you want like you only need to include this kind of at the top if you want

101
00:15:11,800 --> 00:15:18,760
all of the functions below this to be available to R at least when you do,

102
00:15:20,080 --> 00:15:22,149
when you kind of load this into R,

103
00:15:22,150 --> 00:15:32,830
you just you have to include this export that just means that all of these functions will be exported to r I guess is the way to interpret them.

104
00:15:32,890 --> 00:15:36,160
They'll be they'll be made available in your r session.

105
00:15:45,910 --> 00:15:49,510
Okay. So, yeah, so we have this. Yeah, this is just an easy example.

106
00:15:50,350 --> 00:16:02,650
So I just I've named the file times two dot copy if you want to use this in ah at least in like a separate file you just do this source cp,

107
00:16:04,300 --> 00:16:14,320
source CP of times to that CP and then you can just use those functions directly as if they were just regular ah functions more or less.

108
00:16:15,190 --> 00:16:25,410
So you just do the source. CP And then I can use this the functions without any difficulty but high times to that

109
00:16:25,750 --> 00:16:33,670
it's a file or just you need to open the two files at the same time or you know,

110
00:16:33,670 --> 00:16:41,799
they don't have to be open at the same time. But this has to be it has to be saved before you before you do source CTP.

111
00:16:41,800 --> 00:16:47,230
So it's just a save to log off. So on here.

112
00:16:47,590 --> 00:16:53,430
I guess it was in the same working directory but I'm working with.

113
00:16:53,440 --> 00:17:01,720
Yeah. If it's not in the same directory I guess you have to do that with the full file path name like whatever folder it's in.

114
00:17:03,340 --> 00:17:07,090
Yeah. Just make sure you know what. Yeah.

115
00:17:07,180 --> 00:17:15,040
Yeah. To use this, just make sure you know which folder then and what your like the current working directory you are inside of.

116
00:17:15,040 --> 00:17:19,420
Ah. So you just have to make sure all this kind of matches up.

117
00:17:22,350 --> 00:17:32,469
Right. So then once you've moved that in, you can basically use this as if it were a regular, you know, basically regular heart function.

118
00:17:32,470 --> 00:17:38,390
So that was just. A few a few small examples.

119
00:17:38,390 --> 00:17:42,410
And these are not complicated examples, but just how to get started.

120
00:17:43,070 --> 00:17:48,860
So just kind of try try these out just to make sure you kind of know how everything.

121
00:17:49,400 --> 00:17:59,720
I'm sorry to it. Obviously, the first orders should have to have a main functioning file, although you don't actually you don't have to have a mean.

122
00:18:00,110 --> 00:18:09,450
Okay. So I that kind of compile automatically when you do this source CTP, you actually don't know how.

123
00:18:09,800 --> 00:18:16,730
Yeah. You don't need a main actually don't know what does some type of compilation.

124
00:18:16,730 --> 00:18:26,720
But yeah. Because there's not a main function, it's more of just compiling the functions that you've defined here.

125
00:18:28,250 --> 00:18:32,150
Yes. And then you can run this in our. But yeah, there's no you don't have to have it main.

126
00:18:38,450 --> 00:18:41,629
All right. Okay. Yes.

127
00:18:41,630 --> 00:18:45,440
So I think. All right.

128
00:18:45,440 --> 00:18:48,390
Yeah. Yeah. Now more details about our setpieces.

129
00:18:48,950 --> 00:18:55,339
I mean, to me, it helps a little bit to think of this as kind of similar to the standard template library.

130
00:18:55,340 --> 00:19:03,709
So like in the standard template library, a big a big advantage of that.

131
00:19:03,710 --> 00:19:11,990
It has these different data types for containers like we call it factors or maps and, and sets.

132
00:19:14,170 --> 00:19:18,350
Okay. So to do that, you have this, you need to include these header files.

133
00:19:18,350 --> 00:19:23,810
Are these header file with these headers.

134
00:19:24,470 --> 00:19:34,370
We did include vector and then you have this using namespace S.T.D. or you don't have to include this if you don't want to,

135
00:19:34,370 --> 00:19:37,820
but if you don't include it, you have to have this STD double colon.

136
00:19:38,750 --> 00:19:44,330
So it's kind of the same thing with this with RCP.

137
00:19:45,290 --> 00:19:51,530
So when you use RCP a lot, you know, a big advantage of this is that it entertains.

138
00:19:51,800 --> 00:20:00,170
It has the it allows you to use different containers which have kind of similar format to the our container.

139
00:20:00,170 --> 00:20:05,030
So vectors and matrixes and lists and things like that.

140
00:20:05,030 --> 00:20:14,929
So to use this, it's kind of a similar thing instead of include a vector or something like that for everything you just do,

141
00:20:14,930 --> 00:20:22,070
this includes are simply not H So you kind of have to, you basically want to include this for everything.

142
00:20:23,120 --> 00:20:26,239
You don't have to do it for different specific types.

143
00:20:26,240 --> 00:20:32,690
This kind of handles all the containers that you want and then if you want to use well,

144
00:20:32,690 --> 00:20:37,910
it depends if you want to retype RCP Double Colon all the time.

145
00:20:38,450 --> 00:20:42,920
So if you don't want to do that, you can use include the using namespace RCP.

146
00:20:44,450 --> 00:20:50,000
You don't have to. If you don't do that, you just use kind of the RCP double colon.

147
00:20:50,720 --> 00:20:56,060
So it's kind of the same type of thing as with the standard template library.

148
00:20:57,090 --> 00:21:05,630
Okay. So I think probably the main thing that you want to start out with or at least yeah,

149
00:21:05,690 --> 00:21:13,520
probably the main data types that I think are useful are CPR, the numeric vector and the numeric matrix.

150
00:21:16,580 --> 00:21:22,970
Also, there's also a character vector in logical matrix or logical vector and things like that.

151
00:21:23,740 --> 00:21:31,580
But I think numeric vector and numeric matrix are kind of the main factor and matrix types.

152
00:21:35,360 --> 00:21:40,190
There are these other vector matrix types that are available.

153
00:21:40,580 --> 00:21:45,230
I talked about RCP pre-diabetes which we will talk about using.

154
00:21:45,500 --> 00:21:51,260
You can use like steel vectors and maps and things like that inside of RCP.

155
00:21:52,490 --> 00:21:58,280
So we will mention that maybe, maybe next week when I mentioned them today,

156
00:21:59,270 --> 00:22:07,760
but you can use them inside of RCP and start out with I think the numeric vector matrix for kind of.

157
00:22:13,120 --> 00:22:16,990
Probably the most the most important thing to at least at least when you're starting out.

158
00:22:17,860 --> 00:22:23,249
Okay. So here's just an example of an RCP function or writing an RCP function.

159
00:22:23,250 --> 00:22:29,290
So this is like an example of writing in our RCP function in a separate file.

160
00:22:30,130 --> 00:22:35,620
So yeah, here I have I have the include RCP H.

161
00:22:36,250 --> 00:22:43,959
So you want to include that pretty much for any RCP file,

162
00:22:43,960 --> 00:22:56,050
you would have to include this that I'm doing using namespace RCP piece so I don't have to country type RCP double column for everything.

163
00:22:57,220 --> 00:23:01,150
And then here I'm just writing a function called vector sum.

164
00:23:01,750 --> 00:23:08,260
And all it does is basically just computes the sum of all of the elements inside of a vector.

165
00:23:08,290 --> 00:23:19,180
That's all it does. So it returns a double and then the input argument is a numeric vector.

166
00:23:19,960 --> 00:23:36,100
Okay. And so there are not all of them, but there are kind of certain methods that are available to to them to numeric vector type.

167
00:23:36,110 --> 00:23:40,420
So one of them as you can kind of extract the size automatically.

168
00:23:40,900 --> 00:23:44,080
So this is kind of similar to steel vectors.

169
00:23:44,710 --> 00:23:50,080
So if you do the dot size, that'll tell you how many elements that are in the vector.

170
00:23:50,980 --> 00:23:56,110
Okay. So this tells us how many how many elements there are in the vector.

171
00:23:56,110 --> 00:23:59,620
So that's going to be assigned to an integer variable.

172
00:24:00,280 --> 00:24:05,530
And then I just use a loop to compute the sum of all the elements.

173
00:24:06,310 --> 00:24:19,660
And then again, yeah, basically the syntax otherwise is pretty, pretty much the same as if there were, if this were just a vector and C++.

174
00:24:20,530 --> 00:24:26,859
So the indexing starts from zero and then we can just do this updating this way.

175
00:24:26,860 --> 00:24:36,129
So otherwise, for this example, I think there's a syntax is pretty similar.

176
00:24:36,130 --> 00:24:41,320
So I think so for the numeric vector, you can actually give it integers or.

177
00:24:49,710 --> 00:24:55,820
Like we said, like art isn't really. It does have an integer type doesn't.

178
00:24:57,550 --> 00:25:02,420
It doesn't really have like a floating point type.

179
00:25:02,430 --> 00:25:05,520
It kind of just treats everything else as numeric type.

180
00:25:08,970 --> 00:25:17,880
But you can you can you could put in integers or kind of regular numeric types into a numeric vector.

181
00:25:18,510 --> 00:25:27,540
So here I'm just creating a a this creates a factor of like ten with the elements one, two, three, four, five, six, seven, nine, ten.

182
00:25:28,440 --> 00:25:30,959
So this is our code here.

183
00:25:30,960 --> 00:25:40,020
So this is like once you've done a source CPU from this other file, you can just use it as if it were like a regular function.

184
00:25:40,020 --> 00:25:48,690
So this is how it would work inside of R. So just computes this the some of this vector here which has all of the elements.

185
00:25:48,690 --> 00:25:53,820
One, two, three, four, five, six, seven, eight, nine, ten. Okay, so that's kind of nice.

186
00:25:54,660 --> 00:26:00,990
Here's an example with a matrix. Okay.

187
00:26:01,350 --> 00:26:13,270
So this is a numeric matrix type. So I guess I could see important methods to know for a numeric matrix type design.

188
00:26:13,290 --> 00:26:21,210
You can get the number of rows and number of columns directly if you just do a dot in row and data in column,

189
00:26:21,630 --> 00:26:28,560
that kind of returns to the number of rows and columns in the matrix so those can be assigned to integers.

190
00:26:29,280 --> 00:26:44,849
So that's what I'm doing here. And then a numeric vector here can create a numerical vector yet inside of a inside of a RCP.

191
00:26:44,850 --> 00:26:50,549
So you can do the way you declare it as a numeric vector and then the name of the variable.

192
00:26:50,550 --> 00:26:55,380
And then this is saying that it's length R,

193
00:26:56,580 --> 00:27:06,210
so it has a length R and then this is saying kind of the second argument is saying that it's all the elements are going to be initialized to zero.

194
00:27:07,080 --> 00:27:11,270
Okay. So that's what this is saying.

195
00:27:12,260 --> 00:27:17,950
I said that we're going to have a better length are all the elements will be zero and

196
00:27:17,970 --> 00:27:23,810
then I guess the rest of the thing and I guess this is just computing I wrote some.

197
00:27:24,410 --> 00:27:29,840
So I'm doing that with a like a nested loop. So for each.

198
00:27:31,670 --> 00:27:38,420
So the outer loop is looping over like the rows and then the inner loop is looping over the columns.

199
00:27:39,530 --> 00:27:46,880
And so for the I throw, I just compute this sum, right?

200
00:27:48,530 --> 00:27:51,680
I'm saying red ions plus equal to eight.

201
00:27:53,900 --> 00:28:05,270
So this, this, this computes the sum in the up and the I throw because remember red I is is initialized to zero.

202
00:28:05,270 --> 00:28:11,959
So when we do this it'll compute kind of the incorrect rosa so this this is this

203
00:28:11,960 --> 00:28:19,100
is one way to compute a vector frozen so this so this should return a matrix.

204
00:28:19,550 --> 00:28:28,160
Sorry, it should return a numeric vector where the length of the vector is the same length as the number of rows inside of me.

205
00:28:28,940 --> 00:28:40,400
Okay, so you can see that here. So this matrix has three rows and two columns, so it returns a vector of like three.

206
00:28:42,080 --> 00:28:50,930
So again, you can return, you can return numeric vector types and you can return numeric matrix types.

207
00:28:51,530 --> 00:28:57,349
So right, remember this function, you have to declare a type for the function.

208
00:28:57,350 --> 00:29:01,429
So this is the same thing with RCP.

209
00:29:01,430 --> 00:29:07,549
As with C++, you have to declare a type for your function if it's returning something.

210
00:29:07,550 --> 00:29:11,240
So here it's saying that we're going to or returning a numeric vector type.

211
00:29:14,610 --> 00:29:21,320
Okay. Okay. So here's well, here's an example.

212
00:29:21,330 --> 00:29:26,639
Just just another example is to show how to write our zip code.

213
00:29:26,640 --> 00:29:33,520
But it's also an example to showing kind of the maybe the advantages of using RCP.

214
00:29:34,080 --> 00:29:47,250
Okay. So here's an example of writing an RCP p fe p function to compute what's called the quadratic form, right?

215
00:29:47,250 --> 00:29:53,790
So it's like a vector x transpose times a matrix a, times a vector y.

216
00:29:53,910 --> 00:30:01,110
Okay, so a is in by p, x is done by one and then y is P by one.

217
00:30:01,170 --> 00:30:07,229
Okay. So I mean, if you were to write out like the full summation,

218
00:30:07,230 --> 00:30:15,240
it would have this if you were to write it all the the summation with all of the correct subscription things,

219
00:30:16,290 --> 00:30:20,699
I'm going to compare kind of three different ways of computing this quadratic one.

220
00:30:20,700 --> 00:30:36,239
So we'll do one way that times RCP one way which uses nested loop in our we give this in R with no problem we can do

221
00:30:36,240 --> 00:30:44,879
it with a little kind of nested loop to do this double summation and then we'll also do a matrix multiplication.

222
00:30:44,880 --> 00:30:55,150
So you can, you can compute this quadratic form just right with the actual kind of matrix multiplication operator inside of.

223
00:30:55,380 --> 00:31:03,660
So this is how you would do it if you are one way of doing it, if you were to do it, if you were to write the RCMP code directly.

224
00:31:04,560 --> 00:31:12,870
Okay, so here I have a I'm creating an RCP function called clod form C P, so the returns are double.

225
00:31:12,870 --> 00:31:16,410
So the quadratic form is just that it's just a single number.

226
00:31:16,890 --> 00:31:20,550
So in that case it just makes sense to return it as a double, for example.

227
00:31:21,600 --> 00:31:31,100
And then the inputs to this quads for CP function are a, it's a numerical vector and numeric matrix and,

228
00:31:31,260 --> 00:31:38,370
and another numeric vector basically force to numeric factors.

229
00:31:38,370 --> 00:31:40,140
And then there's one numeric matrix.

230
00:31:41,280 --> 00:31:51,240
And then basically I'm just implementing again with a, with a kind of, of it so that the other loop is basically the,

231
00:31:52,380 --> 00:31:56,430
the number of rows in a and the inner loop is the number of columns inside.

232
00:31:57,480 --> 00:32:04,390
And all I'm doing is just. Computing this kind of running sun.

233
00:32:05,290 --> 00:32:16,360
Every time you go inside it will increase the variable rent by the amount IXI times, AJ times, which is just the formula for the quadratic formula.

234
00:32:17,680 --> 00:32:26,710
I mean, we just initialize rent at zero and then rent should be enough and we're just going to return to this computes.

235
00:32:26,760 --> 00:32:32,530
This is kind of this quadratic form which you can think of as just kind of a double summation.

236
00:32:34,060 --> 00:32:37,180
All right. So that should work. Yes, that should work. Fine.

237
00:32:39,620 --> 00:32:41,040
All right. The way you would do it.

238
00:32:41,310 --> 00:32:51,879
Oh, the way you would do it in R is at least if you're using like a nested for loop, which is probably we'll see in a minute.

239
00:32:51,880 --> 00:32:55,530
This is not the optimal play to do it, but it's kind of similar.

240
00:32:55,540 --> 00:33:09,200
You just just had a loop with a number of rows and the number of columns a and then you just increase this variable rent by XIV times at any time,

241
00:33:09,220 --> 00:33:13,660
which every time you could kind of go inside the loop and just increase by this.

242
00:33:13,660 --> 00:33:16,820
And that's the formula for a quadratic form.

243
00:33:17,380 --> 00:33:24,310
So this is a this is the nested for loop implementation, kind of using purely R code.

244
00:33:26,620 --> 00:33:32,740
And this is an implementation which inside of R which just uses kind of the.

245
00:33:34,610 --> 00:33:46,669
The fact that we can represent quadratic forms as kind of this in terms of kind of linear algebra, matrix vector multiplication.

246
00:33:46,670 --> 00:34:03,260
So that remember that kind of matrix of vector multiplication can be done in our with this percent star percent syntax, right?

247
00:34:03,260 --> 00:34:15,080
So this is just a transpose of X times a, times Y where all the multiplications are kind of true linear algebra sense.

248
00:34:15,320 --> 00:34:19,640
Okay, so this will also compute the quadratic form of interest.

249
00:34:22,130 --> 00:34:32,450
So I don't know why I put the code here or something else and you can use actually it's not necessary to use keep thinking of C++ at the same time.

250
00:34:33,740 --> 00:34:38,420
Okay. So here I'm just kind of just comparing the timing.

251
00:34:38,430 --> 00:34:47,000
So the way you could do it could compare timings inside of our is using the system time system dot time function.

252
00:34:48,590 --> 00:34:56,120
So that just gives a timing comparison. All right.

253
00:34:56,510 --> 00:35:04,219
It gives a record to time for how long it took to execute that function, either a function or a chunk of time.

254
00:35:04,220 --> 00:35:06,950
In this case, we're looking at the timing for a function.

255
00:35:07,580 --> 00:35:19,010
So here in this example, I've just defined a matrix, which is as three rows and two columns, and then so X would have three elements and Y two.

256
00:35:20,120 --> 00:35:29,500
So in this case, there's really there's really no pretty much no difference, which I think they use twice the user leave.

257
00:35:29,640 --> 00:35:33,950
That's super time,

258
00:35:33,950 --> 00:35:41,179
at least for the thing of interest in the elapsed is like the total clock time that that

259
00:35:41,180 --> 00:35:48,379
you experience with or look at the documentation again but usually these are pretty

260
00:35:48,380 --> 00:35:56,540
close like the user and the elapsed so you can basically look at either one they'll give

261
00:35:56,540 --> 00:36:05,060
you kind of a similar to pretty similar result if you look at user versus elapsed time.

262
00:36:06,350 --> 00:36:14,420
So in this case, just because the the two factors and matrices are so small, it really doesn't matter much which kind of method you use.

263
00:36:14,840 --> 00:36:25,820
It's really going to become more obvious which method is more efficient when you look at kind of larger matrices and larger vectors.

264
00:36:26,480 --> 00:36:33,080
So here I've done an example where I'm looking at a matrix, which is 10,000 by 10,000.

265
00:36:33,080 --> 00:36:42,110
So it has 10,000 rows and 10,000 columns. And then our vectors, X and Y both have 10,000 elements.

266
00:36:42,400 --> 00:36:47,719
Okay. So this is the timing comparison.

267
00:36:47,720 --> 00:36:59,000
So the key P function. So I think we can look at user or elapsed.

268
00:36:59,060 --> 00:37:07,160
I think that those are probably the most informative. We can just look at elapsed sets of maybe a little bit over one second.

269
00:37:07,880 --> 00:37:12,110
The R implementation took like eight and a half seconds.

270
00:37:12,510 --> 00:37:21,590
It's like eight times slower roughly. And then actually this are implementation where we just did the matrix multiplication that was actually fast.

271
00:37:21,680 --> 00:37:24,620
So that was actually point 2 seconds.

272
00:37:28,080 --> 00:37:38,160
So this is actually the fastest and our implementation where we kind of wrote out the whole loop, that was the slowest.

273
00:37:38,470 --> 00:37:42,720
Okay, so what is the conclusion?

274
00:37:43,350 --> 00:37:55,829
So I think our CPE can be quite a bit faster than our code where kind of your computation is such that it

275
00:37:55,830 --> 00:38:06,600
requires kind of a lot of a lot of looping like we had in that nested for a loop for the for the quadratic form.

276
00:38:07,230 --> 00:38:10,920
So that in that where you kind of need a lot of looping and those kind of cases,

277
00:38:10,920 --> 00:38:18,090
you can get a pretty substantial speed up if you just do kind of the exact same code, but you just implement it.

278
00:38:18,390 --> 00:38:21,630
You just do kind of RCP version. Okay.

279
00:38:23,370 --> 00:38:29,849
However, I guess the other thing we noticed, if you can do all of your computations just using kind of the the build,

280
00:38:29,850 --> 00:38:36,989
then if you can do basically everything is kind of a big linear algebra operation,

281
00:38:36,990 --> 00:38:47,729
that's usually preferable and most it's just there's really no not much of an

282
00:38:47,730 --> 00:38:52,350
advantage all or maybe it's even worse if you're trying to do it with RCP,

283
00:38:52,980 --> 00:38:54,990
right? Because that's already pretty efficient.

284
00:38:56,790 --> 00:39:03,270
Like if you have a big vector, if you just use kind of built in our function to do compute the sum or the mean,

285
00:39:03,990 --> 00:39:10,649
or if you have some type of computation where you can use represent the whole thing is just a big matrix

286
00:39:10,650 --> 00:39:18,870
vector multiplication or a a series of a few matrix vector multiplications that's usually pretty efficient,

287
00:39:19,650 --> 00:39:28,799
just kind of kind of the built in, you know, the built in functions in our that do that are are quite efficient,

288
00:39:28,800 --> 00:39:37,560
which really are not much of a gain to writing an RCP function that contributes to something or the mean of a vector.

289
00:39:38,820 --> 00:39:43,410
It's kind of the main points from that, that comparison.

290
00:39:45,720 --> 00:39:51,270
So at least when you've done it, whenever you if you're in, if you're doing a lot,

291
00:39:51,270 --> 00:40:07,829
if you are whenever you can back to rise your code meaning that you do it with matrix factor multiplications or just do all

292
00:40:07,830 --> 00:40:15,950
of the computation using the built in functions on uncertain vectors or matrices without doing a lot of both statements,

293
00:40:18,330 --> 00:40:27,180
it's often preferable. But there are there are a lot of computations where you can't really you cannot be kind of vector ized easily.

294
00:40:27,750 --> 00:40:32,819
So I think all of at least have a few examples of that today and next week.

295
00:40:32,820 --> 00:40:39,960
So there are definitely still some computations that cannot really be vector ized easily.

296
00:40:40,380 --> 00:40:47,910
So in those types of cases, it's still useful to be able to know how to write RCP functions.

297
00:40:49,400 --> 00:40:58,889
Okay. Okay. So this is actually an example where I or at least I don't think there's really any way of kind of vector arising.

298
00:40:58,890 --> 00:41:04,830
The, the, the algorithm is pretty much have to use kind of a lot of looping.

299
00:41:05,130 --> 00:41:08,490
Okay. So this example is the coordinate.

300
00:41:08,490 --> 00:41:11,850
Well, I guess it's quadratic sense kind of more general.

301
00:41:11,850 --> 00:41:16,409
I guess it's coordinate is set for a spread for particular problems.

302
00:41:16,410 --> 00:41:23,820
So this is the coordinate algorithm for a particular sparse regression setup.

303
00:41:24,660 --> 00:41:34,140
So this is this is a sparse regression for when you have kind of an outcome vector y.

304
00:41:34,200 --> 00:41:43,800
So you have a bunch of outcomes and then you have some kind of design matrix where you have, you know, features or covariance stored in a matrix.

305
00:41:47,790 --> 00:41:54,449
So the, I guess the objective function that you're trying to minimize is the following this this type of thing.

306
00:41:54,450 --> 00:42:04,620
It's kind of a this is like a residual sum of squares if you're trying to fit the outcome of Y with a times x.

307
00:42:05,130 --> 00:42:10,020
So I'm using X here. I guess this is often data.

308
00:42:10,440 --> 00:42:13,530
If you want to think about way in linear regression,

309
00:42:14,040 --> 00:42:25,079
the x is a vector regression coefficients and so on a sparse regression usually optimize this residual sum of squares plus some kind of extra penalty,

310
00:42:25,080 --> 00:42:30,100
which is the. Depends on the absolute values of the regression coefficient.

311
00:42:30,100 --> 00:42:33,340
So according to this, an algorithm is a way,

312
00:42:34,000 --> 00:42:43,180
I guess it's just kind of a sequential updating of each element that's meant to kind of minimize this objective function.

313
00:42:43,180 --> 00:42:51,520
So we're minimizing, as we think of this function as a function of X, this is a function or the components of the X factor.

314
00:42:51,610 --> 00:42:57,550
Okay. So this is this is I just thought I included this example.

315
00:42:58,060 --> 00:43:02,980
I don't think you can really kind of effect arise this computation easily in any way.

316
00:43:03,340 --> 00:43:10,299
You're going to have to do a lot of looping because the update for X in each

317
00:43:10,300 --> 00:43:15,129
iteration kind of depends on all of the values of X in the previous iterations.

318
00:43:15,130 --> 00:43:20,190
So you kind of have to do everything step by step, okay?

319
00:43:24,070 --> 00:43:40,399
And you don't have to. Focus on the details of this Anthony Center, just as I tried to suggest that if you're going through the implementation later,

320
00:43:40,400 --> 00:43:43,790
if you're looking at the notes and you start to put all the details in.

321
00:43:44,840 --> 00:43:54,889
So I guess the key thing to notice yourself, so the note, the notation I'm using here,

322
00:43:54,890 --> 00:44:05,360
you have this exchange of t is the value of the j component of X in life.

323
00:44:05,360 --> 00:44:13,069
The teeth iteration may be all. I mean, the way this works is let's say if X had really just write it down.

324
00:44:13,070 --> 00:44:16,729
If excited, let's say three three elements.

325
00:44:16,730 --> 00:44:25,250
For example, the way when I'm thinking of this as working is you have like you start with,

326
00:44:28,550 --> 00:44:39,830
let's say we have three elements in our vector you have x00, x10 and x20.

327
00:44:40,820 --> 00:44:59,120
That's kind of the initial values in your vector. And kind of at the next step, those 2x01x1 of one samples one one of 0x2 of zero.

328
00:45:00,610 --> 00:45:20,630
The next step is x01x2x1 of 1x20 and then x01x.

329
00:45:21,880 --> 00:45:39,920
One on one and x21 and then x0102x12 on x21.

330
00:45:42,360 --> 00:45:46,920
And then it keeps going. Basically, it keeps cycling through to that.

331
00:45:47,670 --> 00:45:55,050
If the kind of the limitation is not clear, that's kind of what I mean by zero of oxygen of teeth.

332
00:45:56,070 --> 00:46:04,200
So you basically you start here, then you update this, then the next one, then the next one.

333
00:46:04,200 --> 00:46:14,070
And that's I guess that's kind of a full this is like a full cycle, I guess, of updating kind of all the elements.

334
00:46:14,460 --> 00:46:22,740
And then you kind of start over. You keep, you keep going until it kind of converges in some sense, and that's how it works.

335
00:46:25,590 --> 00:46:44,760
So to get so assuming that you have this x j of r, x k of t minus one for all of the case, you know, prior to j, so we so we have sorry,

336
00:46:44,790 --> 00:46:55,890
now we have x k of t for our, for all of the K prior to J and then we have like x k of t minus one for all of that k after j.

337
00:46:57,390 --> 00:47:04,440
So that's kind of where we're at and the way we get the new value of x j of t is the following.

338
00:47:04,440 --> 00:47:11,700
There's like a formula. So there's just we have to focus on the details.

339
00:47:11,700 --> 00:47:20,990
But there is, there is a formula that's, that uses the values of our design matrix A and the vector Y and kind of the,

340
00:47:21,810 --> 00:47:31,770
the current values of X, Katie for K less than J and then x k of T minus one for K larger than J.

341
00:47:32,430 --> 00:47:34,650
And so this is kind of the formula that you would use.

342
00:47:35,190 --> 00:47:45,990
Well, at least to get this I'm calling it Z Jft and and then you have to do this kind of transformation of Z j of T to get your final exchange of T.

343
00:47:46,060 --> 00:47:51,690
So this is the this is kind of the final x jft.

344
00:47:52,200 --> 00:47:59,549
So again, the what is our regression problem when you end up at the end is you'll

345
00:47:59,550 --> 00:48:03,240
actually have a lot of the regression regression coefficients that equals zero.

346
00:48:03,240 --> 00:48:11,190
Exactly. So it's basically from this thing, you can you can get a lot of the estimated regression coefficients to equal zero.

347
00:48:11,700 --> 00:48:17,549
So that's where this comes from. You're setting x t equal to zero.

348
00:48:17,550 --> 00:48:24,810
Exactly. If this is J, empty is empty is less than or the absolute value is less than lambda over.

349
00:48:30,120 --> 00:48:33,920
Okay. Here it is.

350
00:48:38,910 --> 00:48:46,559
So it's actually it's a I guess I split it as the function itself was too long to put on one slide.

351
00:48:46,560 --> 00:48:52,230
So this is kind of the first part. So I guess I call it this coordinate descent function.

352
00:48:52,230 --> 00:49:01,160
So the inputs are a numeric vector Y, a numeric matrix A and then a positive number line.

353
00:49:01,320 --> 00:49:12,660
So it's a double. So I guess the way we're going to do this is let's see.

354
00:49:12,990 --> 00:49:19,890
So I guess the thing that you're that you're returning at the end is going to be this numeric vector x.

355
00:49:20,430 --> 00:49:25,919
So that's why I have this numeric vector type. So I'm going to return a numeric vector type.

356
00:49:25,920 --> 00:49:30,390
So we're, we're going to return a numeric vector except these images.

357
00:49:31,020 --> 00:49:40,140
And then I think the other things are just related to two vectors that are useful in the computation.

358
00:49:40,740 --> 00:49:51,660
I'm 18 by and C back. So C back is like this thing here that's useful to kind of store that as a vector inside of the computation.

359
00:49:52,230 --> 00:50:01,110
So I think 80 Y is actually this this term here, it's going to be a factor.

360
00:50:03,120 --> 00:50:06,240
The components are are this sum here.

361
00:50:07,800 --> 00:50:19,230
So that's kind of where those terms are coming from. So I don't you walk through every all of the details, but basically.

362
00:50:19,230 --> 00:50:22,799
So what is the first part. Oh, the first part.

363
00:50:22,800 --> 00:50:34,170
Yeah, the first part of the function. I'm just computing C back at Y so C back seat back is just uh, this term here.

364
00:50:34,260 --> 00:50:38,400
It's, this is the JTH component of C back.

365
00:50:38,880 --> 00:50:42,240
And then why is this, this, this summation here?

366
00:50:42,240 --> 00:50:50,850
The Jth component is just this summation. So I think I just computed it at the beginning of the function so you don't have to re compute it in every

367
00:50:51,420 --> 00:50:58,200
iteration of the coordinates algorithm so you can just compute it once at the beginning of the function.

368
00:50:58,710 --> 00:51:03,630
And then you don't have to you don't have to re computed every iteration since these terms.

369
00:51:03,630 --> 00:51:09,000
They don't depend on t things, terms that don't depend on ti.

370
00:51:09,000 --> 00:51:13,260
They don't you don't have to re compute them in every iteration.

371
00:51:13,980 --> 00:51:21,230
Okay. And so once you have those I think there's even yeah.

372
00:51:21,430 --> 00:51:27,749
I split it into three parts.

373
00:51:27,750 --> 00:51:33,480
So I guess the other is the other thing that doesn't depend on TI is B matrix.

374
00:51:36,180 --> 00:51:39,840
So it's better just to compute that before you actually do the iteration.

375
00:51:40,800 --> 00:51:49,510
So you that I'm just doing that here, I'm just filling in for matrix B that has these kind of the elements have this formula.

376
00:51:49,590 --> 00:51:52,950
So I'm just doing that here with this kind of.

377
00:51:55,280 --> 00:52:03,929
Guess I did it with kind of a nested loop. And then this is kind of be the final part.

378
00:52:03,930 --> 00:52:07,980
And this is this is actually the iterative part of the coordinates.

379
00:52:08,520 --> 00:52:15,840
And the first part of the function was just setting up kind of the vectors and the matrices that are used.

380
00:52:16,020 --> 00:52:26,309
So this is actually the actual calling to say, Oh, I don't think I need a stopping criterion or like a formal stop and criterion.

381
00:52:26,310 --> 00:52:30,030
I think I just maybe the function was getting too long.

382
00:52:30,600 --> 00:52:35,670
I just, I just run this for a certain number of iterations.

383
00:52:36,210 --> 00:52:42,330
So I'm just going to run the coordinate descent algorithm for t up ten nanometer.

384
00:52:42,630 --> 00:52:54,930
Okay. Now the other iterations. Okay. And so the T is like the outer loop here.

385
00:52:54,930 --> 00:52:58,440
So this is like one value of T, I guess.

386
00:52:59,220 --> 00:53:04,080
And then the inner loop is like you're updating each J for that.

387
00:53:04,080 --> 00:53:12,870
T I guess. Okay. So we have an inner loop and an outer loop so that the T one iteration of T

388
00:53:12,870 --> 00:53:18,900
represents a full updating of every element of the vector like we have here,

389
00:53:19,020 --> 00:53:29,050
like three updates here. And then the T is kind of how many times we do the for the full update in the back end.

390
00:53:30,000 --> 00:53:40,229
So inside in our loop is the details we want that this is just if using the formula that we had on the previous line.

391
00:53:40,230 --> 00:53:43,920
So if you look at the previous slide, you should kind of imagine.

392
00:53:44,670 --> 00:53:48,480
And then so this is defining the value of Z like we were talking about.

393
00:53:49,050 --> 00:53:55,770
And then this was just this J is the function of the Z that we talked about before.

394
00:53:55,770 --> 00:54:04,350
It's it's zero. If this absolute value is less than lambda over C.J. And then the solid formula here.

395
00:54:04,890 --> 00:54:12,690
So this is kind of the full nested loop as the form is really what's doing the coordinate descent part.

396
00:54:14,220 --> 00:54:21,630
Okay. So that's kind of a long one function, but once you've written that function, you can,

397
00:54:22,140 --> 00:54:28,390
you can use it in R so that the name of the function is called core descent c,

398
00:54:28,530 --> 00:54:41,399
l r c, local r d d c So once you do like source CP and write it in, you can use it inside of R as if it were a regular R function.

399
00:54:41,400 --> 00:54:53,610
So just a little example where I'm generating so this is an example where in is 100 and let's see where I choose,

400
00:54:54,870 --> 00:54:58,620
what the length of x should be recent.

401
00:54:58,890 --> 00:55:02,160
It made it here, but the length of x should be three.

402
00:55:03,630 --> 00:55:09,750
So A will have 100 rows and three columns and then y will have 100 elements.

403
00:55:11,220 --> 00:55:16,560
Okay? So I'm just kind of generating those same values of,

404
00:55:16,560 --> 00:55:24,870
by and here this is the only purpose here is kind of simulating some values of y a and then I'm just running it.

405
00:55:25,830 --> 00:55:30,030
I'm just running our our coordinate to set function.

406
00:55:31,230 --> 00:55:37,620
So here I'm just running it for different values. So remember that the third argument was lambda severe.

407
00:55:38,310 --> 00:55:42,540
Lambda is 2.0 in this example when it was 10.0.

408
00:55:42,960 --> 00:55:53,810
In this example, Lambda is 20.0. So you'll get different values of theta hat variable depending on what lambda is.

409
00:55:53,820 --> 00:55:59,820
You get slightly different values for your for your estimates of the regression coefficients.

410
00:56:04,110 --> 00:56:07,200
Okay. Okay.

411
00:56:07,900 --> 00:56:17,380
So that's showing different, I guess, as a way of checking that you're like you're kind of algorithm is reasonable as it's always good to check it,

412
00:56:17,400 --> 00:56:27,370
at least if there's not an easy way to check it. So one way to kind of check that is at least works in the case when Lambda Zero.

413
00:56:27,820 --> 00:56:38,560
So when Lambda is equal to zero, that's the objective function that we're trying to minimize is just the kind of standard residual sum of squares.

414
00:56:39,070 --> 00:56:43,570
And that's kind of the same objective function that you're minimizing when you're just doing regular

415
00:56:43,570 --> 00:56:50,830
kind of regular regression and some of the regular regression in R as implemented by the ELM function.

416
00:56:50,830 --> 00:56:56,150
So we can just compare our results from our coordinate function.

417
00:56:57,550 --> 00:57:05,660
Keep plugging in lambda equals zero and compare that with what you would get from the element function so that you could do that here.

418
00:57:05,680 --> 00:57:16,690
So I, I compute beta dot had zero with that coordinate the set function that we just have written and that gives us these three values.

419
00:57:17,560 --> 00:57:21,670
And then I've also done that with the L1 function in order.

420
00:57:22,300 --> 00:57:27,670
So the way you could do that with a design matrix, a where you don't want it to add an extra intercept,

421
00:57:27,670 --> 00:57:35,530
is just do a line of y tilde a minus one and then to extract the coefficients you just do the dollar sign off.

422
00:57:36,160 --> 00:57:42,879
So all of that beta is the regression coefficients that you would get for R and so those are printed here.

423
00:57:42,880 --> 00:57:51,890
So you can see that they're actually actually pretty much the same at least when you print it out these many digits.

424
00:57:51,890 --> 00:57:57,370
So I think this is kind of a good, good way to double check that we're kind of doing that.

425
00:57:57,850 --> 00:58:01,990
Our RCP five P function is kind of doing that the correct thing.

426
00:58:05,490 --> 00:58:11,460
It's an opportunity. Okay.

427
00:58:12,440 --> 00:58:16,059
So yeah, I just included this was a little bit of a longer example,

428
00:58:16,060 --> 00:58:24,000
but I just thought I'd include his coordinates example because I think it's, it's just a realistic example of a case where you,

429
00:58:25,500 --> 00:58:32,290
you would really want to use RCP rather than R to implement that function just because

430
00:58:32,290 --> 00:58:38,259
I think you're kind of forced to use this just the way the computation set up,

431
00:58:38,260 --> 00:58:41,890
you're kind of forced to use this, this nested loop.

432
00:58:42,490 --> 00:58:46,180
So especially if you have kind of a large matrix,

433
00:58:46,180 --> 00:58:56,440
that's really going to be it could be very time consuming if you were to to implement this directly in R or to I guess, to execute the task.

434
00:58:57,820 --> 00:59:01,149
Okay. So yeah, yeah.

435
00:59:01,150 --> 00:59:07,360
You can't really avoid using this kind of nested loop just because this update of 80 like you saw before,

436
00:59:07,360 --> 00:59:14,590
it involves all of the other x katy that are kind of already in your current vector is really,

437
00:59:16,090 --> 00:59:21,250
really kind of no way to do it in this in a few steps without doing a lot of loop.

438
00:59:21,760 --> 00:59:25,600
Okay. So it's really difficult to vector ise.

439
00:59:26,200 --> 00:59:33,460
So I think this is kind of a good example of it. You really can't avoid using a nested loop.

440
00:59:38,980 --> 00:59:42,910
So it's clear. Okay.

441
00:59:42,910 --> 00:59:52,299
So that's that's I guess the examples that we talked about before are all using numeric vectors or numeric matrices like sort of the other two,

442
00:59:52,300 --> 01:00:01,390
I guess, main data structures that you would probably want to use if you're interacting C++ with R or the list

443
01:00:01,390 --> 01:00:11,050
and the data frame equals or the other kind of big data structures that are commonly used in R.

444
01:00:14,620 --> 01:00:27,480
So basically the way the type that I use, the name of the type that you're going to use in RCP represent list is just this word like capital,

445
01:00:27,700 --> 01:00:37,999
you know, basically it's a list with a capital now and then data frames or that you have to use.

446
01:00:38,000 --> 01:00:53,260
This is data frame one word and you just capitalize both D and and so if you didn't take the R module, the, the,

447
01:00:55,850 --> 01:01:02,150
the usefulness of the list is you can think of them are basically just containers that can store different data types.

448
01:01:02,690 --> 01:01:09,249
A list has a bunch of different elements and the elements can store different data types.

449
01:01:09,250 --> 01:01:13,820
So you can have one element of a list that's a number.

450
01:01:13,870 --> 01:01:24,910
You can have another element of the list that that the character can. That's the key feature of, of, of lists and ah okay.

451
01:01:26,680 --> 01:01:35,230
So I would say at least if you're writing RCP functions, um, the main benefit of returning a list is that they can,

452
01:01:36,490 --> 01:01:51,309
if you want to kind of return multiple things from your function and it's kind of each of the objects have different types.

453
01:01:51,310 --> 01:01:58,030
Like you have one thing that's a character. One thing is that that's a number one thing is a logical variable.

454
01:01:58,420 --> 01:02:04,330
It's all it's often easier to kind of just package that up as a single list and then just return to list.

455
01:02:04,570 --> 01:02:15,040
Okay. That's how it how lists are often beneficial if you're returning them from RCP.

456
01:02:17,200 --> 01:02:20,650
So data. So the other thing is a data frame.

457
01:02:22,000 --> 01:02:29,469
So data frame, I guess the main way to think of this, if you haven't seen them before,

458
01:02:29,470 --> 01:02:35,560
is just the kind of just like a matrix where the, the columns can have different data types.

459
01:02:35,560 --> 01:02:46,600
So for a numeric matrix, kind of all of the elements of that matrix, they have to be numbers for a data frame.

460
01:02:49,750 --> 01:02:56,530
They have kind of a matrix structure. So they have columns and and rows, but the columns can have different data types.

461
01:02:56,530 --> 01:03:07,540
So within a column, all of the values and the different rows have to have the same data type, but across columns they can have different every time.

462
01:03:07,540 --> 01:03:15,130
So you can have a column full of numbers, for example, and a different column is full of logical values.

463
01:03:15,190 --> 01:03:22,179
So that's kind of the key here, at least that you're thinking about using it in RCP.

464
01:03:22,180 --> 01:03:25,959
That's kind of a key feature of data frames to keep in mind.

465
01:03:25,960 --> 01:03:32,380
It has kind of amazing a matrix structure, but the different columns can have you can have different data types.

466
01:03:39,820 --> 01:03:48,370
So the way you create a dataframe in our list is, well, it depends if you're using using namespace or not,

467
01:03:48,370 --> 01:03:57,549
but the way you create a list is just this list of a colon create or dataframe,

468
01:03:57,550 --> 01:04:06,250
double colon, create and show how to use that in an actual example in a minute.

469
01:04:06,970 --> 01:04:17,920
And then to access different elements of a list, you can just access them as if kind of using the same syntax and as a vector.

470
01:04:17,920 --> 01:04:29,760
So to access the for the first element of a list, you just do bracket zero or bracket one, etc. You can actually access them by name as well.

471
01:04:30,880 --> 01:04:36,460
If you do bracket and double click the name of the component of a list.

472
01:04:37,060 --> 01:04:40,540
So list lists, that component of lists can have names.

473
01:04:41,800 --> 01:04:44,140
I mean, they don't have to, but they can't have names.

474
01:04:44,620 --> 01:04:53,379
So if you want to access the elements of the list by name, you could just put a name that you're interested in inside of double quotes,

475
01:04:53,380 --> 01:05:03,580
inside of a bracket, and then for data frames, you can basically access the elements in the same way as you would with a numeric matrix.

476
01:05:05,530 --> 01:05:14,360
So you can have access to the elements of a data frame in the exact same way as you would with a amériques.

477
01:05:15,370 --> 01:05:21,550
Okay. So here's just, I think just two short functions that show how to do these things, these types of things.

478
01:05:22,090 --> 01:05:34,630
So here I just have an example where I have a RCP function called test list basically has no arguments and it just returns a list.

479
01:05:36,790 --> 01:05:52,729
Okay. So. Inside of this function, I'm declaring a numeric vector of length to, so I'm declaring a numeric factor called x of length two by default.

480
01:05:52,730 --> 01:05:59,090
If we don't give it an extra number, it just gives the initial values of zero to all the elements.

481
01:06:00,500 --> 01:06:05,750
And that's what's done here. I'm also declaring a numeric vector called Y.

482
01:06:06,310 --> 01:06:12,410
I has size two and then there's the initial values of each element is 2.0.

483
01:06:13,310 --> 01:06:21,860
That's one side. Then I'm creating a list, I guess, and returning it at the same time.

484
01:06:22,340 --> 01:06:25,940
So this is how you create a list or basically a names list.

485
01:06:25,940 --> 01:06:37,790
So I, I, I create a named list so that the way you do that, like if you want the first component to have name X,

486
01:06:37,790 --> 01:06:44,510
you just do named of X and double quotes and then you want you set it equal to whatever you want it to be.

487
01:06:45,200 --> 01:06:50,150
And if you want the second component to have the name y, you just do it this way.

488
01:06:51,980 --> 01:06:59,410
Okay? So now let's save this. So now once we run it in R, it kind of looks like this, so it returns it with us.

489
01:06:59,420 --> 01:07:09,890
So this is a list look like an R. This is just saying that the first component has name X and so the first component of a list is a vector.

490
01:07:10,370 --> 01:07:13,490
That's two elements. Most of the elements are zero.

491
01:07:15,440 --> 01:07:18,170
And then the second component of the list has named Y.

492
01:07:18,680 --> 01:07:36,480
And then the second component of the list is a vector with like two that are a vector like two and both of the elements are equal to,

493
01:07:36,980 --> 01:07:39,560
okay, so that's how it can work.

494
01:07:40,640 --> 01:07:49,850
Here's an example of kind of a similar thing, but we're just doing a dataframe instead of a list, so kind of a similar thing.

495
01:07:50,450 --> 01:07:55,849
Yes. And then take the argument. Then also same thing.

496
01:07:55,850 --> 01:07:59,840
I'm creating an X factor and a Y vector in the same way.

497
01:08:00,740 --> 01:08:07,790
And then here I'm just returning a data frame instead of a list. So data frames can also have names.

498
01:08:07,790 --> 01:08:12,680
Those are basically you can think of those or you should think of those as the names of the columns.

499
01:08:14,390 --> 01:08:17,810
So a dataframe as rows and columns.

500
01:08:17,810 --> 01:08:23,750
If you if a data frame names, that just means you're you're naming the individual columns.

501
01:08:24,470 --> 01:08:33,140
So that's actually pretty much if you're giving the name of the columns of your data frame,

502
01:08:33,620 --> 01:08:38,390
it's pretty much the same syntax as naming the components of other lists.

503
01:08:38,780 --> 01:08:43,220
So here we're basically creating a data frame and returning it at the same time.

504
01:08:45,860 --> 01:08:49,219
So when we run it in R, it basically looks like this.

505
01:08:49,220 --> 01:08:52,520
So it's, it looks like a matrix is what it returns.

506
01:08:52,520 --> 01:09:02,060
So it's a matrix with two columns and two rows and then the names of the columns are X and Y.

507
01:09:03,170 --> 01:09:15,770
So just to name each of the components of the data frame, those are like the column final data for him are naming names of the columns in the files.

508
01:09:15,770 --> 01:09:22,940
Something any. Okay.

509
01:09:22,940 --> 01:09:32,780
So if we're if you want to access the elements of the list, you just basically at least if you're accessing them using numeric indexing,

510
01:09:33,470 --> 01:09:39,590
it's pretty much the same thing as accessing the elements of a numeric vector, for example.

511
01:09:41,990 --> 01:09:45,920
So here we have an example of our RCP function.

512
01:09:45,920 --> 01:09:49,850
It doesn't retarget anything, so we use the void keyword.

513
01:09:50,750 --> 01:09:54,440
The type is void, so it's not returning anything.

514
01:09:55,100 --> 01:10:03,530
So here, what am I doing? So I'm the input argument is a list.

515
01:10:04,430 --> 01:10:14,720
So it's a list name list. And then I'm just going to print out kind of the elements of the list of.

516
01:10:22,980 --> 01:10:31,770
So here you can get the size of a list. Also using this dot size the same way you get the length of a vector.

517
01:10:32,220 --> 01:10:37,860
So I'm assigning it to the variable and in then I'm just doing a list.

518
01:10:39,570 --> 01:10:46,990
I'm sorry, I'm doing a for loop and for each iteration and the for loop, I'm printing out a component of list.

519
01:10:47,820 --> 01:11:02,100
So there's actually you particularly mentioned in the feature there's in the RCP when you whenever you have it include RCP dot H.

520
01:11:04,420 --> 01:11:14,130
You can use this function called our F. It's pretty much designed to have the set to more or less the exact.

521
01:11:14,370 --> 01:11:19,740
Pretty much the same thing as what print F does in C++.

522
01:11:22,350 --> 01:11:24,810
And it's just kind of written for, for RCP.

523
01:11:25,350 --> 01:11:35,010
So here we're just putting out this message and then you can still use this kind of percent D syntax so that prints out a integer number.

524
01:11:35,520 --> 01:11:38,580
So it's going to print out the element at index.

525
01:11:39,270 --> 01:11:44,729
I have this list is this.

526
01:11:44,730 --> 01:11:50,040
And you can just you can actually just do print directly for printing out certain components.

527
01:11:51,590 --> 01:12:06,550
This. So they should just print out all of the elements of first and then try to remember why I put the other stuff on the bottom.

528
01:12:09,460 --> 01:12:17,430
Is there any point of that? I guess I'm just trying to say put them out.

529
01:12:17,820 --> 01:12:29,760
There's different ways of kind of printing things out so that. Oh, I see, I see.

530
01:12:30,090 --> 01:12:33,340
Yeah. You'll see on the example in a minute.

531
01:12:33,340 --> 01:12:46,470
And so that I was just saying that the remember that the each element of a list like an individual element of list can also be a vector.

532
01:12:47,010 --> 01:12:55,830
Okay. So the size here is the number of elements in the list, but each component of the list can be just kind of a a larger object.

533
01:12:56,040 --> 01:13:00,690
It could potentially be a factor. So I think what I was saying here is just that.

534
01:13:03,540 --> 01:13:13,620
Oh, I see. So, for example, if the first element of our list is a numeric vector, least that's what I'm assuming here.

535
01:13:14,340 --> 01:13:17,760
So this just extracts the first element of the list.

536
01:13:18,210 --> 01:13:27,790
So that's a V. So V is a vector. So if you want to print out the elements of the vector, you can do it this way.

537
01:13:27,810 --> 01:13:33,690
So this prints out like the first element, basically like the first element of the first element of the list.

538
01:13:33,780 --> 01:13:41,340
Okay. Alternatively, I guess I'm assuming like the third element of the list is a character vector.

539
01:13:42,250 --> 01:13:50,190
And so here I'm turning out the the first element of kind of the third element of the list.

540
01:13:50,710 --> 01:13:54,750
And the third component is the third component in the list as a character vector.

541
01:13:54,750 --> 01:13:59,070
And I'm just pointing out the first character, the first character from that vector.

542
01:14:00,510 --> 01:14:03,600
So yeah. Here's, here's the example that I have in mind.

543
01:14:03,600 --> 01:14:10,469
So the input list that I'm going to give it, it's a list with a list of length.

544
01:14:10,470 --> 01:14:18,450
Three is three elements. The first element is a vector of length three, which is the vector one, two, three.

545
01:14:18,870 --> 01:14:25,980
The second component is a single number two. And then the third component is a character vector of length three.

546
01:14:27,270 --> 01:14:38,909
So here you can see that where we run our, our, our c p function, it just prints out that the element at index zero of the list is a factor.

547
01:14:38,910 --> 01:14:44,730
One, two, three, the element index, one of the list is the number two and then the element index.

548
01:14:45,060 --> 01:14:47,880
Two of the list is this character vector.

549
01:14:48,390 --> 01:14:57,700
And then the first element of the first list element is one right of them first element as vectors one and the first element.

550
01:14:57,750 --> 01:15:10,559
The third element of this is like once in our little weirdness s expressions, the character of the character.

551
01:15:10,560 --> 01:15:21,990
ABC So in our characters don't mean necessarily individual letters or anything that can be kind of groups of,

552
01:15:21,990 --> 01:15:32,459
of individual characters inside of double quotes, no doing on time giving little stop there.

553
01:15:32,460 --> 01:15:37,120
I think that the next example is, I guess what I mentioned right at the beginning.

554
01:15:37,120 --> 01:15:50,489
At the beginning, like our CPE has some extra usefulness, at least if you're using kind of special mathematical or statistical functions a lot.

555
01:15:50,490 --> 01:16:04,740
So is P functions which compute like the distribution functions of of of the distributions of certain random variables.

556
01:16:05,400 --> 01:16:12,540
There's kind of a whole a lot of these that are implemented. And you can also you can use them directly in RCP also.

557
01:16:12,540 --> 01:16:15,689
It's also useful for, I think, random number generation.

558
01:16:15,690 --> 01:16:19,980
There's also a lot of random number generators for different distributions in R.

559
01:16:20,370 --> 01:16:23,670
So you can, you can also use them directly in r c p.

560
01:16:25,060 --> 01:16:30,940
I just I just for. Yeah.

561
01:16:32,150 --> 01:16:37,640
Yeah, we'll just do it next time. This example's a little bit too long to do it today.

562
01:16:37,650 --> 01:16:44,630
So this is kind of a useful example of computing a bunch of t tests from a, from a matrix of data.

563
01:16:45,500 --> 01:16:56,570
But we'll start we'll start there on Monday since it's in Mr. Must 35 minutes questions or anything.

564
01:17:07,380 --> 01:17:08,460
Yeah. If not us.

